releaseBuild = true
showEditor = true
postHighscores = true





g_enableMouseOverStates = true

g_rokuDragSensitivity = 0.1

g_levelSelectionMultipleAssets = true

--those are used for the camera panning on sweepping
g_mouseDragAttributes = {mouseDragTime = -1, targetDragTime = 0.5, minDragTime = 0.02, lastPressedX = -1, cummulativeDragX = 0, dragFromTouch = false, dragFromMouse  = false}


		
--needsNewTouchToDrag = will be true when you want the user to release the touch once in order to perform a new one. For example: if the user starts dragging while the camera is not fully at
--						slingshot, the dragging will be disabled, and the user must release the touch and try againa when the camera is at the slingshot
g_birdDragOnTouchAttributes = {	enabled = true, dragging = false, lastCursorX = -1, lastCursorY = -1, 
								previousTouchCount = 0, elapsedTimeAtRest = 0, targetRestTime = 0.01, 
								dragStartPosPhysics = {x= nil, y= nil}, dragLastPosPhysics = {x = nil, y=nil}, 
								touchOneID=nil,shootMinLength = 3, disabledForBirdSpecialty=false, needsNewTouchToDrag=false}
--g_enableBirdDragOnTouch = true

--g_gesturePausePage = {enabled = true, cursorReferenceX = nil, cursorReferenceY = nil, dragLength = 0, currentButtonSelected = nil,   }

g_gesturePausePageEnablingFlags = {enablePage=false, simulateTouchOnWindows=false}

g_enableDebugTextField = false

if releaseBuild then
	showEditor = false
	postHighscores = true
end

tapRadius = 15 * screenWidth/480

-- queue for achievements  to be unlocked
achievementUnlockQueue = {}

-- Filled from C++
--imagePath = "images"
--fontPath = "fonts"
--audioPath = "audio"
--localizationPath = "localization"
--levelPath = "levels"

--relative to the screen width
g_cameraPanAreaRatio = 0.01



g_cursorNames = {"CURSOR_HAND_POINT", "CURSOR_HAND_HOVER", "CURSOR_HAND_GRAB", "CURSOR_HAND_CLICK"}

g_treasureChestAttributes = {timeBetweenKeys=-1, maxTimeBetweenKeys = 0.5, keys = {"O", "P", "E", "N"}, correctKeysCount=0}
if deviceModel == "roku" then
	g_treasureChestAttributes.keys = { "KEY_GAMING_B" }
end

g_currentCursorName = "CURSOR_HAND_POINT"
--for debugging only
g_cursorIndex = 1

--found by experimenting
--g_restartButtonPos = {x = 113, y = 36}
--g_restartButtonScale = 1
--g_restartButtonCollisionRadius = 30

--doesMouseClickSetsCount = on windows it does, so remember to change that to true on windows
g_mouseOrTouchStates = {isUsingMouse=false, lastCursorPosition={x=nil,y=nil}, doesMouseClickSetsCount=nil, releaseTouchTime=-1, fullScreen = true}

g_registrationURLs = {}	



g_registrationKeys = {fullGame = "shop-full-abc-pc-test"}

g_updateCheckFlags = {enabled = false, updateAvailable = false, updateCheckCalled = false}

g_updateCheckFlags.enabled = g_updateCheckEnabled



if releaseBuild then
	g_registrationURLs.validationURL = "http://drm-pc.angrybirdsgame.com/validateKey/?"
	g_registrationURLs.registrationURL = "http://drm-pc.angrybirdsgame.com/consumeKey/?"
	g_registrationKeys = {fullGame = "SABC2011FL"}
else
	g_registrationURLs.validationURL = "http://dev.angrybirds.com/drm/validateKey/?"
	g_registrationURLs.registrationURL = "http://dev.angrybirds.com/drm/consumeKey/?"
	g_registrationKeys = {fullGame = "shop-full-abc-pc-test"}
end



function createStartUpAssets()

	
	
	if deviceModel == "windows" then
		g_cameraProfileList = { deviceModel, "osx", "ipad", "iphone" }
	elseif deviceModel == "osx" then
		g_cameraProfileList = { deviceModel, "windows", "ipad", "iphone" }
	elseif deviceModel == "roku" then
		g_cameraProfileList = { deviceModel, "osx", "windows", "ipad", "iphone" }
	else
		g_cameraProfileList = { deviceModel, "iphone" }
	end
	
	local variant = "full"
	
	-- Create urls
	APP_STORE_FULL_VERSION_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&type=full"
	ANDROID_MARKET_FULL_VERSION_URL = "http://www.angrybirds.com/redirect.php?device=android&variant=litebeta2&type=full"
	REPORT_BUG_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&variant=litebeta2&type=reportbug"
	ANGRY_BIRDS_TRAILER_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&type=trailer"
	OVI_STORE_URL = "http://www.angrybirds.com/redirect.php?device=N900"
	--OVI_STORE_URL_S60 = "http://lr.ovi.mobi/store/10042237_AngryBirds" -- Redirect not allowed by Nokia
	OVI_STORE_URL_S60 = "http://www.angrybirds.com/redirect.php?device=s60&variant=lite&type=full"
	OVI_STORE_MORE_GAMES_URL_S60 = "http://www.angrybirds.com/redirect.php?device=s60&variant=full&type=moregames"
	ROVIO_IN_OVI_STORE_URL = "http://store.ovi.com/publisher/RovioMobile/"
	LP1_IN_OVI_STORE_URL = "http://www.angrybirds.com/redirect.php?device=N900&type=lp1"
	LP2_IN_OVI_STORE_URL = "http://www.angrybirds.com/redirect.php?device=N900&type=lp2"
	FACEBOOK_URL = "http://facebook.angrybirds.com/"
	TWITTER_URL = "http://twitter.angrybirds.com/"
	RIO_CONTEST_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=riocontest"
	ABSHOP_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=shop&variant=" .. variant
	
	
	_G.res.createTextGroupSet(localizationPath .. "/TEXTS_BASIC.dat")
	loadImages( { "SPLASHES" } )
	
	-- if we want to play audio during the startup scene
	
	_G.res.createAudioOutput(2, 16, 44100)
	
	if deviceModel ~= "roku" then
		if settings.fullScreen == nil then
		settings.fullScreen = true
		else
			--the game already starts in full screen mode by default, so if it is in full screen, we don't make an extra call
			if settings.fullScreen == false then
				--setFullScreenMode(settings.fullScreen)
				
				local t_minimumScreenWidth = 1024
				local t_minimumScreenHeight = 600						
				
				if settings.screenWidth == nil then
					settings.screenWidth = t_minimumScreenWidth
				end
				
				if settings.screenHeight == nil then
					settings.screenHeight = t_minimumScreenHeight
				end
				
				local t_width = _G.math.max(t_minimumScreenWidth, settings.screenWidth)
				local t_height = _G.math.max(t_minimumScreenHeight, settings.screenHeight)
				
				--setResolution(t_width, t_height)
			end
		end
	end
	
	if deviceModel == "windows" and g_registrationEnabled == true then
		if settings.license ~= nil then
			local t_fullGameKeyIndex = getIndexInTable(settings.license.registeredKeyTypes, g_registrationKeys.fullGame)
			g_isGameUnlocked = t_fullGameKeyIndex > 0 and areDeviceIDsEqual(settings.license.hardwareID, getDeviceID())
		else
			g_isGameUnlocked = false
		end
		
		if settings.license == nil then
			settings.license = {}
			settings.license.registeredKeyTypes = {}
			settings.license.hardwareID = getDeviceID()
		end							
	end
	
	--settings.platform = {}
	--settings.platform.device = deviceModel
	--settings.platform.hardwareID = getDeviceID()
	
	--highscores.platform = {}
	--highscores.platform.device = deviceModel
	--highscores.platform.hardwareID = getDeviceID()
	
	if deviceModel == "windows" and g_updateCheckFlags.enabled == true then
		
		if settings.updateNotification == nil then
			settings.updateNotification = {}
			settings.updateNotification.updateNotified = false
			settings.updateNotification.gameVersionOnLastWarning = gameVersionNumber
		else
			--user has just updated the game, or installed another version manually (not necessarily newer)
			if settings.updateNotification.gameVersionOnLastWarning ~= gameVersionNumber then
				settings.updateNotification.updateNotified = false
				settings.updateNotification.gameVersionOnLastWarning = gameVersionNumber
			end
		end
	end
end



function getIndexInTable(tableToSearch, value)
	local t_index = 1
	
	for k,v in _G.pairs(tableToSearch) do
		if v == value then 
			return t_index
		end
		t_index = t_inde + 1
	end
	
	return 0
end

function selectAssetProfile()
	-- Default profile is iPhone because it's probably the most up to date
	local profileName = "480x320"
	
	if deviceModel == "iphone" then
		profileName = "480x320"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "iphone4" then
		--profileName = "960x640"
		profileName = "480x320"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "ipad" then
		profileName = "1024X768"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "n900" then
		profileName = "864x480"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "s60" then
		profileName = "640x360"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "roku" then
		profileName = "roku"
		
		-- if screenHeight <= 576 then -- PAL resolution is 720x576
			-- profileName = "roku_low"
		-- end
		
	elseif deviceModel == "windows" or deviceModel == "osx" then
		local i, j = _G.string.find(imagePath, "/")
		profileName = _G.string.sub(imagePath, i+1, _G.string.len(imagePath))
		--print(profileName)
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "palm" then
		-- Palm Pre
		if screenWidth >= 480 then
			profileName = "480x320"
			if isLiteVersion then
				profileName = profileName .. "_lite_palm"
			end
			
		-- Palm Pixi
		else
			profileName = "400x320"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
		end
		
	elseif deviceModel == "android" then
		if screenHeight < 480 then
			profileName = "480x320"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
			
		elseif screenHeight < 800 then
			profileName = "864x480"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
			if isBetaVersion then
				profileName = profileName .. "_beta"
			end
		else
			profileName = "1280x800"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
		end
	
	elseif deviceModel == "pc_build" then
		profileName = "pc_build"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
	

	end
	
	return profileName
end

function getRokuImagePath(sheetName)
	if screenHeight <= 576 and (sheetName == "BUTTONS_SHEET_1.dat" or sheetName == "MENU_SHEET_1.dat" or sheetName == "LEVELSELECTION_SHEET_1.dat"
		or sheetName == "GOLDEN_EGGS_SHEET_1.dat" or sheetName == "GOLDEN_EGGS_SHEET_2.dat" or sheetName == "GOLDEN_EGGS_SHEET_3.dat") then
		return imagePath .. "/low/" .. sheetName
	else
		return imagePath .. "/" .. sheetName
	end

end

function getRokuLowLevelAssets(assets)
	if assets["LEVELSELECTION"] ~= nil then
		assets["LEVELSELECTION"] = assetLoadList["roku_low"]["LEVELSELECTION"]
		_G.table.insert(assets["LEVELSELECTION"], "BACKGROUNDS_LS_1.dat")
	end
	if assets["OTHER"] ~= nil then
		assets["OTHER"] = assetLoadList["roku_low"]["OTHER"]
		_G.table.insert(assets["OTHER"], "CURSORS_SHEET_1.dat")
		_G.table.insert(assets["OTHER"], "POPUPS_SHEET_1.dat")
		_G.table.insert(assets["OTHER"], "TUTORIALS_SHEET_1.dat")
		_G.table.insert(assets["OTHER"], "INGAME_PARALLAX_CRANES.dat")
	end
	if assets["GOLDEN_EGGS"] ~= nil then
		assets["GOLDEN_EGGS"] = assetLoadList["roku_low"]["GOLDEN_EGGS"]
		_G.table.insert(assets["GOLDEN_EGGS"], "BACKGROUNDS_GE_1.dat")
	end
	return assets
end

function loadImages(groups)
	local profileName = selectAssetProfile()
	local assets = assetLoadList[profileName]
	
	if profileName == "roku" and screenHeight <= 576 then
		assets = getRokuLowLevelAssets(assets)
	end
	
	for k,v in _G.pairs(assets) do
		for g=1,#groups do
			if k == groups[g] then
				for i=1,#v do
					local path = imagePath .. "/" .. v[i]
					if deviceModel == "roku" then
						path = getRokuImagePath(v[i])
					end
					_G.res.createSpriteSheet(path)
				end
			end
		end
	end
end

function loadCompoSprites(groups)
	local profileName = selectAssetProfile()
	local assets = assetLoadList[profileName]
	
	for k,v in _G.pairs(assets) do
		for g=1,#groups do
			if k == groups[g] then
				for i=1,#v do
					_G.res.createCompoSpriteSet(imagePath .. "/" .. v[i])	
				end
			end
		end
	end
end

function releaseImages(groups)
	
	local profileName = selectAssetProfile()
	local assets = assetLoadList[profileName]
	
	if profileName == "roku" and screenHeight <= 576 then
		assets = getRokuLowLevelAssets(assets)
	end
	
	for k,v in _G.pairs(assets) do
		for g=1,#groups do
			if k == groups[g] then
				for i=1,#v do
					local path = imagePath .. "/" .. v[i]
					if deviceModel == "roku" then
						path = getRokuImagePath(v[i])
					end
					_G.res.releaseSpriteSheet(path)
				end
			end
		end
	end
end

function releaseCompoSprites(groups)
	local profileName = selectAssetProfile()
	local assets = assetLoadList[profileName]
	
	for k,v in _G.pairs(assets) do
		for g=1,#groups do
			if k == groups[g] then
				for i=1,#v do
					_G.res.releaseCompoSpriteSet(imagePath .. "/" .. v[i])
				end
			end
		end
	end
end

function loadFonts()
	fontBasic = _G.res.getString("TEXTS_BASIC", "FONT_BASIC")
	fontMenu = _G.res.getString("TEXTS_BASIC", "FONT_MENU")
	
	_G.res.createBitmapFont(fontPath .. "/" .. fontBasic .. ".dat")
	_G.res.createBitmapFont(fontPath .. "/" .. fontMenu .. ".dat")
	_G.res.createBitmapFont(fontPath .. "/FONT_SCORE.dat")
	_G.res.createBitmapFont(fontPath .. "/FONT_BIG_NUMBERS.dat")
	_G.res.createBitmapFont(fontPath .. "/FONT_LS_SMALL.dat")
	if deviceModel == "roku" then
		_G.res.createBitmapFont(fontPath .. "/FONT_INGAME_SCORE.dat")
		_G.res.createBitmapFont(fontPath .. "/FONT_LS_SMALLER.dat")
	end
	
	if gameCenterSupported then
		_G.res.createBitmapFont(fontPath .. "/FONT_GAMECENTER_BASIC.dat")
		_G.res.createBitmapFont(fontPath .. "/FONT_GAMECENTER_NUMBERS.dat")
	end
	
end

currentGFXSet = nil

function loadThemeGraphics(name)
	print (" ::  LoadThemeGraphics() \n")
	local themeName = blockTable.themes[name].graphicSetName
	
	if(themeName == currentGFXSet) then
		print(" - - GFX set is the same, not loading or releasing graphics\n")
		return
	end
	
	if(currentGFXSet ~= nil) then
		print("- - Releasing previous graphics set : "..currentGFXSet.."\n")
		releaseImages({currentGFXSet})
		releaseCompoSprites({currentGFXSet.."_COMPOSPRITES"})
	end
	
	-- update current set value
	currentGFXSet = themeName
	
	print(" -- THEME GRAPHICS SET NAME = "..themeName.."\n")
	--[[
	for k,v in _G.pairs(blockTable.themes) do
		if(k ~= "settings" and v.graphicSetName ~= themeName) then -- and v.graphicSetName ~= oldGFXSet) then
			print(" - releasing theme graphics, name = "..k.."\n" ) 
			print(" - graphicSetName = "..(v.graphicSetName).."\n")
			releaseImages({v.graphicSetName})
			releaseCompoSprites({v.graphicSetName.."_COMPOSPRITES"})
		end
	end]]
	
	loadImages({currentGFXSet})
	loadCompoSprites({currentGFXSet.."_COMPOSPRITES"})

end


function createAssets()

	-- uncomment for japanese
	--_G.res.loadLocale("TEXTS_BASIC", "it_IT")
	--_G.res.useLocale("it_IT")	



	if deviceModel == "roku" then
		loadImages( { "INGAME", "OTHER", "CURSORS" } )
		if screenHeight > 576 then
			loadImages( {"OTHER_2"} )
		else
			_G.res.createSpriteSheet(imagePath .. "/low/MENU_SHEET_1.dat")
		end
	else
		loadImages( { "INGAME", "OTHER", "OTHER_2", "CURSORS", "LEVELSELECTION", "GOLDEN_EGGS", "THEME_1", "THEME_2", "THEME_3", "THEME_4", "THEME_5", "THEME_6", "THEME_7", "THEME_8", "THEME_9", "THEME_10" } )
	end
	
	loadCompoSprites( { "COMPOSPRITES" } )
	--loadCompoSprites( { "TUTORIALS_COMPOSPRITES" } )
	
	loadFonts()
	
	if deviceModel == "s60" then
		defaultMenuFont = fontBasic
	else
		defaultMenuFont = fontMenu
	end
	setFont(defaultMenuFont)
	
	-- _G.res.createAudio(audioPath .. "/sfx/bad shot a1.wav", "bad shot a1")
	-- _G.res.createAudio(audioPath .. "/sfx/bad shot a2.wav", "bad shot a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a1.wav", "bird 01 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a2.wav", "bird 01 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a3.wav", "bird 01 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a4.wav", "bird 01 collision a4")
	
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a1_low.wav", "bird 01 collision a1_low")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a2_low.wav", "bird 01 collision a2_low")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a3_low.wav", "bird 01 collision a3_low")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a4_low.wav", "bird 01 collision a4_low")
	
	
	_G.res.createAudio(audioPath .. "/sfx/bird 01 flying.wav", "bird_01_flying")
	_G.res.createAudio(audioPath .. "/sfx/bigbrother_fly.wav", "big_brother_flying")
	_G.res.createAudio(audioPath .. "/sfx/bigbrother_awakens.wav", "big_brother_awakens")
	
	_G.res.createAudio(audioPath .. "/sfx/bird 01 select.wav", "bird_01_select")
	_G.res.createAudio(audioPath .. "/sfx/bigbrother_select.wav", "big_brother_select")
	--_G.res.createAudio(audioPath .. "/sfx/bird 01 unselect.wav", "bird_01_unselect")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a1.wav", "bird 02 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a2.wav", "bird 02 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a3.wav", "bird 02 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a4.wav", "bird 02 collision a4")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a5.wav", "bird 02 collision a5")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 flying.wav", "bird_02_flying")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 select.wav", "bird_02_select")
	--_G.res.createAudio(audioPath .. "/sfx/bird 02 unselect.wav", "bird_02_unselect")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a1.wav", "bird 03 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a2.wav", "bird 03 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a3.wav", "bird 03 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a4.wav", "bird 03 collision a4")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a5.wav", "bird 03 collision a5")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 flying.wav", "bird_03_flying")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 select.wav", "bird_03_select")
	--_G.res.createAudio(audioPath .. "/sfx/bird 03 unselect.wav", "bird_03_unselect")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 flying.wav", "bird_04_flying")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 select.wav", "bird_04_select")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 collision a1.wav", "bird 04 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 collision a2.wav", "bird 04 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 collision a3.wav", "bird 04 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 collision a4.wav", "bird 04 collision a4")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a1.wav", "bird 05 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a2.wav", "bird 05 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a3.wav", "bird 05 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a4.wav", "bird 05 collision a4")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a5.wav", "bird 05 collision a5")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 flying.wav", "bird_05_flying")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 select.wav", "bird_05_select")
	_G.res.createAudio(audioPath .. "/sfx/bird_06_flying.wav", "bird_06_flying")
	_G.res.createAudio(audioPath .. "/sfx/boomerang_select.wav", "boomerang_select")
	--_G.res.createAudio(audioPath .. "/sfx/bird 05 unselect.wav", "bird_05_unselect")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 06 flying.wav", "bird_06_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 07 flying.wav", "bird_07_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 08 flying.wav", "bird_08_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 09 flying.wav", "bird_09_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 10 flying.wav", "bird_10_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 11 flying.wav", "bird_11_flying")

	_G.res.createAudio(audioPath .. "/sfx/bird misc a1.wav", "bird_misc_a1")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a2.wav", "bird_misc_a2")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a3.wav", "bird_misc_a3")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a4.wav", "bird_misc_a4")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a5.wav", "bird_misc_a5")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a6.wav", "bird_misc_a6")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a7.wav", "bird_misc_a7")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a8.wav", "bird_misc_a8")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a9.wav", "bird_misc_a9")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a10.wav", "bird_misc_a10")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a11.wav", "bird_misc_a11")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a12.wav", "bird_misc_a12")

	_G.res.createAudio(audioPath .. "/sfx/bird destroyed.wav", "bird_destroyed")
	--_G.res.createAudio(audioPath .. "/sfx/bird flying generic loop 2.wav", "bird flying generic loop 2")
	--_G.res.createAudio(audioPath .. "/sfx/bird flying generic loop.wav", "bird flying generic loop")
	--_G.res.createAudio(audioPath .. "/sfx/bird next a1.wav", "bird next a1")
	--_G.res.createAudio(audioPath .. "/sfx/bird next a2.wav", "bird next a2")
	--_G.res.createAudio(audioPath .. "/sfx/bird next a3.wav", "bird next a3")
	_G.res.createAudio(audioPath .. "/sfx/bird next military a1.wav", "bird next military a1")
	_G.res.createAudio(audioPath .. "/sfx/bird next military a2.wav", "bird next military a2")
	_G.res.createAudio(audioPath .. "/sfx/bird next military a3.wav", "bird next military a3")
	--_G.res.createAudio(audioPath .. "/sfx/bird shot.wav", "bird_shot")
	-- _G.res.createAudio(audioPath .. "/sfx/good shot a1.wav", "good shot a1")
	-- _G.res.createAudio(audioPath .. "/sfx/good shot a2.wav", "good shot a2")
	-- _G.res.createAudio(audioPath .. "/sfx/good shot a3.wav", "good shot a3")
	_G.res.createAudio(audioPath .. "/sfx/bird shot-a1.wav", "bird shot a1")
	_G.res.createAudio(audioPath .. "/sfx/bird shot-a2.wav", "bird shot a2")
	_G.res.createAudio(audioPath .. "/sfx/bird shot-a3.wav", "bird shot a3")
	--_G.res.createAudio(audioPath .. "/sfx/level clear a1.wav", "level clear a1")
	--_G.res.createAudio(audioPath .. "/sfx/level clear a2.wav", "level clear a2")
	_G.res.createAudio(audioPath .. "/sfx/level clear military a1.mp3", "level clear military a1")
	_G.res.createAudio(audioPath .. "/sfx/level clear military a2.mp3", "level clear military a2")
	--_G.res.createAudio(audioPath .. "/sfx/level failed a1.wav", "level failed a1")
	--_G.res.createAudio(audioPath .. "/sfx/level failed a2.wav", "level failed a2")
	_G.res.createAudio(audioPath .. "/sfx/level failed piglets a1.mp3", "level failed piglets a1")
	_G.res.createAudio(audioPath .. "/sfx/level failed piglets a2.mp3", "level failed piglets a2")
	--_G.res.createAudio(audioPath .. "/sfx/level start a1.wav", "level start a1")
	--_G.res.createAudio(audioPath .. "/sfx/level start a2.wav", "level start a2")
	_G.res.createAudio(audioPath .. "/sfx/level start military a1.mp3", "level start military a1")
	_G.res.createAudio(audioPath .. "/sfx/level start military a2.mp3", "level start military a2")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a1.wav", "light collision a1")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a2.wav", "light collision a2")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a3.wav", "light collision a3")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a4.wav", "light collision a4")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a5.wav", "light collision a5")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a6.wav", "light collision a6")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a7.wav", "light collision a7")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a8.wav", "light collision a8")
	_G.res.createAudio(audioPath .. "/sfx/light damage a1.wav", "light damage a1")
	_G.res.createAudio(audioPath .. "/sfx/light damage a2.wav", "light damage a2")
	_G.res.createAudio(audioPath .. "/sfx/light damage a3.wav", "light damage a3")
	_G.res.createAudio(audioPath .. "/sfx/light destroyed a1.wav", "light destroyed a1")
	_G.res.createAudio(audioPath .. "/sfx/light destroyed a2.wav", "light destroyed a2")
	_G.res.createAudio(audioPath .. "/sfx/light destroyed a3.wav", "light destroyed a3")
	_G.res.createAudio(audioPath .. "/sfx/light rolling.wav", "light_rolling")
	_G.res.createAudio(audioPath .. "/sfx/menu back.wav", "menu_back")
	_G.res.createAudio(audioPath .. "/sfx/menu confirm.wav", "menu_confirm")
	_G.res.createAudio(audioPath .. "/sfx/menu select.wav", "menu_select") -- is this used anywhere?
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a1.wav", "piglette collision a1")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a2.wav", "piglette collision a2")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a3.wav", "piglette collision a3")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a4.wav", "piglette collision a4")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a5.wav", "piglette collision a5")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a6.wav", "piglette collision a6")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a7.wav", "piglette collision a7")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a8.wav", "piglette collision a8")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a1.wav", "piglette damage a1")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a2.wav", "piglette damage a2")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a3.wav", "piglette damage a3")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a4.wav", "piglette damage a4")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a5.wav", "piglette damage a5")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a6.wav", "piglette damage a6")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a7.wav", "piglette damage a7")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a8.wav", "piglette damage a8")
	_G.res.createAudio(audioPath .. "/sfx/piglette destroyed.wav", "piglette_destroyed")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a1.wav", "rock collision a1")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a2.wav", "rock collision a2")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a3.wav", "rock collision a3")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a4.wav", "rock collision a4")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a5.wav", "rock collision a5")
	_G.res.createAudio(audioPath .. "/sfx/rock damage a1.wav", "rock damage a1")
	_G.res.createAudio(audioPath .. "/sfx/rock damage a2.wav", "rock damage a2")
	_G.res.createAudio(audioPath .. "/sfx/rock damage a3.wav", "rock damage a3")
	_G.res.createAudio(audioPath .. "/sfx/rock destroyed a1.wav", "rock destroyed a1")
	_G.res.createAudio(audioPath .. "/sfx/rock destroyed a2.wav", "rock destroyed a2")
	_G.res.createAudio(audioPath .. "/sfx/rock destroyed a3.wav", "rock destroyed a3")
	_G.res.createAudio(audioPath .. "/sfx/rock rolling.wav", "rock_rolling")
	_G.res.createAudio(audioPath .. "/sfx/special boost.wav", "special_boost")
	_G.res.createAudio(audioPath .. "/sfx/special egg explosion.wav", "special_explosion")
	_G.res.createAudio(audioPath .. "/sfx/special group.wav", "special_egg")
	_G.res.createAudio(audioPath .. "/sfx/special egg.wav", "special_group")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a1.wav", "wood collision a1")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a2.wav", "wood collision a2")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a3.wav", "wood collision a3")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a4.wav", "wood collision a4")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a5.wav", "wood collision a5")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a6.wav", "wood collision a6")
	_G.res.createAudio(audioPath .. "/sfx/wood damage a1.wav", "wood damage a1")
	_G.res.createAudio(audioPath .. "/sfx/wood damage a2.wav", "wood damage a2")
	_G.res.createAudio(audioPath .. "/sfx/wood damage a3.wav", "wood damage a3")
	_G.res.createAudio(audioPath .. "/sfx/wood destroyed a1.wav", "wood destroyed a1")
	_G.res.createAudio(audioPath .. "/sfx/wood destroyed a2.wav", "wood destroyed a2")
	_G.res.createAudio(audioPath .. "/sfx/wood destroyed a3.wav", "wood destroyed a3")
	_G.res.createAudio(audioPath .. "/sfx/wood rolling.wav", "wood_rolling")
	_G.res.createAudio(audioPath .. "/sfx/balloon_pop.wav", "balloon_pop")
	
	-- new
	_G.res.createAudio(audioPath .. "/sfx/bird pushing egg out.wav", "bird_pushing_egg_out")
	--_G.res.createAudio(audioPath .. "/sfx/bird releaved.wav", "bird_releaved")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette sneezing.wav", "piglette_sneezing")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a1.wav", "piglette snoring a1")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a2.wav", "piglette snoring a2")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a3.wav", "piglette snoring a3")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a4.wav", "piglette snoring a4")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a5.wav", "piglette snoring a5")
	_G.res.createAudio(audioPath .. "/sfx/slingshot streched.wav", "slingshot_stretched")
	-- _G.res.createAudio(audioPath .. "/sfx/special tweat.wav", "special_tweat")
	_G.res.createAudio(audioPath .. "/sfx/tnt box explodes.wav", "tnt_explodes")
	_G.res.createAudio(audioPath .. "/sfx/boomerang_swish.wav", "boomerang_swish")
	_G.res.createAudio(audioPath .. "/sfx/boomerang_activate.wav", "boomerang_activate")
	_G.res.createAudio(audioPath .. "/sfx/trampoline.wav", "trampoline")
	
	_G.res.createAudio(audioPath .. "/sfx/redbird_yell01.wav", "red_special_1")
	_G.res.createAudio(audioPath .. "/sfx/redbird_yell02.wav", "red_special_2")
	_G.res.createAudio(audioPath .. "/sfx/redbird_yell03.wav", "red_special_3")
	
	--_G.res.createAudio(audioPath .. "/sfx/redbird_yell01_low.wav", "big_brother_special_1")
	--_G.res.createAudio(audioPath .. "/sfx/redbird_yell02_low.wav", "big_brother_special_2")
	--_G.res.createAudio(audioPath .. "/sfx/redbird_yell03_low.wav", "big_brother_special_3")
	_G.res.createAudio(audioPath .. "/sfx/bigbrother_yell.wav", "big_brother_special_1")
	
	
	--_G.res.createAudio(audioPath .. "/sfx/mightymouse.wav", "bait_mouse_fly")
	--_G.res.createAudio(audioPath .. "/sfx/mightymouse_select.wav", "bait_mouse_select")
	_G.res.createAudio(audioPath .. "/sfx/mightyeagle.wav", "mighty_eagle_yell")
	_G.res.createAudio(audioPath .. "/sfx/mightyeagle_thump.wav", "mighty_eagle_thump")
		
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a1.wav", "piglette_a1")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a2.wav", "piglette_a2")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a3.wav", "piglette_a3")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a4.wav", "piglette_a4")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a5.wav", "piglette_a5")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette oink a6.wav", "piglette_a6")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette oink a7.wav", "piglette_a7")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a8.wav", "piglette_a8")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a9.wav", "piglette_a9")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a10.wav", "piglette_a10")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a11.wav", "piglette_a11")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a12.wav", "piglette_a12")
	_G.res.createAudio(audioPath .. "/sfx/star_collect.wav", "star_collect")
	_G.res.createAudio(audioPath .. "/sfx/button_radio.wav", "button_radio")
	_G.res.createAudio(audioPath .. "/sfx/goldenegg.wav", "goldenegg")
	_G.res.createAudio(audioPath .. "/sfx/piano-c.wav", "noteC")
	_G.res.createAudio(audioPath .. "/sfx/piano-cis.wav", "noteCis")
	_G.res.createAudio(audioPath .. "/sfx/piano-d.wav", "noteD")
	_G.res.createAudio(audioPath .. "/sfx/piano-dis.wav", "notedis")
	_G.res.createAudio(audioPath .. "/sfx/piano-e.wav", "noteE")
	_G.res.createAudio(audioPath .. "/sfx/piano-f.wav", "noteF")
	_G.res.createAudio(audioPath .. "/sfx/piano-fis.wav", "noteFis")
	_G.res.createAudio(audioPath .. "/sfx/piano-g.wav", "noteG")
	
	_G.res.createAudio(audioPath .. "/music/level_complete.mp3", "level_complete")
	_G.res.createAudio(audioPath .. "/music/game_complete.mp3", "game_complete")
	_G.res.createAudio(audioPath .. "/music/title_theme.mp3", "title_theme")
	_G.res.createAudio(audioPath .. "/music/ambient_white_dryforest.mp3", "ambient_theme1")
	_G.res.createAudio(audioPath .. "/music/ambient_green_jungleish.mp3", "ambient_theme2")
	_G.res.createAudio(audioPath .. "/music/ambient_red_savannah.mp3", "ambient_theme3")
	_G.res.createAudio(audioPath .. "/music/ambient_city.mp3", "ambient_theme7")
	_G.res.createAudio(audioPath .. "/music/birds_outro.mp3", "birds_outro")
	_G.res.createAudio(audioPath .. "/music/birds_intro.mp3", "birds_intro")
	_G.res.createAudio(audioPath .. "/music/birds_boss.mp3", "birds_boss")
	_G.res.createAudio(audioPath .. "/music/funky_theme.mp3", "funky_theme")
	--_G.res.createAudio(audioPath .. "/music/atmosphere_halloween.mp3", "atmosphere_halloween")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink story.wav", "piglette_oink_story")
	_G.res.createAudio(audioPath .. "/sfx/ball_bounce.wav", "ball_bounce")
	
	_G.res.createAudio(audioPath .. "/music/ambient_construction.mp3", "construction_theme1")
	
	-- sequencer
	_G.res.createAudio(audioPath .. "/sfx/pig_bd.wav", "pig_bd")
	_G.res.createAudio(audioPath .. "/sfx/pig_snare_1.wav", "pig_snare_1")
	_G.res.createAudio(audioPath .. "/sfx/pig_snare_2.wav", "pig_snare_2")
	_G.res.createAudio(audioPath .. "/sfx/pig_snare_3.wav", "pig_snare_3")
	_G.res.createAudio(audioPath .. "/sfx/pig_snare_4.wav", "pig_snare_4")
	_G.res.createAudio(audioPath .. "/sfx/pig_hi-hat_1.wav", "pig_hi-hat_1")
	_G.res.createAudio(audioPath .. "/sfx/pig_hi-hat_2.wav", "pig_hi-hat_2")
	
	audioGroups = {
		--bad_shot = { "bad shot a1", "bad shot a2" },
		bird_01_collision = { "bird 01 collision a1", "bird 01 collision a2", "bird 01 collision a3", "bird 01 collision a4" },
		bird_02_collision = { "bird 02 collision a1", "bird 02 collision a2", "bird 02 collision a3", "bird 02 collision a4", "bird 02 collision a5" },
		bird_03_collision = { "bird 03 collision a1", "bird 03 collision a2", "bird 03 collision a3", "bird 03 collision a4", "bird 03 collision a5" },
		bird_04_collision = { "bird 04 collision a1", "bird 04 collision a2", "bird 04 collision a3", "bird 04 collision a4" },
		bird_05_collision = { "bird 05 collision a1", "bird 05 collision a2", "bird 05 collision a3", "bird 05 collision a4", "bird 05 collision a5" },
		big_brother_collision = { "bird 01 collision a1_low", "bird 01 collision a2_low", "bird 01 collision a3_low", "bird 01 collision a4_low" },
		bird_next = { "bird next a1", "bird next a2", "bird next a3" },
		bird_next_military = { "bird next military a1", "bird next military a2", "bird next military a3" },
		bird_shot = { "bird shot a1", "bird shot a2", "bird shot a3"},
		--good_shot = { "good shot a1", "good shot a2", "good shot a3"},
		--level_clear = { "level clear a1", "level clear a2" },
		level_clear_military = { "level clear military a1", "level clear military a2" },
		--level_failed = { "level failed a1", "level failed a2" },
		level_failed_piglets = { "level failed piglets a1", "level failed piglets a2" },
		--level_start = { "level start a1", "level start a2" },
		level_start_military = { "level start military a1", "level start military a2" },
		light_collision = { "light collision a1", "light collision a2", "light collision a3", "light collision a4", "light collision a5", "light collision a6", "light collision a7", "light collision a8" },
		light_damage = { "light damage a1", "light damage a2", "light damage a3" },
		light_destroyed = { "light destroyed a1", "light destroyed a2", "light destroyed a3" },
		piglette_collision = { "piglette collision a1", "piglette collision a2", "piglette collision a3", "piglette collision a4", "piglette collision a5", "piglette collision a6", "piglette collision a7", "piglette collision a8" },
		piglette_damage = { "piglette damage a1", "piglette damage a2", "piglette damage a3", "piglette damage a4", "piglette damage a5", "piglette damage a6", "piglette damage a7", "piglette damage a8" },
		rock_collision = { "rock collision a1", "rock collision a2", "rock collision a3", "rock collision a4", "rock collision a5" },
		rock_damage = { "rock damage a1", "rock damage a2", "rock damage a3" },
		rock_destroyed = { "rock destroyed a1", "rock destroyed a2", "rock destroyed a3" },
		wood_collision = { "wood collision a1", "wood collision a2", "wood collision a3", "wood collision a4", "wood collision a5", "wood collision a6" },
		wood_damage = { "wood damage a1", "wood damage a2", "wood damage a3" },
		wood_destroyed = { "wood destroyed a1", "wood destroyed a2", "wood destroyed a3" },
		bird_misc = { "bird_misc_a1", "bird_misc_a2", "bird_misc_a3", "bird_misc_a4", "bird_misc_a5", "bird_misc_a6", "bird_misc_a7", "bird_misc_a8", "bird_misc_a9", "bird_misc_a10", "bird_misc_a11", "bird_misc_a12" },
		--piglette_snoring = { "piglette snoring a1", "piglette snoring a2", "piglette snoring a3", "piglette snoring a4", "piglette snoring a5" },
		piglette = { "piglette_a1", "piglette_a2", "piglette_a3", "piglette_a4", "piglette_a5", "piglette_a8", "piglette_a9", "piglette_a10", "piglette_a11", "piglette_a12" },
		--, "piglette_a6", "piglette_a7"
		red_special = { "red_special_1", "red_special_2", "red_special_3" },
		--big_brother_special = { "big_brother_special_1", "big_brother_special_2", "big_brother_special_3" },
		big_brother_special = { "big_brother_special_1", },
	}

		musics = {  "ambient_theme1", -- 1
					"ambient_theme2", -- 2
					"ambient_theme3", -- 3
					"ambient_theme1", -- 4
					"ambient_theme3", -- 5
					"ambient_theme3", -- 6
					"ambient_theme7", -- 7
					"ambient_theme2", -- 8
					"construction_theme1", -- 9
					"construction_theme1", -- 10
					"construction_theme1", -- 11
					"construction_theme1", -- 12
					"construction_theme1", -- 13
					"construction_theme1", -- 14
					"construction_theme1", -- 15
					"atmosphere_halloween", --16
					"ambient_theme3", -- 17
				}

	if settings.audioEnabled == false then
		_G.res.stopAudioOutput()
		setEffectsVolume(0)
		setMusicVolume(0)
	else
		_G.res.startAudioOutput()
		setEffectsVolume(1)
		setMusicVolume(1)
	end
	
	if deviceModel == "roku" then
		settings.currentMainMenuTheme = settings.currentMainMenuTheme or "theme1"
		
		if(settings.currentMainMenuTheme ~= nil) then
			for k, v in _G.pairs(blockTable.themes) do
				if(k == settings.currentMainMenuTheme) then
					loadThemeGraphics(k)
					break
				end
			end
		end
	end
	
	assetsCreated = true
end

function saveLuaFileWrapper(fileName, tableName, appData)
	if isLiteVersion == true and deviceModel == "s60" then
		if tableName == "settings" then
			fileName = "settings_trial.lua"
		end
		
		if tableName == "highscores" then
			fileName = "highscores_trial.lua"
		end
	end		
	
	saveLuaFile(fileName, tableName, appData)
end

function getAudioName(name)
	if audioGroups[name] ~= nil then
		local index = _G.math.random(1, #audioGroups[name])
		return audioGroups[name][index]
	end

	return name
end

--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Game main function, this is called every frame by the engine

showFps = false
showBG = true
showSleepingObjects = false

fpsTimer = 0
fpsFrames = 0
fps = 0
zoomLevel = 0

function update(dt, realDt)
	if g_DynamicAssetLoading and currentGameMode ~= updateLoadingEx then
		loadDynamicAssets(g_DynamicAssetLoading)
		g_DynamicAssetLoading = nil
	end
	
--	print("RX = "..(cursor.x / screenWidth).." RY = "..(cursor.y / screenHeight).."\n")
	
	-- if deviceModel == "roku" and releaseBuild ~= true and keyPressed["KEY_GAMING_B"] then
		-- g_gfxLowQuality = not g_gfxLowQuality
	-- end
	
	if g_mouseOrTouchStates.doesMouseClickSetsCount == nil then
		g_mouseOrTouchStates.doesMouseClickSetsCount = doesMouseClickSetsTouchCount()
	end
	
	if g_gesturePausePageEnablingFlags.simulateTouchOnWindows == true and deviceModel ~= "roku" then
		if keyHold["L"] then
			touchcount = 3
			touches["654"] = {}
			touches["654"].x = cursor.x
			touches["654"].y = cursor.y
			--captureMouse(true)
			captureMouse(false)
		else
			touchcount = 0
			touches = {}
			captureMouse(false)
		end
	end
	
	
	--changes mouse cursor on global, level, mouse cursor changes can be modified on other updates methods
	--this is for all mouse down states, including, menus
	if keyHold["LBUTTON"] then
		g_currentCursorName = "CURSOR_HAND_CLICK"
	elseif currentGameMode == updateGame and birdTutorialPopups and #birdTutorialPopups == 0 then
		g_currentCursorName = "CURSOR_HAND_HOVER"
	else
		g_currentCursorName = "CURSOR_HAND_POINT"
	end
	
	
	
	if newMenuPageNeedsPrepare == true or currentMenuPage ~= newMenuPage then
		setActiveMenuPageDelayed(newMenuPage, newMenuPageNeedsPrepare)
		newMenuPageNeedsPrepare = nil
	end
	
	if loadLevelDelayed ~= nil then
		--loadLevelInternal(loadLevelDelayed)
		initCameras()
		loadLevelDelayed = nil
		setGameMode(updateGame)
		updateGame(dt)
		drawGame()
	end
	
	if additionalPopupPageDelay ~= true and newPopupPage ~= nil and popupPage ~= newPopupPage then
		popupPage = newPopupPage
		if popupPage == upsellPage then
			releaseCutScenes()
		end
		
		if deviceModel == "iphone4" and (popupPage == goldenEggAchievedPage or popupPage == boomerangBirdAchievedPage) then
			resetCameras()
		end
		
		if newPopupPageNeedsPrepare ~= false then
			prepareMenuPage(popupPage)
			if popupPage == goldenEggAchievedPage then
				print("goldenEggAchievedPage prepared\n")
			end
		end
		print("popup delayed: "..popupPage.name .. "\n")
		newPopupPageNeedsPrepare = nil
		newPopupPage = nil
	end
	
	if additionalPopupPageDelay == true then
		additionalPopupPageDelay = nil
	end

	-- Initialize current game mode to splash sequence
	currentGameMode = currentGameMode or updateSplashes

	-- Keep track of elapsed time
	time = time and time + dt or 0
	playtimeCounter = playtimeCounter and playtimeCounter + dt or 0
	
	-- Check for double clicks
	doubleClick = false
	
	if doubleClickTimer == nil then
		doubleClickTimer = 0
	end
	
	if keyPressed["LBUTTON"] then
		if doubleClickState ~= 2 then
			doubleClickState = 1
			doubleClickTimer = 0.5
		else
			doubleClickState = 3
		end
	elseif doubleClickTimer > 0 and keyReleased["LBUTTON"] then
		if doubleClickState == 1 then
			doubleClickState = 2
		elseif doubleClickState == 3 then
			doubleClick = true
		end
	end
	
	doubleClickTimer = doubleClickTimer - dt
	if doubleClickTimer <= 0 then
		doubleClickTimer = 0
		doubleClickState = 0
	end

	-- Update current "game scene"
	-- NOTE: loadingScreen is a hack to make sure the cursor isn't drawn during loading screens
	local loadingScreen = currentGameMode == updateLoading or currentGameMode == updateLoadingEx
	currentGameMode(dt, time)
	loadingScreen = loadingScreen or currentGameMode == updateLoading or currentGameMode == updateLoadingEx

	if keyPressed["S"] then
		changeAudio()
		toggleSoundBoardSFXButtons()
	end
	
	if audioRampVolume then
		audioRampVolume = audioRampVolume + (dt / audioRampLength)
		
		if audioRampVolume <= 0 then
			_G.res.stopAudioOutput()
			audioRampVolume = nil
		elseif audioRampVolume > 1 then
			audioRampVolume = nil
		else
			-- Use squared volume because it gives more linear response
			setMusicVolume( audioRampVolume * audioRampVolume )
			setEffectsVolume( audioRampVolume * audioRampVolume )
		end
	end
	
	
	if (keyPressed["0"] or keyPressed["F"]) and (not releaseBuild) then
	--if (keyPressed["0"] or keyPressed["F"])  then
		showFps = not showFps
	end

	if keyPressed["9"] and (not releaseBuild) then
		showBG = not showBG
	end

	if keyPressed["8"] and not releaseBuild then
		showSleepingObjects = not showSleepingObjects
	end
	
	-- show fps
	if showFps and assetsCreated == true then
		if fpsTimer >= 1 then
			fps = fpsFrames / fpsTimer
			fpsTimer = 0
			fpsFrames = 0
		end
		fpsString = _G.string.format("%.1f", fps)
		setFont(fontBasic);
		_G.res.drawString("", fpsString, screenWidth*0.5, screenHeight, "BOTTOM", "HCENTER")
		fpsTimer = fpsTimer + realDt
		fpsFrames = fpsFrames + 1
	end
	
	if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
		
		if #achievementUnlockQueue > 0 then
			if lastAchievementUnlockTime == nil then
				lastAchievementUnlockTime = -3
			end
			
			if time - lastAchievementUnlockTime > 3 then
				if gameCenterEnabled then
					if gameCenter and gameCenter.achievements and gameCenter.achievements.loading ~= true then
						unlockAchievement(achievementUnlockQueue[1].id, achievementUnlockQueue[1].desc)
						_G.table.remove(achievementUnlockQueue, 1)
						lastAchievementUnlockTime = time
					end
				else
					unlockAchievement(achievementUnlockQueue[1].id, achievementUnlockQueue[1].desc)
					_G.table.remove(achievementUnlockQueue, 1)
					lastAchievementUnlockTime = time
				end
			end
		end
	
		if checkForCrystalEnabled == true and userEnabledCrystal() == true then
			checkForCrystalEnabled = false
			showCrystalInMainMenu = true
			activateCrystalUIAtProfile()
		end
	end
	
	if currentGameMode ~= updateSplashes then
		
		if 	g_updateCheckFlags.enabled == true and deviceModel == "windows" and 
			g_updateCheckFlags.updateCheckCalled == false then
			
			g_updateCheckFlags.updateCheckCalled = true
			
			checkForUpdates()
		end
		
		if keyPressed["SPACE"] and (not releaseBuild) then
			g_cursorIndex = g_cursorIndex + 1
			g_cursorIndex = (g_cursorIndex % #g_cursorNames)
			g_currentCursorName = g_cursorNames[g_cursorIndex+1]
		end
		
		setRenderState(0,0, 1, 1, 0)
		
		--[[
		if keyHold["L"] then
			touchcount = 1
			touches ={{},{}}
			touches[1].x = cursor.x
			touches[1].y = cursor.y
		else
			touchcount = 0
		end
		]]
		
		updateMultipleInputSystemStates(dt)
		
		
		
		if currentGameMode == updateGame and deviceModel ~= "roku" then 
			if birdTutorialPopups ~= nil and #birdTutorialPopups > 0 then
				_G.res.drawSprite("", g_currentCursorName, cursor.x, cursor.y)
			else
				if g_currentCursorName ~= nil and g_mouseOrTouchStates.isUsingMouse then
					_G.res.drawSprite("", g_currentCursorName, cursor.x, cursor.y)
				end
			end
			
			--Native-side function don't exist on earliest version
			--setIsMultitouchMouseWheelSimulationEnabled(false)
		elseif currentGameMode ~= updateGame then
		
			local isEpisodeEndMenu =
				function(menuPage)
					return menuPage == gameFinishedThreeStars or menuPage == gameFinishedThreeStarsLP2 or menuPage == gameFinishedThreeStarsLP3 or
						menuPage == gameFinishedThreeStarsLP4 or menuPage == gameFinishedThreeStarsLP5 or menuPage == gameFinished or
						menuPage == gameFinishedLP2 or menuPage == gameFinishedLP3 or menuPage == gameFinishedLP4 or menuPage == gameFinishedLP5
				end
		
			local inCutScene = currentMenuPage and currentMenuPage.isCutScene
			local disableCursor = loadingScreen or inCutScene or isEpisodeEndMenu(currentMenuPage)
			if deviceModel ~= "roku" or not disableCursor then
				if g_gesturePausePageEnablingFlags.enablePage == true then
					if currentMenuPage ~= g_gesturePausePage and newMenuPage ~= g_gesturePausePage then
						_G.res.drawSprite("", g_currentCursorName, cursor.x, cursor.y)
						setIsMultitouchMouseWheelSimulationEnabled(true)
					end
				else
					_G.res.drawSprite("", g_currentCursorName, cursor.x, cursor.y)
					--setIsMultitouchMouseWheelSimulationEnabled(true)
				end
			end

			if 	(deviceModel == "windows") and 
				(g_updateCheckFlags.enabled == true) and 
				(currentGameMode == updateMenu) and 
				(settings.updateNotification ~= nil) and
				(settings.updateNotification.updateNotified == false) and
				(g_updateCheckFlags.updateAvailable == true) and
				(currentMenuPage == mainMenu) then
				
				settings.updateNotification.gameVersionOnLastWarning = gameVersionNumber
				
				showUpdateNotificationPrompt()
			end
		end
		
		if deviceModel ~= "roku" and isInFullScreenMode() == false then
			settings.screenWidth = screenWidth
			settings.screenHeight = screenHeight
		end
	end
	
	
	
	--drawLine2D(screenWidth / 2, 0, screenWidth / 2, screenHeight, 2,255,0,0,255)	
	--drawLine2D(screenWidth / 2 + (215 / 2), 0, screenWidth / 2 + (215 / 2), screenHeight, 2,255,0,0,255)
	
	--drawLine2D(screenWidth / 2 + (724 -296) / 2, 0, screenWidth / 2 + (724 -296) / 2, screenHeight, 2,255,0,0,255)	
	
	--drawLine2D(0, 461, screenWidth, 461, 2,0,255,0,255)	
	--drawLine2D(0, 502, screenWidth, 502, 2,0,255,0,255)	
	--drawLine2D(0, 544, screenWidth, 544, 2,0,255,0,255)	
	
	--[[
	drawLine2D(screenWidth / 2 + (492) / 2 + 24, 0, screenWidth / 2 + (492) / 2 + 24, screenHeight, 2,255,0,0,255)	
	drawLine2D(screenWidth / 2 - (492) / 2 - 24, 0, screenWidth / 2 - (492) / 2 - 24, screenHeight, 2,255,0,0,255)	
	
	_G.res.drawSprite("", "POPUP_TOP_LEFT", 50, 50)
	drawLine2D(50, 0, 50, screenHeight, 2,255,0,0,255)	
	drawLine2D(50-34, 0, 50-34, screenHeight, 2,255,0,0,255)	
	]]--
	
	if fontBasic ~= nil  and g_enableDebugTextField == true then
		setFont(fontBasic)
		if isMouseCaptured() then
			_G.res.drawString("TEXTS_BASIC", "mouse captured x: " .. cursor.x .. " y: " .. cursor.y, 50, 50, "TOP", "LEFT")
		else
			_G.res.drawString("TEXTS_BASIC", "mouse not captured x: " .. cursor.x .. " y: " .. cursor.y, 50, 50, "TOP", "LEFT")
		end
	end
		
		
		

	if (deviceModel == "windows") and (g_registrationEnabled == true) and (g_isFullScreenBeforeOpeningRegistration == true) then
		--g_updateCount is hack, for some reason, the game need a few updates in order to get the registration window selectable and the 
		--game drawn correctly, the target works with 3, but we use 10 to play safe
		g_updateCount = g_updateCount + 1
		
		if g_updateCount == 10 then
			
			local t_returnedKey = openRegistrationDialog("Activate the full game!", g_registrationURLs.validationURL, g_registrationURLs.registrationURL, g_registrationKeys.fullGame)
			-- local t_isOnGameScene = (sm~= nil) and (sm.currentScene ~= nil) and (sm.currentScene == sm.scenes.game)
			-- local t_isOnPauseScene = (sm~= nil) and (sm.currentScene ~= nil) and (sm.currentScene == pause)
			local t_isLevelSelection = currentMenuPage == levelSelectionPagesBasic or currentMenuPage == levelSelectionPagesExtra or currentMenuPage == levelSelectionPagesPack3
			                           or currentMenuPage == levelSelectionPagesPack4 or currentMenuPage == levelSelectionPagesPack5 or currentMenuPage == levelSelectionPagesPack6
			                           or currentMenuPage == levelSelectionPagesGoldenEggs
								
			-- local t_isDuringGame = not t_isLevelSelection
			local t_isDuringGame = currentGameMode == updateGame
			if t_returnedKey ~= "" then
				g_isGameUnlocked = true
				
				_G.table.insert(settings.license.registeredKeyTypes, g_registrationKeys.fullGame)
				settings.license.hardwareID = getDeviceID()
				
				local t_button = getItemByName(mainMenu.items, "buttonActivateFullVersion")	
				t_button.visible = (g_isGameUnlocked == false)
				
				local buttonNextLevel = getItemByName(levelComplete.items, "buttonNextLevel")
				-- buttonNextLevel.visible = true
				
			elseif t_isDuringGame == true then
			-- else
				-- gotoMainMenu()
				
				-- loadNextLevel(dt)
			end
			
						
			setFullScreenMode(true)
			
			-- if t_isOnPauseScene == true then
				-- pause.pages["pause"]:closeMenu()				
			-- end
			g_isFullScreenBeforeOpeningRegistration = false
			g_updateCount = 0
		end
	end		
	
end

function gameResumed()

	if g_restoreFullScreenOnReactivate then
		setFullScreenMode(true)
		g_restoreFullScreenOnReactivate = nil
	end

end

function gamePaused()
	calculatePlaytime()
	saveLuaFileWrapper("settings.lua", "settings", true)
	if currentGameMode == updateGame then	
		showPauseMenu()
		setPhysicsEnabled(false)
		pausePage.offsetX = 0
		pausePage.backgroundOverlay.shade = 0.65
		setAnimationState("ingamePausePageScroll", "VISIBLE")
		drawGame()
	end
end

function setFont(fontName)
	_G.res.useFont(fontName)
end

function setGameMode(gameMode)
	currentGameMode = gameMode
	if currentGameMode == updateGame then
		setGameOn(true)
		avoidCrystalBackgroundActivity(true)
	else
		if deviceModel == "roku" and not rokuOnWindows and not isMouseCaptured() then
			captureMouse(true)
		end

		setGameOn(false)
		avoidCrystalBackgroundActivity(false)
	end
end

function setActivePopupPage(popupPage, prepare)	
	newPopupPage = popupPage
	newPopupPageNeedsPrepare = prepare
end

function changeSliderStatus()
	local buttonSliderBG = getItemByName(mainMenu.items, "buttonSliderBG")
	local sliderBGRight = getItemByName(mainMenu.items, "sliderBGRight")
	if buttonSliderBG.state == "closed" then
		sliderBGRight.visible = true
		buttonSliderBG.state = "opening"
	elseif buttonSliderBG.state == "open" then
		buttonSliderBG.state = "closing"
	end
end

function changeOptionSliderStatus()
	local buttonSliderBGOptions = getItemByName(mainMenu.items, "buttonSliderBGOptions")
	local sliderBGLeft = getItemByName(mainMenu.items, "sliderBGLeft")
	if buttonSliderBGOptions.state == "closed" then
		sliderBGLeft.visible = true
		buttonSliderBGOptions.state = "opening"
	elseif buttonSliderBGOptions.state == "open" then
		buttonSliderBGOptions.state = "closing"
	end
end


function scrollLevelSelectionLeft(page)
	if page.currentPage > 1 then
		levelSelectionDragSpeed = 1000
		page.currentPage = page.currentPage - 1
		_G.res.playAudio("menu_confirm", 1, false)
	end
end

function scrollLevelSelectionRight(page)
	if page.currentPage < page.pageCount then
		levelSelectionDragSpeed = 1000
		page.currentPage = page.currentPage + 1
		_G.res.playAudio("menu_confirm", 1, false)
	end
end

function setActiveMenuPage(menuPage, prepare)
	--print("setActiveMenuPage: "..menuPage.name)
	newMenuPage = menuPage
	newMenuPageNeedsPrepare = prepare
	if newMenuPage ~= nil and newMenuPage.bgColor ~= nil then
		setBGColor(newMenuPage.bgColor.red, newMenuPage.bgColor.green, newMenuPage.bgColor.blue)
	end
end

function setActiveMenuPageDelayed(menuPage, prepare)
	oldMenuPage = currentMenuPage
	
	if oldMenuPage ~= nil and oldMenuPage ~= menuPage then
		onExitPage(oldMenuPage)
	end
	
	currentMenuPage = menuPage
	
	-- for iphone4 resolution changing
	if deviceModel == "iphone4" and (menuPage == pausePage or menuPage == levelFailed or menuPage == levelComplete or
									 menuPage == goldenEggAchievedPage or menuPage == boomerangBirdAchievedPage or
								     menuPage == gameFinished or menuPage == gameFinishedThreeStars or
									 menuPage == gameFinishedLP2 or menuPage == gameFinishedThreeStarsLP2 or
									 menuPage == gameFinishedLP3 or menuPage == gameFinishedThreeStarsLP3 or
									 menuPage == gameFinishedLP4 or menuPage == gameFinishedThreeStarsLP4 or
									 menuPage == gameFinishedLP5 or menuPage == gameFinishedThreeStarsLP5) then
		resetCameras()
	end
	
	if prepare ~= false and currentMenuPage ~= nil then
		if currentMenuPage == mainMenu or currentMenuPage == about then
			prepareMenuPage(mainMenu)
			prepareMenuPage(about)
		else
			prepareMenuPage(currentMenuPage)
		end
	end
	
	if showCrystalInMainMenu then
		if menuPage == mainMenu then
			activateCrystalUI()
		else
			playerInitializedCrystalUiDeactivation = false
			deactivateCrystalUI()
		end
	end
end

function onExitPage(menuPage)
	
end

function crystalUiDeactivated()
	if playerInitializedCrystalUiDeactivation ~= false then
		showCrystalInMainMenu = false
	end
	
	playerInitializedCrystalUiDeactivation = true
end

function loadGoldenEggSprites()
	if deviceModel == "roku" then
		if screenHeight > 576 then
			_G.res.createSpriteSheet(imagePath .. "/GOLDEN_EGGS_SHEET_1.dat")
			_G.res.createSpriteSheet(imagePath .. "/GOLDEN_EGGS_SHEET_2.dat")
		else
			_G.res.createSpriteSheet(imagePath .. "/low/GOLDEN_EGGS_SHEET_2.dat")
			_G.res.createSpriteSheet(imagePath .. "/low/GOLDEN_EGGS_SHEET_3.dat")
		end
	end
end

function loadGoldenEggStarSprites()
	if deviceModel == "roku" then
		if screenHeight > 576 then
			_G.res.createSpriteSheet(imagePath .. "/GOLDEN_EGGS_SHEET_1.dat")
		else
			_G.res.createSpriteSheet(imagePath .. "/low/GOLDEN_EGGS_SHEET_1.dat")
			_G.res.createSpriteSheet(imagePath .. "/low/GOLDEN_EGGS_SHEET_3.dat")
		end
	end
end

function goldenEggAchieved(level)
	if settings.openGoldenEggLevels[level] == nil then
		settings.openGoldenEggLevels[level] = 0
		highscores[goldenEggLevelMapping[level]] = {completed = false, birds = 0, score = 0, lowScore = 0}
		saveLuaFileWrapper("highscores.lua", "highscores", true)
		saveLuaFileWrapper("settings.lua", "settings", true)
		additionalPopupPageDelay = true
		
		loadGoldenEggSprites()
		
		setActivePopupPage(goldenEggAchievedPage)
		
		if calculateOpenGoldenEggLevels() == 10 then
			addToAchievementUnlockQueue("Egg Hunter")
		end
		if deviceModel == "iphone4" then
			changeResolution = true
			wantedResolution = "HALF"
			print("change resolution to half\n")
		end
	end
end

function showAchievementPopUp()
	if gameCenterEnabled and gameCenter and gameCenter.achievements 
	  and gameCenter.achievements.showPopUpID then
		local achi = gameCenter.achievements[gameCenter.achievements.showPopUpID]
		if achi then
			prepareMenuPage(achievementPopUpPage)
			setActivePopupPage(achievementPopUpPage)
		end
	end
end

function goldenEggStarAchieved(level)
	setActivePopupPage(goldenEggStarAchievedPage)
	goldenEggStarAchievedPage.currentLevel = level
	
	if settings.openGoldenEggLevels[level] == 2 then
		goldenEggStarAchievedPage.items[1].sprite = "GOLDEN_EGG_STAR_COLLECTED"
		goldenEggStarAchievedPage.items[2].visible = false
	else
		goldenEggStarAchievedPage.items[1].sprite = "GOLDEN_EGG_STAR"
		goldenEggStarAchievedPage.items[2].visible = true
		_G.res.playAudio("star_collect", 1, false)
	end
		
	settings.openGoldenEggLevels[level] = 2
	if highscores[goldenEggLevelMapping[level]] ~= nil then
		highscores[goldenEggLevelMapping[level]].completed = true
	else
		highscores[goldenEggLevelMapping[level]] = {completed = true, birds = 0, score = 0, lowScore = 0}
	end
	saveLuaFileWrapper("highscores.lua", "highscores", true)
	saveLuaFileWrapper("settings.lua", "settings", true)
	
	if calculateStarsFromGoldenEggLevels() == 10 then
		addToAchievementUnlockQueue("Egg Cracker")
	end
	
	--print("FlurryEventWithParam: Golden egg level completed, param: Level, paramValue: " .. goldenEggLevelMapping[level] .. "\n")
	logFlurryEventWithParam("Golden egg level completed", "Level", "" .. goldenEggLevelMapping[level]) 
end

function aboutGoldenEggAchieved()
	g_releaseGEOnPopupExit = true
	getItemByName(about.items, "goldenEgg").visible = false
	goldenEggAchieved("Level5")
end

function episode3LevelSelectionEggAchieved()
	getItemByName(levelSelectionPagesPack3.items, "goldenEgg").visible = false
	goldenEggAchieved("Level11")
end

--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Mode for splash sequences

function updateSplashes(dt, time)
	
	
	-- Initialize on first time
	if splashTimer == nil then
		splashTimer = 0
		current = 1
		--[[
		splashes = { 	{ sprite = "SPLASH_CLICKGAMER", time = 2, bgColor = { red = 255, green = 255, blue = 255} },
						{ sprite = "SPLASH_ROVIO", time = 2, bgColor = { red = 255, green = 255, blue = 255}},
						{ sprite = "SPLASH_ANGRY_BIRDS", time = 1, bgColor = { red = 0, green = 0, blue = 0}} }
		]]--
		splashes = { 	{ sprite = "SPLASH_ROVIO", time = 2, bgColor = { red = 255, green = 255, blue = 255}},
						{ sprite = "SPLASH_ANGRY_BIRDS", time = 1, bgColor = { red = 0, green = 0, blue = 0}} }
		
		--if deviceModel ~= "iphone" and deviceModel ~= "ipad" and deviceModel ~= "iphone4" then
		--	current = 2
		--end
		if deviceModel == "roku" then
			current = 2
			setBGColor(0, 0, 0)
		end
	end

	-- Update timer
	splashTimer = splashTimer + dt
	
	if keyPressed["LBUTTON"] then
		splashTimer = splashes[current].time + 1
	end

	
	local sw, sh = _G.res.getSpriteBounds("", splashes[current].sprite)
	local scale = false
	local xs, ys = 1, 1
	local xCoord, yCoord =  screenWidth / 2, screenHeight / 2
	if splashes[current].sprite == "SPLASH_ROVIO" and screenHeight * 0.8 < sh then
		scale = true
		ys = (screenHeight * 0.8) / sh
		xs = (screenHeight * 0.8) / sh
		local newWidth = sw * xs
		if newWidth > screenWidth then
			ys = screenWidth / sw
			xs = screenWidth / sw
		end
	elseif splashes[current].sprite ~= "SPLASH_ROVIO" and screenHeight ~= sh then
		if splashes[current].sprite ~= "SPLASH_CLICKGAMER" and deviceModel ~= "ipad" then
			scale = true
			ys = screenHeight / sh
			xs = screenHeight / sh
			local newWidth = sw * xs
			if newWidth > screenWidth then
				ys = screenWidth / sw
				xs = screenWidth / sw
			end
		end
	end
			
	if scale then
		setRenderState(0, 0, xs, ys)
		_G.res.drawSprite("", splashes[current].sprite, _G.math.floor(xCoord / xs), _G.math.floor(yCoord / ys))
		if splashes[current].sprite == "SPLASH_ANGRY_BIRDS" then
			if isBetaVersion and deviceModel == "android" then
				_G.res.drawSprite("", "LITE_SPLASH", _G.math.floor(xCoord) / xs, _G.math.floor(yCoord) / ys)
			end
			--setRenderState(0, 0, 1, 1)
			if isBetaVersion and deviceModel == "android" then
				_G.res.drawSprite("", "SPLASH_LOADING", screenWidth, screenHeight)
			else
				if deviceModel == "roku" then
					local sw, sh = _G.res.getSpriteBounds("LOADING_EN")
					local xC, yC = screenWidth - sw * 0.5, screenHeight - sh
					local loadingScale = 1.8
					if screenHeight <= 576 then
						loadingScale = 1.2
					end
					setRenderState(0, 0, loadingScale, loadingScale)
					_G.res.drawSprite("", "LOADING_EN", _G.math.floor(xC / loadingScale), _G.math.floor(yC / loadingScale))
					setRenderState(0, 0, xs, ys)
				else
					_G.res.drawSprite("", _G.res.getString("TEXTS_BASIC", "TEXT_SPLASH_LOADING_SPRITE"), screenWidth / xs, screenHeight / ys)
				end
			end
		end
		setRenderState(0, 0, 1, 1)
	else
		_G.res.drawSprite("", splashes[current].sprite, screenWidth/2, screenHeight/2)
		-- loading text in different languages
		if splashes[current].sprite == "SPLASH_ANGRY_BIRDS" then
			_G.res.drawSprite("", _G.res.getString("TEXTS_BASIC", "TEXT_SPLASH_LOADING_SPRITE"), screenWidth, screenHeight)
			if isBetaVersion and deviceModel == "android" then
				_G.res.drawSprite("", "LITE_SPLASH", screenWidth / 2, screenHeight / 2)
				_G.res.drawSprite("", "SPLASH_LOADING", screenWidth, screenHeight)
			end
		end
	end
	

	if current >= 2 and splashTimer > dt and assetsCreated ~= true then
		createAssets()
	end
	
	-- Change sprite if showed long enough
	if splashTimer > splashes[current].time then
		splashTimer = 0
		current = current + 1
		if splashes[current] ~= nil then
			setBGColor(splashes[current].bgColor.red, splashes[current].bgColor.green, splashes[current].bgColor.blue)
		end
		if current > #splashes then
			initialize()
					
			
			local t_minimumScreenWidth = 1024
			--local t_minimumScreenHeight = 768
			--local t_minimumScreenHeight = 720
			local t_minimumScreenHeight = 600
			
			if screenWidth < t_minimumScreenWidth or screenHeight < t_minimumScreenHeight then
				g_invalidResolutionTriggeredOnStart = true											
			end
			
			setGameMode(updateMenu)
		end
	end
	
end

-- change ingame settings here so that the settings are refreshed properly
function updateValues()
	defaultForce = -925.0
	boostForce = defaultForce
--	colorDamageFactor = 4
--	blueBirdFactor = 0.725
--	yellowBirdFactor = 0.65
--	blueBirdFactor = 0.725
--	yellowBirdFactor = 0.6
	collisionParticleForceThreshold = 10
	collisionSoundForceThreshold = 3
	blockDestroyedScoreIncrement = 500
	pigletteDestroyedScoreIncrement = 5000
	birdsLeftScoreIncrement = 10000
	hardLimitSimultaneousParticles = 150
	softLimitSimultaneousParticles = 75
end

function initialize()
	_G.math.randomseed(_G.os.time())
	
	--[[
	defaultLanguage = "en_EN"
	currentLanguage = defaultLanguage
	-- IF you add languages remember to add short language name, language sprite (flag) and about sprite as well
	languageNames = {"en_EN", "fr_FR", "it_IT", "de_DE", "es_ES" } --, "jp_JP", "cn_TC"}
	shortLanguageNames = {"en", "fr", "it", "de", "es" } --, "jp", "cn" }
	currentLanguageId = 1
	languageSprites = { 
		en_EN = "SETTINGS_FLAG_EN",
		fr_FR = "SETTINGS_FLAG_FR",
		it_IT = "SETTINGS_FLAG_IT",
		de_DE = "SETTINGS_FLAG_DE",
		es_ES = "SETTINGS_FLAG_ES",
		--jp_JP = "SETTINGS_FLAG_JP",
		--cn_TC = "SETTINGS_FLAG_CN",
	}

	if settings.currentLanguage == nil then
		settings.currentLanguage = "en_EN"
	end
	
	currentLanguage = settings.currentLanguage
	_G.res.loadLocale("TEXTS_BASIC", settings.currentLanguage)
	_G.res.useLocale(settings.currentLanguage)
	--]]
	
	numberKeys = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" }

	-- these coordinates are the screen in world space, scaling affects here
	screen = { x = screenWidth*0.5, y = screenHeight*0.5, top = 0, left = 0, bottom = screenHeight, right = screenWidth }

	oldScreenWidth = screenWidth
	oldScreenHeight = screenHeight	
	
	cameraShakeX, cameraShakeY = 0, 0
	
	floatingScoreScaling = 1
		
	loading = false
	
	menuSunsetAngle = 0
	
	goldenEggsStarEffectAngle = 0

	rubberBandPos = { x = 0, y = 0 }
	rubberBandSpeed = 0

	floatingScores = {}

	objectCounts = {}

	scoreTable = {}

	draggingSpeed = 0
	draggingStartPosPhysics = { x = -1, y = -1 }
	draggingStartPosWorld = { x = -1, y = -1 }
	draggingStartPosScreen = { x = -1, y = -1 }
	selectedObjects = { }
	selectedObjectPos = { x = 0, y = 0 }
	selectedBird = nil

	objectToAdd = nil
	objectToAddAngle = 0

	currentGroupIndex = 1
	currentGroup = nil

	currentThemeIndex = 1
	currentTheme = nil

	cameraTargetObject = nil

	doubleClickTimer = 0
	quadClickTimer = 0
	quadClickCounter = 0
	rokuClickTimer = 0
	rokuClickCounter = 0
	gameTimer = 0
	levelCompleteTimer = 0
	birdBuffTimer = 0
	currentBirdIndex = 1
	currentBirdName = nil
	flyingBird = nil
	birdSpecialtyAvailable = false
	particleAmount = 0
	blockMoveTimer = 0
	
	cursorPhysics = {x = 0, y = 0}
	cursorWorld = {x = 0, y = 0}
	oldCursorWorld = {x = 0, y = 0}
	oldCursor = {x = 0, y = 0}
	tapPosWorld = {x = 0, y = 0}

	springConstant = 1500
	springDampening = 50

	difficultyLevel = 1
	score = 0
	zoomLevel = 0
	
	defaultForce = -800.0
	blockDestroyedScoreIncrement = 100

	physicsToWorld = 20
	physicsScale = 1/physicsToWorld
	shootRange = 2.2
	--shootRange = 0.6

	continueButtonY = screenHeight*0.5 + 70

	oldScale = 1
	levelStartPosition = { x = 0, y = 0 }
	animationScreen = { x = 0, y = 0 }
	animationWorldScale = 1

	setPhysicsSimulationScale(physicsToWorld)

	levelName = ""

	cameraFunction = defaultCamera
	castleCameraTimer = 0

	levelStartTimer = 0

	currentLevelNumber = -1
	currentThemeNumber = -1
	currentWorldNumber = -1
	inExtraWorld = false
	currentLevelNumberInTheme = -1
	currentPageNumber = -1
	
	collisionParticleForceThreshold = 5

	physicsEnabled = false
	levelSaved = true
	selectionRectActive = false
	birdFired = false

	loadingPageDrawn = false
	
	-- particle table
	particles = {}

	-- main menu page animations
	elementAnimations = {}
	
	initializeMenu()

	updateValues()

	setPhysicsEnabled(false)

	cos = _G.math.cos
	sin = _G.math.sin

	--createDirectory("/temp")
end

-- Initialization ends
-------------------------------------------------------------------------------
-- Menu stuff starts

--[[
Possible menu item values
-updateFunction = the function that is set as active update function when this menuitem is selected
-page = the next menu page if this item is used to change menu pages
-action = the action that is sent to game when this menu item is selected
-visible = is this item visible, if this is not set default is true
-selectable = can this item be selected
-sprite = sprite that is used to draw this menu item
-text = text that is used to draw this menu item
-textBoxSize = width that this text item can use, text is cut to fit this width
-x = preset x position of this menu item
-y = preset y position of this menu item
-hanchor = horizontal anchor of this menu item
-vanchor = vertical anchor of this menu item
-font = the font used to draw this item
-sound = sound to play when item is selected

template item
items = {
	{ updateFunction = updateGame, page = nil, action = -1, visible = true, selectable = true, sprite = nil, text = "TID_NONE", textBoxSize = 200, x = 0, y = 0, hanchor = "HCENTER", vanchor = "VCENTER")
}

Menu page values
-titleText = text that is shown as title text
-titleFont = font that is used for title text
-titleSprite = image that is shown as title image
-backgroundSprite = sprite that is drawn to the background
-backgroundOverlaySprite = sprite that drawn after the draw function has been called, tiled if necessary
-backgroundDrawFunction = function that is called to draw the background
-popup = is this menu page a popup page
-font = default font for this page
-state = current state of the page "READY" means ready for input
-sound = selectable item selection sound
]]

function initializeMenu()

	if isLiteVersion then
		levelOrder = {
			packs = {
			"pack1",
			},
			pack1 = {
		-- 1 - 10
				"Level1",
				"Level2",
				"Level7",
				"Level13",
				"Level17",
				"Level16",

	--			"Level227",
	--			"Level228",
	--			"Level229",
	--			"Level222",
	--			"Level218",
	--			"Level213",

	--			"LevelLite1",
	--			"LevelLite2",
	--			"LevelLite3",
	--			"LevelLite4",
	--			"LevelLite5",
	--			"LevelLite6",

				"LevelLite9",
				"LevelLite8",
				"LevelLite10",
				"LevelLite7",
				"LevelLite12",
				"LevelLite11", 
				
				"LevelLite13", 
				"LevelLite14", 
				"LevelLite15", 
			}
		}
	else
		levelOrder = {
			packs = {
				"pack1",
				"pack2",
				"pack3",
				"pack4",
				"pack5",
				"pack6",
				"pack7",
				"pack8",
				"pack9",
				"pack10",
				"pack11",
				"goldeneggs1",
			},
			
			pack1 = {
		-- 1 - 10
				"Level1",
				"Level57",
				"Level53",
				"Level3",
				"Level6",
				"Level2",
				"Level4",
				"Level5",
				"Level7",
				"Level8",

		-- 11 - 21
				"Level9",
				"Level13",
				"Level10",
				"Level39",
				"Level12",
				"Level15",
				"Level17",
				"Level14",
				"Level16",
				"Level23",

				"Level44",
			},
			pack2 = {
		-- 22 - 31
				"Level52",
				"Level34",
				"Level42",
				"Level24",
				"Level88",
				"Level36",
				"Level31",
				"Level21",
				"Level41",
				"Level76",

		-- 32 - 42
				"Level38",
				"Level35",
				"Level20",
				"Level26",
				"Level66",
				"Level85",
				"Level27",
				"Level32",
				"Level72",
				"Level90",

				"Level96",
			},
			pack3 = {

		-- 43 - 52
				"Level43",
				"Level77",
				"Level28",
				"Level29",
				"Level87",
				"Level18",
				"Level91",
				"Level49",
				"Level45",
				"Level75",

		-- 53 - 63
				"Level51",
				"Level30",
				"Level79",
				"Level40",
				"Level59",
				"Level58",
				"Level95",
				"Level82",
				"Level22",
				"Level89",

				"Level81"
			},
			pack4 = {
				"LevelP2_103",
				"LevelP2_91",
				"LevelP2_65",
				"LevelP2_96",
				"LevelP2_69",
				"LevelP2_88",
				"LevelP2_64",
				"LevelP2_80",
				"LevelP2_108",
				"LevelP2_85",

		-- 11 - 21
				"LevelP2_82",
				"LevelP2_66",
				"LevelP2_104",
				"LevelP2_210",
				"LevelP2_83",
				"LevelP2_79",
				"LevelP2_77",
				"LevelP2_114",
				"LevelP2_81",
				"LevelP2_68",

				"LevelP2_95",

			},
			pack5 = {
		-- 22 - 31
				"LevelP2_78",
				"LevelP2_100",
				"LevelP2_92",
				"LevelP2_94",
				"LevelP2_89",
				"LevelP2_73",
				"LevelP2_76",
				"LevelP2_122", 
				"LevelP2_99",
				"LevelP2_84",

		-- 32 - 42
				"LevelP2_86",
				"LevelP2_74",
				"LevelP2_115",
				"LevelP2_98",
				"LevelP2_71",
				"LevelP2_72",
				"LevelP2_87",
				"LevelP2_93",
				"LevelP2_67",
				"LevelP2_97",

				"LevelP2_90",		
			},
			goldeneggs1 = {
				"LevelGE_4",
				"LevelGE_3",
				"LevelGE_2",
				"LevelGE_1",
				"LevelGE_5",
				"LevelGE_6",
				"LevelGE_7",
				"LevelGE_8",
				"LevelGE_9",
				"LevelGE_10",
				"LevelGE_11",
				"LevelGE_14",
				"LevelGE_14",
				"LevelGE_15"
			},
			pack6 = {			
				"LevelP3_212",
				"LevelP3_134",
				"LevelP3_162",
				"LevelP3_271",
				"LevelP3_224",
				"LevelP3_253",
				"LevelP3_225",
				"LevelP3_232",
				"LevelP3_150",
				"LevelP3_211",
				
				"LevelP3_223",
				"LevelP3_226",
				"LevelP3_215",
				"LevelP3_220",
				"LevelP3_231",

			},
			pack7 = {
				"LevelP3_166",
				"LevelP3_237",
				"LevelP3_216",
				"LevelP3_298",
				"LevelP3_303",
				"LevelP3_214",
				"LevelP3_159",
				"LevelP3_164",
				"LevelP3_299",
				"LevelP3_302",
				"LevelP3_219",
				"LevelP3_163",
				"LevelP3_160",
				"LevelP3_161",
				"LevelP3_304",
			},
			pack8 = {
				"LevelP3_297",
				"LevelP3_221",
				"LevelP3_306",
				"LevelP3_301",
				"LevelP3_312",
				"LevelP3_309",
				"LevelP3_168",
				"LevelP3_311",
				"LevelP3_308",
				"LevelP3_310",
				"LevelP3_217",
				"LevelP3_307",
				"LevelP3_296",
--				"LevelP3_167",
				"LevelP3_149",
				"LevelP3_313",
			},
			pack9 = {			
				"LevelP4_421",
				"LevelP4_423",
				"LevelP4_424",
				"LevelP4_425",
				"LevelP4_426",
				"LevelP4_427",
				"LevelP4_428",
				"LevelP4_429",
				"LevelP4_431",
				"LevelP4_432",
				"LevelP4_433",
				"LevelP4_436",
				"LevelP4_439",
				"LevelP4_440",
				"LevelP4_441",

			},
			pack10 = {			
				"LevelP4_442",
				"LevelP4_443",
				"LevelP4_444",
				"LevelP4_445",
				"LevelP4_448",
				"LevelP4_449",
				"LevelP4_451",
				"LevelP4_452",
				"LevelP4_453",
				"LevelP4_454",

				"LevelP4_455",
				"LevelP4_457",
				"LevelP4_458",
				"LevelP4_459",
				"LevelP4_462",

			},
			pack11 = {			
				"LevelP4_463",
				"LevelP4_464",
				"LevelP4_465",
				"LevelP4_466",
				"LevelP4_467",
				"LevelP4_468",
				"LevelP4_469",
				"LevelP4_470",
				"LevelP4_471",
				"LevelP4_472",
				
				"LevelP4_473",
				"LevelP4_474",
				"LevelP4_475",
				"LevelP4_477",
				"LevelP4_478",

			}
		}
	end
	if isLiteVersion then
		levelOrder_packBasic = { levelOrder["pack1"] }
	else
		levelOrder_packBasic = { levelOrder["pack1"], levelOrder["pack2"], levelOrder["pack3"] }
	end
	levelOrder_packOne = { levelOrder["pack4"], levelOrder["pack5"] }
	levelOrder_packThree = { levelOrder["pack6"], levelOrder["pack7"], levelOrder["pack8"] }
	levelOrder_packFour = { levelOrder["pack9"], levelOrder["pack10"], levelOrder["pack11"] }
	levelOrder_goldenEggs = levelOrder["goldeneggs1"]
	
	goldenEggLevelMapping = { Level1 = "LevelGE_4", Level2 = "LevelGE_3", Level3 = "LevelGE_2",
		--Level4 = "SOUNDBOARD1", Level5 = "MIGHTY_EAGLE", Level6 = "PIGGY", Level7 = "RADIO",
		Level4 = "SOUNDBOARD1", Level5 = "LevelGE_14", Level6 = "LevelGE_15", Level7 = "RADIO",
		Level8 = "LevelGE_1", Level9 = "LevelGE_5", Level10 = "LevelGE_6", Level11 = "LevelGE_7",
		Level12 = "KEYBOARD", Level13 = "LevelGE_8", Level14 = "LevelGE_9", Level15 = "LevelGE_10",
		Level16 = "LevelGE_11",Level17 = "SEQUENCER"}
	
	
	resetSettings()
	
	createMenuPages()
	
	selectedMenuItem = -1
	setActiveMenuPage(mainMenu)
	oldMenuPage = nil
	
	limitLevels = false
	openDemoLevels = { 1, 6, 17, 26, 34, 36, 45, 49, 58 }
	
	newAnimation("settingsPageScroll", "HIDDEN", settingsPage, 600, 600)
	newAnimation("aboutPageScroll", "HIDDEN", about, 600, 600)
	newAnimation("ingamePausePageScroll", "HIDDEN", pausePage, 600, 600)
	newAnimation("ingameGesturePausePageScroll", "HIDDEN", g_gesturePausePage, 600, 600)
	
	popupPage = nil
	birdAnimations = {}
	
	baitSardine = {
        y = 0,
        x = 0,
        name = "BaitSardine_1",
        startNumber = nil,
        angle = 0,
        definition = "BaitSardine",
		}
	
	if isBetaVersion then
		setActivePopupPage(betaDisclaimerPage)
	end	
end

function resetSettings()
	if settings.audioEnabled == nil then
		settings.audioEnabled = true
	end
	
	if settings.mightyEagleEnabled == nil then
		settings.mightyEagleEnabled = false
	end
	
	if settings.wilhelmTell == nil then
		settings.wilhelmTell = false
	end
	
	if settings.bullsEye == nil then
		settings.bullsEye = false
	end
	
	if settings.cumulativeStars == nil then
		local score, gainedStarsBasic, totalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
		local score, gainedStarsOne, totalStars = calculateTotalScoreAndStars(levelOrder_packOne)
		local score, gainedStarsThree, totalStars = calculateTotalScoreAndStars(levelOrder_packThree)
		local score, gainedStarsFour, totalStars = calculateTotalScoreAndStars(levelOrder_packFour)
		
		settings.cumulativeStars = gainedStarsBasic + gainedStarsOne + gainedStarsThree + gainedStarsFour
	end
	
	if settings.gameStarts == nil then
		settings.gameStarts = 1
	end
	
	if settings.totalLevelsCompleted == nil then
		local totalLevelsBasic = calculateTotalLevelsCompleted(levelOrder_packBasic)
		local totalLevelsOne = calculateTotalLevelsCompleted(levelOrder_packOne)
		local totalLevelsThree = calculateTotalLevelsCompleted(levelOrder_packThree)
		local totalLevelsFour = calculateTotalLevelsCompleted(levelOrder_packFour)
		
		settings.totalLevelsCompleted = totalLevelsBasic + totalLevelsOne + totalLevelsThree + totalLevelsFour
	end
	
	if settings.cumulativeScore == nil then
		local totalScoreBasic, gainedStarsBasic, totalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
		local totalScoreOne, gainedStarsOne, totalStars = calculateTotalScoreAndStars(levelOrder_packOne)
		local totalScoreThree, gainedStarsThree, totalStars = calculateTotalScoreAndStars(levelOrder_packThree)
		local totalScoreFour, gainedStarsFour, totalStars = calculateTotalScoreAndStars(levelOrder_packFour)
		
		settings.cumulativeScore = _G.string.format("%d", totalScoreBasic + totalScoreOne + totalScoreThree + totalScoreFour)
	end
	
	if settings.gameRestarted == nil then
		settings.gameRestarted = 0
	end
	
	if settings.birdsShooted == nil then
		settings.birdsShooted = 0
	end
	
	if settings.lastOpenLevel == nil then
		settings.lastOpenLevel = 1
	end
	
	if settings.lastOpenLevelLP2 == nil then
		settings.lastOpenLevelLP2 = 1
	end
	
	if settings.lastOpenLevelLP3 == nil then
		settings.lastOpenLevelLP3 = 1
	end
	
	if settings.lastOpenLevelLP4 == nil then
		settings.lastOpenLevelLP4 = 1
	end
	
	
	if not isLiteVersion then
		if settings.theme1Completed ~= true then
			local episode1firstPack = levelOrder_packBasic[1]
			if highscores[episode1firstPack[#episode1firstPack]] ~= nil 
			  and highscores[episode1firstPack[#episode1firstPack]].completed then
				settings.theme1Completed = true
			end
		end
		
		if settings.theme2Completed ~= true then
			local episode1secondPack = levelOrder_packBasic[2]
			if highscores[episode1secondPack[#episode1secondPack]] ~= nil 
			  and highscores[episode1secondPack[#episode1secondPack]].completed then
				settings.theme2Completed = true
			end
		end
		
		if settings.gameCompleted ~= true then
			local episode1lastPack = levelOrder_packBasic[3]
			if highscores[episode1lastPack[#episode1lastPack]] ~= nil 
			  and highscores[episode1lastPack[#episode1lastPack]].completed then
				settings.gameCompleted = true
				settings.lastOpenLevel = 64
			end
		end
		
		if settings.theme4Completed ~= true then
			local episode2firstPack = levelOrder_packOne[1]
			if highscores[episode2firstPack[#episode2firstPack]] ~= nil
			  and highscores[episode2firstPack[#episode2firstPack]].completed then
				settings.theme4Completed = true
			end
		end
		
		if settings.theme5Completed ~= true then
			local episode2lastPack = levelOrder_packOne[2]
			if highscores[episode2lastPack[#episode2lastPack]] ~= nil
			  and highscores[episode2lastPack[#episode2lastPack]].completed then
				settings.theme5Completed = true
				settings.lastOpenLevelLP2 = 43
			end
		end
		
		if settings.theme6Completed ~= true then
			local episode3firstPack = levelOrder_packThree[1]
			if highscores[episode3firstPack[#episode3firstPack]] ~= nil
			  and highscores[episode3firstPack[#episode3firstPack]].completed then
				settings.theme6Completed = true
			end
		end
		
		if settings.theme7Completed ~= true then
			local episode3secondPack = levelOrder_packThree[2]
			if highscores[episode3secondPack[#episode3secondPack]] ~= nil
			  and highscores[episode3secondPack[#episode3secondPack]].completed then
				settings.theme7Completed = true
			end
		end
		
		if settings.theme8Completed ~= true then
			local episode3lastPack = levelOrder_packThree[3]
			if highscores[episode3lastPack[#episode3lastPack]] ~= nil
			  and highscores[episode3lastPack[#episode3lastPack]].completed then
				settings.theme8Completed = true
				settings.lastOpenLevelLP3 = 46
			end
		end
		
		if settings.theme9Completed ~= true then
			local episode4firstPack = levelOrder_packFour[1]
			if highscores[episode4firstPack[#episode4firstPack]] ~= nil
			  and highscores[episode4firstPack[#episode4firstPack]].completed then
				settings.theme9Completed = true
			end
		end
		
		if settings.theme10Completed ~= true then
			local episode4secondPack = levelOrder_packFour[2]
			if highscores[episode4secondPack[#episode4secondPack]] ~= nil
			  and highscores[episode4secondPack[#episode4secondPack]].completed then
				settings.theme10Completed = true
			end
		end
		
		if settings.theme11Completed ~= true then
			local episode4lastPack = levelOrder_packFour[3]
			if highscores[episode4lastPack[#episode4lastPack]] ~= nil
			  and highscores[episode4lastPack[#episode4lastPack]].completed then
				settings.theme11Completed = true
			end
		end
		
		if settings.threeStars ~= true then
			local episode1TotalScore, episode1Stars, episode1TotalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
			if episode1Stars >= episode1TotalStars then
				settings.threeStars = true
			end
		end
	
		if settings.threeStarsLP2 ~= true then
			local episode2TotalScore, episode2Stars, episode2TotalStars = calculateTotalScoreAndStars(levelOrder_packOne)
			if episode2Stars >= episode2TotalStars then
				settings.threeStarsLP2 = true
			end
		end
	
		if settings.threeStarsLP3 ~= true then
			local episode3TotalScore, episode3Stars, episode3TotalStars = calculateTotalScoreAndStars(levelOrder_packThree)
			if episode3Stars >= episode3TotalStars then
				settings.threeStarsLP3 = true
			end
		end
		
		if settings.threeStarsLP4 ~= true then
			local episode4TotalScore, episode4Stars, episode4TotalStars = calculateTotalScoreAndStars(levelOrder_packFour)
			if episode4Stars >= episode4TotalStars then
				settings.threeStarsLP4 = true
			end
		end
		
	end

	if settings.currentLevelSelectionPages == nil then
		settings.currentLevelSelectionPages = {}
		settings.currentLevelSelectionPages.basic = 1
		settings.currentLevelSelectionPages.extra = 1
		settings.currentLevelSelectionPages.pack3 = 1
		settings.currentLevelSelectionPages.pack4 = 1
		settings.currentLevelSelectionPages.goldeneggs = 1
	end
	
	if settings.eaglesAvailable == nil then
		settings.eaglesAvailable = {}
		settings.eaglesAvailable.basic = 1
		settings.eaglesAvailable.extra = 1
		settings.eaglesAvailable.pack3 = 1
		settings.eaglesAvailable.pack4 = 1
		
	end
	
	if settings.eaglesUsedIn == nil then
		settings.eaglesUsedIn = {}
	end
	
	if settings.openGoldenEggLevels == nil then
		settings.openGoldenEggLevels = {}
		for k, v in _G.pairs(goldenEggLevelMapping) do
			if highscores[v] ~= nil then
				if highscores[v].completed then
					settings.openGoldenEggLevels[k] = 2
				else
					settings.openGoldenEggLevels[k] = 1
				end
			end
		end
	end
	
	if settings.currentLevelSelectionPages.goldeneggs == nil then
		settings.currentLevelSelectionPages.goldeneggs = 1
	end
	if settings.currentLevelSelectionPages.pack3 == nil then
		settings.currentLevelSelectionPages.pack3 = 1
	end
	if settings.currentLevelSelectionPages.pack4 == nil then
		settings.currentLevelSelectionPages.pack4 = 1
	end
	
	if settings.currentLevelSelectionPages.pack5 == nil then
		settings.currentLevelSelectionPages.pack5 = 1
	end
	
	if settings.currentLevelSelectionPages.pack6 == nil then
		settings.currentLevelSelectionPages.pack6 = 1
	end
	
	if settings.eaglesAvailable.basic == nil then
		settings.eaglesAvailable.basic = 1
	end
	if settings.eaglesAvailable.extra == nil then
		settings.eaglesAvailable.extra = 1
	end
	if settings.eaglesAvailable.pack3 == nil then
		settings.eaglesAvailable.pack3 = 1
	end
	if settings.eaglesAvailable.pack4 == nil then
		settings.eaglesAvailable.pack4 = 1
	end
	
	if settings.selectedEpisode == nil then
		settings.selectedEpisode = 1
	end
	
	if settings.tutorials == nil then
		settings.tutorials = {}
	end
		
	if settings.gameStarts	== nil then
		settings.gameStarts = 1
	else
		if settings.playtime ~= nil then
			settings.averagePlaytime = _G.string.format("%d", settings.playtime / settings.gameStarts)
		end
		settings.gameStarts = settings.gameStarts + 1
	end
	
	if not releaseBuild then
		settings.lastOpenLevel = 200
		settings.lastOpenLevelLP2 = 200
		settings.lastOpenLevelLP3 = 200
		settings.lastOpenLevelLP4 = 200
		settings.gameCompleted    = true
		settings.theme5Completed  = true
		settings.theme8Completed  = true
		settings.theme11Completed = true
		settings.theme14Completed = true
		
		-- unlock all golden egg levels
		for level, _ in _G.pairs(goldenEggLevelMapping) do
			if not settings.openGoldenEggLevels[level] or
				settings.openGoldenEggLevels[level] < 1 then
				settings.openGoldenEggLevels[level] = 1
			end
		end
		
		-- this code gets three stars to every level of an episode except for the last
		-- meant for total destruction testing
		--[=[
		local packs = { 1, 2, 4, 6, 7, 9, 10, 12, 13, 15, 16 }
		local lastPacks = { 3, 5, 8, 11, 14 }
		
		for _, n in _G.ipairs(packs) do
			local pack = levelOrder[levelOrder.packs[n]]
			for i=1, #pack do
				local name = pack[i]
				highscores[name] = { completed = true, score = starTable[name].goldScore }
			end
		end
		for _, n in _G.ipairs(lastPacks) do
			local pack = levelOrder[levelOrder.packs[n]]
			for i=1, #pack-1 do
				local name = pack[i]
				highscores[name] = { completed = true, score = starTable[name].goldScore }
			end
		end
		--]=]
	end
	
	saveLuaFileWrapper("settings.lua", "settings", true)
end


function makeEditLevelPack(index, currentLevel)
	local page = {}
	
	page.name = "levelSelectionEdit" .. index
	page.theme = index
	page.back = nil
	page.font = fontBasic
	page.state = "READY"
	page.title = { text = "Theme" .. index, x = screenWidth * 0.5, y = 7, vanchor = "TOP", hanchor = "HCENTER" }
	page.items = {}	

	local linesPerPage = 3
	local itemsPerLine = 10
	local itemsPerPage = 21 --itemsPerLine * linesPerPage
	local levelNumber = currentLevel
	
	local pageLevelIndex = 0
	local currentPage = index
		
	if levelOrder.packs[currentPage] ~= nil then
		page.title.text = levelOrder.packs[currentPage]
		itemsPerPage = #levelOrder[levelOrder.packs[currentPage]]
	end	
	
	for line = 1, linesPerPage do
		local yDivider = line / (linesPerPage + 1)
		for index = 1, itemsPerLine do
			pageLevelIndex = pageLevelIndex + 1
			
			if pageLevelIndex <= itemsPerPage then
				levelNumber = levelNumber + 1
				_G.table.insert(page.items, 
					{
						boss = false,
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						themeIndex = page.theme,
						text =  "" .. levelNumber,
						folder = levelPath .. "/pack" .. currentPage .. "/",					
						filename = "Level" .. levelNumber,
						updateFunction = updateEditor, 
						x = screenWidth / (itemsPerLine + 0.5) * index - 12,
						y = screenHeight * yDivider,
					}
				)
				
				if levelOrder.packs[currentPage] ~= nil then
					page.items[#page.items].filename = levelOrder[levelOrder.packs[currentPage]][pageLevelIndex]
					page.items[#page.items].folder = levelPath .. "/" .. levelOrder.packs[currentPage] .. "/"
				end	

				if checkForLuaFile(page.items[#page.items].folder .. page.items[#page.items].filename .. ".lua") == true then
					page.items[#page.items].sprite = "LS_LEVEL_BG_NORMAL_OPEN_1"
					page.items[#page.items].sheet = "LEVELSELECTION_SHEET_1"
				end
			end
		end
	end
	
	return page, levelNumber
end

function startCrystal()

	if isCrystalUIShowing() then
		showCrystalInMainMenu = false
		deactivateCrystalUI()
	else
		showCrystalInMainMenu = true
		postTotalHighScores()
		logFlurryEvent("Crystal UI started")
		activateCrystalUI()
	end
	
end

-- GameCenter stuff
--[[function getScoresForPlayers(leaderboard, players)
	if gameCenterEnabled and gameCenter[leaderboard] then
		return getLeaderboardScoresForPlayers({leaderboardID = leaderboard, playerIDs = players})
	else
		return false
	end
end

function getLocalPlayerRanks()
	if gameCenterEnabled then
		return getRanksForLocalPlayer()
	else
		return false
	end
end]]

function setIndicatorPositions()
	if gameCenterEnabled and gameCenter and gameCenter.leaderboards then
		local bg = getItemByName(episodeSelectionPage.items[1].children, "ep1MeterBG")
		if bg.x then
			if gameCenter.leaderboards[leaderboards["totalScoreEpisode1"]] and gameCenter.leaderboards[leaderboards["totalScoreEpisode1"]].loading ~= true then
				local lboard = gameCenter.leaderboards[leaderboards["totalScoreEpisode1"]]
				if lboard.localRank and lboard.range then
					local posInMeter = 1
					if lboard.localRank == 1 then
						posInMeter = 0
					elseif lboard.localRank ~= 0 and lboard.range ~= 0 then
						posInMeter = (1 / lboard.range) * lboard.localRank
					end
					local ep1MeterIndicator = getItemByName(episodeSelectionPage.items[1].children, "ep1MeterIndicator")
					--ep1MeterIndicator.x, ep1MeterIndicator.y = bg.x, 46 - 100 * posInMeter
					ep1MeterIndicator.x, ep1MeterIndicator.y = bg.x, -54 + 100 * posInMeter
				end
			end
			
			if gameCenter.leaderboards[leaderboards["totalScoreEpisode2"]] and gameCenter.leaderboards[leaderboards["totalScoreEpisode2"]].loading ~= true then
				local lboard = gameCenter.leaderboards[leaderboards["totalScoreEpisode2"]]
				if lboard.localRank and lboard.range then
					local posInMeter = 1
					if lboard.localRank == 1 then
						posInMeter = 0
					elseif lboard.localRank ~= 0 and lboard.range ~= 0 then
						posInMeter = (1 / lboard.range) * lboard.localRank
					end
					local ep2MeterIndicator = getItemByName(episodeSelectionPage.items[2].children, "ep2MeterIndicator")
					--ep2MeterIndicator.x, ep2MeterIndicator.y = bg.x, 46 - 100 * posInMeter
					ep2MeterIndicator.x, ep2MeterIndicator.y = bg.x, -54 + 100 * posInMeter
				end
			end
			
			if gameCenter.leaderboards[leaderboards["totalScoreEpisode3"]] and gameCenter.leaderboards[leaderboards["totalScoreEpisode3"]].loading ~= true then
				local lboard = gameCenter.leaderboards[leaderboards["totalScoreEpisode3"]]
				if lboard.localRank and lboard.range then
					local posInMeter = 1
					if lboard.localRank == 1 then
						posInMeter = 0
					elseif lboard.localRank ~= 0 and lboard.range ~= 0 then
						posInMeter = (1 / lboard.range) * lboard.localRank
					end
					local ep3MeterIndicator = getItemByName(episodeSelectionPage.items[3].children, "ep3MeterIndicator")
					--ep3MeterIndicator.x, ep3MeterIndicator.y = bg.x, 46 - 100 * posInMeter
					ep3MeterIndicator.x, ep3MeterIndicator.y = bg.x, -54 + 100 * posInMeter
				end
			end
			
			if gameCenter.leaderboards[leaderboards["totalScoreEpisode4"]] and gameCenter.leaderboards[leaderboards["totalScoreEpisode4"]].loading ~= true then
				local lboard = gameCenter.leaderboards[leaderboards["totalScoreEpisode4"]]
				if lboard.localRank and lboard.range then
					local posInMeter = 1
					if lboard.localRank == 1 then
						posInMeter = 0
					elseif lboard.localRank ~= 0 and lboard.range ~= 0 then
						posInMeter = (1 / lboard.range) * lboard.localRank
					end
					local ep4MeterIndicator = getItemByName(episodeSelectionPage.items[4].children, "ep4MeterIndicator")
					--ep4MeterIndicator.x, ep4MeterIndicator.y = bg.x, 46 - 100 * posInMeter
					ep4MeterIndicator.x, ep4MeterIndicator.y = bg.x, -54 + 100 * posInMeter
				end
			end
		end
	end
end

function disableGameCenter()
	if mainMenu and mainMenu.items and episodeSelectionPage and episodeSelectionPage.items then
		local leaderboards = getItemByName(mainMenu.items, "leaderboards")
		if leaderboards then
			leaderboards.callFunction = initGameCenter
		end
		
		local achievements = getItemByName(mainMenu.items, "achievements")
		if achievements then
			achievements.callFunction = initGameCenter
		end
			
		local ep1MeterBG = getItemByName(episodeSelectionPage.items, "ep1MeterBG")
		if ep1MeterBG then
			ep1MeterBG.visible = false
		end
		local ep1MeterIndicator = getItemByName(episodeSelectionPage.items, "ep1MeterIndicator")
		if ep1MeterIndicator then
			ep1MeterIndicator.visible = false
		end
		
		local ep2MeterBg = getItemByName(episodeSelectionPage.items, "ep2MeterBG")
		if ep2MeterBg then
			ep2MeterBg.visible = false
		end
		local ep2MeterIndicator = getItemByName(episodeSelectionPage.items, "ep2MeterIndicator")
		if ep2MeterIndicator then
			ep2MeterIndicator.visible = false
		end
		
		local ep3MeterBG = getItemByName(episodeSelectionPage.items, "ep3MeterBG")
		if ep3MeterBG then
			ep3MeterBG.visible = false
		end
		local ep3MeterIndicator = getItemByName(episodeSelectionPage.items, "ep3MeterIndicator")
		if ep3MeterIndicator then
			ep3MeterIndicator.visible = false
		end
		
		local ep4MeterBG = getItemByName(episodeSelectionPage.items, "ep4MeterBG")
		if ep4MeterBG then
			ep4MeterBG.visible = false
		end
		local ep4MeterIndicator = getItemByName(episodeSelectionPage.items, "ep4MeterIndicator")
		if ep4MeterIndicator then
			ep4MeterIndicator.visible = false
		end
	end
end

function enableGameCenter()
	if mainMenu and mainMenu.items and episodeSelectionPage and episodeSelectionPage.items then
		local leaderboards = getItemByName(mainMenu.items, "leaderboards")
		if leaderboards then
			leaderboards.callFunction = showLeaderboards
		end
		
		local achievements = getItemByName(mainMenu.items, "achievements")
		if achievements then
			achievements.callFunction = showAchievements
		end
			
		local ep1MeterBG = getItemByName(episodeSelectionPage.items, "ep1MeterBG")
		if ep1MeterBG then
			ep1MeterBG.visible = true
		end
		local ep1MeterIndicator = getItemByName(episodeSelectionPage.items, "ep1MeterIndicator")
		if ep1MeterIndicator then
			ep1MeterIndicator.visible = true
		end
		
		local ep2MeterBg = getItemByName(episodeSelectionPage.items, "ep2MeterBG")
		if ep2MeterBg then
			ep2MeterBg.visible = true
		end
		local ep2MeterIndicator = getItemByName(episodeSelectionPage.items, "ep2MeterIndicator")
		if ep2MeterIndicator then
			ep2MeterIndicator.visible = true
		end
		
		local ep3MeterBG = getItemByName(episodeSelectionPage.items, "ep3MeterBG")
		if ep3MeterBG then
			ep3MeterBG.visible = true
		end
		local ep3MeterIndicator = getItemByName(episodeSelectionPage.items, "ep3MeterIndicator")
		if ep3MeterIndicator then
			ep3MeterIndicator.visible = true
		end
		
		local ep4MeterBG = getItemByName(episodeSelectionPage.items, "ep4MeterBG")
		if ep4MeterBG then
			ep4MeterBG.visible = true
		end
		local ep4MeterIndicator = getItemByName(episodeSelectionPage.items, "ep4MeterIndicator")
		if ep4MeterIndicator then
			ep4MeterIndicator.visible = true
		end
	end
end

-- GameCenter stuff ends.

function createMenuPages()

	createPopupBoxSpriteTables()
	
	
	mainMenu = {}
	episodeSelectionPage = {}
	gameStart = {}
	theme4Start = {}
	theme6Start = {}
	theme9Start = {}
	theme12Start = {}
	theme15Start = {}
	upsellPage = {}
	
	if gameCenterSupported then
		achievementPopUpPage = {
			name = "achievementPopUpPage",
			popup = true,
			back = nil,
			state = "NOTREADY",
			items = {
				{ name = "achievementBox", box = achievementBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "RIGHT", vanchor = "TOP",
					children = {{ name = "achievementIcon", sprite = "", selectable = false},
							   { name = "achievementTitle", text = "", font = "FONT_GAMECENTER_BASIC", selectable = false, hanchor = "HCENTER", vanchor = "TOP"},
							   { name = "achievementText", text = "", font = "FONT_GAMECENTER_BASIC", selectable = false, hanchor = "LEFT", vanchor = "BOTTOM"}},
			   }
			}
		}
		achievementPopUpPage.icons = {}
		achievementPopUpPage.icons["Wilhelm Tell"] = "ACHIEVEMENT_WILHELM_TELL"
		achievementPopUpPage.icons["Mr Moustache"] = "ACHIEVEMENT_FINISH_WORLD_2"
		achievementPopUpPage.icons["Defeat of The King"] = "ACHIEVEMENT_FINISH_EPISODE"
		achievementPopUpPage.icons["The Imposter"] = "ACHIEVEMENT_FINISH_WORLD_4"
		achievementPopUpPage.icons["The Mysterious Escape"] = "ACHIEVEMENT_FINISH_EPISODE"
		achievementPopUpPage.icons["Episode 1 - Total Destruction"] = "ACHIEVEMENT_TOTAL_DESTRUCTION"
		achievementPopUpPage.icons["Episode 1 - Score Addict"] = "ACHIEVEMENT_GET_XXX_POINTS"
		achievementPopUpPage.icons["Episode 2 - Total Destruction"] = "ACHIEVEMENT_TOTAL_DESTRUCTION"
		achievementPopUpPage.icons["Episode 2 - Score Addict"] = "ACHIEVEMENT_GET_XXX_POINTS"
		achievementPopUpPage.icons["Episode 3 - Total Destruction"] = "ACHIEVEMENT_TOTAL_DESTRUCTION"
		achievementPopUpPage.icons["Episode 3 - Score Addict"] = "ACHIEVEMENT_GET_XXX_POINTS"
		achievementPopUpPage.icons["Episode 4 - Total Destruction"] = "ACHIEVEMENT_TOTAL_DESTRUCTION"
		achievementPopUpPage.icons["Episode 4 - Score Addict"] = "ACHIEVEMENT_GET_XXX_POINTS"
		achievementPopUpPage.icons["Split it!"] = "ACHIEVEMENT_GET_BLUE_BIRD"
		achievementPopUpPage.icons["Speed is the Essence"] = "ACHIEVEMENT_GET_YELLOW_BIRD"
		achievementPopUpPage.icons["Boom Boom!"] = "ACHIEVEMENT_GET_BLACK_BIRD"
		achievementPopUpPage.icons["Mother of all Bombs"] = "ACHIEVEMENT_GET_WHITE_BIRD"
		achievementPopUpPage.icons["Backward Compatibility"] = "ACHIEVEMENT_BACKWARD_SHOOTER"
		achievementPopUpPage.icons["Space Invader"] = "ACHIEVEMENT_SPACE_INVADER"
		achievementPopUpPage.icons["Woodpecker"] = "ACHIEVEMENT_SMASH_5000_WOOD_BLOCKS"
		achievementPopUpPage.icons["Icepecker"] = "ACHIEVEMENT_SMASH_5000_ICE_BLOCKS"
		achievementPopUpPage.icons["Stonecutter"] = "ACHIEVEMENT_SMASH_5000_ROCK_BLOCKS"
		achievementPopUpPage.icons["Pig Popper"] = "ACHIEVEMENT_SMASH_5000_PIGS"
		achievementPopUpPage.icons["Block Smasher"] = "ACHIEVEMENT_SMASH_50000_BLOCKS"
		achievementPopUpPage.icons["Smash Maniac"] = "ACHIEVEMENT_SMASH_1000000_BLOCKS"
		achievementPopUpPage.icons["Return to Sender"] = "ACHIEVEMENT_GET_BOOMERANG_BIRD"
		achievementPopUpPage.icons["Egg Hunter"] = "ACHIEVEMENT_EGG_HUNTER"
		achievementPopUpPage.icons["Egg Cracker"] = "ACHIEVEMENT_EGG_CRACKER"
		achievementPopUpPage.icons["Hovering Helmet"] = "ACHIEVEMENT_FINISH_WORLD_6"
		achievementPopUpPage.icons["Mounting Moustache"] = "ACHIEVEMENT_FINISH_WORLD_7"
		achievementPopUpPage.icons["Green Baron"] = "ACHIEVEMENT_FINISH_EPISODE"
		achievementPopUpPage.icons["Seeing Red"] = "ACHIEVEMENT_GET_BIG_BROTHER"
		achievementPopUpPage.icons["Hardhat Hidalgo"] = "ACHIEVEMENT_FINISH_WORLD_9"
		achievementPopUpPage.icons["Mason Moustache"] = "ACHIEVEMENT_FINISH_WORLD_10"
		achievementPopUpPage.icons["Bull's Eye"] = "ACHIEVEMENT_BULLS_EYE"
		achievementPopUpPage.icons["Angry Birds Fan"] = "ACHIEVEMENT_ANGRYBIRDS_FAN"
		achievementPopUpPage.icons["True Angry Birds Fan"] = "ACHIEVEMENT_ANGRYBIRDS_TRUE_FAN"
		achievementPopUpPage.icons["Angry Birds Addict"] = "ACHIEVEMENT_ANGRYBIRDS_ADDICT"
		achievementPopUpPage.icons["Star Collector"] = "ACHIEVEMENT_STAR_COLLECTOR"
		achievementPopUpPage.icons["Star Gatherer"] = "ACHIEVEMENT_STAR_GATHERER"
		achievementPopUpPage.icons["Bird Slinger"] = "ACHIEVEMENT_BIRD_SLINGER"
		achievementPopUpPage.icons["Royal Ringleader"] = "ACHIEVEMENT_FINISH_EPISODE"
		
	end
	
	goldenEggAchievedPage = {
		name = "goldenEggAchievedPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		items = {
			{sprite = "GOLDEN_EGG_5", selectable = false},
		}
	}	
	
	goldenEggStarAchievedPage = {
		name = "goldenEggStarAchievedPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		items = {
			{sprite = "GOLDEN_EGG_STAR", selectable = false},
			{sprite = "", selectable = false},
		}
	}
	
	boomerangBirdAchievedPage = {
		name = "boomerangBirdAchievedPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		items = {
			{sprite = "BIRD_BOOMERANG_STILL", selectable = false},
		}
	}
	
	mightyEaglePaymentPage = {
		name = "mightyEaglePaymentPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundBox = { name = "backgroundMightyEagle", sprites = whiteBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{sprite = "NOKIA_LOGO", selectable = false},
			{ name = "confirming", sprite = "NOKIA_CONFIRMING_PAYMENT", selectable = false, visible = true},
			{sprite = "NOKIA_LOADING", selectable = false, visible = false, angle = 0, timer = 0},
			{sprite = "NOKIA_PAYMENT_SUCCESSFUL", selectable = false, visible = false},
			{sprite = "NOKIA_OK", selectable = true, visible = false, callFunction = closeMightyEaglePurchasePage},
		}
	}
	
	mightyEaglePurchasePage = {
		name = "mightyEaglePurchasePage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundBox = { name = "backgroundMightyEagle", sprites = whiteBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{sprite = "NOKIA_CONFIRM_PURCHASE", selectable = false},
			{sprite = "NOKIA_PHONE_BILL", selectable = false},
			{sprite = "NOKIA_MIGHTY_EAGLE", selectable = false},
			{sprite = "NOKIA_CONFIRM", selectable = true, updateFunction = updateMenu, page = mightyEaglePaymentPage},
			{sprite = "NOKIA_CANCEL", selectable = true, callFunction = closeMightyEaglePurchasePage},
			{sprite = "NOKIA_LOGO", selectable = false},
		}
	}
	
	mightyEagleDemoPage = {
		name = "mightyEagleDemoPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundBox = { name = "backgroundMightyEagleDemo", sprites = tutorialBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{ name = "eagle", sprite = "TUTORIAL_MIGHTYEAGLE", selectable = false, x = screenWidth / 2, y = screenHeight / 2, isCompoSprite = true},
			{ name = "buttonOk", sheet = "BUTTONS_SHEET_1", sprite = "TUTORIAL_OK", selectable = true,  updateFunction = updateMenu, page = mightyEaglePurchasePage},
		}
	}
	
	if isBetaVersion then
		betaDisclaimerPage = {
			name = "betaDisclaimerPage",
			popup = true,
			back = nil,
			state = "READY",
			backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
			backgroundBox = { name = "backgroundDisclaimer", sprites = whiteBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
			items = {
				{name = "disclaimerText", text = "Angry Birds Lite Beta is an unfinished version of the application and may not reflect the final gameplay. Please report any issues you might encounter by using the bug button in the main menu. \n\n", font = fontBasic, selectable = false, hanchor = "HCENTER", vanchor = "VCENTER"},
				{name = "okButton", sheet = "", sprite = "TUTORIAL_OK", selectable = true, callFunction = closeBetaDisclaimerPage},
				{name = "hideArea1", callFunction = closeBetaDisclaimerPage, activateOnRelease = true },
				{name = "hideArea2", callFunction = closeBetaDisclaimerPage, activateOnRelease = true },
				{name = "hideArea3", callFunction = closeBetaDisclaimerPage, activateOnRelease = true },
				{name = "hideArea4", callFunction = closeBetaDisclaimerPage, activateOnRelease = true },
			}
		
		}
	end
	
	
	
	levelSelectionPagesBasic = {}
	
	local itemsPerPage = 21
	local levelCount = itemsPerPage
	local pages = 3
		
	if isLiteVersion then
		itemsPerPage = 16
		levelCount = 15
		pages = 1
	end
	
	if settings.currentLevelSelectionPages.basic > pages then
		settings.currentLevelSelectionPages.basic = 1
	end
		
	levelSelectionPagesBasic.currentPage = settings.currentLevelSelectionPages.basic
	levelSelectionPagesBasic.currentOffset = (levelSelectionPagesBasic.currentPage - 1) * -screenWidth
	levelSelectionPagesBasic.targetOffset = levelSelectionPagesBasic.currentOffset
		

	levelSelectionPagesBasic.name = "levelSelectionPagesBasic"
	levelSelectionPagesBasic.pageCount = pages
	levelSelectionPagesBasic.levelsPerPage = levelCount
	levelSelectionPagesBasic.themes = { 1, 2, 3 }
	levelSelectionPagesBasic.back = episodeSelectionPage
	levelSelectionPagesBasic.font = fontBasic
	levelSelectionPagesBasic.backgroundDrawFunction = drawLevelSelectionBackground
	levelSelectionPagesBasic.state = "READY"
	levelSelectionPagesBasic.sound = "menu_confirm"
	levelSelectionPagesBasic.items = { 	
			{ name = "left", sprite = "LS_THEME_1_LEFT", selectable = false },
			{ name = "right", sprite = "LS_THEME_1_RIGHT", selectable = false },
			{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back", activateOnRelease = true },
			{ name = "text_1", text = "1", font = "FONT_LS_SMALL", visible = false },
			{ name = "text_2", text = "2", font = "FONT_LS_SMALL", visible = false },
			{ name = "text_3", text = "3", font = "FONT_LS_SMALL", visible = false },
			{ name = "dot1", sprite = "LS_DOT_WHITE", visible = false },
			{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
			{ name = "dot3", sprite = "LS_DOT_BLACK", visible = false },
			{name = "title", sprite = "SELECT_LEVEL", selectable = false },
			{name = "scrollAreaOverlay", sprite = "LS_CLIP_AREA", selectable = false},
			{name = "leftNavigation", sprite = "BUTTON_ARROW_LEFT", visible = true, activateOnRelease = true,
				shortcutKeys = { "LEFT", "PAGEDOWN" }, callFunction = scrollLevelSelectionLeft, callParam1 = levelSelectionPagesBasic },
			{name = "rightNavigation", sprite = "BUTTON_ARROW_RIGHT", visible = true, activateOnRelease = true,
				shortcutKeys = { "RIGHT", "PAGEUP" }, callFunction = scrollLevelSelectionRight, callParam1 = levelSelectionPagesBasic },
		}
	
	if deviceModel == "n900" then
		_G.table.insert(levelSelectionPagesBasic.items, { name = "overlay", sprite = "DIM_BLOCK", x = 0, y = 0, shade = 0, visible = false })
		_G.table.insert(levelSelectionPagesBasic.items, { name = "button1", sheet = "", sprite = "AVAILABLE_ON_APP_STORE", callFunction = gotoOviStore, selectable = false, visible = false})
		_G.table.insert(levelSelectionPagesBasic.items, { name = "button2", sheet = "", sprite = "UPSELL_BUTTON", callFunction = gotoOviStore, selectable = false, visible = false })

		if settings.currentLevelSelectionPages.basic >= 2 then
			getItemByName(levelSelectionPagesBasic.items, "overlay").shade = 0.65
		end
	end
	
	if deviceModel == "roku" then
		getItemByName(levelSelectionPagesBasic.items, "leftNavigation").sprite = "ROKU_BUTTON_ARROW_LEFT"
		getItemByName(levelSelectionPagesBasic.items, "rightNavigation").sprite = "ROKU_BUTTON_ARROW_RIGHT"
	end
	
	levelSelectionPagesBasic.firstLevelIndex = #levelSelectionPagesBasic.items + 1
	
	local levelNumber = 0
	for currentPage = 1, pages do	
		local pageLevelIndex = 0	
		for i = 1, itemsPerPage do
			pageLevelIndex = pageLevelIndex + 1
			levelNumber = levelNumber + 1
			item = {
					levelIndex = levelNumber,
					pageLevelIndex = pageLevelIndex,
					pageIndex = currentPage,
					themeIndex = levelSelectionPagesBasic.themes[currentPage],
					worldNumber = currentPage,
					text =  "" .. pageLevelIndex,
					folder = levelPath .. "/pack" .. currentPage .. "/",
					filename = levelOrder[levelOrder.packs[currentPage]][pageLevelIndex],
					sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. currentPage,
					sheet = "LEVELSELECTION_SHEET_1",
					updateFunction = updateGame, 
					activateOnRelease = true,
					releaseAssetList = {"LEVELSELECTION"}
				}
			

			if deviceModel == "windows" and currentPage > 1 then
				item.updateFunction = nil
				item.callFunction = loadLevelFromLevelSelection
				item.callParam1 = {	levelIndex = levelNumber, 
									pageLevelIndex = pageLevelIndex,
									folder = levelPath .. "/pack" .. currentPage .. "/",
									pageIndex = currentPage,
									themeIndex = levelSelectionPagesBasic.themes[currentPage],
									filename = levelOrder[levelOrder.packs[currentPage]][pageLevelIndex],
									worldNumber = currentPage,
									page = levelSelectionPagesBasic,
								}
			end
			item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds(item.sheet, item.sprite)
			_G.table.insert(levelSelectionPagesBasic.items, item)
			
			if isLiteVersion then
				item.folder = levelPath .. "/packLite/"
			end
		end
		
	end
		
	if isLiteVersion then
		local lastItemIndex = #levelSelectionPagesBasic.items
		
		if deviceModel == "s60" then
			levelSelectionPagesBasic.items[1].visible = false
			levelSelectionPagesBasic.items[lastItemIndex].sprite = "OVI_BUTTON_MEDIUM"
			levelSelectionPagesBasic.items[lastItemIndex].sheet = ""
			levelSelectionPagesBasic.items[lastItemIndex].levelIndex = nil
			levelSelectionPagesBasic.items[lastItemIndex].text = nil
			levelSelectionPagesBasic.items[lastItemIndex].updateFunction = updateMenu
			levelSelectionPagesBasic.items[lastItemIndex].page = upsellPage
			levelSelectionPagesBasic.back = mainMenu
			levelSelectionPagesBasic.items[3].page = mainMenu
		else
			levelSelectionPagesBasic.items[lastItemIndex].sprite = "LS_FULL_VERSION"
			levelSelectionPagesBasic.items[lastItemIndex].sheet = ""
			levelSelectionPagesBasic.items[lastItemIndex].levelIndex = nil
			levelSelectionPagesBasic.items[lastItemIndex].text = nil
			--levelSelectionPagesBasic.items[lastItemIndex].callFunction = gotoFullVersionInAppStore
			--levelSelectionPagesBasic.items[lastItemIndex].updateFunction = nil
			levelSelectionPagesBasic.items[lastItemIndex].page = upsellPage
			levelSelectionPagesBasic.items[lastItemIndex].updateFunction = updateMenu
			levelSelectionPagesBasic.back = mainMenu
			levelSelectionPagesBasic.items[3].page = mainMenu
		end
	end
	
	levelSelectionPagesBasic.bgColors = { { red = 41, green = 118, blue = 142 }, { red = 14, green = 104, blue = 79 }, { red = 161, green = 98, blue = 60 } }
	levelSelectionPagesBasic.bgColor = { red = 41, green = 118, blue = 142 }
	levelSelectionPagesBasic.items[levelSelectionPagesBasic.firstLevelIndex].updateFunction = updateMenu
	levelSelectionPagesBasic.items[levelSelectionPagesBasic.firstLevelIndex].page = gameStart
	levelSelectionPagesBasic.items[levelSelectionPagesBasic.firstLevelIndex].needLoadingScreen = true

	
	if not isLiteVersion then
		
		levelSelectionPagesExtra = {}
			
		local itemsPerPage = 21
		local levelCount = itemsPerPage
		local pages = 2
			
		if settings.currentLevelSelectionPages.extra > pages then
			settings.currentLevelSelectionPages.extra = 1
		end
			
		levelSelectionPagesExtra.currentPage = settings.currentLevelSelectionPages.extra
		levelSelectionPagesExtra.currentOffset = (levelSelectionPagesExtra.currentPage - 1) * -screenWidth
		levelSelectionPagesExtra.targetOffset = levelSelectionPagesExtra.currentOffset			
		
		levelSelectionPagesExtra.name = "levelSelectionPagesExtra"
		levelSelectionPagesExtra.pageCount = pages
		levelSelectionPagesExtra.levelsPerPage = levelCount
		levelSelectionPagesExtra.themes = { 4, 5 }
		levelSelectionPagesExtra.back = episodeSelectionPage
		levelSelectionPagesExtra.font = fontBasic
		levelSelectionPagesExtra.state = "READY"
		levelSelectionPagesExtra.sound = "menu_confirm"
		levelSelectionPagesExtra.items = { 	
				{ name = "left", sprite = "LS_THEME_4_LEFT", selectable = false },
				{ name = "right", sprite = "LS_THEME_4_RIGHT", selectable = false },
				{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back", activateOnRelease = true },
				{ name = "text_4", text = "4", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_5", text = "5", font = "FONT_LS_SMALL", visible = false },
				{ name = "dot1", sprite = "LS_DOT_WHITE", visible = false },
				{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
				{name = "title", sprite = "SELECT_LEVEL", selectable = false },	
				{name = "scrollAreaOverlay", sprite = "LS_CLIP_AREA", selectable = false},
				{name = "leftNavigation", sprite = "BUTTON_ARROW_LEFT", visible = true, activateOnRelease = true,
					shortcutKeys = { "LEFT", "PAGEDOWN" }, callFunction = scrollLevelSelectionLeft, callParam1 = levelSelectionPagesExtra },
				{name = "rightNavigation", sprite = "BUTTON_ARROW_RIGHT", visible = true, activateOnRelease = true,
					shortcutKeys = { "RIGHT", "PAGEUP" }, callFunction = scrollLevelSelectionRight, callParam1 = levelSelectionPagesExtra },
			}
				
		levelSelectionPagesExtra.firstLevelIndex = #levelSelectionPagesExtra.items + 1
		levelSelectionPagesExtra.backgroundDrawFunction = drawLevelSelectionBackground
		
		if deviceModel == "roku" then
			getItemByName(levelSelectionPagesExtra.items, "leftNavigation").sprite = "ROKU_BUTTON_ARROW_LEFT"
			getItemByName(levelSelectionPagesExtra.items, "rightNavigation").sprite = "ROKU_BUTTON_ARROW_RIGHT"
		end
		
		local levelNumber = 0
		for currentPage = 1, pages do	
			local pageLevelIndex = 0
			for i = 1, itemsPerPage do
				pageLevelIndex = pageLevelIndex + 1
				levelNumber = levelNumber + 1
				item = {
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						pageIndex = currentPage,
						themeIndex = levelSelectionPagesExtra.themes[currentPage],
						worldNumber = currentPage + 3,
						text =  "" .. pageLevelIndex,
						folder = levelPath .. "/pack" .. currentPage + 3 .. "/",
						filename = levelOrder[levelOrder.packs[currentPage + 3]][pageLevelIndex],
						sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. currentPage,
						sheet = "LEVELSELECTION_SHEET_1",
						updateFunction = updateGame, 
						activateOnRelease = true,
						releaseAssetList = {"LEVELSELECTION"}
					}
					
				if deviceModel == "windows" then
					item.updateFunction = nil
					item.callFunction = loadLevelFromLevelSelection
					item.callParam1 = {	levelIndex = levelNumber, 
										pageLevelIndex = pageLevelIndex,
										folder = levelPath .. "/pack" .. currentPage + 3 .. "/",
										pageIndex = currentPage,
										themeIndex = levelSelectionPagesExtra.themes[currentPage],
										filename = levelOrder[levelOrder.packs[currentPage + 3]][pageLevelIndex],
										worldNumber = currentPage + 3,
										page = levelSelectionPagesExtra,
									}
				end
				item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds(item.sheet, item.sprite)
				_G.table.insert(levelSelectionPagesExtra.items, item)
			end
		end


		levelSelectionPagesExtra.bgColors = { { red = 105, green = 184, blue = 225 }, { red = 184, green = 152, blue = 91 } }
		levelSelectionPagesExtra.bgColor =  { red = 105, green = 184, blue = 225 }
		
		-- The check below was commented out because if the game is locked he shouldn't even enter episodes > 1, if it is decided to change later, 
		-- just bring it back
		-- if deviceModel ~= "windows" or g_registrationEnabled ~= true or g_isGameUnlocked == true then
			-- levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].callFunction = nil
			-- levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].callParam1 = nil
		-- end
		levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].callFunction = nil
		levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].callParam1 = nil
		levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].updateFunction = updateMenu
		levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].page = theme4Start
		levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].needLoadingScreen = true
			
		levelSelectionPagesGoldenEggs = { {} }
		levelCount = 17
		
		-- golden eggs menu
		local pages = 2
		if settings.currentLevelSelectionPages.goldeneggs > pages then
			settings.currentLevelSelectionPages.goldeneggs = 1
		end
		levelSelectionPagesGoldenEggs[1].currentPage = 1
		levelSelectionPagesGoldenEggs[1].currentOffset = 0
		levelSelectionPagesGoldenEggs[1].targetOffset = 0
		levelSelectionPagesGoldenEggs[1].pageCount = 2
		levelSelectionPagesGoldenEggs[1].name = "levelSelectionPagesGoldenEggs" .. 1
		levelSelectionPagesGoldenEggs[1].pageNumber = 1
		levelSelectionPagesGoldenEggs[1].levelCount = levelCount
		levelSelectionPagesGoldenEggs[1].back = episodeSelectionPage
		levelSelectionPagesGoldenEggs[1].font = fontBasic
		levelSelectionPagesGoldenEggs[1].state = "READY"
		levelSelectionPagesGoldenEggs[1].sound = "menu_confirm"
		levelSelectionPagesGoldenEggs[1].themes = {1, 2}
		levelSelectionPagesGoldenEggs[1].items = {}
		levelSelectionPagesGoldenEggs[1].backgroundDrawFunction = drawLevelSelectionBackground
		levelSelectionPagesGoldenEggs[1].drawSpritesFirst = false
		levelSelectionPagesGoldenEggs[1].dragging = false
			
		
		
					
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{ name = "puzzledBird", sheet = puzzledBirdSheet, sprite = "GOLDEN_EGG_PUZZLED_BIRD"})		
				
		
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, { name = "text_1", text = "1", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="VCENTER", visible = false, })
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, { name = "text_2", text = "2", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="VCENTER", visible = false })
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,	{ name = "dot1", sprite = "LS_DOT_WHITE", visible = false})
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, { name = "dot2", sprite = "LS_DOT_BLACK", visible = false})
		
				
		
			
		
	
		
		levelSelectionPagesGoldenEggs[1].firstLevelIndex = #levelSelectionPagesGoldenEggs[1].items + 1
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 1,
				levelIndex = 1,
				filename = levelOrder_goldenEggs[1],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame, 
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_2",
				children = { { sprite = "EGG_HINT_TUTORIAL", visible = false}, },
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 2,
				levelIndex = 2,
				filename = levelOrder_goldenEggs[2],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame, 
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_4",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_ROCKET", visible = false}, },
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 3,
				levelIndex = 3,
				filename = levelOrder_goldenEggs[3],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame,
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_1",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_BEACH_BALL", visible = false}, },
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 4,
				levelIndex = 4,
				updateFunction = updateGame, 
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_3",
				updateFunction = updateSoundboard,
				soundboard = "SOUNDBOARD1",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_3STAR_EP1", visible = false}, },
				selectable = false,
				worldNumber = -1,
			})
			
		--[[
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 5,
				levelIndex = 5,
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_5",
				updateFunction = updatePictureLevel,
				pictureLevel = "MIGHTY_EAGLE",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_ABOUT", visible = false}, },
				selectable = false
			})
			]]--
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 5,
				levelIndex = 5,
				filename = levelOrder_goldenEggs[13],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame, 
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_5",
				children = { { sprite = "EGG_HINT_ABOUT", visible = false}, },
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			--[[
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 6,
				levelIndex = 6,
				sprite = "EGG_SILHOUETTE_7",
				updateFunction = updatePictureLevel,
				pictureLevel = "PIGGY",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_TREASURE_CHEST", visible = false}, },
				selectable = false
			})
			]]--
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 6,
				levelIndex = 6,
				filename = levelOrder_goldenEggs[14],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame, 
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_7",
				children = { { sprite = "EGG_HINT_TREASURE_CHEST", visible = false}, },
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 7,
				levelIndex = 7,
				sprite = "EGG_SILHOUETTE_6",
				updateFunction = updateSoundboard,
				soundboard = "RADIO",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_3STAR_EP2", visible = false}, },
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 8,
				levelIndex = 8,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[4],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_2",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 9,
				levelIndex = 9,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[5],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_3",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 10,
				levelIndex = 10,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[6],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_3",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 11,
				levelIndex = 11,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[7],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_3",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 12,
				levelIndex = 12,
				sprite = "GOLDEN_EGG_1",
				updateFunction = updateSoundboard,
				soundboard = "KEYBOARD",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION"},
				loadAssetList = {"INGAME"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 13,
				levelIndex = 13,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[8],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_3",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
				
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 14,
				levelIndex = 14,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[9],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_1",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 15,
				levelIndex = 15,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[10],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_1",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 16,
				levelIndex = 16,
				sprite = "GOLDEN_EGG_1",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[11],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 17,
				levelIndex = 17,
				sprite = "GOLDEN_EGG_3",
				updateFunction = updateSoundboard,
				soundboard = "SEQUENCER",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1,
				loadAssetList = {"INGAME"},
				releaseAssetList = {"LEVELSELECTION"}
			})		
		
			
		for i = 1, levelCount do
			_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{ sprite = "GOLDEN_EGG_CARVED_STAR",
			  visible = false,
			  selectable = false,
			  levelIndex = i+1,
			})
		end
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back", activateOnRelease = true, releaseAssetList = {"GOLDEN_EGGS"}} )
		
		if deviceModel == "roku" and screenHeight > 576 then
			getItemByName(levelSelectionPagesGoldenEggs[1].items, "back").loadAssetList = {"OTHER_2"}
		end
		
		if deviceModel == "roku" then
			getItemByName(levelSelectionPagesGoldenEggs[1].items, "back").needLoadingScreen = true
		end
		
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{ name = "overlay", itemDrawFunction = goldenEggMenuDimDraw, sprite = "DIM_BLOCK", shade = 0, visible = false, fadeSpeed = 0, x = 0, y = 0 })
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{name = "tipBubble", sprite = "EGG_THOUGHT_BUBBLE_3", 
				children = { {sprite = "EGG_THOUGHT_BUBBLE_2"},
						     {sprite = "EGG_THOUGHT_BUBBLE_1"},
							}
			})	
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{name = "tipContent", sprite = "EGG_HINT_TREASURE_CHEST", visible = false,
			})
		levelSelectionPagesGoldenEggs[1].bgColors = {{ red = 238, green = 176, blue = 66 }, { red = 238, green = 176, blue = 66 }}
		levelSelectionPagesGoldenEggs[1].bgColor = { red = 238, green = 176, blue = 66 }
		
		levelSelectionPagesPack3 = {}
			
		local itemsPerPage = 15
		local levelCount = itemsPerPage
		local pages = 3
			
		if settings.currentLevelSelectionPages.pack3 > pages then
			settings.currentLevelSelectionPages.pack3 = 1
		end
			
		levelSelectionPagesPack3.currentPage = settings.currentLevelSelectionPages.pack3
		levelSelectionPagesPack3.currentOffset = (levelSelectionPagesPack3.currentPage - 1) * -screenWidth
		levelSelectionPagesPack3.targetOffset = levelSelectionPagesPack3.currentOffset
			
			
		levelSelectionPagesPack3.name = "levelSelectionPagesPack3"
		levelSelectionPagesPack3.pageCount = pages
		levelSelectionPagesPack3.levelsPerPage = levelCount
		levelSelectionPagesPack3.themes = { 6, 7, 8 }
		levelSelectionPagesPack3.back = episodeSelectionPage
		levelSelectionPagesPack3.font = fontBasic
		levelSelectionPagesPack3.state = "READY"
		levelSelectionPagesPack3.sound = "menu_confirm"
		levelSelectionPagesPack3.items = { 	
				{ name = "left", sprite = "LS_THEME_6_LEFT", selectable = false },
				{ name = "right", sprite = "LS_THEME_6_RIGHT", selectable = false },
				{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back", activateOnRelease = true },
				{ name = "text_6", text = "6", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_7", text = "7", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_8", text = "8", font = "FONT_LS_SMALL", visible = false },
				{ name = "dot1", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot3", sprite = "LS_DOT_BLACK", visible = false },
				{name = "title", sprite = "SELECT_LEVEL", selectable = false },
				{name = "scrollAreaOverlay", sprite = "LS_CLIP_AREA", selectable = false},
				{name = "leftNavigation", sprite = "BUTTON_ARROW_LEFT", visible = true, activateOnRelease = true,
					shortcutKeys = { "LEFT", "PAGEDOWN" }, callFunction = scrollLevelSelectionLeft, callParam1 = levelSelectionPagesPack3 },
				{name = "rightNavigation", sprite = "BUTTON_ARROW_RIGHT", visible = true, activateOnRelease = true,
					shortcutKeys = { "RIGHT", "PAGEUP" }, callFunction = scrollLevelSelectionRight, callParam1 = levelSelectionPagesPack3 },
			}
				
			levelSelectionPagesPack3.firstLevelIndex = #levelSelectionPagesPack3.items + 1
			levelSelectionPagesPack3.backgroundDrawFunction = drawLevelSelectionBackground
		
		if deviceModel == "roku" then
			getItemByName(levelSelectionPagesPack3.items, "leftNavigation").sprite = "ROKU_BUTTON_ARROW_LEFT"
			getItemByName(levelSelectionPagesPack3.items, "rightNavigation").sprite = "ROKU_BUTTON_ARROW_RIGHT"
		end
		
		local levelNumber = 0
		for currentPage = 1, pages do
			local pageLevelIndex = 0
			for i = 1, itemsPerPage do
				pageLevelIndex = pageLevelIndex + 1
				levelNumber = levelNumber + 1
				item = {
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						pageIndex = currentPage,
						themeIndex = levelSelectionPagesPack3.themes[currentPage],
						worldNumber = currentPage + 5,
						text =  "" .. pageLevelIndex,
						folder = levelPath .. "/pack" .. currentPage + 5 .. "/",
						filename = levelOrder[levelOrder.packs[currentPage + 5]][pageLevelIndex],
						sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. levelSelectionPagesPack3.themes[currentPage],
						updateFunction = updateGame, 
						activateOnRelease = true,
						releaseAssetList = {"LEVELSELECTION"}
					}
					
				if deviceModel == "windows" then
					item.updateFunction = nil
					item.callFunction = loadLevelFromLevelSelection
					item.callParam1 = {	levelIndex = levelNumber, 
										pageLevelIndex = pageLevelIndex,
										folder = levelPath .. "/pack" .. currentPage + 5 .. "/",
										pageIndex = currentPage,
										themeIndex = levelSelectionPagesPack3.themes[currentPage],
										filename = levelOrder[levelOrder.packs[currentPage + 5]][pageLevelIndex],
										worldNumber = currentPage + 5,
										page = levelSelectionPagesPack3,
									}
				end
				
				item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds("", item.sprite)
				_G.table.insert(levelSelectionPagesPack3.items, item)
					
			end	
			if currentPage == 3 then
				--golden egg
				_G.table.insert(levelSelectionPagesPack3.items, 
					{
					name = "goldenEgg",
					sprite = "GOLDEN_EGG_5",
					callFunction = episode3LevelSelectionEggAchieved
					})
			end
		end
				
		levelSelectionPagesPack3.bgColors = { { red = 82, green = 103, blue = 43 }, { red = 21, green = 31, blue = 63 }, { red = 190, green = 219, blue = 229 } }
		levelSelectionPagesPack3.bgColor = { red = 82, green = 103, blue = 43 }
		
		-- The check below was commented out because if the game is locked he shouldn't even enter episodes > 1, if it is decided to change later, 
		-- just bring it back
		-- if deviceModel ~= "windows" or g_registrationEnabled ~= true or g_isGameUnlocked == true then
			-- levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].callFunction = nil
			-- levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].callParam1 = nil
		-- end
		levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].callFunction = nil
		levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].callParam1 = nil
		levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].updateFunction = updateMenu
		levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].page = theme6Start
		levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].needLoadingScreen = true

		
		levelSelectionPagesPack4 = {}
			
		local itemsPerPage = 15
		local levelCount = itemsPerPage
		local pages = 3
		
		if settings.currentLevelSelectionPages.pack4 > pages then
			settings.currentLevelSelectionPages.pack4 = 1
		end
			
		levelSelectionPagesPack4.currentPage = settings.currentLevelSelectionPages.pack4
		levelSelectionPagesPack4.currentOffset = (levelSelectionPagesPack4.currentPage - 1) * -screenWidth
		levelSelectionPagesPack4.targetOffset = levelSelectionPagesPack4.currentOffset
		
		
		levelSelectionPagesPack4.name = "levelSelectionPagesPack4"
		levelSelectionPagesPack4.pageCount = pages
		levelSelectionPagesPack4.levelsPerPage = levelCount
		levelSelectionPagesPack4.themes = { 9, 10, 11}
		levelSelectionPagesPack4.back = episodeSelectionPage
		levelSelectionPagesPack4.font = fontBasic
		levelSelectionPagesPack4.state = "READY"
		levelSelectionPagesPack4.sound = "menu_confirm"
		levelSelectionPagesPack4.items = { 	
				{ name = "left", sprite = "LS_THEME_9_LEFT", selectable = false },
				{ name = "right", sprite = "LS_THEME_9_RIGHT", selectable = false },
				{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back", activateOnRelease = true },
				{ name = "text_9", text = "9", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_10", text = "10", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_11", text = "11", font = "FONT_LS_SMALL", visible = false },
				{ name = "dot1", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot3", sprite = "LS_DOT_BLACK", visible = false },
				{name = "title", sprite = "SELECT_LEVEL", selectable = false },	
				{name = "scrollAreaOverlay", sprite = "LS_CLIP_AREA", selectable = false},
				{name = "leftNavigation", sprite = "BUTTON_ARROW_LEFT", visible = true, activateOnRelease = true,
					shortcutKeys = { "LEFT", "PAGEDOWN" }, callFunction = scrollLevelSelectionLeft, callParam1 = levelSelectionPagesPack4 },
				{name = "rightNavigation", sprite = "BUTTON_ARROW_RIGHT", visible = true, activateOnRelease = true,
					shortcutKeys = { "RIGHT", "PAGEUP" }, callFunction = scrollLevelSelectionRight, callParam1 = levelSelectionPagesPack4 },
			}
				
			levelSelectionPagesPack4.firstLevelIndex = #levelSelectionPagesPack4.items + 1
			levelSelectionPagesPack4.backgroundDrawFunction = drawLevelSelectionBackground
		
		if deviceModel == "roku" then
			getItemByName(levelSelectionPagesPack4.items, "leftNavigation").sprite = "ROKU_BUTTON_ARROW_LEFT"
			getItemByName(levelSelectionPagesPack4.items, "rightNavigation").sprite = "ROKU_BUTTON_ARROW_RIGHT"
		end
		
		local levelNumber = 0
		for currentPage = 1, pages do
			local pageLevelIndex = 0
			for i = 1, itemsPerPage do
				pageLevelIndex = pageLevelIndex + 1
				levelNumber = levelNumber + 1
				item = {
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						pageIndex = currentPage,
						themeIndex = levelSelectionPagesPack4.themes[currentPage],
						worldNumber = currentPage + 8,
						text =  "" .. pageLevelIndex,
						folder = levelPath .. "/pack" .. currentPage + 8 .. "/",
						filename = levelOrder[levelOrder.packs[currentPage + 8]][pageLevelIndex],
						sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. levelSelectionPagesBasic.themes[currentPage], -- uses buttons from episode 1
						sheet = "LEVELSELECTION_SHEET_1",
						updateFunction = updateGame, 
						activateOnRelease = true,
						releaseAssetList = {"LEVELSELECTION"}
					}
					
				if deviceModel == "windows" then
					item.updateFunction = nil
					item.callFunction = loadLevelFromLevelSelection
					item.callParam1 = {	levelIndex = levelNumber, 
										pageLevelIndex = pageLevelIndex,
										folder = levelPath .. "/pack" .. currentPage + 8 .. "/",
										pageIndex = currentPage,
										themeIndex = levelSelectionPagesPack4.themes[currentPage],
										filename = levelOrder[levelOrder.packs[currentPage + 8]][pageLevelIndex],
										worldNumber = currentPage + 8,
										page = levelSelectionPagesPack4,
									}
				end
				
				item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds(item.sheet, item.sprite)
				_G.table.insert(levelSelectionPagesPack4.items, item)
			end
		end
					
		levelSelectionPagesPack4.bgColors = { { red = 41, green = 118, blue = 142 }, { red = 105, green = 184, blue = 225 }, { red = 82, green = 103, blue = 43 } }
		levelSelectionPagesPack4.bgColor = { red = 41, green = 118, blue = 142 }
		
		-- The check below was commented out because if the game is locked he shouldn't even enter episodes > 1, if it is decided to change later, 
		-- just bring it back
		-- if deviceModel ~= "windows" or g_registrationEnabled ~= true or g_isGameUnlocked == true then
			-- levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].callFunction = nil
			-- levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].callParam1 = nil
		-- end
		levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].callFunction = nil
		levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].callParam1 = nil
		levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].updateFunction = updateMenu
		levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].page = theme9Start
		levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].needLoadingScreen = true
	
		
	end

	
	
	if showEditor then
		levelSelectionEdit = {}
		
		local currentLevel = 0
		for i = 1, 50 do			
			levelSelectionEdit[i], currentLevel = makeEditLevelPack(i, currentLevel)
			currentLevel = i * 21
			levelSelectionEdit[i].back = mainMenu
			
			if i > 0 then
				_G.table.insert(levelSelectionEdit[i].items,
					{sprite = "LS_BACK_BUTTON", x = 0, y = screenHeight, updateFunction = updateMenu, page = levelSelectionEdit[i-1], sound = "menu_back" } )
					if i == 1 then
						levelSelectionEdit[i].items[#levelSelectionEdit[i].items].back = mainMenu
						levelSelectionEdit[i].items[#levelSelectionEdit[i].items].page = mainMenu
					end
			end
			
			if i-1 > 0 then
				_G.table.insert(levelSelectionEdit[i-1].items,
					{sprite = "LS_BACK_BUTTON", x = screenWidth - 100, y = screenHeight, updateFunction = updateMenu, page = levelSelectionEdit[i], sound = "menu_back" } )
			end
		end
	end
	
	settingsBGw, settingsBGh = _G.res.getSpriteBounds("", "SETTINGS_BG")
	levelFinishBGw, levelFinishBGh = _G.res.getSpriteBounds("", "LEVEL_FINISH_BG")	
	levelFailedBGw, levelFailedBGh = _G.res.getSpriteBounds("", "LEVEL_FAILED_BG")
	
	if  deviceModel == "roku" then
		pauseButtonW, pauseButtonH = _G.res.getSpriteBounds("", "ROKU_MENU_BUTTON")
	else
		pauseButtonW, pauseButtonH = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "MENU_BUTTON")
	end
	if deviceModel == "iphone4" then
		pauseButtonW, pauseButtonH = pauseButtonW * 2, pauseButtonH * 2
	end
		
	overlayMenuPage = {
		name = "overlayMenuPage",
		back = nil,
		title = { text = "" },
		state = "READY",
		sound = "menu_confirm",
		items = {
		}
	}
	
	if deviceModel == "n900" then
		_G.table.insert(overlayMenuPage.items, {name = "taskSwitcher", sprite = "BUTTON_TASK_SWITCHER", x = 0, y = 0, callFunction = goToTaskSwitcherLua } )
		_G.table.insert(overlayMenuPage.items, {name = "close", sprite = "BUTTON_CLOSE", x = screenWidth, y = 0, callFunction = requestExit} )
	elseif deviceModel == "s60" then
		_G.table.insert(overlayMenuPage.items, {name = "close", sprite = "BUTTON_CLOSE", x = screenWidth, y = 0, callFunction = requestExit} )
	elseif deviceModel == "android" and isBetaVersion then
		_G.table.insert(overlayMenuPage.items, {name = "betaUp", sprite = "BETA_UP_LEFT", selectable = false})
	end
	
	local scoreSpriteName = _G.res.getString("TEXTS_BASIC", "TEXT_SCORE_SPRITE")
	
	local textY = 30
	local scoreBox = {topLeft = "SCORE_TOP_LEFT", left = "SCORE_LEFT", bottomLeft = "SCORE_BOTTOM_LEFT", bottomMiddle = "SCORE_BOTTOM_MIDDLE",
					  bottomRight = "SCORE_BOTTOM_RIGHT", right = "SCORE_RIGHT", topRight = "SCORE_TOP_RIGHT", topMiddle = "SCORE_TOP_MIDDLE",
					  center = "SCORE_CENTER"}
	
	
	
	episodeSelectionPage.name = "episodeSelectionPage"
	episodeSelectionPage.back = mainMenu
	episodeSelectionPage.backgroundDrawFunction = drawLevelSelectionBackground
	episodeSelectionPage.state = "READY"
	episodeSelectionPage.sound = "menu_confirm"
	episodeSelectionPage.bgColor = { red = 11, green = 101, blue = 76 }							
	episodeSelectionPage.numEpisodes = 6
	
	episodeSelectionPage.items = {												
		{name = "left", sprite = "LS_MAIN_LEFT", selectable = false },
		{name = "right", sprite = "LS_MAIN_RIGHT", selectable = false },
		
		{name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = mainMenu, sound = "menu_back",  releaseAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}, loadAssetList={"INGAME"}},						
		{name = "title", sprite = "SELECT_EPISODE", page = mainMenu, selectable = false },				
		
	}		
	
	if deviceModel == "roku" then
		getItemByName(episodeSelectionPage.items, "back").needLoadingScreen = true
	end
	
	_G.table.insert(episodeSelectionPage.items, 1, 
		{name = "episode1",  updateFunction = gotoLevelSelection, box = { topLeft = "EPISODE1_TOP_LEFT", left = "EPISODE1_LEFT", 
											   bottomLeft = "EPISODE1_BOTTOM_LEFT", bottomMiddle = "EPISODE1_BOTTOM_MIDDLE",
											   bottomRight = "EPISODE1_BOTTOM_RIGHT", right = "EPISODE1_RIGHT",
											   topRight = "EPISODE1_TOP_RIGHT", topMiddle = "EPISODE1_TOP_MIDDLE",
											   center = "EPISODE1_CENTER"}, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER", 	
			children = { {name = "ep1Sprite", sprite = "LS_PACK_THUMB_01"},
						 {name = "ep1ScoreBox1", box = scoreBox, hanchor = "LEFT", vanchor = "BOTTOM"},
						 {name = "ep1ScoreBox2", box = scoreBox, hanchor = "RIGHT", vanchor = "BOTTOM"},
						 {name = "episode1Text", text = "TEXT_LP_NAME_1", hanchor="HCENTER", vanchor="VCENTER", font = fontBasic },
						 {name = "episode1Score", text = "score", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM"},
						 {name = "episode1Stars", text = "stars", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" },
						 {name = "episode1ScoreText", sprite = scoreSpriteName, selectable = false, visible = false, vanchor = "VCENTER", hanchor = "TOP"},
						 {name = "episode1YellowLine", box = {topMiddle = "EPISODE_YELLOW_LINE"}, hanchor = "HCENTER", vanchor = "TOP"},
						 {name = "ep1StarSprite", sprite = "LS_STAR_GOLD", hanchor = "HCENTER", vanchor = "VCENTER"},
						 {name = "lock", sprite = "LS_LEVEL_PACK_LOCK"},
						}}
	)
	
	if deviceModel == "roku" and screenHeight <= 576 then
		getItemByName(episodeSelectionPage.items, "episode1Score").font = "FONT_LS_SMALLER"
	end	
	
	_G.table.insert(episodeSelectionPage.items, 2, 
		{name = "episode2", updateFunction = gotoLevelSelectionExtra, box = { topLeft = "EPISODE2_TOP_LEFT", left = "EPISODE2_LEFT", 
											   bottomLeft = "EPISODE2_BOTTOM_LEFT", bottomMiddle = "EPISODE2_BOTTOM_MIDDLE",
											   bottomRight = "EPISODE2_BOTTOM_RIGHT", right = "EPISODE2_RIGHT",
											   topRight = "EPISODE2_TOP_RIGHT", topMiddle = "EPISODE2_TOP_MIDDLE",
											   center = "EPISODE2_CENTER"}, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER",
			children = { {name = "ep2Sprite", sprite = "LS_PACK_THUMB_02"},
						 {name = "ep2ScoreBox1", box = scoreBox, hanchor = "LEFT", vanchor = "BOTTOM"},
						 {name = "ep2ScoreBox2", box = scoreBox, hanchor = "RIGHT", vanchor = "BOTTOM"},
						 {name = "episode2Text", text = "TEXT_LP_NAME_2", hanchor="HCENTER", vanchor="VCENTER", font = fontBasic },
						 {name = "episode2Score", text = "score", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" },
						 {name = "episode2Stars", text = "stars", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" },
						 {name = "episode2ScoreText", sprite = scoreSpriteName,  selectable = false, visible = false, vanchor = "TOP", hanchor = "HCENTER"},
						 {name = "appStore", sprite = "AVAILABLE_ON_APP_STORE"},
						 {name = "episode2YellowLine", box = {topMiddle = "EPISODE_YELLOW_LINE"}, hanchor = "HCENTER", vanchor = "TOP"},
						 {name = "ep2StarSprite", sprite = "LS_STAR_GOLD", hanchor = "HCENTER", vanchor = "VCENTER"},
						 {name = "lock", sprite = "LS_LEVEL_PACK_LOCK"},
						}}
	)
	
	_G.table.insert(episodeSelectionPage.items, 3, 
	{
		name = "episode3", updateFunction = gotoLevelSelectionPack3, box = { topLeft = "EPISODE3_TOP_LEFT", left = "EPISODE3_LEFT", 
												   bottomLeft = "EPISODE3_BOTTOM_LEFT", bottomMiddle = "EPISODE3_BOTTOM_MIDDLE",
												   bottomRight = "EPISODE3_BOTTOM_RIGHT", right = "EPISODE3_RIGHT",
												   topRight = "EPISODE3_TOP_RIGHT", topMiddle = "EPISODE3_TOP_MIDDLE",
												   center = "EPISODE3_CENTER"}, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER",
		children = { {name = "ep3Sprite", sprite = "LS_PACK_THUMB_03"},
					 {name = "ep3ScoreBox1", box = scoreBox, hanchor = "LEFT", vanchor = "BOTTOM"},
					 {name = "ep3ScoreBox2", box = scoreBox, hanchor = "RIGHT", vanchor = "BOTTOM"},
					 {name = "episode3Text", text = "TEXT_LP_NAME_3", hanchor="HCENTER", vanchor="VCENTER", font = fontBasic },
					 {name = "episode3Score", text = "", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" },
					 {name = "episode3Stars", text = "", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" },
					 {name = "episode3ScoreText", sprite = scoreSpriteName, selectable = false, visible = false, vanchor = "TOP", hanchor = "HCENTER"},
					 {name = "appStore", sprite = "AVAILABLE_ON_APP_STORE"},
					 {name = "episode3YellowLine", box = {topMiddle = "EPISODE_YELLOW_LINE"}, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "TOP"},
					 {name = "ep3StarSprite", sprite = "LS_STAR_GOLD", hanchor = "HCENTER", vanchor = "VCENTER"},
					 {name = "lock", sprite = "LS_LEVEL_PACK_LOCK"},
					}
	})
	
	
	_G.table.insert(episodeSelectionPage.items, 4, 
	{
		name = "episode4", updateFunction = gotoLevelSelectionPack4, box = { topLeft = "EPISODE4_TOP_LEFT", left = "EPISODE4_LEFT", 
											   bottomLeft = "EPISODE4_BOTTOM_LEFT", bottomMiddle = "EPISODE4_BOTTOM_MIDDLE",
											   bottomRight = "EPISODE4_BOTTOM_RIGHT", right = "EPISODE4_RIGHT",
											   topRight = "EPISODE4_TOP_RIGHT", topMiddle = "EPISODE4_TOP_MIDDLE",
											   center = "EPISODE4_CENTER"}, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER",
		children = { {name = "ep4Sprite", sprite = "LS_PACK_THUMB_04"},
					 {name = "ep4ScoreBox1", box = scoreBox, hanchor = "LEFT", vanchor = "BOTTOM"},
					 {name = "ep4ScoreBox2", box = scoreBox, hanchor = "RIGHT", vanchor = "BOTTOM"},
					 {name = "episode4Text", text = "TEXT_LP_NAME_4", hanchor="HCENTER", vanchor="VCENTER", font = fontBasic },
					 {name = "episode4Score", text = "", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" },
					 {name = "episode4Stars", text = "", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" },
					 {name = "episode4ScoreText", sprite = scoreSpriteName, selectable = false, visible = false, vanchor = "TOP", hanchor = "HCENTER"},
					 {name = "appStore", sprite = "AVAILABLE_ON_APP_STORE"},
					 {name = "episode4YellowLine", box = {topMiddle = "EPISODE_YELLOW_LINE"}, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "TOP"},
					 {name = "ep4StarSprite", sprite = "LS_STAR_GOLD", hanchor = "HCENTER", vanchor = "VCENTER"},
					 {name = "lock", sprite = "LS_LEVEL_PACK_LOCK"},
					}
	})
		
	_G.table.insert(episodeSelectionPage.items, 5, 
	{
		name = "episodeG", updateFunction = gotoLevelSelectionGoldenEggs, box = { topLeft = "EPISODEG_TOP_LEFT", left = "EPISODEG_LEFT", 
											   bottomLeft = "EPISODEG_BOTTOM_LEFT", bottomMiddle = "EPISODEG_BOTTOM_MIDDLE",
											   bottomRight = "EPISODEG_BOTTOM_RIGHT", right = "EPISODEG_RIGHT",
											   topRight = "EPISODEG_TOP_RIGHT", topMiddle = "EPISODEG_TOP_MIDDLE",
											   center = "EPISODEG_CENTER"}, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER", 
		children = {{name = "epGSprite", sprite = "EPISODEG_ICON"}, 
					{name = "epGStar", sprite = "LS_PACK_GE_STAR"},
					{name = "epGEggs", sprite = "LS_PACK_GE_THUMB_01"},
					{name = "epGEpisodeText", text = "Golden Eggs", vanchor = "VCENTER", hanchor = "HCENTER", font = fontBasic},
					{ name = "epGStarText", text = "", hanchor="HCENTER", vanchor="VCENTER", font = "FONT_LS_SMALL"} }
	})		
	
	episodeSelectionPage.goldenEggHitBox = {}			
			
	for i = 1, episodeSelectionPage.numEpisodes do
		episodeSelectionPage.items[i].activateOnRelease = true
	end
	
	if deviceModel == "roku" then
		getItemByName(episodeSelectionPage.items, "episodeG").needLoadingScreen = true
	end

	if settings.selectedEpisode > episodeSelectionPage.numEpisodes then
		settings.selectedEpisode = 1
	end
	
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButton1", sprite = "BUTTON_EP_1", updateFunction = gotoLevelSelection, page = mainMenu, sound = "menu_back", activateOnRelease = true })
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonScore1", text = "score", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM"})
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonStars1", text = "stars", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" })
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonLock1", sprite = "LS_LEVEL_PACK_LOCK"})
					 
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButton2", sprite = "BUTTON_EP_2", updateFunction = gotoLevelSelectionExtra, page = mainMenu, sound = "menu_back", activateOnRelease = true })						
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonScore2", text = "score", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM"})
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonStars2", text = "stars", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" })
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonLock2", sprite = "LS_LEVEL_PACK_LOCK"})
	
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButton3", sprite = "BUTTON_EP_3", updateFunction = gotoLevelSelectionPack3, page = mainMenu, sound = "menu_back", activateOnRelease = true })						
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonScore3", text = "score", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM"})
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonStars3", text = "stars", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" })
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonLock3", sprite = "LS_LEVEL_PACK_LOCK"})
	
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButton4", sprite = "BUTTON_EP_4", updateFunction = gotoLevelSelectionPack4, page = mainMenu, sound = "menu_back", activateOnRelease = true })					
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonScore4", text = "score", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM"})
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonStars4", text = "stars", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" })
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonLock4", sprite = "LS_LEVEL_PACK_LOCK"})
	
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonG", sprite = "BUTTON_EP_G", updateFunction = gotoLevelSelectionGoldenEggs, page = mainMenu, sound = "menu_back", activateOnRelease = true, loadAssetList = {"GOLDEN_EGGS"} })						
	_G.table.insert(episodeSelectionPage.items,	{name = "episodeButtonStarsG", text = "stars", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" })
	
	if deviceModel == "roku" and screenHeight > 576 then
		getItemByName(episodeSelectionPage.items, "episodeButtonG").releaseAssetList = {"OTHER_2"}
	end
	
	if deviceModel == "roku" then
		getItemByName(episodeSelectionPage.items, "episodeButtonG").needLoadingScreen = true
	end
	
	moreGamesPage = {
		name = "moreGamesPage",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		popup = true,
		back = nil,
		state = "READY",
		sound = "menu_confirm",
		items = {
			{x = 0, y = 0, w = screenWidth, h = screenHeight, updateFunction = removePopupMenu },
			{sprite = "LEVEL_FAILED_BG", x = screenWidth * 0.5, y = screenHeight * 0.5 },
			{text = "Get More on Ovi", x = screenWidth * 0.5, y = screenHeight * 0.5 - 10 },
			{sprite = "BUTTON_MENU", x = screenWidth * 0.5 - 80, y = screenHeight * 0.5 + 80, updateFunction = removePopupMenu },
			{sprite = "BUTTON_NEXTLEVEL", x = screenWidth * 0.5 + 80, y = screenHeight * 0.5 + 80, callFunction = gotoMoreOnOviStore },
		}
	}
	
	local sliderBox = {topLeft = "MENU_SLIDER_BG_TOP_LEFT", left = "MENU_SLIDER_BG_LEFT", bottomLeft = "MENU_SLIDER_BG_BOTTOM_LEFT", bottomMiddle = "MENU_SLIDER_BG_BOTTOM_MIDDLE",
					  bottomRight = "MENU_SLIDER_BG_BOTTOM_RIGHT", right = "MENU_SLIDER_BG_RIGHT", topRight = "MENU_SLIDER_BG_TOP_RIGHT", topMiddle = "MENU_SLIDER_BG_TOP_MIDDLE",
					  center = "MENU_SLIDER_BG_CENTER"}
	
	
	local playSpriteName = _G.res.getString("TEXTS_BASIC", "TEXT_PLAY_SPRITE")
	
	playSpriteName = "MENU_PLAY_EN"		
	
	if screenWidth < 1920 or(g_levelSelectionMultipleAssets ~= true) then
		--playSpriteName = "MENU_PLAY_SMALL_EN"
	end
	
	
	
	mainMenu.name = "mainMenu"
	mainMenu.back = nil
	mainMenu.bgColor = { red = 11, green = 101, blue = 76 }
	mainMenu.state = "READY"
	mainMenu.sound = "menu_confirm"
	mainMenu.items = {
			{name = "play", sprite = playSpriteName, updateFunction = updateMenu, page = episodeSelectionPage, hanchor="HCENTER", vanchor="VCENTER", activateOnRelease = true, loadAssetList = {"LEVELSELECTION"}, releaseAssetList = {"INGAME"}}, 
			{name = "sliderBGRight", box = sliderBox, hanchor = "HCENTER", vanchor = "BOTTOM", visible = false},
			{name = "sliderBGLeft", box = sliderBox, hanchor = "HCENTER", vanchor = "BOTTOM", visible = false},
			{name = "sfx", sprite = "BUTTON_SOUNDS_SMALL", callFunction = changeAudio, hanchor="HCENTER", vanchor="VCENTER", selectable = false, activateOnRelease=true } ,
			{name = "credits", sprite = "BUTTON_ABOUT_SMALL", callFunction = showLeftMenu, hanchor="HCENTER", vanchor="VCENTER", selectable = false, activateOnRelease=true } ,
			{name = "fullScreen", sprite = "BUTTON_FULLSCREEN", callFunction = toggleFullScreen, hanchor="HCENTER", vanchor="VCENTER", selectable = false, activateOnRelease=true } ,
			{name = "trailer", sprite = "BUTTON_TRAILER_SMALL", callFunction = gotoAngryBirdsTrailer, selectable = false, visible = false },
			{name = "buttonOff", sprite = "BUTTON_SOUNDS_OFF_SMALL", selectable = false } ,
			{name = "menuOvi", sprite = "MENU_OVI", callFunction = gotoOviStore, visible = false },
			{name = "menuLogo", sprite = "MENU_LOGO", selectable = false, visible = true },
			{name = "logoLite", sprite = "LOGO_LITE", selectable = false, visible = false },
			{name = "appStore", sprite = "MENU_APP_STORE", visible = false, callFunction = gotoFullVersionInAppStore },
			{name = "facebook", sprite = "BUTTON_FACEBOOK_SMALL", visible = false, callFunction = gotoFacebook, selectable = false },
			{name = "twitter", sprite = "BUTTON_TWITTER_SMALL", visible = false, callFunction = gotoTwitter, selectable = false },
			{name = "resetMightyEagle", text = "Reset Mighty Eagle", updateFunction = resetMightyEagleFeature, activateOnRelease = true, hanchor = "LEFT", vanchor = "TOP" },
			{name = "lockLevels", text = "Lock levels", updateFunction = lockLevels, activateOnRelease = true, hanchor = "RIGHT", vanchor = "TOP" },
			{name = "unlockLevels", text = "Unlock levels", updateFunction = unlockLevels, activateOnRelease = true, hanchor = "RIGHT", vanchor = "TOP" },
			{name = "leaderboards", sprite = "BUTTON_LEADERBOARDS", visible = false, callFunction = showLeaderboards },
			{name = "achievements", sprite = "BUTTON_ACHIEVEMENTS", visible = false, callFunction = showAchievements },--updateFunction = updateMenu, page = achievementsPage},			
		}
	
	if deviceModel == "roku" then
		getItemByName(mainMenu.items, "play").needLoadingScreen = true
	end
	
	if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
		_G.table.insert(mainMenu.items, {name = "crystal", sprite = "BUTTON_CRYSTAL_SMALL", callFunction = startCrystal, hanchor="HCENTER", vanchor="VCENTER", visible = false, selectable = false } )
	end

	if deviceModel == "s60" then
		if isLiteVersion then
			_G.table.insert(mainMenu.items, {name = "oviButton", sprite = "OVI_BUTTON", updateFunction = updateMenu, page = upsellPage } )
		else
			_G.table.insert(mainMenu.items, {name = "oviButton", sprite = "OVI_BUTTON", updateFunction = updateMenu, page = moreGamesPage } )
			_G.table.insert(mainMenu.items, {name = "mightyEagleButton", sprite = "OVI_BUTTON", updateFunction = updateMenu, page = moreGamesPage } )
		end
	end
	if isBetaVersion and deviceModel == "android" then
		local menuAndroid = getItemByName(mainMenu.items, "menuOvi")
		menuAndroid.callFunction = gotoAndroidMarket
		menuAndroid.sprite = "MENU_FULL_VERSION"
		menuAndroid.visible = true
		_G.table.insert(mainMenu.items, {name = "reportBug", sprite = "BUTTON_BUG_SMALL", callFunction = gotoReportBug})
	end
	
	if showEditor then
		_G.table.insert(mainMenu.items, {name = "editor", text = "MI_EDIT", updateFunction = updateMenu, page = levelSelectionEdit[1] } )
	end
	
	
	
	if deviceModel == "roku" then
		_G.table.insert( mainMenu.items, {name = "buttonSliderBGOptions", sprite = "BUTTON_EMPTY", visible = true, 
	callFunction = 	changeOptionSliderStatus, state = "closed", elements = {{name = "sfx", sprite = "BUTTON_SOUNDS_SMALL"},
																			{ name = "credits", sprite = "BUTTON_ABOUT_SMALL"}}, 
					activateOnRelease = true})
	else
		_G.table.insert( mainMenu.items, {name = "buttonSliderBGOptions", sprite = "BUTTON_EMPTY", visible = true, 
	callFunction = 	changeOptionSliderStatus, state = "closed", elements = {{ name = "fullScreen", sprite = "BUTTON_FULLSCREEN"},{name = "sfx", sprite = "BUTTON_SOUNDS_SMALL"},
																			{ name = "credits", sprite = "BUTTON_ABOUT_SMALL"}}, 
					activateOnRelease = true})
	end
	
	_G.table.insert( mainMenu.items, {name = "buttonSliderOptions", sprite = "BUTTON_OPTIONS", 
	visible = true, itemDrawFunction = buttonSliderOptionsDraw, angle = 0, selectable = false })
	
	local t_quitOffsetX = 60
	local t_quitOffsetY = -35
	_G.table.insert( mainMenu.items, {	name = "buttonQuit", sprite = "MENU_QUIT_EN", 
										visible = true, selectable = true, activateOnRelease = true, callFunction = openExitPage}																			
					)
	_G.table.insert( mainMenu.items, {	name = "buttonUpdateAvailable", sprite = "BUTTON_RIO_ONLINE", 
										visible = false, selectable = true, activateOnRelease = true, callFunction = showUpdateNotificationPrompt}																			
					)
					
	_G.table.insert( mainMenu.items, {	name = "buttonActivateFullVersion", sprite = "BUTTON_ACTIVATE_FULL", 
										visible = false, selectable = true, activateOnRelease = true, callFunction = requestActivation}																			
					)
	
	if( deviceModel == "iphone") or ( deviceModel == "iphone4") then
		_G.table.insert( mainMenu.items, {name = "buttonSliderBG", sprite = "BUTTON_EMPTY", visible = true, 
		callFunction = changeSliderStatus, state = "closed", elements = {{name = "crystal", sprite = "BUTTON_CRYSTAL_SMALL"},
		{ name = "twitter", sprite = "BUTTON_TWITTER_SMALL"}, { name = "facebook", sprite = "BUTTON_FACEBOOK_SMALL"}, 
		{ name = "trailer", sprite = "BUTTON_TRAILER_SMALL"}}})
	elseif ( deviceModel == "android") and isBetaVersion then
		_G.table.insert( mainMenu.items, {name = "buttonSliderBG", sprite = "BUTTON_EMPTY", visible = true, 
		callFunction = changeSliderStatus, state = "closed", elements = {{name = "reportBug", sprite = "BUTTON_BUG_SMALL"},
		{ name = "twitter", sprite = "BUTTON_TWITTER_SMALL"}, { name = "facebook", sprite = "BUTTON_FACEBOOK_SMALL"}, 
		{ name = "trailer", sprite = "BUTTON_TRAILER_SMALL"}}})
	else
		_G.table.insert( mainMenu.items, {name = "buttonSliderBG", sprite = "BUTTON_EMPTY", visible = true, 
		callFunction = changeSliderStatus, state = "closed", elements = {{ name = "twitter", sprite = "BUTTON_TWITTER_SMALL"}, { name = "facebook", sprite = "BUTTON_FACEBOOK_SMALL"}, 
		{ name = "trailer", sprite = "BUTTON_TRAILER_SMALL"}}, activateOnRelease = true})
	end
	
	_G.table.insert( mainMenu.items, {name = "buttonSlider", sprite = "BUTTON_SLIDER", 
	visible = true, itemDrawFunction = buttonSliderDraw, angle = 0, selectable = false })
	
	about = {
		name = "about",
		back = mainMenu,
		-- about text overlay 0,0
		sound = "menu_confirm",		
		backgroundBox = { name = "aboutbg", sprites = {  right = "MAIN_SETTINGS_LEFT", center = "MAIN_CENTER" }, sheet = "POPUPS_SHEET_1", hanchor = "LEFT", vanchor = "TOP"},
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		state = "READY",
		font = fontBasic,
		scrollStart = 1,
		scrollEnd = 9,
		items = {
			{name = "birds1", sprite = "ABOUT_BIRDS_1" },
			{name = "textAbout", text = "TEXT_ABOUT_PC", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "birds2", sprite = "ABOUT_PIG_1", selectable = false },
			{name = "textCreditsOrig", text = "TEXT_CREDITS_ORIGINAL", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "birds1_2", sprite = "ABOUT_BIRDS_2" },			
			{name = "textCredits", text = "TEXT_CREDITS_PC", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "birds2_2", sprite = "ABOUT_PIG_2", selectable = false },
			{name = "textCreditsAdditional", text = "TEXT_CREDITS_ADDITIONAL", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "goldenEgg", sprite = "GOLDEN_EGG_5", callFunction = aboutGoldenEggAchieved },
			{name = "arrow", sprite = "ARROW_LEFT", callFunction = hideLeftMenu, visible = false, activateOnRelease = true },
			{name = "hideArea", callFunction = hideLeftMenu, activateOnRelease = true, visible = false } ,
		}
	}
	
	-- if deviceModel == "roku" then
		-- getItemByName(about.items, "textAbout").text = "TEXT_CREDITS_ROKU"
	-- end
	
	--[[local textAbout = getItemByName(about.items, "textAbout")
	if deviceModel == "iphone" or deviceModel == "iphone4" then
		if isLiteVersion then
			textAbout.text = "TEXT_ABOUT_CLICKGAMER_LITE"
		else
			textAbout.text = "TEXT_ABOUT_CLICKGAMER"
		end
	elseif deviceModel == "s60" then
		textAbout.text = "TEXT_ABOUT_S60"
	elseif deviceModel == "palm" then
		if isLiteVersion then
			textAbout.text = "TEXT_ABOUT_PALM_LITE"
		else
			textAbout.text = "TEXT_ABOUT_PALM"
		end
	elseif deviceModel == "android" then
		if isBetaVersion then
			textAbout.text = "TEXT_ABOUT_ANDROID_BETA"
		else
			textAbout.text = "TEXT_ABOUT_ANDROID"
		end
	elseif deviceModel == "ipad" then
		textAbout.text = "TEXT_ABOUT_CHILLINGO"
	end]]
	
	upsellPage.name = "upsellPage"
	upsellPage.popup = true
	upsellPage.back = mainMenu
	upsellPage.state = "READY"
	upsellPage.sound = "menu_confirm"
	upsellPage.bgColor = { red = 0, green = 0, blue = 0 }
	
	if deviceModel == "n900" then
		upsellPage.backgroundSprite = { name = "UPSELL", x = 0, y = 0 }
		upsellPage.items = {
			{sprite = "BUTTON_MENU", x = 60, y = screenHeight - 70, selectable = true, updateFunction = updateMenu, page = levelSelectionPagesBasic },
			{sprite = "UPSELL_BUTTON", x = screenWidth*0.5, y = screenHeight, selectable = true, callFunction = gotoOviStore },
		}
	elseif deviceModel == "s60" then
		upsellPage.backgroundSprite = { name = "UPSELL_BG", x = 0, y = 0 }
		upsellPage.items = {
			{text = "TEXT_UPSELL", x = screenWidth*0.5, y = 9, vanchor = "TOP", hanchor = "HCENTER" },
			{sprite = "BUTTON_MENU", x = 40, y = screenHeight - 40, selectable = true, updateFunction = removePopupMenu },
			{sprite = "UPSELL_BUTTON", x = screenWidth*0.5, y = 266, selectable = true, callFunction = gotoOviStore },
			{text = "TEXT_UPSELL_BUTTON_2", x = screenWidth*0.5, y = screenHeight-3, vanchor = "BOTTOM", hanchor = "HCENTER" },
		}
	elseif deviceModel == "android" then
		upsellPage.backgroundSprite = { name = "UPSELL_BG", x = 0, y = 0 }
		upsellPage.items = {
			{name = "back", sprite = "LS_BACK_BUTTON",  selectable = true, updateFunction = removePopupMenu },
			{name = "button", sprite = "UPSELL_BUTTON", selectable = true, callFunction = gotoAndroidMarket },
		}
	else
		upsellPage.backgroundSprite = { name = "UPSELL_BG", x = 0, y = 0 }
		upsellPage.items = {
		--	{name = "background", sprite = "UPSELL_BG", selectable = false},
			{name = "back", sprite = "LS_BACK_BUTTON",  selectable = true, updateFunction = updateMenu, page = mainMenu },
			{name = "button", sprite = "UPSELL_BUTTON", selectable = true, callFunction = gotoFullVersionInAppStore },
		}
	end

	
	pauseBGw = 0
	pausePage = {
		name = "pause",
		back = "goToGame",
		backgroundBox = { name = "pausebg", sprites = { left = "MAIN_ABOUT_RIGHT", right = "MAIN_SETTINGS_LEFT", center = "MAIN_CENTER" }, sheet = "POPUPS_SHEET_1", hanchor = "LEFT", vanchor = "TOP"},
		backgroundDrawFunction = drawGame,
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		state = "READY",
		sound = "menu_confirm",
		font = fontMenu,
		items = {
			{name = "buttonSfx", sprite = "BUTTON_SFX", selectable = true, callFunction = changeAudio, activateOnRelease = true } ,
			{name = "buttonOff", sprite = "BUTTON_OFF_SMALL", selectable = false, activateOnRelease = true } ,
			--{name = "buttonMenu", sprite = "BUTTON_MENU", selectable = true, updateFunction = updateMenu, page = nil, activateOnRelease = true } ,
			{name = "buttonMenu", sprite = "BUTTON_MENU", visible = true, selectable = true, updateFunction = updateMenu, callFunction = goToLevelSelectionFromPause, page = nil, activateOnRelease = true, shortcutKeys = { "KEY_BACK" }, loadAssetList = {"LEVELSELECTION"}, releaseAssetList = { "INGAME"}} ,
			{name = "buttonMainMenu", sprite = "MENU_MENU_EN", selectable = true, updateFunction = updateMenu, page = mainMenu, callFunction = goToMainMenuFromPause, activateOnRelease = true },
			{name = "buttonRestart", sprite = "BUTTON_RESTART", visible = true, selectable = true, updateFunction = updateGame, restartLevel = true, activateOnRelease = true, shortcutKeys = { "F5" }, } ,
			{name = "buttonResume", sprite = "BUTTON_RESUME", visible = true, selectable = true, updateFunction = hidePauseMenu, activateOnRelease = true, shortcutKeys = { "PAUSE" }, } ,
			{name = "hideArea", updateFunction = hidePauseMenu, activateOnRelease = true },
			{name = "levelText", text = "", selectable = false } ,
			{name = "buttonTutorials", sprite = "MENU_TUTORIALS", selectable = true, updateFunction = showTutorials, activateOnRelease = true } ,
			{name = "buttonEagle", sprite = "INGAME_BUTTON_EAGLE", selectable = true, updateFunction = launchEagleBaitFromPauseMenu,  } ,
		}
	}
	
	if deviceModel == "roku" then
		getItemByName(pausePage.items, "buttonRestart").sprite = "ROKU_GESTURE_RESTART"
		getItemByName(pausePage.items, "buttonMenu").sprite = "ROKU_BUTTON_MENU"
		getItemByName(pausePage.items, "buttonMainMenu").visible = false
	end
	
	g_gesturePausePage = {
		name = "gesturePausePage",
		back = "goToGame",		
		backgroundDrawFunction = drawGame,
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		state = "READY",
		sound = "menu_confirm",
		font = fontMenu,
		targetDragTotal = 20,
		currentButtonSelected = nil,		
		currentDragX = 0,
		currentDragY = 0,
		items = {			
			{name = "buttonMenu", sprite = "GESTURE_LEVELS", spriteSelected="GESTURE_LEVELS_SELECTED", spriteNormal="GESTURE_LEVELS", selectable = true, updateFunction = updateMenu, callFunction = goToLevelSelectionFromPause, page = nil, activateOnRelease = true } ,
			{name = "buttonMainMenu", sprite = "GESTURE_MENU", spriteSelected="GESTURE_MENU_SELECTED", spriteNormal="GESTURE_MENU", selectable = true, updateFunction = updateMenu, page = mainMenu, activateOnRelease = true },
			{name = "buttonRestart", sprite = "GESTURE_RESTART", spriteSelected="GESTURE_RESTART_SELECTED", spriteNormal="GESTURE_RESTART",  selectable = true, updateFunction = updateGame, restartLevel = true, activateOnRelease = true } ,
			{name = "buttonResume", sprite = "GESTURE_PLAY", spriteSelected="GESTURE_PLAY_SELECTED", spriteNormal="GESTURE_PLAY", updateFunction = hideGesturePauseMenu, activateOnRelease = true, activateOnRelease = true } ,						
		}
		
		
	}
	
	if deviceModel == "roku" then
		getItemByName(g_gesturePausePage.items, "buttonRestart").sprite = "ROKU_GESTURE_RESTART"
		getItemByName(g_gesturePausePage.items, "buttonRestart").spriteSelected = "ROKU_GESTURE_RESTART_SELECTED"
		getItemByName(g_gesturePausePage.items, "buttonRestart").spriteNormal = "ROKU_GESTURE_RESTART"
	end
	
	--this page will not been drawn nor updated using the drawmenu../updatemenu methods, we update
	--and draw those items in updateGame and drawGame methods
	g_ingamePausePage = {
		items = {
			{name = "ingameButtonPause", sheet = "BUTTONS_SHEET_1", sprite = "MENU_BUTTON", shortcutKeys = { "KEY_BACK", "PAUSE" } } ,
			{name = "ingameButtonRestart", sheet = "BUTTONS_SHEET_1", sprite = "BUTTON_INGAME_RESTART", shortcutKeys = { "F5" } } 
			
		}
	}
	
	if deviceModel == "roku" then
		getItemByName(g_ingamePausePage.items, "ingameButtonPause").sheet = ""
		getItemByName(g_ingamePausePage.items, "ingameButtonPause").sprite = "ROKU_MENU_BUTTON"
		getItemByName(g_ingamePausePage.items, "ingameButtonRestart").sheet = ""
		getItemByName(g_ingamePausePage.items, "ingameButtonRestart").sprite = "ROKU_BUTTON_INGAME_RESTART"
	end
	
	if deviceModel == "n900" or deviceModel == "s60" then
		_G.table.insert(pausePage.items, {name = "taskSwitcher", sprite = "BUTTON_TASK_SWITCHER", callFunction = goToTaskSwitcherLua } )
	end
	
	if deviceModel == "s60" and isLiteVersion then
		_G.table.insert(pausePage.items, {name = "buttonOvi", sprite = "OVI_BUTTON", updateFunction = updateMenu, page = upsellPage } )	
	end	
	
	tutorials = {
		name = "tutorials",
		back = nil,
		backgroundBox = { name = "tutorialBg", sprites = {left = "TUTORIAL_LEFT", bottomLeft = "TUTORIAL_BOTTOM_LEFT", 
						  bottomMiddle = "TUTORIAL_BOTTOM_MIDDLE", bottomRight = "TUTORIAL_BOTTOM_RIGHT", right = "TUTORIAL_RIGHT", 
						  topRight = "TUTORIAL_TOP_RIGHT", topMiddle = "TUTORIAL_TOP_MIDDLE", topLeft = "TUTORIAL_TOP_LEFT", 
						  center = "TUTORIAL_CENTER" }, hanchor = "HCENTER", vanchor = "VCENTER"},
		items = { 
				{ name = "TUTORIAL_1", sprite = "TUTORIAL_RED", selectable = false }, --red
				{ name = "TUTORIAL_2", sprite = "TUTORIAL_BLUE", selectable = false }, --blue
				{ name = "TUTORIAL_3", sprite = "TUTORIAL_YELLOW", selectable = false }, --yellow
				{ name = "TUTORIAL_4", sprite = "TUTORIAL_BLACK", selectable = false }, --black
				{ name = "TUTORIAL_5", sprite = "TUTORIAL_WHITE", selectable = false }, --white
				{ name = "TUTORIAL_6", sprite = "TUTORIAL_BOOMERANG", selectable = false }, --boomerang
				{ name = "TUTORIAL_7", sprite = "TUTORIAL_BIG_BROTHER", selectable = false }, --bigbrother
				{ name = "TUTORIAL_8", sprite = "TUTORIAL_MIGHTYEAGLE", selectable = false }, --mightyeagle
				}
		}

	if deviceModel ~= "roku" then
		_G.table.insert(tutorials.items, { name = "TUTORIAL_9", sprite = "TUTORIAL_TRACKPAD_1", selectable = false, trackpadTutorial=true} ) --trackpad
		_G.table.insert(tutorials.items, { name = "TUTORIAL_10", sprite = "TUTORIAL_TRACKPAD_2", selectable = false, trackpadTutorial=true } ) -- trackpad
		_G.table.insert(tutorials.items, { name = "TUTORIAL_11", sprite = "TUTORIAL_TRACKPAD_3", selectable = false, trackpadTutorial=true } ) -- trackpad
		_G.table.insert(tutorials.items, { name = "okButton", sprite = "TUTORIAL_OK" , selectable = true, activateOnRelease = true } )
	else
		getItemByName(tutorials.items, "TUTORIAL_1").sprite = "ROKU_TUTORIAL_RED"
		getItemByName(tutorials.items, "TUTORIAL_2").sprite = "ROKU_TUTORIAL_BLUE"
		getItemByName(tutorials.items, "TUTORIAL_3").sprite = "ROKU_TUTORIAL_YELLOW"
		getItemByName(tutorials.items, "TUTORIAL_4").sprite = "ROKU_TUTORIAL_BLACK"
		getItemByName(tutorials.items, "TUTORIAL_5").sprite = "ROKU_TUTORIAL_WHITE"
		getItemByName(tutorials.items, "TUTORIAL_6").sprite = "ROKU_TUTORIAL_BOOMERANG"
		getItemByName(tutorials.items, "TUTORIAL_7").sprite = "ROKU_TUTORIAL_BIG_BROTHER"
		getItemByName(tutorials.items, "TUTORIAL_8").sprite = "ROKU_TUTORIAL_MIGHTYEAGLE"
		_G.table.insert(tutorials.items, { name = "TUTORIAL_9", sprite = "ROKU_TUTORIAL_ZOOM", selectable = false, trackpadTutorial=true } ) 
		_G.table.insert(tutorials.items, { name = "TUTORIAL_10", sprite = "ROKU_TUTORIAL_CAMERA", selectable = false, trackpadTutorial=true } )
		_G.table.insert(tutorials.items, { name = "okButton", sprite = "ROKU_TUTORIAL_OK" , visible = true, selectable = true, activateOnRelease = true, shortcutKeys = { "LBUTTON" } } )
	end
	

	if deviceModel == "roku" or deviceModel == "s60" or deviceModel == "n900" or deviceModel == "android" or deviceModel == "windows" or deviceModel == "osx" then
		areYouSurePage = {
			name = "areYouSure",
			state = "READY",
			back = nil,
			popup = true,
			backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
			backgroundBox = { name = "backgroundAreYouSure", 
							  sprites = {topLeft = "POPUP_TOP_LEFT", left = "POPUP_LEFT", 
										 bottomLeft = "POPUP_BOTTOM_LEFT", bottomMiddle = "POPUP_BOTTOM_MIDDLE", 
										 bottomRight = "POPUP_BOTTOM_RIGHT", right = "POPUP_RIGHT", topRight = "POPUP_TOP_RIGHT", 
										 topMiddle = "POPUP_TOP_MIDDLE", center = "POPUP_CENTER"}, 
							  sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
			items = {
				{name = "areYouSureText", text = "Are you sure you want to quit?", font = fontBasic, hanchor = "HCENTER", vanchor = "BASELINE"},
				{name = "buttonNo", sprite = "MENU_NO", selectable = true, callFunction = closeBetaDisclaimerPage, activateOnRelease = true},				
				{name = "buttonYes", sprite = "MENU_YES", selectable = true, callFunction = requestExit, activateOnRelease = true},
			}
		
		}
	end
	
	if deviceModel == "windows" and g_updateCheckFlags.enabled == true then
		g_updateNotificationScreen = {
			name = "updateNotificationPage",
			state = "READY",
			back = nil,
			popup = true,
			backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
			backgroundBox = { name = "backgroundAreYouSure", 
							  sprites = {topLeft = "POPUP_TOP_LEFT", left = "POPUP_LEFT", 
										 bottomLeft = "POPUP_BOTTOM_LEFT", bottomMiddle = "POPUP_BOTTOM_MIDDLE", 
										 bottomRight = "POPUP_BOTTOM_RIGHT", right = "POPUP_RIGHT", topRight = "POPUP_TOP_RIGHT", 
										 topMiddle = "POPUP_TOP_MIDDLE", center = "POPUP_CENTER"}, 
							  sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
			items = {
				{name = "updateText", text = "A new version of Angry Birds is available.\nDo you want to download it now?", font = fontBasic, hanchor = "HCENTER", vanchor = "BASELINE"},
				{name = "buttonNo", sprite = "MENU_NO", selectable = true, callFunction = updateNotificationCancel, activateOnRelease = true},				
				{name = "buttonYes", sprite = "MENU_YES", selectable = true, callFunction = updateNotificationConfirm, activateOnRelease = true},
			}
		
		}
	end
	
	invalidResolutionPage= {
		name = "invalidResolutionPage",
		state = "READY",
		back = nil,
		popup = true,
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundAreYouSure", 
						  sprites = {topLeft = "POPUP_TOP_LEFT", left = "POPUP_LEFT", 
									 bottomLeft = "POPUP_BOTTOM_LEFT", bottomMiddle = "POPUP_BOTTOM_MIDDLE", 
									 bottomRight = "POPUP_BOTTOM_RIGHT", right = "POPUP_RIGHT", topRight = "POPUP_TOP_RIGHT", 
									 topMiddle = "POPUP_TOP_MIDDLE", center = "POPUP_CENTER"}, 
						  sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{name = "areYouSureText",  font = fontBasic, hanchor = "HCENTER", vanchor = "BASELINE"},						
			{name = "buttonYes", sprite = "MENU_YES", selectable = true, callFunction = closeResolutionWarningPage, activateOnRelease = true},
		}
	
	}
	
	loadingPage = {
		name = "loading",	
		back = nil,
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true, shade = 0 },
		--backgroundDrawFunction = drawMenu,
		state = "READY",
		sound = "menu_confirm",
		nextPage = nil,		
		items = {
			{name = "loadingText", text = "MI_LOADING", selectable = false, hanchor="HCENTER", vanchor="VCENTER" } ,
		}
	}
	
	if deviceModel == "roku" then
		loadingPage.backgroundOverlay.shade = 1
	end
	
	-- this is not used
	clearSaveConfirm = {
		name = "clearSaveConfirm",
		popup = true,
		back = nil,
		title = { text = "" },
		state = "READY",
		sound = "menu_confirm",
		itemBackgroundSprite = "BUTTON_BG",
		itemBackgroundSpriteSelected = "BUTTON_BG_HOVER",
		items = {
			{text = "MI_VIBRA", x = screenWidth*0.5, y = screenHeight*0.5 - 90, selectable = false },
			{text = "MI_VIBRA", x = screenWidth*0.5, y = screenHeight*0.5 - 15, selectable = false },
			{text = "SK_YES", updateFunction = clearSaveFunction, x = screenWidth*0.5 - 50, y = screenHeight*0.5 + 70, selectable = true } , 
			{text = "SK_NO", updateFunction = removePopupMenu, x = screenWidth*0.5 + 50, y = screenHeight*0.5 + 70, selectable = true } , 
		}
	}	
	
	settingsPage = {
		name = "settingsPage",
		back = nil,
		--title = { text = "MT_SETTINGS",	x = screenWidth - 108, y = 36 },
		sound = "menu_confirm",		
		backgroundSprite = { name = "SETTINGS_BG", x = screenWidth, y = 0 },
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		state = "READY",
		items = {
			-- {sprite = "BUTTON_SFX", x = screenWidth - 64, y = 178, selectable = true, callFunction = changeAudio } ,
			-- {sprite = "BUTTON_OFF", x = screenWidth - 64, y = 178, selectable = false } ,
			-- {sprite = "BUTTON_MUSIC", x = screenWidth - 160, y = 178, selectable = true, updateFunction = changeMusic } ,
			-- {sprite = "BUTTON_OFF", x = screenWidth - 160, y = 178, selectable = false } ,
			-- {sprite = "FLAG_TEMPLATE", x = screenWidth - 111 , y = 245, selectable = true, updateFunction = changeLanguage, visible = false } ,
			-- {sprite = "SETTINGS_LANGUAGE_BORDERS", x = screenWidth - 111 , y = 245, selectable = false, visible = false } ,
			-- {sprite = "ARROW_RIGHT", x = screenWidth - settingsBGw + 22, y = screenHeight - 30, updateFunction = hideRightMenu } ,
			-- {x = 0, y = 0, w = screenWidth - settingsBGw, h = screenHeight, updateFunction = hideLeftMenu, activateOnRelease = true } ,
			--old data
			--{text = "MI_AUDIO", x = 130, y = 120, selectable = false } ,
			--{text = "MI_VIBRA", x = 130, y = 220, selectable = false } ,
			--{sprite = "BUTTON_BIG", x = 335, y = 120, selectable = true, updateFunction = updateMenu, page = clearSaveConfirm } ,
			--{text = "ITEM_ERASE_DATA", x = 335, y = 120, selectable = false } ,
			--{sprite = "BUTTON_SQUARE", x = 335, y = 235, selectable = true, updateFunction = changeLanguage } ,
			--{text = "TITLE_CHOOSE_LANGUAGE", x = 335, y = 210, selectable = false } ,
			--{sprite = "SETTINGS_LANGUAGE_BORDERS", x = 335, y = 250, selectable = false } ,
		}
	}
		
	gameStart.name = "gameStart"
	gameStart.back = nil
	gameStart.sound = "menu_confirm"
	gameStart.state = "READY"
	gameStart.animationState = "SCROLL"
	gameStart.timer = 0
	gameStart.bgColor = { red = 0, green = 0, blue = 0 }
	gameStart.isCutScene = true
	gameStart.items = { 
						{name = "cutSceneBg", sprite = "CUTSCENE_BG", updateFunction = gotoFirstLevel, dontOffset = true},
						{name = "storyBegin1", sprite = "STORY_BEGIN_BG_1", updateFunction = gotoFirstLevel, isBackground = true },					
						{name = "storyBeginGroup", sprite = "STORY_BEGIN_PIG_GROUP_1", selectable = false },
						{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
						{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
						{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
						{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
						}
	
	theme1Complete = {
		name = "theme1Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_1", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}

	theme2Complete = {
		name = "theme2Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_2", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}
	

	gameComplete = {
		name = "gameComplete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyEnd1", sprite = "STORY_END_1_1", selectable = false, isBackground = true },
			{name = "storyEnd2", sprite = "STORY_END_1_2", selectable = false, isBackground = true },
			{name = "storyEndEyeNormal", sprite = "STORY_END_KING_EYE_NORMAL",selectable = false, visible = false },
			{name = "storyEndEyePeek", sprite = "STORY_END_KING_EYE_PEEK", selectable = false, visible = false },
			{name = "storyEndEyeWink", sprite = "STORY_END_KING_EYE_WINK", selectable = false, visible = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}	

	theme4Start.name = "theme4Start"
	theme4Start.back = nil
	theme4Start.sound = "menu_confirm"
	theme4Start.state = "READY"
	theme4Start.animationState = "SCROLL"
	theme4Start.timer = 0
	theme4Start.bgColor = { red = 0, green = 0, blue = 0 }
	theme4Start.isCutScene = true
	theme4Start.items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG",  updateFunction = gotoFirstLevelLP2, dontOffset = true},
			{name = "storyBg", sprite = "STORY_BEGIN_BG_1", updateFunction = gotoFirstLevelLP2, isBackground = true },
			{name = "storyBegin1", sprite = "STORY_BEGIN_BG_2", updateFunction = gotoFirstLevelLP2, isBackground = true },
			{name = "storyFakeEggs", sprite = "STORY_BEGIN_FAKE_EGGS", selectable = false },
			{name = "storyGroup", sprite = "STORY_BEGIN_PIG_GROUP_2", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	
	theme4Complete = {
		name = "theme4Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_4", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}
	
	theme5Complete = {
		name = "theme5Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_4", selectable = false, visible = false },
			{name = "storyTongue", sprite = "STORY_END_2_TONGUE", selectable = false, visible = false },
			{name = "storyEggs", sprite = "STORY_END_2_EGGS", selectable = false, visible = false },
			{name = "storyKing", sprite = "STORY_END_2_HIDING_KING", selectable = false, visible = false },
			{name = "storyEyeOpen", sprite = "STORY_END_2_EYE_OPEN", selectable = false, visible = false },
			{name = "storyEyePeek", sprite = "STORY_END_2_EYE_PEEK", selectable = false, visible = false },
			{name = "storyEyeWink", sprite = "STORY_END_2_EYE_WINK", selectable = false, visible = false },
			{name = "storySmile", sprite = "STORY_END_2_SMILE", selectable = false, visible = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}	
	
	theme6Start.name = "theme6Start"
	theme6Start.back = nil
	theme6Start.sound = "menu_confirm"
	theme6Start.state = "READY"
	theme6Start.animationState = "SCROLL"
	theme6Start.timer = 0
	theme6Start.offsetY = 0
	theme6Start.bgColor = { red = 61, green = 163, blue = 204 }
	theme6Start.isCutScene = true
	theme6Start.items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", updateFunction = gotoFirstLevelLP3, dontOffset = true},
			{name = "blueRect", sprite = "", selectable = false, rectangle = true, color = { red = 59 / 255, green = 161 / 255, blue = 203 / 255 }, dontOffset = true},
			{name = "storyBg", sprite = "STORY_BEGIN_BG_1", updateFunction = gotoFirstLevelLP3 },
			{name = "storyHideHoof", sprite = "STORY_HIDE_HOOF_1", selectable = false },
			{name = "storyFade", sprite = "STORY_BEGIN_FADE", selectable = false },
			{name = "storyFade2", sprite = "STORY_BEGIN_FADE_2", selectable = false },
			{name = "storyCloud4", sprite = "STORY_CLOUD_4", selectable = false },
			{name = "storyCloud3", sprite = "STORY_CLOUD_3", selectable = false },
			{name = "storyCloud2", sprite = "STORY_CLOUD_2", selectable = false },
			{name = "storyCloud1", sprite = "STORY_CLOUD_1", selectable = false },
			{name = "storyYellow", sprite = "STORY_ANGRY_YELLOW_BIRD", selectable = false },
			{name = "storyPigs3", sprite = "STORY_FLYING_PIGS_3", selectable = false },
			{name = "storyPigs2", sprite = "STORY_FLYING_PIGS_2", selectable = false },
			{name = "storyPigs1", sprite = "STORY_FLYING_PIGS_1", selectable = false },
			{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_3", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}

	
	theme6Complete = {
		name = "theme6Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyHoof", sprite = "STORY_HIDE_HOOF_2", selectable = false },
			{name = "storyBalloon", sprite = "STORY_BOSS_FLATTENED_BALLOON",  selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_1", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING_2",  selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}	
	
	theme7Complete = {
		name = "theme7Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyHoof", sprite = "STORY_HIDE_HOOF_2", selectable = false },
			{name = "storyBalloon", sprite = "STORY_BOSS_FLATTENED_BALLOON_2", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_2", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING_3", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}	
	
	theme8Complete = {
		name = "theme8Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyHoof", sprite = "STORY_HIDE_HOOF_2", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING_4", selectable = false },
			{name = "storyCarpet", sprite = "STORY_BOSS_CARPET", selectable = false },
			{name = "storyEye", sprite = "STORY_BOSS_KING_ESCAPING_4_EYE_2", selectable = false, visible = false },
			{name = "storyWink", sprite = "STORY_BOSS_KING_ESCAPING_4_EYE_WINK", selectable = false, visible = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}

	theme9Start.name = "theme9Start"
	theme9Start.back = nil
	theme9Start.sound = "menu_confirm"
	theme9Start.state = "READY"
	theme9Start.animationState = "SCROLL"
	theme9Start.timer = 0
	theme9Start.bgColor = { red = 0, green = 0, blue = 0 }
	theme9Start.isCutScene = true
	theme9Start.items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", updateFunction = gotoFirstLevelLP4, dontOffset = true},
			{name = "storyBg1", sprite = "STORY_BEGIN_BG_1", updateFunction = gotoFirstLevelLP4, isBackground = true  },
			{name = "storyBg2", sprite = "STORY_BEGIN_BG_2", updateFunction = gotoFirstLevelLP4, isBackground = true  },
			{name = "storyHideBirds1", sprite = "STORY_HIDE_BIRDS_1", selectable = false },
			{name = "storyHideBirds2", sprite = "STORY_HIDE_BIRDS_2", selectable = false },
			{name = "storyHideBirds3", sprite = "STORY_HIDE_BIRDS_3", selectable = false },
			{name = "storyYard", sprite = "STORY_CONSTRUCTION_YARD", selectable = false },
			{name = "bg_extension", sprite = "STORY_BEGIN_BG_EXTENSION", selectable = false },
			{name = "storyBigBrother", sprite = "STORY_EP4_START_BIG_BROTHER", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}	
		
	theme9Complete = {
		name = "theme9Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_1", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_4", selectable = false },
			{name = "storyBigBrother", sprite = "STORY_BIG_BROTHER_2", selectable = false },
			{name = "storyHelmet", sprite = "STORY_BOSS_1_HELMET", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}	
	
	theme10Complete = {
		name = "theme10Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_2", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_4", selectable = false },
			{name = "storyBigBrother", sprite = "STORY_BIG_BROTHER_2", selectable = false },
			{name = "storyHelmet", sprite = "STORY_BOSS_2_HELMET", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}
	
	theme11Complete = {
		name = "theme11Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_4", selectable = false },
			{name = "storyEnd", sprite = "STORY_EP4_END", selectable = false },
			{name = "storyBigBrother", sprite = "STORY_BIG_BROTHER_2", selectable = false },
			{name = "storyHelmet", sprite = "STORY_BIG_BROTHER_HELMET", selectable = false },
			{name = "storyKingPeak", sprite = "STORY_EP4_KING_PEAK", selectable = false, visible = false },
			{name = "storyKingWink", sprite = "STORY_EP4_KING_WINK", selectable = false, visible = true },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}
	
	theme12Start.name = "theme12Start"
	theme12Start.back = nil
	theme12Start.sound = "menu_confirm"
	theme12Start.state = "READY"
	theme12Start.animationState = "SCROLL"
	theme12Start.timer = 0
	theme12Start.bgColor = { red = 0, green = 0, blue = 0 }
	theme12Start.isCutScene = true
	theme12Start.items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", updateFunction = gotoFirstLevelLP5, dontOffset = true},
			{name = "storyBg1", sprite = "STORY_WESTERN_BEGIN", updateFunction = gotoFirstLevelLP5, isBackground = true, isCompoSprite=true, dontOffset = false },
			--{name = "storyBg1", sprite = "STORY_BEGIN_BG_1", updateFunction = gotoFirstLevelLP5, isBackground = true, isCompoSprite=false },
			--{name = "storyBg2", sprite = "STORY_BEGIN_BG_2", updateFunction = gotoFirstLevelLP5, isBackground = true  },
			--{name = "storyHideBirds1", sprite = "STORY_HIDE_BIRDS_1", selectable = false },
			--{name = "storyHideBirds2", sprite = "STORY_HIDE_BIRDS_2", selectable = false },
			--{name = "storyHideBirds3", sprite = "STORY_HIDE_BIRDS_3", selectable = false },
			--{name = "storyYard", sprite = "STORY_CONSTRUCTION_YARD", selectable = false },
			--{name = "storyBg2", sprite = "STORY_WESTERN_BEGIN", updateFunction = gotoFirstLevelLP5, isBackground = false, isCompoSprite=true },
			{name = "bg_extension", sprite = "STORY_BEGIN_BG_EXTENSION", selectable = false },
			--{name = "storyBigBrother", sprite = "STORY_EP4_START_BIG_BROTHER", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}	
		
	theme12Complete = {
		name = "theme12Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			--{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBg", sprite = "STORY_WESTERN_MIDDLE_1", isCompoSprite=true, selectable=false},
			--{name = "storyBoss", sprite = "STORY_BOSS_THEME_2", selectable = false },
			--{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			--{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_4", selectable = false },
			--{name = "storyBigBrother", sprite = "STORY_BIG_BROTHER_2", selectable = false },
			--{name = "storyHelmet", sprite = "STORY_BOSS_2_HELMET", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}
	
	theme13Complete = {
		name = "theme13Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_WESTERN_MIDDLE_2", isCompoSprite=true, selectable=false},
			--{name = "storyBoss", sprite = "STORY_BOSS_THEME_2", selectable = false },
			--{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			--{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_4", selectable = false },
			--{name = "storyBigBrother", sprite = "STORY_BIG_BROTHER_2", selectable = false },
			--{name = "storyHelmet", sprite = "STORY_BOSS_2_HELMET", selectable = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}
	
	theme14Complete = {
		name = "theme14Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_WESTERN_MIDDLE_2", isCompoSprite=true, selectable=false},
			--{name = "storyBoss", sprite = "STORY_BOSS_THEME_2", selectable = false },
			--{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			--{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_4", selectable = false },
			--{name = "storyBigBrother", sprite = "STORY_BIG_BROTHER_2", selectable = false },
			--{name = "storyHelmet", sprite = "STORY_BOSS_2_HELMET", selectable = false },
			{name = "storyWesternEndFinal", sprite = "STORY_WESTERN_END", isCompoSprite = true, selectable = false},
			{name = "kingEyeOpen", sprite = "STORY_WEST_KING_EYE_OPEN", visible = false },
			{name = "kingEyePeak", sprite = "STORY_WEST_KING_EYE_PEAK", visible = false },
			{name = "kingEyeBlink", sprite = "STORY_WEST_KING_EYE_WINK", visible = false },
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}
	
	theme15Complete = {
		name = "theme15Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_CAVE_MIDDLE_1", isCompoSprite = true, selectable = false},
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}

	
	
	theme15Start.name = "theme15Start"
	theme15Start.back = nil
	theme15Start.sound = "menu_confirm"
	theme15Start.state = "READY"
	theme15Start.animationState = "SCROLL"
	theme15Start.timer = 0
	theme15Start.bgColor = { red = 0, green = 0, blue = 0 }
	theme15Start.isCutScene = true
	theme15Start.items = {
		{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
		{name = "storyBg", sprite = "STORY_CAVE_BEGIN", isCompoSprite = true, selectable = false},
		{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
		{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
		{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
		{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
	}
	
	-- ADDED
	theme16Complete = {
		name = "theme16Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_CAVE_MIDDLE_2", isCompoSprite = true, selectable = false},
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}

	-- ADDED
	theme17Complete = {
		name = "theme17Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		isCutScene = true,
		items = {
			{name = "cutSceneBg", sprite = "CUTSCENE_BG", dontOffset = true},
			{name = "storyBg", sprite = "STORY_CAVE_END", isCompoSprite = true, selectable = false},
			{name = "cutSceneFilmLeft", sprite = "CUTSCENE_FILMSTRIP_LEFT", dontOffset = true},
			{name = "cutSceneFilmRight", sprite = "CUTSCENE_FILMSTRIP_RIGHT", dontOffset = true},
			{name = "cutSceneFilmTop", sprite = "CUTSCENE_FILMSTRIP_TOP", dontOffset = true},
			{name = "cutSceneFilmBottom", sprite = "CUTSCENE_FILMSTRIP_BOTTOM", dontOffset = true},
		}
	}
	
	
	--fine tunning
	--the popup boxes borders have "fake" widths, the sprite has some alpha overlay in it
	--so we couldnt use the sprites width to calculate the box real size, I come up with this value
	--by checking the sprite on ggs
	g_popupBorderRealWidth = 24
	g_popupButtonRealWidth = 92	
	g_popupHighScoreLabelYOffset = -5
	g_popupHighScoreYOffset = 5
	--this will be addded to the height of the top orange part of the level pop ups
	g_levelPopUpsTopBackgroundHeightOffset = 10
	g_popupBoxHeightOffset = -20
	g_popupLevelClearedLabelOffsetY = 5
	g_popupLevelClearedScoreLabelOffsetY = 5
	g_popupLevelClearedScoreOffsetY = 5
	
	g_levelPopUpsFailTopBackgroundHeightOffset = 12
	g_popupFailHighScoreLabelYOffset = -7
	g_popupFailHighScoreYOffset = 5
	
	
	
	
	levelComplete = {
		name = "levelComplete",
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundBox = { name = "backgroundTop", sprites = completeBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "BOTTOM"},
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		font = fontBasic,
		items = {
			{name = "background", box = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
			{name = "levelNumber", text = "LEVEL_NUMBER_PLACEHOLDER", selectable = false, font = "FONT_BIG_NUMBERS", hanchor="LEFT", vanchor="VCENTER" },
			{name = "newHighScore", sprite = "NEW_HIGHSCORE_BG", selectable = false, hanchor="HCENTER", vanchor="VCENTER" } ,
			{name = "levelComplete", text = "MT_LEVEL_COMPLETE", font = fontBasic, selectable = false, hanchor="LEFT", vanchor="TOP" },
			{name = "score", text = "MI_SCORE", selectable = false, hanchor="LEFT", vanchor="VCENTER" } ,
			{name = "scoreNumber", text = "MI_SCORE_AMOUNT_PLACEHOLDER", selectable = false, hanchor="LEFT", vanchor="VCENTER" } ,
			{name = "highScoreText", text = "MI_HIGH_SCORE", selectable = false, hanchor="HCENTER", vanchor="BOTTOM" },
			{name = "highScoreNumber", text = "MI_HIGH_SCORE_PLACEHOLDER", selectable = false, hanchor="RIGHT", vanchor="BOTTOM" } ,
			{name = "starEffect", sprite = "EAGLE_METER_EFFECT", selectable = false, itemDrawFunction = starEffectItemDraw},
			{name = "buttonMenu", sprite = "BUTTON_MENU", updateFunction = updateMenu, page = levelSelectionPagesBasic[1], visible = true, shortcutKeys = { "KEY_BACK" }, activateOnRelease = true, loadAssetList = {"LEVELSELECTION"}, releaseAssetList = { "INGAME"}  },
			{name = "buttonRestart", sprite = "BUTTON_RESTART", updateFunction = updateGame, restartLevel = true, activateOnRelease = true, shortcutKeys = { "F5" } },
			{name = "buttonNextLevel", sprite = "BUTTON_NEXTLEVEL", callFunction = loadNextLevel, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene1", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme1Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene2", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme2Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene3", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = gameComplete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "stars", sprite = "", selectable = false },
			{name = "starsCurrent", sprite = "", selectable = false },
			{name = "buttonCutscene4", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme4Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene5", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme5Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene6", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme6Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene7", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme7Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene8", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme8Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene9", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme9Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene10", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme10Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene11", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme11Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene12", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme12Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene13", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme13Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene14", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme14Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene15", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme15Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene16", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme16Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene17", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme17Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "eagleFeatherEmpty", sprite = "EAGLE_METER_EMPTY", selectable = false } ,
			{name = "eagleFeatherFull", sprite = "EAGLE_METER_FULL", selectable = false } ,
			{name = "totalDestruction", text = "MT_TOTAL_DESTRUCTION", selectable = false, hanchor="HCENTER", vanchor="TOP" } ,
			{name = "eagleScoreNumber", text = "50%", selectable = false, hanchor="RIGHT", vanchor="TOP" } ,
			{name = "eagleFeatherFill", sprite = "EAGLE_METER_FILL", selectable = false, itemDrawFunction = eagleFeatherFillDraw } ,
			{name = "buttonRio", sprite = "BUTTON_RIO_ONLINE", callFunction = gotoAngryBirdsRioTrailer, activateOnRelease = true },
			
		}
	}
	
	if deviceModel == "roku" then
		getItemByName(levelComplete.items, "buttonMenu").sprite = "ROKU_BUTTON_MENU"
		getItemByName(levelComplete.items, "buttonRestart").sprite = "ROKU_GESTURE_RESTART"
		
		-- NOTE: this isn't actually changed to match the cutscene buttons since they are all in the same place,
		--       so we can just place the cursor at the same place at all times
		levelComplete.defaultItem = getItemByName(levelComplete.items, "buttonNextLevel")
	end
	
	levelFailed = {
		name = "levelFailed",
		back = nil,
		state = "READY",
		sound = "menu_confirm",
		backgroundBox = { name = "backgroundTop", sprites = completeBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "BOTTOM"},
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		font = fontBasic,
		items = {
			{name = "background", box = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
			{name = "levelNumber", text = "LEVEL_NUMBER_PLACEHOLDER", selectable = false, font = "FONT_BIG_NUMBERS", hanchor="LEFT", vanchor="VCENTER" },
			{name = "levelFailed", text = "MT_LEVEL_FAILED", font = fontBasic, selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "highScoreText", text = "MI_HIGH_SCORE", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "highScoreNumber", text = "MI_HIGH_SCORE_PLACEHOLDER", selectable = false, hanchor="RIGHT", vanchor="VCENTER" } ,
			{name = "buttonMenu", sprite = "BUTTON_MENU", updateFunction = updateMenu, page = levelSelectionPagesBasic[1], visible = true, shortcutKeys = { "KEY_BACK" }, activateOnRelease = true, loadAssetList = {"LEVELSELECTION", "GOLDEN_EGGS"}, releaseAssetList = { "INGAME", "THEMES"} },
			{name = "buttonRestart", sprite = "BUTTON_RESTART", visible = true, updateFunction = updateGame, restartLevel = true, activateOnRelease = true, shortcutKeys = { "F5" } },
			{name = "stars", sprite = "RESULT_STARS_0", selectable = false },
			{name = "buttonEagle", sprite = "BUTTON_EAGLE", updateFunction = launchEagleBait, activateOnRelease = true },
			{name = "buttonEagleLost", sprite = "BUTTON_EAGLE_LOST", selectable = false },
			{name = "buttonNextLevel", sprite = "BUTTON_NEXTLEVEL", callFunction = loadNextLevel, visible = false, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene1", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme1Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene2", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme2Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene3", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = gameComplete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene4", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme4Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene5", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme5Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene6", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme6Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene7", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme7Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene8", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme8Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene9", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme9Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene10", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme10Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene11", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme11Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene12", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme12Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene13", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme13Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene14", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme14Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene15", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme15Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene16", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme16Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonCutscene17", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme17Complete, needLoadingScreen = true, activateOnRelease = true, shortcutKeys = { "PAGEUP" } },
			{name = "buttonEagleBuy", sprite = "BUTTON_EAGLE_BUY", updateFunction = updateMenu, page = mightyEagleDemoPage },
		}
	}
	
	
	if deviceModel == "roku" then
		getItemByName(levelFailed.items, "buttonMenu").sprite = "ROKU_BUTTON_MENU"
		getItemByName(levelFailed.items, "buttonRestart").sprite = "ROKU_GESTURE_RESTART"
		
		levelFailed.defaultItem = getItemByName(levelFailed.items, "buttonRestart")
	end
	
	if ( deviceModel ~= "s60") then
		local buttonEagleBuy = getItemByName(levelFailed.items, "buttonEagleBuy")
		buttonEagleBuy.visible = false
	end
	
	gameFinished = {
		name = "gameFinished",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, visible = true, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_1"},
			{text = "TEXT_COMPLETE", selectable = false, textBoxSize = 270, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_1", selectable = false, hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	if deviceModel == "roku" then
		getItemByName(gameFinished.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinished.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end
	
	
	gameFinishedLP2 = {
		name = "gameFinishedLP2",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, visible = true, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_2" },
			{text = "TEXT_COMPLETE", selectable = false,  hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_2", selectable = false,  hanchor="LEFT", vanchor="BASELINE" },
		}
	}

	if deviceModel == "roku" then
		getItemByName(gameFinishedLP2.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinishedLP2.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end	
	
	gameFinishedLP3 = {
		name = "gameFinishedLP3",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0,  itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete,  visible = true, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_3"},
			{text = "TEXT_COMPLETE", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_3", selectable = false,  hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	if deviceModel == "roku" then
		getItemByName(gameFinishedLP3.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinishedLP3.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end	
	
	gameFinishedLP4 = {
		name = "gameFinishedLP4",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, visible = true, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_4", },
			{text = "TEXT_COMPLETE", selectable = false,  hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_4", selectable = false,  hanchor="LEFT", vanchor="BASELINE" },
		}
	}

	if deviceModel == "roku" then
		getItemByName(gameFinishedLP4.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinishedLP4.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end	
	
	gameFinishedLP5 = {
		name = "gameFinishedLP5",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, visible = true, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_5", },
			{text = "TEXT_COMPLETE", selectable = false,  hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_5", selectable = false,  hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	if deviceModel == "roku" then
		getItemByName(gameFinishedLP5.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinishedLP5.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end	
	
	gameFinishedThreeStars = {
		name = "gameFinishedThreeStars",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", visible = true, updateFunction = updateMenu, page = levelComplete, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_1_STAR"},
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_1", selectable = false, hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	if deviceModel == "roku" then
		getItemByName(gameFinishedThreeStars.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinishedThreeStars.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end	
	
	gameFinishedThreeStarsLP2 = {
		name = "gameFinishedThreeStarsLP2",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		font = fontBasic,
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", visible = true, updateFunction = updateMenu, page = levelComplete, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_2_STAR", },
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_2", selectable = false, hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	if deviceModel == "roku" then
		getItemByName(gameFinishedThreeStarsLP2.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinishedThreeStarsLP2.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end	
	
	gameFinishedThreeStarsLP3 = {
		name = "gameFinishedThreeStarsLP3",
		back = nil,
		state = "READY",
		sound = "menu_confirm",
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", visible = true, updateFunction = updateMenu, page = levelComplete, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_3_STAR", },
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_3", selectable = false, hanchor="LEFT", vanchor="BASELINE"},
		}
	}	
	
	if deviceModel == "roku" then
		getItemByName(gameFinishedThreeStarsLP3.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinishedThreeStarsLP3.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end	
	
	gameFinishedThreeStarsLP4 = {
		name = "gameFinishedThreeStarsLP4",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0,itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", visible = true, updateFunction = updateMenu, page = levelComplete, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_4_STAR"},
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_4", selectable = false,hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	if deviceModel == "roku" then
		getItemByName(gameFinishedThreeStarsLP4.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinishedThreeStarsLP4.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end	
	
	gameFinishedThreeStarsLP5 = {
		name = "gameFinishedThreeStarsLP5",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0,itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", visible = true, updateFunction = updateMenu, page = levelComplete, selectable = true, activateOnRelease = true  },
			{sprite = "REWARD_5_STAR"},
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_5", selectable = false,hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	if deviceModel == "roku" then
		getItemByName(gameFinishedThreeStarsLP5.items, "buttonYes").sprite = "ROKU_MENU_YES"
		getItemByName(gameFinishedThreeStarsLP5.items, "buttonYes").shortcutKeys = { "LBUTTON" }
	end	
	
	tutorialGoldenEggPosition = { }
	
	

	prepareMenuPage(mainMenu)
	prepareMenuPage(about)
	prepareMenuPage(settingsPage)
	prepareMenuPage(loadingPage)
	prepareMenuPage(g_ingamePausePage)
	prepareMenuPage(pausePage)
	prepareMenuPage(g_gesturePausePage)
end

function updateMenu(dt, time)

	--this can only be valid once throughout the whole game flow, if the user has started the 
	--game in a invalid resolution
	if deviceModel ~= "roku" and g_invalidResolutionTriggeredOnStart == true then
		popupPage = invalidResolutionPage
		prepareMenuPage(popupPage)
		g_invalidResolutionTriggeredOnStart = false
	end

	selectedMenuItem = -1
	if oldScreenWidth ~= screenWidth or oldScreenHeight ~= screenHeight then
		oldScreenWidth = screenWidth
		oldScreenHeight = screenHeight
		--createMenuPages()
		--initializeMenu()

		if currentMenuPage == about or currentMenuPage == mainMenu then
			prepareMenuPage(mainMenu)
			hideLeftMenu(dt)
			prepareMenuPage(about)
		else
			prepareMenuPage(currentMenuPage)
			prepareMenuPage(tutorials)
		end
		
		prepareMenuPage(g_ingamePausePage)
		
		local t_minimumScreenWidth = 1024
		--local t_minimumScreenHeight = 768
		--local t_minimumScreenHeight = 720
		local t_minimumScreenHeight = 600
		
		if deviceModel ~= "roku" and (screenWidth < t_minimumScreenWidth or screenHeight < t_minimumScreenHeight) then
			
			if invalidResolutionPage.fromMainMenu == false then				
				popupPage = invalidResolutionPage	
			else				
				invalidResolutionPage.fromMainMenu = true
				popupPage = invalidResolutionPage				
			end
				
			prepareMenuPage(popupPage)			
			
		else
			closeResolutionWarningPage()
		end
		
	end
	
	-- if audioRampVolume then
		-- audioRampVolume = audioRampVolume + (dt / audioRampLength)
		
		-- if audioRampVolume <= 0 then
			-- _G.res.stopAudioOutput()
			-- audioRampVolume = nil
		-- else
			--Use squared volume because it gives more linear response
			-- setMusicVolume( audioRampVolume * audioRampVolume )
			-- setEffectsVolume( audioRampVolume * audioRampVolume )
		-- end
	-- end
	if currentMenuPage == mainMenu or currentMenuPage == about then
		menuSunsetAngle = menuSunsetAngle + 0.125 * dt
		if menuSunsetAngle > _G.math.pi then
			menuSunsetAngle = menuSunsetAngle - 2 * _G.math.pi
		end
		animateBirds(dt)
	end
		
	goldenEggsStarEffectAngle = goldenEggsStarEffectAngle + 0.6 * dt
	if goldenEggsStarEffectAngle > _G.math.pi then
		goldenEggsStarEffectAngle = goldenEggsStarEffectAngle - 2 * _G.math.pi
	end
	
	if currentMenuPage.bgColor ~= nil then
		setBGColor( currentMenuPage.bgColor.red, currentMenuPage.bgColor.green, currentMenuPage.bgColor.blue)
	end
	
	
	
	-- handle dragging
	if menuDrag ~= nil then
		menuDrag = nil
	end
	if keyPressed["LBUTTON"] then
		if currentMenuPage == levelSelectionPagesBasic or currentMenuPage == levelSelectionPagesExtra 
		  or currentMenuPage == levelSelectionPagesPack3 or currentMenuPage == levelSelectionPagesPack4
		  or currentMenuPage == levelSelectionPagesPack5 or currentMenuPage == levelSelectionPagesPack6 then
			--if 	cursor.x > g_levelSelectionClippingArea.x - 20 and cursor.x < g_levelSelectionClippingArea.y - 20 + g_levelSelectionClippingArea.width + 40
			--	and cursor.y > g_levelSelectionClippingArea.y - 20 and cursor.y < g_levelSelectionClippingArea.y - 20 + g_levelSelectionClippingArea.height + 40 then
			if 	cursor.x > g_levelSelectionClippingArea.x - g_levelSelectionClippingArea.offsetX and 
				cursor.x < g_levelSelectionClippingArea.x - g_levelSelectionClippingArea.offsetX + g_levelSelectionClippingArea.width + (g_levelSelectionClippingArea.offsetX *2) and 
				cursor.y > g_levelSelectionClippingArea.y - g_levelSelectionClippingArea.offsetY and 
				cursor.y < g_levelSelectionClippingArea.y - g_levelSelectionClippingArea.offsetY + g_levelSelectionClippingArea.height + (g_levelSelectionClippingArea.offsetY * 2) then
				
				menuDragStart = { x = cursor.x, y = cursor.y, time = time, page = currentMenuPage}
			end
		else
			menuDragStart = { x = cursor.x, y = cursor.y, time = time, page = currentMenuPage}
		end
	elseif menuDragStart ~= nil and keyReleased["LBUTTON"] then
		if menuDragStart.page == currentMenuPage then
			dist = distance(menuDragStart.x, menuDragStart.y, cursor.x, cursor.y)
			menuDrag = { startX = menuDragStart.x, startY = menuDragStart.y, endX = cursor.x, endY = cursor.y, speed = dist / (time - menuDragStart.time) }
		end
		
		menuDragStart = nil
	end
	
	if g_mouseOrTouchStates.isUsingMouse == false then
		
		if	currentMenuPage == levelSelectionPagesBasic or currentMenuPage == levelSelectionPagesExtra 
			or currentMenuPage == levelSelectionPagesPack3 or currentMenuPage == levelSelectionPagesPack4
			or currentMenuPage == levelSelectionPagesPack5 or currentMenuPage == levelSelectionPagesPack6 then
			
			if 	multitouchSweep.isSweepping == true and cursor.x > g_levelSelectionClippingArea.x - g_levelSelectionClippingArea.offsetX and 
				cursor.x < g_levelSelectionClippingArea.x - g_levelSelectionClippingArea.offsetX + g_levelSelectionClippingArea.width + (g_levelSelectionClippingArea.offsetX *2) and 
				cursor.y > g_levelSelectionClippingArea.y - g_levelSelectionClippingArea.offsetY and 
				cursor.y < g_levelSelectionClippingArea.y - g_levelSelectionClippingArea.offsetY + g_levelSelectionClippingArea.height + (g_levelSelectionClippingArea.offsetY * 2) then
				
				if currentMenuPage.usingTouchScroll == nil or currentMenuPage.usingTouchScroll == false then
					menuDragStart = { x = multitouchSweep.sweepCurrentX, y = multitouchSweep.sweepCurrentY, time = time, page = currentMenuPage}					
					levelSelectionPagesDragStartOffset = currentMenuPage.currentOffset	
				end
				currentMenuPage.usingTouchScroll = true
				
				g_mouseDragStartedFromNavigation = false
				
				
				
			elseif multitouchSweep.isSweepping ~= true and currentMenuPage.usingTouchScroll == true then
				currentMenuPage.usingTouchScroll = false
				
				if menuDragStart ~= nil then
					
					if menuDragStart.page == currentMenuPage then
						dist = distance(menuDragStart.x, menuDragStart.y, cursor.x, cursor.y)
						menuDrag = { startX = menuDragStart.x, startY = menuDragStart.y, endX = cursor.x, endY = cursor.y, speed = dist / (time - menuDragStart.time) }
					end
					
					menuDragStart = nil
					
				end
			end
			
		end
	end
	
	
	
	
	if ((currentMenuPage == mainMenu and mainMenu.back == nil and popupPage == nil) or
		(currentMenuPage == mainMenu and popupPage == areYouSurePage))
		and (keyPressed["ESCAPE"] or keyPressed["KEY_BACK"]) then
		--requestExit()
		closeBetaDisclaimerPage()
		return
	end
	
	if currentMenuPage == mainMenu and popupPage == areYouSurePage and keyPressed["RETURN"] then
		requestExit()
	end
	
	
	if (currentMenuPage == mainMenu) then
		
		lockTimer = lockTimer and lockTimer - dt or 0
		if deviceModel == "roku" and
			keyHold["KEY_GAMING_A"] and keyHold["KEY_GAMING_B"] and lockTimer < 0 then
			lockTimer = 1.0
			lockLevels()
		end
		
		-- Right Slider
		local buttonSliderBG = getItemByName(mainMenu.items, "buttonSliderBG")
		local buttonSlider = getItemByName(mainMenu.items, "buttonSlider")
		local speed = 600
		
		if buttonSliderBG.state == "closed" then
			for i = 1, #buttonSliderBG.elements do
				getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).visible = false
			end
		end
		
		if buttonSliderBG.state == "opening" then
			local sliderBGRight = getItemByName(mainMenu.items, "sliderBGRight")
			
			if buttonSlider.angle < 3.14 then
				buttonSlider.angle = buttonSlider.angle + 20 * dt
			else
				buttonSlider.angle = 3.14
			end

			if sliderBGRight.height < sliderBGRight.maxHeight then
				for i = 1, #buttonSliderBG.elements do
					
					if getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y > buttonSliderBG.elements[i].yPos then
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y - speed*dt
					else
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = buttonSliderBG.elements[i].yPos
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).visible = true
					end
				end
				sliderBGRight.height = sliderBGRight.height + speed*dt
				if sliderBGRight.height >= sliderBGRight.maxHeight then
					sliderBGRight.height = sliderBGRight.maxHeight
					for i = 1, #buttonSliderBG.elements do
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).selectable = true
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = buttonSliderBG.elements[i].yPos
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).visible = true
						
					end
					buttonSliderBG.state = "open"
				end
			end
		elseif buttonSliderBG.state == "closing" then
			local sliderBGRight = getItemByName(mainMenu.items, "sliderBGRight")
			
			if buttonSlider.angle > 0 then
				buttonSlider.angle = buttonSlider.angle - 20 * dt
			else
				buttonSlider.angle = 0
			end
			
			if sliderBGRight.height > 0 then
				for i = 1, #buttonSliderBG.elements do
					getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).selectable = false
					if getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y < (buttonSliderBG.y - speed*dt) then
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y + speed*dt
					else
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = buttonSliderBG.y
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).visible = false
					end
				end
				sliderBGRight.height = sliderBGRight.height - speed*dt
			else
				sliderBGRight.height = 0
				sliderBGRight.visible = false
				buttonSliderBG.state = "closed"
			end
		
		end
		
		-- Left Slider
		local buttonSliderBGOptions = getItemByName(mainMenu.items, "buttonSliderBGOptions")
		local buttonSliderOptions = getItemByName(mainMenu.items, "buttonSliderOptions")
		local speed = 600
		local buttonOff = getItemByName(mainMenu.items, "buttonOff")
		
		if buttonSliderBGOptions.state == "closed" then
			for i = 1, #buttonSliderBGOptions.elements do
				getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).visible = false
			end
		end
		
		local t_gearRotationSpeed = 10
		
		if buttonSliderBGOptions.state == "opening" then
			local sliderBGLeft = getItemByName(mainMenu.items, "sliderBGLeft")
			
			if buttonSliderOptions.angle < 3.14 then
				--buttonSliderOptions.angle = buttonSliderOptions.angle + 20 * dt
				buttonSliderOptions.angle = buttonSliderOptions.angle + t_gearRotationSpeed * dt
			else
				buttonSliderOptions.angle = 3.14
			end
			
			if sliderBGLeft.height < sliderBGLeft.maxHeight then
				for i = 1, #buttonSliderBGOptions.elements do
					
					if getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y > buttonSliderBGOptions.elements[i].yPos then
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y - speed*dt
						if buttonSliderBGOptions.elements[i].name == "sfx" then
							buttonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
						end
					else
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = buttonSliderBGOptions.elements[i].yPos
						if buttonSliderBGOptions.elements[i].name == "sfx" then
							buttonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
						end
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).visible = true
					end
				end
				
				sliderBGLeft.height = sliderBGLeft.height + speed*dt
				
				if sliderBGLeft.height >= sliderBGLeft.maxHeight then
					sliderBGLeft.height = sliderBGLeft.maxHeight
					for i = 1, #buttonSliderBGOptions.elements do
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).selectable = true
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = buttonSliderBGOptions.elements[i].yPos
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).visible = true
						
					end
					buttonSliderBGOptions.state = "open"
				end
			end
		elseif buttonSliderBGOptions.state == "closing" then
			local sliderBGLeft = getItemByName(mainMenu.items, "sliderBGLeft")
			
			if buttonSliderOptions.angle > 0 then
				--buttonSliderOptions.angle = buttonSliderOptions.angle - 20 * dt
				buttonSliderOptions.angle = buttonSliderOptions.angle - t_gearRotationSpeed * dt
			else
				buttonSliderOptions.angle = 0
			end
			
			if sliderBGLeft.height > 0 then
				for i = 1, #buttonSliderBGOptions.elements do
					getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).selectable = false
					if getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y < (buttonSliderBGOptions.y - speed*dt)  then
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y + speed*dt
						if buttonSliderBGOptions.elements[i].name == "sfx" then
							buttonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
						end
					else
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = buttonSliderBGOptions.y
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).visible = false
						if buttonSliderBGOptions.elements[i].name == "sfx" then
							buttonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
							--buttonOff.visible = false
						end
					end
				end
				sliderBGLeft.height = sliderBGLeft.height - speed*dt
			else
				sliderBGLeft.height = 0
				sliderBGLeft.visible = false
				buttonSliderBGOptions.state = "closed"
			end
		
		end
	end
	
	if popupPage == nil then
		updateMenuPage(currentMenuPage, dt)
	elseif popupPage == achievementPopUpPage then
		updateMenuPage(currentMenuPage, dt)
		local page = achievementPopUpPage
		if page.animationState == "MOVEUP" then
			page.animationTimer = page.animationTimer - dt
			local bgBox = getItemByName(page.items, "achievementBox")
			bgBox.y = bgBox.y - 190 * dt
			if page.animationTimer < 0 then
				page.animationState = "HOLD"
				page.animationTimer = 2
			end
		elseif page.animationState == "HOLD" then
			page.animationTimer = page.animationTimer - dt
			if page.animationTimer < 0 then
				page.animationState = "MOVEDOWN"
				page.animationTimer = 0.3
			end
		elseif page.animationState == "MOVEDOWN" then
			page.animationTimer = page.animationTimer - dt
			local bgBox = getItemByName(page.items, "achievementBox")
			bgBox.y = bgBox.y + 190 * dt
			if page.animationTimer < 0 then
				popupPage = nil
			end
		end
	else
		updateMenuPage(popupPage, dt)
	end
	
	if gameCenterEnabled and gameCenter and gameCenter.getScoresTimer then
		gameCenter.getScoresTimer = gameCenter.getScoresTimer - dt
		if gameCenter.getScoresTimer < 0 and gameCenter.leaderboards then
			for k, v in _G.pairs(gameCenter.leaderboards) do
				getLeaderboardScoresForRange(k, 1, 1)
			end
			gameCenter.getScoresTimer = 15
		end
	end

	if (deviceModel == "n900" or deviceModel == "s60") and currentMenuPage.animationState == nil and currentMenuPage ~= upsellPage then
		updateMenuPage(overlayMenuPage, dt)
	end
	
	
	local sw, _  = _G.res.getSpriteBounds("", getItemByName(mainMenu.items, "credits").sprite)
	local sideBorderOffset = sw / 4

	updateAnimations(dt)
	about.offsetX = elementAnimations["aboutPageScroll"].percentage / 100 * (about.backgroundBox.width - sideBorderOffset) - about.backgroundBox.width - sideBorderOffset
	about.backgroundOverlay.shade = elementAnimations["aboutPageScroll"].percentage / 100 * 0.6
	-- do not fade background if tutorials are going to be shown next
	if birdTutorialPopups == nil or #birdTutorialPopups == 0 then
		pausePage.backgroundOverlay.shade = elementAnimations["ingamePausePageScroll"].percentage / 100 * 0.65
		g_gesturePausePage.backgroundOverlay.shade = elementAnimations["ingameGesturePausePageScroll"].percentage / 100 * 0.65
	else
		pausePage.backgroundOverlay.shade = 0
		g_gesturePausePage.backgroundOverlay.shade = 0
	end
	pausePage.offsetX = elementAnimations["ingamePausePageScroll"].percentage / 100 * pauseBGw - pauseBGw
	
	
	
	drawMenu()
end

-- uses page offset values to offset current coordinates
function offsetCoordinates(page, x, y)
	if page.offsetX ~= nil then
		x = x + page.offsetX
	end
	if page.offsetY ~= nil then
		y = y + page.offsetY
	end

	return x, y
end

function updateItemMouseOverState(item, dt)
	--mouse over states for items
	
	--print("\n updating item")
	if item.mouseStateReferenceItem ~= nil then
		if item.mouseStateReferenceItem.visible == false then
			return
		end
	end
	
	if item.ignoreCursorInput == true then
		updateItemMouseOverStateIgnoringMouseInput(item, dt)
		return
	end

	if item.mouseState ~= nil then
		local itemHovered = hitTest(item.mouseStateAreaPivotX, item.mouseStateAreaPivotY, item.mouseStateAreaWidth, item.mouseStateAreaHeight, item.mouseStateReferenceItem.x, item.mouseStateReferenceItem.y, cursor.x, cursor.y)
		local itemPressed = keyHold["LBUTTON"]
		
		-- simulate button hovers with shortcut keys
		if item.shortcutKeys and item.visible and deviceModel == "roku" then
			for _, shortcutKey in _G.pairs(item.shortcutKeys) do
				itemHovered = itemHovered or keyHold[shortcutKey]
				--itemPressed = itemPressed or keyHold[shortcutKey]
			end
		end
		
		if item.mouseState == "up" then
			if itemHovered then
				if itemPressed then
					item.mouseState = "down"
					item.mouseStateTime = item.mouseStateTargetTime
				else
					item.mouseState = "overIn"
					item.mouseStateTime = 0
				end
			end
		elseif item.mouseState == "down" then
			if itemPressed then
				if not itemHovered then
					item.mouseState = "overOut"
					item.mouseStateTime = 0
				end
			else
				if itemHovered then
					item.mouseState = "over"
					item.mouseStateTime = 0
				else
					item.mouseState = "overOut"
					item.mouseStateTime = 0
				end
			end
		elseif item.mouseState == "over" then
			if itemHovered then
				if itemPressed then
					item.mouseState = "down"
					item.mouseStateTime = item.mouseStateTargetTime
				end
			else
				item.mouseState = "overOut"
				item.mouseStateTime = 0
			end
		elseif item.mouseState == "overIn" then
			if itemHovered then
				if itemPressed then
					item.mouseState = "down"
					item.mouseStateTime = item.mouseStateTargetTime
				else
					if item.mouseStateTime >= item.mouseStateTargetTime then
						item.mouseState = "over"
					end
				end
			else
				item.mouseState = "overOut"
				item.mouseStateTime = item.mouseStateTargetTime - item.mouseStateTime
			end
			
			item.mouseStateTime = item.mouseStateTime + dt
			item.mouseStateTime = _G.math.min(item.mouseStateTime, item.mouseStateTargetTime)
		elseif item.mouseState == "overOut" then
			if itemHovered then
				if itemPressed then
					item.mouseState = "down"
					item.mouseStateTime = item.mouseStateTargetTime
				else
					item.mouseState = "overIn"
					item.mouseStateTime = item.mouseStateTargetTime - item.mouseStateTime
				end
			else
				if item.mouseStateTime >= item.mouseStateTargetTime then
					item.mouseState = "up"
				end
			end
			
			item.mouseStateTime = item.mouseStateTime + dt
			item.mouseStateTime = _G.math.min(item.mouseStateTime, item.mouseStateTargetTime)
		end
	end
end

--the three methods below are only used when you want to simulate a mouse input even if there isn't any, so you can call simulateMouseOverState from anywhere (i.e, gesture pause menu)

function updateItemMouseOverStateIgnoringMouseInput(item, dt)

	if item.mouseState ~= nil then
		
		if item.mouseState == "overIn" then
			
			if item.mouseStateTime >= item.mouseStateTargetTime then
				item.mouseState = "over"
			end						
			
			item.mouseStateTime = item.mouseStateTime + dt									
			
			item.mouseStateTime = _G.math.min(item.mouseStateTime, item.mouseStateTargetTime)
			
		elseif item.mouseState == "overOut" then
			
			if item.mouseStateTime >= item.mouseStateTargetTime then
				item.mouseState = "up"
			end			
			
			item.mouseStateTime = item.mouseStateTime + dt	
			item.mouseStateTime = _G.math.min(item.mouseStateTime, item.mouseStateTargetTime)
		end
	end						
	
end 

function simulateMouseOverState(item, isMouseOver)
	if isMouseOver then
		if item.mouseState ~= nil then
			
			if item.mouseState == "up" or item.mouseState == "overOut"  then			
				setItemMouseOverState(item, "overIn")			
			end
			
		else
			setItemMouseOverState(item, "overIn")
		end
	else
		if item.mouseState ~= nil then
			
			if item.mouseState == "down" or item.mouseState == "over" or item.mouseState == "overIn" then
				setItemMouseOverState(item, "overOut")	
			end			
			
		else
			setItemMouseOverState(item, "overOut")	
		end
	end
end

function setItemMouseOverState(item, newState)
	if newState == item.mouseState then 
		return
	end
	
	if item.mouseState ~= nil then			
		if 	(item.mouseState == "overIn" and newState == "overOut") or
			(item.mouseState == "overOut" and newState == "overIn") then
			
			item.mouseStateTime = item.mouseStateTargetTime - item.mouseStateTime
		else
			item.mouseStateTime = 0	
		end						
	else		
		item.mouseStateTime = 0	
	end
	
	item.mouseState = newState			
	
end


function loadDynamicAssets(item)
	if item.releaseAssetList then
		releaseImages(item.releaseAssetList)
	end

	if item.loadAssetList then
		loadImages(item.loadAssetList)
		if item.name and item.name == "buttonMenu" and inExtraWorld == true then
			loadImages({"GOLDEN_EGGS"})
		end
	end
end


function checkShortcutKeys(page, itemIndex)

	local t_item = page.items[itemIndex]
	if deviceModel ~= "roku" or not t_item or not t_item.shortcutKeys or not t_item.visible then
		return
	end

	-- simulate button presses with shortcuts
	for _, shortcutKey in _G.pairs(t_item.shortcutKeys) do
		if (t_item.activateOnRelease and keyReleased[shortcutKey]) or
			(not t_item.activateOnRelease and keyPressed[shortcutKey]) then
			simulatePageItemPress(page, itemIndex)
			return shortcutKey
		end
	end
end


function simulatePageItemPress(page, itemIndex)

	local selectedItem = page.items[itemIndex]
	if selectedItem == nil then
		return
	end
	
	if selectedItem.updateFunction ~= nil and selectedItem.disableUpdateFunctionChange ~= true then
		setGameMode(selectedItem.updateFunction)
		if currentGameMode == updateMenu then
			if selectedItem.page.popup == true then
				setActivePopupPage(selectedItem.page)
			else
				if selectedItem.needLoadingScreen == true then
					setGameMode(updateLoadingEx)
					loadingPage.nextPage = selectedItem.page
				else
					setActiveMenuPage(selectedItem.page)
					popupPage = nil
				end
			end
		end
		if currentGameMode == addPopupMenu then
			setGameMode(updateMenu)
			setActivePopupPage(selectedItem.page)
		end
		if currentGameMode == removePopupMenu then
			setGameMode(updateMenu)
			popupPage = nil
		end
		handleGameModeChange(page, itemIndex)
	end
	
	-- Item selection sound
	local sound = page.sound
	if selectedItem.sound ~= nil then
		sound = selectedItem.sound
	end
	if sound ~= nil then
		_G.res.playAudio(sound, 1, false)
	end

	if deviceModel == "roku" then
		if selectedItem.releaseAssetList or selectedItem.loadAssetList then
			g_DynamicAssetLoading = selectedItem
		end
	end

	if selectedItem.callFunction ~= nil then
		selectedItem.callFunction(selectedItem.callParam1)
	end
end


function updateMenuPage(page, dt)
	
	if page == nil then
		return
	end
	updateGameMenuPage(page, dt)
	
	-- if page is not ready for input
	if page.state ~= "READY" then
		return
	end
	
	local t_i = 1
	for t_i = 1, #page.items, 1 do
		local t_item = page.items[t_i]
		if t_item.mouseState ~= nil then
			updateItemMouseOverState(t_item, dt)
			if checkShortcutKeys(page, t_i) == "KEY_BACK" then return end
		end
	end
	
	-- Handle menu items
	-- update items and select one that is under the cursor
	if keyPressed["LBUTTON"] or keyReleased["LBUTTON"] then
		local i = #page.items
		local distanceToSelected = 10000
		while i >= 1 do
			local ci = page.items[i]
			-- is menu item visible
			if ci.visible ~= false and ci.selectable ~= false then
				if ci.activateOnRelease ~= true and keyPressed["LBUTTON"] or ci.activateOnRelease == true and keyReleased["LBUTTON"] then
					local selectionCandidate = nil
					local x = ci.x and ci.x or 0
					local y = ci.y and ci.y or 0
					if ci.dontOffset ~= true then
						x, y = offsetCoordinates(page, x, y)
					end
					-- menu item is text
					if ci.text ~= nil then
						x = screenWidth/2
						y = screenHeight/(#page.items + 1) * i
						x = ci.x and ci.x or x
						y = ci.y and ci.y or y
						x, y = offsetCoordinates(page, x, y)

						if ci.font ~= nil then
							--use item default
							setFont(ci.font)
						elseif page.font ~= nil then
							--use page override
							setFont(page.font)
						else
							--use menu default
							setFont(defaultMenuFont)
						end

						if checkTextBounds("TEXTS_BASIC", ci.text, ci.hanchor, ci.vanchor, x, y, cursor.x, cursor.y) then
							selectionCandidate = i
						end
					end

					-- menu item is image
					if ci.sprite ~= nil then
						if checkSpriteBounds("", ci.sprite, x, y, cursor.x, cursor.y) then
							selectionCandidate = i
						end
					end

					-- menu item is just touch area
					if ci.w ~= nil and ci.h ~= nil then
						if checkBounds(x, y, ci.w, ci.h, cursor.x, cursor.y) then
							selectionCandidate = i
						end
					end
					
					if ci.box ~= nil and ci.width ~= nil and ci.height ~= nil then
						if checkBounds(x, y, ci.width, ci.height, cursor.x, cursor.y, nil, ci.hanchor, ci.vanchor) then
							selectionCandidate = i
						end
					end
					
					if selectionCandidate ~= nil and page.items[selectionCandidate].disableSelection ~= true then
						local dist = distance(x, y, cursor.x, cursor.y)
						if dist < distanceToSelected then
							selectedMenuItem = selectionCandidate
							distanceToSelected = dist
						end
					end
				end
			end
			i = i - 1
		end

		if selectedMenuItem > -1 then
			simulatePageItemPress(page, selectedMenuItem)
			selectedMenuItem = -1
		end
	end
	
	if deviceModel == "n900" and hasLevelPack1() == false and page == episodeSelectionPage 
	 and keyReleased["LBUTTON"] and page.items[1].disableUpdateFunctionChange ~= true then
		local itm = getItemByName(page.items, "pack1buy")
		if checkSpriteBounds(itm.sheet, itm.sprite, page.items[1].x + itm.x, page.items[1].y + itm.y - 10, cursor.x, cursor.y) then
			itm.callFunction(dt)
		end
	end
	
	if (keyPressed["ESCAPE"] or keyReleased["KEY_BACK"]) and page.back ~= nil then

		if currentMenuPage == about and page.back == mainMenu then
			hideLeftMenu(dt)
		elseif page.back == "goToGame" and deviceModel ~= "roku" then
			setGameMode(hidePauseMenu)
		elseif page.back.popup then
			setActivePopupPage(page.back)
		else
			setActiveMenuPage(page.back)
			if deviceModel == "roku" and page.items then
				local itm = getItemByName(page.items, "back")
				if itm and (itm.releaseAssetList or itm.loadAssetList) then
					g_DynamicAssetLoading = itm
				end
			end
		end
		if page.popup then
			popupPage = nil
		end
	end
	
	if page == pausePage then
		if keyPressed["P"] then
			setGameMode(hidePauseMenu)
		end
		
		--we store the touchcount in the pausepage table because we need to compare the previous touch count.
		--In order to switch back to the game, the player must perform a 3 fingers tap, which is only allowed if
		--the player has released all fingers at least once. This will probably change when the pause menu changes
		--to support multitouch gestures
		if pausePage.previousTouchCount == nil then
			pausePage.previousTouchCount = touchcount			
		end
		
		if pausePage.has3FingerBeenReleased == true then
			if touchcount < 3 and pausePage.previousTouchCount == 3 and isInFullScreenMode() then
				hidePauseMenu()
			end
		else
			pausePage.has3FingerBeenReleased = touchcount == 0			
		end
		
		pausePage.previousTouchCount = touchcount
		
	end
	
	if page == g_gesturePausePage then
		
		if touches[g_gesturePausePage.touchOneID] == nil then
			
			if  elementAnimations["ingameGesturePausePageScroll"].state ~= "EXITING" then				
			
				
				if g_gesturePausePage.currentButtonSelected == nil then
					setGameMode(hideGesturePauseMenu)
				else
					if g_gesturePausePage.currentButtonSelected.name == "buttonMainMenu" then
						_G.res.stopAllAudio()
						setGameMode(updateMenu)
						handleGameModeChange(mainMenu,  getIndexInTable(g_gesturePausePage.items, t_item))
						setActiveMenuPage(mainMenu)
					elseif g_gesturePausePage.currentButtonSelected.name == "buttonResume" then
						setGameMode(hideGesturePauseMenu)
					elseif g_gesturePausePage.currentButtonSelected.name == "buttonMenu" then	
						local t_item = getItemByName(g_gesturePausePage.items, "buttonMenu")
						setGameMode(updateMenu)
						setActiveMenuPage(t_item.page)
						handleGameModeChange(g_gesturePausePage,  getIndexInTable(g_gesturePausePage.items, t_item))                
						goToLevelSelectionFromPause( t_item.callParam1 )											
					elseif g_gesturePausePage.currentButtonSelected.name == "buttonRestart" then
						local t_item = getItemByName(g_gesturePausePage.items, "buttonRestart")						
						setGameMode(t_item.updateFunction)						
						handleGameModeChange(g_gesturePausePage, getIndexInTable(g_gesturePausePage.items, t_item) )						
					else
						setGameMode(hideGesturePauseMenu)
					end
				end			
				
				g_gesturePausePage.touchOneID = nil
				g_gesturePausePage.currentButtonSelected = nil
				g_gesturePausePage.currentDragX = 0
				g_gesturePausePage.currentDragY = 0
				
				--captureMouse(false)
			end
			
		else
			
			--g_gesturePausePage.currentDragX = g_gesturePausePage.currentDragX + touches[g_gesturePausePage.touchOneID].x
			--g_gesturePausePage.currentDragY = g_gesturePausePage.currentDragY + touches[g_gesturePausePage.touchOneID].y
			
			--local t_dragDistance = distance(0,0,g_gesturePausePage.currentDragX,g_gesturePausePage.currentDragY)
			local t_dragDistance = distance(g_gesturePausePage.currentDragX,g_gesturePausePage.currentDragY, touches[g_gesturePausePage.touchOneID].x, touches[g_gesturePausePage.touchOneID].y)
			
			if t_dragDistance > g_gesturePausePage.targetDragTotal then
				
				--local t_normalizedVector = normalizeVector(g_gesturePausePage.currentDragX, g_gesturePausePage.currentDragY)
				local t_normalizedVector = normalizeVector(touches[g_gesturePausePage.touchOneID].x - g_gesturePausePage.currentDragX,touches[g_gesturePausePage.touchOneID].y - g_gesturePausePage.currentDragY)
				local t_dot = dotProduct(1,0, t_normalizedVector.x, t_normalizedVector.y)
									
				
				
				local t_abs45DegCos = 0.707
				
				local t_newButtonSelected = nil
				
				if t_dot >= t_abs45DegCos then
					
					t_newButtonSelected = getItemByName(g_gesturePausePage.items, "buttonMenu")
				elseif t_dot < t_abs45DegCos and t_dot >= (-t_abs45DegCos) and (t_normalizedVector.y < 0) then
					
					t_newButtonSelected = getItemByName(g_gesturePausePage.items, "buttonResume")
				elseif t_dot < (-t_abs45DegCos) then
					
					t_newButtonSelected = getItemByName(g_gesturePausePage.items, "buttonMainMenu")										
				--elseif t_dot < t_abs45DegCos and t_dot >= (-t_abs45DegCos) and (g_gesturePausePage.currentDragY < 0) then
				else
					
					t_newButtonSelected = getItemByName(g_gesturePausePage.items, "buttonRestart")
				end						

				if t_newButtonSelected ~= g_gesturePausePage.currentButtonSelected then
					g_gesturePausePage.currentButtonSelected = t_newButtonSelected	

					for k,v in _G.pairs(g_gesturePausePage.items) do
						if v == t_newButtonSelected then
							simulateMouseOverState(v, true)
							v.sprite = v.spriteSelected
						else
							simulateMouseOverState(v, false)
							v.sprite = v.spriteNormal
						end
					end
				end
				
				
				g_gesturePausePage.currentDragX = touches[g_gesturePausePage.touchOneID].x
				g_gesturePausePage.currentDragY = touches[g_gesturePausePage.touchOneID].y
				
			end
			
			
			
		end
		
	end
	
	
	if (keyPressed["KEY_MENU"]) and page.menuButton then
		
		if page.menuButton == about then
			showLeftMenu()
		elseif page.menuButton == mainMenu then
			hideLeftMenu(dt)
		elseif page.menuButton == "goToGame" then
			setGameMode(hidePauseMenu)
		else
			setActiveMenuPage(page.menuButton)
		end
		if page.popup then
			popupPage = nil
		end
	end

end

function getIndexInTable(a_table, a_item)
	local t_index = 0
	for k,v in _G.pairs(a_table) do
		t_index = t_index + 1
		if v == a_item then
			return (t_index)
		end
	end
	
	return 0
end

function normalizeVector(x,y)
	local t_length = distance(0,0, x,y)
	return {x=x/t_length, y = y/t_length}
end

function dotProduct(x1,y1,x2,y2)
	return x1*x2 + y1*y2
end

function setSelectedEpisode(item)
	settings.selectedEpisode = item
end

-- Game specific menu update logic
function updateGameMenuPage(page, dt)
	
	if page.backgroundOverlay ~= nil then
		if page.backgroundOverlay.sprite ~= nil and page.backgroundOverlay.visible ~= false then
			if page.backgroundOverlay.sprite == "DIM_BLOCK" then
				if page.backgroundOverlay.shade == nil then
					page.backgroundOverlay.shade = 0
				end
				page.backgroundOverlay.shade = page.backgroundOverlay.shade + dt * 2.7
				if page.backgroundOverlay.shade > 0.65 then
					page.backgroundOverlay.shade = 0.65
				end
			end
		end
	end
	

	if page == mainMenu then
		if _G.res.isAudioPlaying("title_theme") == false then
			_G.res.playAudio("title_theme", 0.8, true, 7)
		end
	end
	
	if page == pausePage then
		local currentMusic = musics[currentThemeNumber]
		if _G.res.isAudioPlaying(currentMusic) == false then
			_G.res.playAudio(currentMusic, 1, true,7)
		end
	end
	
	if page == episodeSelectionPage then
		
		if dragSpeed == nil then
			dragSpeed = 0
		end
		
		local minDragSpeed = 500 * (screenWidth + 480) / 960
	
		--if doubleClick and cursor.x >= page.goldenEggHitBox.xMin and cursor.x < page.goldenEggHitBox.xMax
		--   and cursor.y >= page.goldenEggHitBox.yMin and cursor.y < page.goldenEggHitBox.yMax then
		--	goldenEggAchieved("Level8")
		--end
		
		
		
		
			
		--[[
		if episodeMenuDragStart == nil then
			for i = 1, page.numEpisodes do
				page.items[i].disableSelection = true
			end
		end
		
		]]--
		
		--print("\n selected episode " .. settings.selectedEpisode)
			
		--will never enter this if, we removed the scrolling from the episode selection alltogether. If we decide to roll back, the code is still here
		if (deviceModel == "windows" or deviceModel == "osx") and false then
			local t_left = getItemByName(episodeSelectionPage.items, "leftNavigation")
			local t_right= getItemByName(episodeSelectionPage.items, "rightNavigation")
			
			local t_clickedOnNavigationButtons = false;
			
			
			if keyPressed["LBUTTON"] then
				if checkSpriteBounds("", t_left.sprite, t_left.x, t_left.y, cursor.x, cursor.y) then
					settings.selectedEpisode = settings.selectedEpisode - 1
					t_clickedOnNavigationButtons = true
					
				elseif checkSpriteBounds("", t_right.sprite, t_right.x, t_right.y, cursor.x, cursor.y) then
					
					--print("\n right")
					settings.selectedEpisode = settings.selectedEpisode + 1
					t_clickedOnNavigationButtons = true
				end
			
			elseif keyPressed["LEFT"] then
				
				settings.selectedEpisode = settings.selectedEpisode - 1
				t_clickedOnNavigationButtons = true
			elseif keyPressed["RIGHT"] then
				
				settings.selectedEpisode = settings.selectedEpisode + 1
				t_clickedOnNavigationButtons = true
			end
			
			
			
			if t_clickedOnNavigationButtons then
				--print("\n current " .. settings.selectedEpisode)
				if settings.selectedEpisode > page.numEpisodes  then
					settings.selectedEpisode = page.numEpisodes
				elseif settings.selectedEpisode < 1  then
					settings.selectedEpisode = 1
				end
				
				-- check if episode is not locked and enable updatefunction
				if (settings.selectedEpisode ~= page.numEpisodes and getItemByName(page.items[settings.selectedEpisode].children, "lock").visible ~= true) or
					settings.selectedEpisode == page.numEpisodes then
					page.items[settings.selectedEpisode].disableUpdateFunctionChange = false
				end
				
				episodeMenuDragStart = nil
				
				dragSpeed = minDragSpeed
				
				
			else
			--not clicked on any navigation buttons, check for dragging
				if keyPressed["LBUTTON"] then
			
					episodeMenuDragStart = { x = cursor.x, y = cursor.y, time = time }
					episodeMenuDragStart.itemsx = {}
					for i = 1, page.numEpisodes do
						_G.table.insert(episodeMenuDragStart.itemsx, page.items[i].x)
						page.items[i].disableSelection = false
					end
						
				elseif keyReleased["LBUTTON"] and episodeMenuDragStart ~= nil then
					
					local dragLength = distance( episodeMenuDragStart.x, episodeMenuDragStart.y, cursor.x, cursor.y )
					dragSpeed = dragLength / (time - episodeMenuDragStart.time)
					local xdrag = _G.math.abs( episodeMenuDragStart.x - cursor.x)
					local left = cursor.x < episodeMenuDragStart.x
						
					for i = 1, page.numEpisodes do
						page.items[i].disableUpdateFunctionChange = true
						if i ~= settings.selectedEpisode then
							--page.items[i].callFunction = setSelectedEpisode
							--page.items[i].callParam1 = i
						else
							page.items[i].callFunction = nil
						end
					end
					
					if dragLength > (0.65 * screenWidth) then
						local dist = screenWidth
						local closest
						for i = 1, page.numEpisodes do
							if _G.math.abs(page.items[i].x - (screenWidth / 2)) < dist then
								closest = i
								dist = _G.math.abs(page.items[i].x - (screenWidth / 2))
							end
						end
						centerItem = closest
					
					elseif dragSpeed > 200 and dragLength > 40 then
						-- change the center item if a fast sweep was made
						if left then
							if settings.selectedEpisode < page.numEpisodes then
								settings.selectedEpisode = settings.selectedEpisode + 1
							elseif dragSpeed > minDragSpeed then
								dragSpeed = minDragSpeed
							end
						else
							if settings.selectedEpisode > 1 then
								settings.selectedEpisode = settings.selectedEpisode - 1
							elseif dragSpeed > minDragSpeed then
								dragSpeed = minDragSpeed
							end
						end
					elseif dragLength <= 40 then
					
						-- check if episode is not locked and enable updatefunction
						if (settings.selectedEpisode ~= page.numEpisodes and getItemByName(page.items[settings.selectedEpisode].children, "lock").visible ~= true) or
							settings.selectedEpisode == page.numEpisodes then
							page.items[settings.selectedEpisode].disableUpdateFunctionChange = false
						end
					
						-- set the center item to the one that's closest to the center
						for i = 1, page.numEpisodes do
							if page.items[i].x > screenWidth * 0.25 and page.items[i].x <= screenWidth * 0.75 then
								--settings.selectedEpisode = i
							end
						end
					end
					
					if dragSpeed < minDragSpeed then
						dragSpeed = minDragSpeed
					end
					
				elseif keyHold["LBUTTON"] and episodeMenuDragStart ~= nil then
					
					local horizontalDrag = cursor.x - episodeMenuDragStart.x
					
					if page.items[1].x > screenWidth / 2 then
						if episodeMenuDragStart.itemsx[1] < screenWidth / 2 then
							horizontalDrag = horizontalDrag - 0.5 * (horizontalDrag - (screenWidth / 2 - episodeMenuDragStart.itemsx[1]))
						else
							horizontalDrag = horizontalDrag * 0.5
						end
					elseif page.items[page.numEpisodes].x < screenWidth / 2 then
						if episodeMenuDragStart.itemsx[page.numEpisodes] > screenWidth / 2 then
							horizontalDrag = horizontalDrag + 0.5 * (horizontalDrag * -1 - (episodeMenuDragStart.itemsx[page.numEpisodes] - screenWidth / 2))
						else
							horizontalDrag = horizontalDrag * 0.5
						end
					end
						
					for i = 1, page.numEpisodes do
						page.items[i].x = episodeMenuDragStart.itemsx[i] + horizontalDrag
					end
						
				else
					--print("\n current2 " .. settings.selectedEpisode)
					if centerItem ~= nil then
						settings.selectedEpisode = centerItem
						centerItem = nil
					end
					
					-- move items to their places
					--print("\n here selected episode " .. settings.selectedEpisode)
					local distToRest = page.items[settings.selectedEpisode].x - screenWidth / 2
					if _G.math.abs(distToRest) < 1 then
						
						for i = 1, page.numEpisodes do
							
							--page.items[i].x = (i - settings.selectedEpisode) * g_episodeSpacing + g_episodeSpacing
							local t_diff = i - settings.selectedEpisode
							--page.items[i].x = (i - settings.selectedEpisode) * g_episodeSpacing + g_episodeSpacing
							page.items[i].x = screenWidth / 2 + (t_diff * g_episodeSpacing)
							
						end
						-- check if episode is not locked and enable updatefunction
						if (settings.selectedEpisode ~= page.numEpisodes and getItemByName(page.items[settings.selectedEpisode].children, "lock").visible ~= true) or
							settings.selectedEpisode == page.numEpisodes then
							page.items[settings.selectedEpisode].disableUpdateFunctionChange = false
						end
						
						for i = 1, page.numEpisodes do
							getItemByName(page.items, "dot" .. i).sprite = "LS_DOT_BLACK"
						end
						getItemByName(page.items, "dot" .. settings.selectedEpisode).sprite = "LS_DOT_WHITE"
						
					else
						
						if _G.math.abs(distToRest) < dragSpeed * dt * 3 then
							dragSpeed = dragSpeed * 0.7
						end
						dragSpeed = _G.math.max(dragSpeed, 10)
						add = _G.math.min(dragSpeed * dt, _G.math.abs(distToRest))
						if distToRest > 0 then
							add = add * -1
						end
						for i = 1, page.numEpisodes do
							--print("\n here 2 " .. distToRest)
							page.items[i].x = page.items[i].x + add
						end
					end
					
					
				end
				
				--setRenderState(0,0,1,1,0)
				--drawLine2D(screenWidth / 2, 0, screenWidth / 2, screenHeight, 2, 0, 255, 0, 255)
				--drawLine2D(screenWidth / 2 - g_episodeSpacing / 2, 0, screenWidth / 2 - g_episodeSpacing / 2, screenHeight, 2, 0, 255, 0, 255)
				--drawLine2D(screenWidth / 2 + g_episodeSpacing / 2, 0, screenWidth / 2 + g_episodeSpacing / 2, screenHeight, 2, 0, 255, 0, 255)
			end
			
		end
		
		--double click in the sun
		--those values were found by experimenting
		local t_hotspotY = 0.897 * screenHeight
		local t_hotspotX = screenWidth * 0.5		
		local t_hotspotW = 0.13 * screenWidth
		local t_hotspotH = 0.08 * screenHeight
		local t_hotspotLeft = t_hotspotX - t_hotspotW * 0.5
		local t_hotspotTop = t_hotspotY - t_hotspotH * 0.5
		if page ~= levelSelectionPagesGoldenEggs[1] then
			if doubleClick == true and checkBounds(t_hotspotLeft, t_hotspotTop, t_hotspotW, t_hotspotH, cursor.x, cursor.y, 0) then
				g_releaseGEOnPopupExit = true
				goldenEggAchieved("Level8")
			end
			
		end
	
	
	end
	
	--this flag will be true when the user tries to scroll by clicking on the navigation buttons. We dont allow that
	
	
	if page == levelSelectionPagesBasic or page == levelSelectionPagesExtra or page == levelSelectionPagesPack3 or page == levelSelectionPagesPack4 or page == levelSelectionPagesPack5 or page == levelSelectionPagesPack6 or (levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1]) then
		if not isLiteVersion then
			local t_cursorOnClipArea = false
			local g_mouseDragStartedFromNavigation = false
			
			if 	deviceModel ~= "roku" and
				cursor.x > g_levelSelectionClippingArea.x - g_levelSelectionClippingArea.offsetX and 
				cursor.x < g_levelSelectionClippingArea.x - g_levelSelectionClippingArea.offsetX + g_levelSelectionClippingArea.width + (g_levelSelectionClippingArea.offsetX * 2) and
				cursor.y > g_levelSelectionClippingArea.y - g_levelSelectionClippingArea.offsetY and 
				cursor.y < g_levelSelectionClippingArea.y - g_levelSelectionClippingArea.offsetY + g_levelSelectionClippingArea.height + (g_levelSelectionClippingArea.offsetY * 2) then
				
				t_cursorOnClipArea = true
				
				if not keyHold["LBUTTON"] then
					if page ~= levelSelectionPagesGoldenEggs[1] then
						g_currentCursorName = "CURSOR_HAND_HOVER"
					end
					for i = page.firstLevelIndex, #page.items do
						local levelItm = page.items[i]
						if checkSpriteBounds("", levelItm.sprite, levelItm.x, levelItm.y, cursor.x, cursor.y) then
							g_currentCursorName = "CURSOR_HAND_POINT"
							break
						end
					end
				elseif page ~= levelSelectionPagesGoldenEggs[1] then
					g_currentCursorName = "CURSOR_HAND_GRAB"
				end
			end
			
			if page ~= levelSelectionPagesGoldenEggs[1] then
				
				-- legacy solution for platforms that don't use page item shortcut keys
				if deviceModel ~= "roku" then
					if keyPressed["LEFT"] then
						scrollLevelSelectionLeft(page)
					elseif keyPressed["RIGHT"] then
						scrollLevelSelectionRight(page)
					end
				elseif page.currentPage == page.pageCount and page == levelSelectionPagesPack3 and getItemByName(levelSelectionPagesPack3.items, "goldenEgg").visible then
					local t_rightNavButton = getItemByName(page.items, "rightNavigation")
					local triggerScroll = false
					for _, shortcut in _G.ipairs(t_rightNavButton.shortcutKeys or {}) do
						triggerScroll = triggerScroll or keyHold[shortcut]
					end
					
					if triggerScroll then
						page.currentOffset = page.currentOffset - 10
					end
				end
				
				--scrolling with mouse wheel
				local t_speed = levelSelectionDragSpeed or 0
				local t_scrollSpeedAbs = _G.math.abs(t_speed)
				
				if cursor.wheelTriggered == true and t_cursorOnClipArea == true then
					
					
					if cursor.wheel > 0 and page.currentPage < page.pageCount and  t_scrollSpeedAbs < 1 then
						levelSelectionDragSpeed = 1500
						page.currentPage = page.currentPage +1
					elseif cursor.wheel < 0 and page.currentPage > 1 and  t_scrollSpeedAbs < 1 then
						
						levelSelectionDragSpeed = 1500
						page.currentPage = page.currentPage -1
					end
					
					
					cursor.wheelTriggered = false
				end
			end
			
			--if page.scrollToNextPage == true and page.currentPage < page.pageCount then
			if page.scrollToNextPage == true and page.currentPage < page.pageCount then
				levelSelectionDragSpeed = 500
				page.currentPage = _G.math.min(page.currentPage +1, page.pageCount)
				page.scrollToNextPage = false
				
				if page  == levelSelectionPagesBasic then
					settings.currentLevelSelectionPages.basic = _G.math.min(settings.currentLevelSelectionPages.basic + 1, page.pageCount)
				elseif page ==  levelSelectionPagesExtra then
					settings.currentLevelSelectionPages.extra = _G.math.min(settings.currentLevelSelectionPages.extra + 1, page.pageCount)
				elseif page ==  levelSelectionPagesPack3 then
					settings.currentLevelSelectionPages.pack3 = _G.math.min(settings.currentLevelSelectionPages.pack3 + 1, page.pageCount)
				elseif page ==  levelSelectionPagesPack4 then
					settings.currentLevelSelectionPages.pack4 = _G.math.min(settings.currentLevelSelectionPages.pack4 + 1, page.pageCount)
				elseif page ==  levelSelectionPagesPack5 then
					settings.currentLevelSelectionPages.pack5 = _G.math.min(settings.currentLevelSelectionPages.pack5 + 1, page.pageCount)
				elseif page == levelSelectionPagesPack6 then
					settings.currentLevelSelectionPages.pack6 = _G.math.min(settings.currentLevelSelectionPages.pack6 + 1, page.pageCount)
				end
			end
			
			--disable scrolling on golden eggs level
			if page == levelSelectionPagesGoldenEggs[1] then
				menuDrag = nil
			end 
			
			
			if menuDrag ~= nil then
				if (_G.math.abs(menuDrag.endX - menuDrag.startX) > 30 and menuDrag.speed > 100) or 
				   (_G.math.abs(menuDrag.endX - menuDrag.startX) > 90 and menuDrag.speed > 20) then
					if menuDrag.endX > menuDrag.startX then
						--if page.currentPage > 1 and page.currentOffset > -(page.currentPage - 1) * screenWidth then
						if page.currentPage > 1 and page.currentOffset > -(page.currentPage - 1) * g_levelSelectionScrollOffset then
							page.currentPage = page.currentPage - 1
						end
					--elseif page.currentPage < page.pageCount and page.currentOffset < -(page.currentPage - 1) * screenWidth then
					elseif page.currentPage < page.pageCount and page.currentOffset < -(page.currentPage - 1) * g_levelSelectionScrollOffset then
						if page.currentPage < page.pageCount then
							page.currentPage = page.currentPage + 1
						end
					end
					levelSelectionDragSpeed = _G.math.max(menuDrag.speed, 500)
				end
				if page == levelSelectionPagesBasic then
					settings.currentLevelSelectionPages.basic = page.currentPage
				elseif page == levelSelectionPagesExtra then
					settings.currentLevelSelectionPages.extra = page.currentPage
				elseif page == levelSelectionPagesPack3 then
					settings.currentLevelSelectionPages.pack3 = page.currentPage
				elseif page == levelSelectionPagesPack4 then
					settings.currentLevelSelectionPages.pack4 = page.currentPage
				elseif page == levelSelectionPagesPack5 then
					settings.currentLevelSelectionPages.pack5 = page.currentPage
				elseif page == levelSelectionPagesPack6 then
					settings.currentLevelSelectionPages.pack6 = page.currentPage
				elseif page == levelSelectionPagesGoldenEggs[1] then
					--settings.currentLevelSelectionPages.goldeneggs = page.currentPage
					if (_G.math.abs(menuDrag.endX - menuDrag.startX) > 30 and menuDrag.speed > 100) or 
				   (_G.math.abs(menuDrag.endX - menuDrag.startX) > 60 and menuDrag.speed > 20) then
						for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do
							page.items[i].selectable = false
						end
						page.dragging = true
					elseif not(helpAreaPressed) then
						for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do
							page.items[i].selectable = true
						end
						page.dragging = false
					end
				end
			end
			
			
			--page.targetOffset = -(page.currentPage - 1) * screenWidth
			if g_levelSelectionScrollOffset == nil then
				g_levelSelectionScrollOffset = screenWidth
			end
			page.targetOffset = -(page.currentPage - 1) * g_levelSelectionScrollOffset
			
			local t_scrollingWithMultiTouch = page.usingTouchScroll == true and g_mouseOrTouchStates.isUsingMouse == false
			
			
			--when clicked detected, enable clicking for the level buttons
			if keyPressed["LBUTTON"] then
			
				levelSelectionPagesDragStartOffset = page.currentOffset
				if deviceModel == "roku" or t_cursorOnClipArea or page == levelSelectionPagesGoldenEggs[1] then
					levelSelectionPagesPressed = true
					if page ~= levelSelectionPagesGoldenEggs[1] then
						for i = page.firstLevelIndex, #page.items do
							page.items[i].disableSelection = false
						end
					else
						for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do
							page.items[i].selectable = true
						end
					end
				end
			elseif deviceModel ~= "roku" and (keyHold["LBUTTON"] == true and ( not g_mouseDragStartedFromNavigation) and (page ~= levelSelectionPagesGoldenEggs[1]) and menuDragStart) then
			
				if levelSelectionPagesDragStartOffset == nil then
					levelSelectionPagesDragStartOffset = 0
				end	
				
				if page.currentOffset > 0 or page.currentOffset < (page.pageCount - 1) * -g_levelSelectionScrollOffset then
					
					if page.currentOffset > 0 and levelSelectionPagesDragStartOffset < 0 then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset
						levelSelectionPagesDragStartOffset = 0
					elseif page.currentOffset < (page.pageCount - 1) * -g_levelSelectionScrollOffset and levelSelectionPagesDragStartOffset > (page.pageCount - 1) * -g_levelSelectionScrollOffset  then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset + (page.pageCount - 1) * -g_levelSelectionScrollOffset
						levelSelectionPagesDragStartOffset = (page.pageCount - 1) * -g_levelSelectionScrollOffset
					end
					
					page.currentOffset = levelSelectionPagesDragStartOffset + (cursor.x - menuDragStart.x) / 2
					if page.currentOffset > g_levelSelectionScrollOffset then
						page.currentOffset = g_levelSelectionScrollOffset
					elseif page.currentOffset < page.pageCount * -g_levelSelectionScrollOffset then
						page.currentOffset = page.pageCount * -g_levelSelectionScrollOffset
					end
				else
					if levelSelectionPagesDragStartOffset > 0 then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset * 2
						levelSelectionPagesDragStartOffset = 0
					elseif levelSelectionPagesDragStartOffset < (page.pageCount - 1) * -g_levelSelectionScrollOffset  then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset * 2 + (page.pageCount - 1) * -g_levelSelectionScrollOffset * 2
						levelSelectionPagesDragStartOffset = (page.pageCount - 1) * -g_levelSelectionScrollOffset
					end
					if ( menuDragStart ~= nil) then
						page.currentOffset = levelSelectionPagesDragStartOffset + (cursor.x - menuDragStart.x)
					end
				end
			elseif deviceModel ~= "roku" and ((t_scrollingWithMultiTouch == true) and ( not g_mouseDragStartedFromNavigation) and (page ~= levelSelectionPagesGoldenEggs[1]) and menuDragStart) then

				
				
				if levelSelectionPagesDragStartOffset == nil then
					levelSelectionPagesDragStartOffset = 0
				end
				
				if page.currentOffset > 0 or page.currentOffset < (page.pageCount - 1) * -g_levelSelectionScrollOffset then
					
					if page.currentOffset > 0 and levelSelectionPagesDragStartOffset < 0 then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset
						levelSelectionPagesDragStartOffset = 0
					
					elseif page.currentOffset < (page.pageCount - 1) * -g_levelSelectionScrollOffset and levelSelectionPagesDragStartOffset > (page.pageCount - 1) * -g_levelSelectionScrollOffset  then
						
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset + (page.pageCount - 1) * -g_levelSelectionScrollOffset						
						levelSelectionPagesDragStartOffset = (page.pageCount - 1) * -g_levelSelectionScrollOffset
					end
					
					
					
					
					page.currentOffset = levelSelectionPagesDragStartOffset + (multitouchSweep.sweepCurrentX - menuDragStart.x) / 2
					
					if page.currentOffset > g_levelSelectionScrollOffset then
						
						page.currentOffset = g_levelSelectionScrollOffset
					
					elseif page.currentOffset < page.pageCount * -g_levelSelectionScrollOffset then
						
						page.currentOffset = page.pageCount * -g_levelSelectionScrollOffset
					end
				else
					if levelSelectionPagesDragStartOffset > 0 then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset * 2
						levelSelectionPagesDragStartOffset = 0
					
					elseif levelSelectionPagesDragStartOffset < (page.pageCount - 1) * -g_levelSelectionScrollOffset  then
						
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset * 2 + (page.pageCount - 1) * -g_levelSelectionScrollOffset * 2						
						levelSelectionPagesDragStartOffset = (page.pageCount - 1) * -g_levelSelectionScrollOffset
					end
					if ( menuDragStart ~= nil) then
						page.currentOffset = levelSelectionPagesDragStartOffset + (multitouchSweep.sweepCurrentX - menuDragStart.x)
					end
				end
			
			--elseif (not g_mouseDragStartedFromNavigation) and (page ~= levelSelectionPagesGoldenEggs[1])  then 
			elseif (page ~= levelSelectionPagesGoldenEggs[1])  then 
				if levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0 then
					local speed = 1000
					if levelSelectionDragSpeed ~= nil then
						if _G.math.abs(page.targetOffset - page.currentOffset) < levelSelectionDragSpeed * dt * 3 then
							levelSelectionDragSpeed = levelSelectionDragSpeed * 0.7
						end
						speed = _G.math.max(levelSelectionDragSpeed, 100)
					end
					if page.currentOffset > page.targetOffset then
						page.currentOffset = page.currentOffset - dt * speed
						if page.currentOffset <= page.targetOffset then
							page.currentOffset = page.targetOffset
						end
					elseif page.currentOffset < page.targetOffset then
						page.currentOffset = page.currentOffset + dt * speed
						if page.currentOffset >= page.targetOffset then
							page.currentOffset = page.targetOffset
						end
					end
				else
					levelSelectionScrollStartTimer = levelSelectionScrollStartTimer - dt
				end
			end
			
			--dots and numbers
			if page.currentOffset == page.targetOffset  then
				local _, textIndex = getItemByName(page.items, "text_" .. page.themes[1])
				for i = 1, page.pageCount do
					page.items[i + textIndex - 1].visible = page.currentPage == i and (page ~= levelSelectionPagesGoldenEggs[1])
				end
				local _, dotIndex = getItemByName(page.items, "dot1")
				for i = dotIndex, dotIndex + page.pageCount - 1 do
					page.items[i].sprite = "LS_DOT_BLACK"
				end
				page.items[dotIndex + page.currentPage - 1].sprite = "LS_DOT_WHITE"	

				if page == levelSelectionPagesBasic then
					settings.currentLevelSelectionPages.basic = page.currentPage
				elseif page == levelSelectionPagesExtra then
					settings.currentLevelSelectionPages.extra = page.currentPage
				elseif page == levelSelectionPagesPack3 then
					settings.currentLevelSelectionPages.pack3 = page.currentPage
				elseif page == levelSelectionPagesPack4 then
					settings.currentLevelSelectionPages.pack4 = page.currentPage
				elseif page == levelSelectionPagesPack5 then
					settings.currentLevelSelectionPages.pack5 = page.currentPage
				elseif page == levelSelectionPagesPack6 then
					settings.currentLevelSelectionPages.pack6 = page.currentPage
				end
			end
			
			for i = page.firstLevelIndex, #page.items do
				if page.items[i].levelIndex ~= nil then
				

				
					page.items[i].x = page.items[i].relativeX + page.currentOffset
					
					if page.items[i].starItem ~= nil then
						page.items[i].starItem.x = page.items[i].x
						updateItemMouseOverState(page.items[i].starItem, dt)
					end
					if levelSelectionPagesPressed and page ~= levelSelectionPagesGoldenEggs[1] then
						page.items[i].disableSelection = page.currentOffset ~= page.targetOffset
						if (page.items[i].x < g_levelSelectionClippingArea.x or (page.items[i].x > ( g_levelSelectionClippingArea.x + g_levelSelectionClippingArea.width) )) then
							page.items[i].disableSelection = true
						end
					end
				end
			end
			
			if page == levelSelectionPagesPack3 then
				-- move golden egg
					local goldenEgg = getItemByName(page.items, "goldenEgg")
					goldenEgg.x = goldenEgg.relativeX + page.currentOffset
					
					local w, _ = _G.res.getSpriteBounds("", goldenEgg.sprite)
					local px, _ = _G.res.getSpritePivot("", goldenEgg.sprite)
					--if goldenEgg.x + (w - px) + (screenWidth - (g_levelSelectionClippingArea.x + g_levelSelectionClippingArea.width - 20)) <= screenWidth then
					if goldenEgg.x + (w - px) + 20 < g_levelSelectionClippingArea.x + g_levelSelectionClippingArea.width then
						episode3LevelSelectionEggAchieved()
					end
			end
			
			--double click in the sun
			--those values were found by experimenting
			local t_hotspotY = 0.897 * screenHeight
			local t_hotspotX = screenWidth * 0.5
			local t_hotspotW = 0.13 * screenWidth
			local t_hotspotH = 0.08 * screenHeight
			local t_hotspotLeft = t_hotspotX - t_hotspotW * 0.5
			local t_hotspotTop = t_hotspotY - t_hotspotH * 0.5
			if page ~= levelSelectionPagesGoldenEggs[1] then
				--print("\n here")
				if doubleClick == true and checkBounds(t_hotspotLeft, t_hotspotTop, t_hotspotW, t_hotspotH, cursor.x, cursor.y, 0) then
					g_releaseGEOnPopupExit = true
					goldenEggAchieved("Level8")
				end
				
			end
		else
			if keyPressed["LBUTTON"] and levelSelectionPagesPressed == false then
				levelSelectionPagesPressed = true
				if levelSelectionPagesGoldenEggs == nil or (levelSelectionPagesGoldenEggs and page ~= levelSelectionPagesGoldenEggs[1]) then
					for i = page.firstLevelIndex, #page.items do
						page.items[i].disableSelection = false
					end
				end
			end
		end
			
		--bgColorPhase = _G.math.max(1, _G.math.min(page.pageCount, -(page.currentOffset / screenWidth - 1)))
		bgColorPhase = _G.math.max(1, _G.math.min(page.pageCount, -(page.currentOffset / g_levelSelectionScrollOffset - 1)))
		if bgColorPhase == page.pageCount then
			page.bgColor = { red = page.bgColors[page.pageCount].red, green = page.bgColors[page.pageCount].green, blue = page.bgColors[page.pageCount].blue}
		else
			leftColor = page.bgColors[_G.math.floor(bgColorPhase)]
			rightColor = page.bgColors[_G.math.floor(bgColorPhase) + 1]
			_, rightWeight = _G.math.modf(bgColorPhase)
			leftWeight = 1 - rightWeight
			red = leftColor.red * leftWeight + rightColor.red * rightWeight
			green = leftColor.green * leftWeight + rightColor.green * rightWeight
			blue = leftColor.blue * leftWeight + rightColor.blue * rightWeight
			page.bgColor = { red = red, green = green, blue = blue}
		end
			
		-- move Ovistore buttons
		if deviceModel == "n900" and page == levelSelectionPagesBasic and getItemByName(page.items, "overlay").visible then
			getItemByName(page.items, "overlay").shade = _G.math.max(0, _G.math.min(0.65, (page.currentOffset / -screenWidth)))  	
			if page.currentOffset < -screenWidth then
				getItemByName(page.items, "button1").x = screenWidth / 2
				getItemByName(page.items, "button2").x = screenWidth / 2
			else
				getItemByName(page.items, "button1").x = getItemByName(page.items, "button1").relativeX + page.currentOffset
				getItemByName(page.items, "button2").x = getItemByName(page.items, "button2").relativeX + page.currentOffset
			end
		end
		
	end
		
	if levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1] then

		if getItemByName(page.items, "overlay") ~= nil then
			if getItemByName(page.items, "overlay").shade == nil then
				getItemByName(page.items, "overlay").shade = 0
			end
			
			if getItemByName(page.items, "overlay").fadeSpeed > 0 then
				getItemByName(page.items, "overlay").shade = getItemByName(page.items, "overlay").shade + dt * getItemByName(page.items, "overlay").fadeSpeed
				if getItemByName(page.items, "overlay").shade > 0.65 then
					getItemByName(page.items, "overlay").shade = 0.65
					getItemByName(page.items, "overlay").fadeSpeed = 0
				end
			elseif getItemByName(page.items, "overlay").fadeSpeed < 0 then
				getItemByName(page.items, "overlay").shade = getItemByName(page.items, "overlay").shade + dt * getItemByName(page.items, "overlay").fadeSpeed
				if getItemByName(page.items, "overlay").shade < 0 then
					getItemByName(page.items, "overlay").shade = 0
					getItemByName(page.items, "overlay").fadeSpeed = 0
					getItemByName(page.items, "overlay").visible = false
				end
			end
		end
	
		-- help text bubble

		
		if page == levelSelectionPagesGoldenEggs[1] and keyReleased["LBUTTON"] then
				helpAreaPressed = false
				for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do
					if page.items[i].visible ~= false and page.items[i].disableSelection and not(page.dragging) then 
						local w, h = _G.res.getSpriteBounds("", page.items[i].sprite)
						local px, py = _G.res.getSpritePivot("", page.items[i].sprite)
						if cursor.x > page.items[i].x - px and cursor.x < page.items[i].x + (w - px) and
						   cursor.y > page.items[i].y - py and cursor.y < page.items[i].y + (h - py) then
							getItemByName(page.items, "tipContent").sprite = page.items[i].children[1].sprite
							helpAreaPressed = true
						end
					end
				end
				
				if helpAreaPressed and getItemByName(page.items, "tipBubble").visible ~= true then 
					getItemByName(page.items, "tipBubble").visible = true
					getItemByName(page.items, "overlay").visible = true
					getItemByName(page.items, "overlay").shade = 0
					getItemByName(page.items, "overlay").fadeSpeed = 2.7
					getItemByName(page.items, "tipContent").visible = true

					-- disable egg buttons until the help text is dismissed
					for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do
						page.items[i].selectable = false
					end
				else
					getItemByName(page.items, "tipBubble").visible = false	
					getItemByName(page.items, "tipContent").visible = false
					getItemByName(page.items, "overlay").fadeSpeed = -2.7
				end
		end
	end
	
	if page == about then
		about.scrollTimer = about.scrollTimer - dt
		local scrollSpeed = 35
		
		if deviceModel == "roku" then
			dragSpeed = 0
			if keyHold["DOWN"] then
				dragSpeed = -30
				scrollSpeed = 0
			elseif keyHold["UP"] then
				dragSpeed = 30
				scrollSpeed = 0
			end
		end
		
		if keyPressed["LBUTTON"] and cursor.x < page.backgroundBox.width then
			aboutDragStart = { x = cursor.x, y = cursor.y }
			scrollSpeed = 0
		elseif keyReleased["LBUTTON"] and aboutDragStart ~= nil then
			scrollSpeed = 35
			aboutDragStart = nil
		elseif keyHold["LBUTTON"] and aboutDragStart ~= nil then
			scrollSpeed = 0
			dragSpeed = cursor.y - aboutDragStart.y
			aboutDragStart = { x = cursor.x, y = cursor.y }
		end
		
		--scrolling with mouse wheel
		t_cursorOnScrollArea = cursor.x < page.backgroundBox.width
		if cursor.wheelTriggered == true then
			if t_cursorOnScrollArea == true then 
				local t_tickSpeed = 20
				dragSpeed = cursor.wheel * t_tickSpeed
			end
			cursor.wheelTriggered = false
		end
		
		if about.scrollTimer < 0 then
			for i = about.scrollStart, about.scrollEnd do
				about.items[i].y = about.items[i].y - dt * scrollSpeed
			end
		end
		for i = about.scrollStart, about.scrollEnd do
			about.items[i].y = about.items[i].y + dragSpeed
		end
			
		if about.items[about.scrollEnd].y < -about.items[about.scrollEnd].h * 0.5 then

			local increment = 0
			for i = 1, about.scrollEnd do
				increment = increment + about.items[i].h
			end
			increment = increment + 120 + screenHeight			
			
			for i = about.scrollStart, about.scrollEnd do
				about.items[i].y = about.items[i].y + increment	+ 120
			end
		elseif about.items[1].y > about.items[1].h + screenHeight + 10 then
		
			local increment = 0			
			for i = 1, about.scrollEnd do
				increment = increment + about.items[i].h
			end			
			increment = increment + 120 + screenHeight
			
			for i = about.scrollStart, about.scrollEnd do
				about.items[i].y = about.items[i].y - increment - 200
			end 	
		
		end
		
		dragSpeed = dragSpeed * _G.math.pow(0.002, dt)
		if _G.math.abs(dragSpeed) < 0.1 then
			dragSpeed = 0
		end
	end
	
	if page == goldenEggAchievedPage then
		page.timer = page.timer - dt
		local _, eggHeight = _G.res.getSpriteBounds("", page.items[1].sprite)
		page.items[1].angle = page.items[1].angle + 1.6 * dt
		
		if page.animationState == "FADEIN" then
			page.backgroundOverlay.shade = (page.fadeInLength - page.timer) / page.fadeInLength * page.fullyShaded
			page.items[1].visible = true
			page.items[1].y = (screenHeight*0.5) + _G.math.pow(page.timer / page.fadeInLength, 2) * ((screenHeight*0.5) + eggHeight)
			if page.timer < 0 then
				page.timer = page.fadedLength
				page.animationState = "FADED"
			end
		end
		
		if page.animationState == "FADED" then
			page.backgroundOverlay.shade = page.fullyShaded
			page.items[1].y = screenHeight*0.5
			if page.timer < 0 then
				page.timer = page.fadeOutLength
				page.animationState = "FADEOUT"
			end
		end
		
		if page.animationState == "FADEOUT" then
			page.backgroundOverlay.shade = (page.timer / page.fadeOutLength) * page.fullyShaded
			page.items[1].y = (screenHeight*0.5) - _G.math.pow((page.fadeInLength - page.timer) / page.fadeInLength, 2) * ((screenHeight*0.5) + eggHeight)
			if page.timer < 0 then
				if page.enablePhysicsWhenDone then
					setPhysicsEnabled(true)
				end
				if deviceModel == "roku" and g_releaseGEOnPopupExit then
					releaseImages({ "GOLDEN_EGGS" })
					g_releaseGEOnPopupExit = nil
				end
				popupPage = nil
				if deviceModel == "iphone4" and currentGameMode ~= updateMenu then
					changeResolution = true
					wantedResolution = "FULL"
					resolutionChanged = true
				end
				
				if currentMenuPage == levelSelectionPagesGoldenEggs[1] then
					prepareMenuPage(currentMenuPage)
				end
			end
		end
	end
	
	-- effects in levelcomplete when mighty eagle is used 
	if page == levelComplete then
		if eagleBaitLaunched == true then
			local starEffect = getItemByName(levelComplete.items, "starEffect")
			starEffect.angle = starEffect.angle + 1.6 * dt
			
			local eagleFeatherFill = getItemByName(levelComplete.items, "eagleFeatherFill")
			local eagleScoreNumber = getItemByName(levelComplete.items, "eagleScoreNumber")
			
			if starEffect.angle > 0.8 then
				eagleFeatherFill.fill = eagleFeatherFill.fill + 50 * dt 
				if eagleFeatherFill.fill > mightyEagleScore then
					eagleFeatherFill.fill = mightyEagleScore
				end
				eagleScoreNumber.text = _G.string.format("%d", eagleFeatherFill.fill) .. "%"
				prepareTextItem(page, eagleScoreNumber)
			end
			
			local totalDestruction = getItemByName(levelComplete.items, "totalDestruction")
			local eagleFeatherFull = getItemByName(levelComplete.items, "eagleFeatherFull")
			local eagleFeatherEmpty = getItemByName(levelComplete.items, "eagleFeatherEmpty")
			
			if eagleFeatherFill.fill >= 100 then
				eagleScoreNumber.visible = false
				totalDestruction.visible = true
				eagleFeatherFull.visible = true
				eagleFeatherFill.visible = false
				eagleFeatherEmpty.visible = false
				starEffect.visible = true
			end
		end
	end
	
	if page == goldenEggStarAchievedPage then
		page.timer = page.timer - dt
		local _, eggHeight = _G.res.getSpriteBounds("", page.items[1].sprite)
		page.items[1].angle = page.items[1].angle + 1.6 * dt
		
		if page.animationState == "FADEIN" then
			page.backgroundOverlay.shade = (page.fadeInLength - page.timer) / page.fadeInLength * page.fullyShaded
			page.items[1].visible = true
			page.items[1].y = (screenHeight*0.5) + _G.math.pow(page.timer / page.fadeInLength, 2) * ((screenHeight*0.5) + eggHeight)
			if page.timer < 0 then
				page.timer = page.fadedLength
				page.animationState = "FADED"
			end
		end
		
		if page.animationState == "FADED" then
			page.backgroundOverlay.shade = page.fullyShaded
			page.items[1].y = screenHeight*0.5

			if page.timer < 0 then
				page.timer = page.fadeOutLength
				page.animationState = "FADEOUT"
			end
		end
		
		if page.animationState == "FADEOUT" then
			page.backgroundOverlay.shade = (page.timer / page.fadeOutLength) * page.fullyShaded
			page.items[1].y = (screenHeight*0.5) - _G.math.pow((page.fadeInLength - page.timer) / page.fadeInLength, 2) * ((screenHeight*0.5) + eggHeight)
			if page.timer < 0 then
				if page.enablePhysicsWhenDone then
					setPhysicsEnabled(true)
				end
				popupPage = nil
			end
		end
	end
	
	if page == mightyEaglePaymentPage then
		page.items[3].timer = page.items[3].timer + dt
		if(page.items[3].timer > 0.125) and (page.items[3].angle <= 1080) then
			page.items[3].angle = page.items[3].angle + 45
			page.items[3].timer = 0
		end
		if (page.items[3].angle == 1080) then
			page.items[3].angle = page.items[3].angle + 45
			
			page.items[2].visible = false
			page.items[4].visible = true
			page.items[5].visible = true
			enableMightyEagleFeature()		
		end
	end
	
	if page == boomerangBirdAchievedPage then
		page.timer = page.timer - dt
		local _, birdHeight = _G.res.getSpriteBounds("", page.items[1].sprite)
		page.items[1].angle = page.items[1].angle + 1.6 * dt
		
		if page.animationState == "FADEIN" then
			page.backgroundOverlay.shade = (page.fadeInLength - page.timer) / page.fadeInLength * page.fullyShaded
			page.items[1].visible = true
			page.items[1].y = (screenHeight*0.5) + _G.math.pow(page.timer / page.fadeInLength, 2) * ((screenHeight*0.5) + birdHeight)
			if page.timer < 0 then
				page.timer = page.fadedLength
				page.animationState = "FADED"
			end
		end
		
		if page.animationState == "FADED" then
			page.backgroundOverlay.shade = page.fullyShaded
			page.items[1].y = screenHeight*0.5
			if page.timer < 0 then
				page.timer = page.fadeOutLength
				page.animationState = "FADEOUT"
			end
		end
		
		if page.animationState == "FADEOUT" then
			page.backgroundOverlay.shade = (page.timer / page.fadeOutLength) * page.fullyShaded
			page.items[1].y = (screenHeight*0.5) - _G.math.pow((page.fadeInLength - page.timer) / page.fadeInLength, 2) * ((screenHeight*0.5) + birdHeight)
			if page.timer < 0 then
				setPhysicsEnabled(true)
				popupPage = nil
				if deviceModel == "roku" then
					releaseImages({ "GOLDEN_EGGS" })
				end
				if deviceModel == "iphone4" and currentGameMode ~= updateMenu then
					changeResolution = true
					wantedResolution = "FULL"
					resolutionChanged = true
				end
				if deviceModel == "roku" and g_releaseGEOnPopupExit then
					releaseImages({ "GOLDEN_EGGS" })
					g_releaseGEOnPopupExit = nil
				end
				
				if currentMenuPage == levelComplete then
					prepareMenuPage(currentMenuPage)
				end
			end
		end
	end
	
	if page == gameComplete then

		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth
					end
					page.timer = 1
					page.animationState = "STATE1"
					return
				end
			end
			
			if page.animationState == "STATE1" then
				page.items[4].visible = true
				page.timer = 0.5
				page.animationState = "STATE2"
				return
			end

			if page.animationState == "STATE2" then
				page.items[4].visible = false
				page.items[5].visible = true
				page.timer = 1
				page.animationState = "STATE3"
				return
			end

			if page.animationState == "STATE3" then
				page.items[5].visible = false
				page.items[4].visible = true
				page.timer = 1.3
				page.animationState = "STATE4"
				return
			end
			
			if page.animationState == "STATE4" then
				page.items[4].visible = false
				page.items[5].visible = false
				page.items[6].visible = true
				page.timer = 0.15
				page.animationState = "STATE5"
				return
			end

			if page.animationState == "STATE5" then
				page.items[6].visible = false
				page.items[4].visible = true
				_G.res.playAudio("piglette_oink_story", 1, false, 0)
				page.timer = 2
				page.animationState = "END"
				return
			end
						
			if page.animationState == "END" then
				setGameMode(gotoAbout)
			end
		end
	end
	
	if page == theme5Complete then
	
		if _G.res.isAudioPlaying("birds_outro") == false then
			_G.res.playAudio("birds_outro", 1, true,7)
		end
	
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth
					end
					page.timer = 1
					page.animationState = "STATE1"
					return
				end
			end
			
			if page.animationState == "STATE1" then
				page.timer = 0.5
				page.animationState = "STATE2"
				return
			end

			if page.animationState == "STATE2" then
				page.items[7].visible = false
				page.items[8].visible = true
				page.timer = 1
				page.animationState = "STATE3"
				return
			end

			if page.animationState == "STATE3" then
				page.items[8].visible = false
				page.items[7].visible = true
				page.timer = 1.3
				page.animationState = "STATE4"
				return
			end
			
			if page.animationState == "STATE4" then
				_G.res.playAudio("piglette_oink_story", 1, false, 0)
				page.items[7].visible = false
				page.items[8].visible = false
				page.items[9].visible = true
				page.timer = 0.15
				page.animationState = "STATE5"
				return
			end

			if page.animationState == "STATE5" then
				page.items[9].visible = false
				page.items[7].visible = true
				page.timer = 1.0
				page.animationState = "STATE6"
				return
			end
			
			if page.animationState == "STATE6" then
				page.items[7].visible = false
				page.items[10].visible = true
				page.timer = 2.0
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoAbout)
			end
		end
	end
	
	if page == gameStart then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth
					end
					page.timer = 0
					page.animationState = "STATE1"
					return
				end
			end

			if page.animationState == "STATE1" then
				page.timer = 2.5
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoFirstLevel)
				settings.gameStarted = true
			end
		end
	end
	
	if page == theme1Complete then
		
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset)  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
				
			end
									
			if page.animationState == "END" then
				if not hasLevelPack1() then
					if isLiteVersion then
						setActiveMenuPage(mainMenu, false)
						setActivePopupPage(upsellPage)
					else
						setGameMode(gotoLevelSelection)
						setActiveMenuPage(levelSelectionPagesBasic)
						--settings.currentLevelSelectionPages.basic = settings.currentLevelSelectionPages.basic + 1
						levelSelectionPagesBasic.scrollToNextPage = true
					end
				else
					setGameMode(gotoLevelSelection)
					--settings.currentLevelSelectionPages.basic = settings.currentLevelSelectionPages.basic + 1
					levelSelectionPagesBasic.scrollToNextPage = true
				end
			end
		end
	end
	
	if page == theme2Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset)  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelection)
				--settings.currentLevelSelectionPages.basic = settings.currentLevelSelectionPages.basic + 1
				levelSelectionPagesBasic.scrollToNextPage = true
			end
		end
	end

	if page == theme4Start then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth
					end
					page.timer = 0
					page.animationState = "STATE1"
					return
				end
			end

			if page.animationState == "STATE1" then
				page.timer = 2.5
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoFirstLevelLP2)
				settings.lp2Started = true
			end
		end
	end
	
	if page == theme4Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset)  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelectionExtra)
				--settings.currentLevelSelectionPages.extra = settings.currentLevelSelectionPages.extra + 1				
				levelSelectionPagesExtra.scrollToNextPage = true
			end
		end
	end
	
	if page == theme6Start then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local ys = page.ys or 1
				if not page.dontScroll then
					page.offsetY = page.offsetY + dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetY >= page.maxOffsetY) then
					if not page.dontScroll then
						page.offsetY = page.maxOffsetY
					end
					page.animationState = "END"
					page.timer = 5.0
				end
			elseif page.animationState == "END" then
				setGameMode(gotoFirstLevelLP3)
				settings.lp3Started = true
			end
		end
		
		if settings.lp3Started == true and keyPressed["LBUTTON"] then
			gotoFirstLevelLP3()
		end
	end
	
	if page == theme6Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset)  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelectionPack3)
				--settings.currentLevelSelectionPages.pack3 = settings.currentLevelSelectionPages.pack3 + 1
				levelSelectionPagesPack3.scrollToNextPage = true
			end
		end
	end
	
	if page == theme7Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset)  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelectionPack3)
				--settings.currentLevelSelectionPages.pack3 = settings.currentLevelSelectionPages.pack3 + 1
				levelSelectionPagesPack3.scrollToNextPage = true
			end
		end
	end
	
	if page == theme8Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset)  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX + screenWidth
					end
					page.timer = 1.5
					page.animationState = "STATE1"
					return
				end
			end
			if page.animationState == "STATE1" then
				page.items[6].visible = true
				page.timer = 1
				page.animationState = "STATE2"
				return
			end
			
			if page.animationState == "STATE2" then
				page.items[6].visible = false
				page.timer = 1.3
				page.animationState = "STATE3"
				return
			end
			
			if page.animationState == "STATE3" then
				page.items[7].visible = true
				page.timer = 0.15
				page.animationState = "STATE4"
				return
			end

			if page.animationState == "STATE4" then
				_G.res.playAudio("piglette_oink_story", 1, false, 0)
				page.items[7].visible = false
				page.timer = 2.0
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoAbout)
			end
		end
	end
	
	if page == theme9Start then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth
					end
					page.timer = 0
					page.animationState = "STATE1"
					return
				end
			end

			if page.animationState == "STATE1" then
				page.timer = 2.3 
				page.animationState = "SCROLL_FORWARD"
				local sw2, _ = _G.res.getSpriteBounds("", getItemByName(page.items, "bg_extension").sprite)
				local scaleX = page.xs or 1
				page.tuneTimer = 1.73075
				page.dontScroll = true
				if (page.backgroundWidth + sw2) * scaleX > screenWidth then
					page.dontScroll = false
				end
				page.scrollSpeed = sw2 * scaleX / page.tuneTimer
				return
			end
			
			if page.animationState == "SCROLL_FORWARD" then
				local sw2, _ = _G.res.getSpriteBounds("", getItemByName(page.items, "bg_extension").sprite)
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 then --or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + sw2) * scaleX  + screenWidth) then
					if not page.dontScroll then
						--page.offsetX = -(page.backgroundWidth + sw2) * scaleX  + screenWidth
					end
					page.timer = 0
					page.animationState = "STATE2"
					return
				end
			end
			
			if page.animationState == "STATE2" then
				_G.res.stopAllAudio()
				_G.res.playAudio("big_brother_awakens", 1, false, 7)
				page.timer = 2.2
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoFirstLevelLP4)
				settings.lp4Started = true
			end
		end
	end
	
	--update
	if page == theme12Start then
		page.timer = page.timer - dt
		if page.timer < 0 then
			
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX  + screenWidth
					end
					page.timer = 0
					page.animationState = "STATE1"
					return
				end
			end

			if page.animationState == "STATE1" then
				page.timer = 2.5
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				--print("\n end")
				setGameMode(gotoFirstLevelLP5)
				settings.lp5Started = true
			end
		end
	end
	
	if page == theme9Complete or page == theme10Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset)  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelectionPack4)
				--settings.currentLevelSelectionPages.pack4 = settings.currentLevelSelectionPages.pack4 + 1
				levelSelectionPagesPack4.scrollToNextPage = true
			end
		end
	end
	
	if page == theme11Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + page.cutSceneOffset)  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + page.cutSceneOffset) * scaleX + screenWidth
					end
					page.timer = 3.0
					page.animationState = "OINK"
					return
				end
			end
			if page.animationState == "OINK" then
				_G.res.playAudio("piglette_oink_story", 1, false, 0)
				page.timer = 2
				page.animationState = "END"
				return
			end
			if page.animationState == "END" then
				setGameMode(gotoAbout)
			end
		end
	end
	
	if page == gameFinished or page == gameFinishedThreeStars or
	   page == gameFinishedLP2 or page == gameFinishedThreeStarsLP2 or 
	   page == gameFinishedLP3 or page == gameFinishedThreeStarsLP3 or
	   page == gameFinishedLP4 or page == gameFinishedThreeStarsLP4 then
		page.items[1].angle = page.items[1].angle + 0.8 * dt
	end
end

function prepareTextItem(page, ci)
	if ci.text ~= nil then
		local textBoxSize = ci.textBoxSize and ci.textBoxSize or screenWidth
		local group = ci.group and ci.group or "TEXTS_BASIC"
		
		--check font
		if ci.font == nil then
			-- use default
			ci.font = defaultMenuFont
			--use page default if it exists
			if page.font ~= nil then
				ci.font = page.font
			end
		end
		--print("\nXXXXXXXXXX font used " .. ci.font)
		setFont(ci.font)
		clipText(group, ci.text, textBoxSize)
		local fh = _G.res.getFontLeading()
		local textHeight = #clippedText.lines * fh
		ci.h = textHeight
		ci.w = clippedText.widestLine
		ci.lines = {}
		
		local k = 1
		while  k <= #clippedText.lines do
			ci.lines[k] = clippedText.lines[k]
			--print("Calculated new lines: " .. ci.lines[k] .. "\n")
			k = k + 1
		end
	end
end

function calculateTotalScoreAndStars(levelTable)

	local totalScore = 0
	local gainedStars = 0
	local totalStars = 0
	
	for k = 1, #levelTable do
		local pageTable = levelTable[k]
		totalStars = totalStars + #pageTable*3
		for i = 1, #pageTable do
		
			if highscores[pageTable[i]] ~= nil then
				totalScore = totalScore + highscores[pageTable[i]].score
				
				if highscores[pageTable[i]].score >= starTable[pageTable[i]].goldScore then
					gainedStars = gainedStars + 3
				elseif highscores[pageTable[i]].score >= starTable[pageTable[i]].silverScore then
					gainedStars = gainedStars + 2
				else
					gainedStars = gainedStars + 1
				end
			end
			
		end
	end
	
	return totalScore, gainedStars, totalStars
end

function calculateTotalLevelsCompleted(levelTable)
	local totalLevelsCompleted = 0
	
	for k = 1, #levelTable do
		local pageTable = levelTable[k]
		for i = 1, #pageTable do
		
			if highscores[pageTable[i]] ~= nil then
				totalLevelsCompleted = totalLevelsCompleted + 1
			end
		end
	end
	return totalLevelsCompleted
end


function calculateStarsFromGoldenEggLevels()
	stars = 0
	--_G.table.foreach( settings.openGoldenEggLevels, function(k,v) if v == 2 then stars = stars + 1 end end)
	for k, v in _G.pairs(goldenEggLevelMapping) do
		if customer ~= "Intel" then
			if settings.openGoldenEggLevels[k] == 2 then stars = stars + 1 end
		else
			local num = (_G.string.sub(k, 6) + 0)
			if num > 26 then
				if highscores[v] ~= nil and highscores[v].completed then
					stars = stars + 1
				end
			else
				if settings.openGoldenEggLevels[k] == 2 then stars = stars + 1 end
			end
		end
	end
	return stars
end

function calculateOpenGoldenEggLevels()
	count = 0
	_G.table.foreach( settings.openGoldenEggLevels, function(k,v) count = count + 1 end)
	return count
end


--tween ease functions
function tweenLinear (currentTime, startValue, changeOfValue, duration)
	local c = changeOfValue
	local t = currentTime
	local d = duration
	local b = startValue
	return c*t/d + b;
end


function tweenEaseCubicIn(currentTime, startValue, changeOfValue, duration)
	local c = changeOfValue
	local t = currentTime
	local d = duration
	local b = startValue
	t = t/d
	return c*(t)*t*t + b;
end


function tweenEaseCubicOut(currentTime, startValue, changeOfValue, duration)
	local c = changeOfValue
	local t = currentTime
	local d = duration
	local b = startValue
	t = t/d-1
	return c*((t)*t*t + 1) + b;
end


function tweenEaseCubicInOut(currentTime, startValue, changeOfValue, duration)
	
	local c = changeOfValue
	local t = currentTime
	local d = duration
	local b = startValue

	t = t / (d/2);
	if (t < 1) then
		return (c/2) * (t*t*t) + b;  
	end 
	t = t-2
	return (c/2) * (t*t*t + 2) + b;

end


--the ignore reference flag indicates that the item will not take the reference objects coordinates
--into consideration when drawing
function prepareItemForMouseScalingStates(item, referenceCollisionItem, ignoreReference, ignoreCursorInput)
	if g_enableMouseOverStates ~= true then
		return
	end
	
	item.mouseStateTime = 0
	item.mouseStateTargetTime = 0.15
	item.mouseStateTargetScale = 1.1
	--the possible states are up, down,over, overIn, overOut
	item.mouseState = "up"
	--item.tweenFunction = tweenEaseCubicOut
	item.tweenFunction = tweenLinear
	
	if referenceCollisionItem == nil then
		referenceCollisionItem = item
	end
	
	local t_w, t_h = _G.res.getSpriteBounds(referenceCollisionItem.sheet or "", referenceCollisionItem.sprite)
	local t_px, t_py = _G.res.getSpritePivot(referenceCollisionItem.sheet or "", referenceCollisionItem.sprite)
	
	local t_xs = referenceCollisionItem.xs or 1
	local t_ys = referenceCollisionItem.ys or 1
	
	item.mouseStateAreaWidth = t_w * t_xs
	item.mouseStateAreaHeight = t_h * t_ys
	item.mouseStateAreaPivotX = t_px * t_xs
	item.mouseStateAreaPivotY = t_py * t_ys
	item.mouseStateReferenceItem = referenceCollisionItem		
	
	if ignoreCursorInput == true then
		item.ignoreCursorInput = true
	else
		item.ignoreCursorInput = false
	end		
	
	if ignoreReference == true then
		item.mouseStateReferenceItem = item
	end
	
end

function prepareItemForHoveringStates(item, referenceCollisionItem, spriteUp, spriteOver, spriteDown, ignoreReference)
	if g_enableMouseOverStates ~= true then
		return
	end
	
	item.mouseStateTime = 0
	item.mouseStateTargetTime = 0.15
	item.mouseStateTargetScale = 1.1
	--the possible states are up, down,over, overIn, overOut
	item.mouseState = "up"
	--item.tweenFunction = tweenEaseCubicOut
	item.tweenFunction = tweenLinear
	
	if referenceCollisionItem == nil then
		referenceCollisionItem = item
	end
	
	local t_w, t_h = _G.res.getSpriteBounds(referenceCollisionItem.sheet or "", referenceCollisionItem.sprite)
	local t_px, t_py = _G.res.getSpritePivot(referenceCollisionItem.sheet or "", referenceCollisionItem.sprite)
	
	local t_xs = referenceCollisionItem.xs or 1
	local t_ys = referenceCollisionItem.ys or 1
	
	item.mouseStateAreaWidth = t_w * t_xs
	item.mouseStateAreaHeight = t_h * t_ys
	item.mouseStateAreaPivotX = t_px * t_xs
	item.mouseStateAreaPivotY = t_py * t_ys
	item.mouseStateReferenceItem = referenceCollisionItem	

	item.useSprites = true
	
	item.spriteUp = spriteUp
	item.spriteOver = spriteOver
	item.spriteDown = spriteDown
	
	if ignoreReference == true then
		item.mouseStateReferenceItem = item
	end
	
end


--this function will calculate the final clipping area of the level selection buttons, 
--referenceX, referenceY, referenceWidth and referenceHeight are the desired coordinates and dimensions based on the mockups
function calculateLevelSelectionClippingArea()
	local t_referenceScreenWidth = 1920
	local t_referenceScreenHeight = 1200
	
	local t_overlayW, t_overlayH = _G.res.getSpriteBounds("", "LS_CLIP_AREA")	
	
	local t_width = (t_overlayW / t_referenceScreenWidth) * screenWidth
	local t_height = (t_overlayH / t_referenceScreenHeight) * screenHeight	
	local t_y = (330 / t_referenceScreenHeight) * screenHeight
	
	local t_spriteName = "LS_LEVEL_BG_NORMAL_OPEN_HD_1"
	
	if screenWidth  < 1920 or (g_levelSelectionMultipleAssets ~= true) then
		t_spriteName = "LS_LEVEL_BG_NORMAL_OPEN_1"
	end
	
	
	
	local t_spriteWidth, t_spriteHeight = _G.res.getSpriteBounds("", t_spriteName)
	
	local t_offsetX = 20
	local t_offsetY = 20
	--65 found by measuring mockup
	local t_maxSpacingX = t_spriteWidth + 65 
	--80 found by measuring mockup
	local t_maxSpacingY = t_spriteHeight + 80 
	
	if deviceModel == "roku" and screenHeight <= 576 then
		t_maxSpacingX = t_spriteWidth  + 20
		t_maxSpacingY = t_spriteHeight + 70
	end
	
	local t_minSpacingX = t_spriteWidth + 40 
	local t_minSpacingY = t_spriteHeight + 80 
	
	if screenWidth  < 1920 or (g_levelSelectionMultipleAssets ~= true) then
		t_minSpacingX = t_spriteWidth + 20 
		t_minSpacingY = t_spriteHeight + 60 
	end
	
	
	
	local t_maxItemsPerRow = 7
	local t_maxItemsPerCol = 3
	
	local t_referenceSpacingX = t_width / (t_maxItemsPerRow - 1)
	local t_referenceSpacingY = t_height / (t_maxItemsPerCol - 1)
	
	local t_finalSpaceX = _G.math.min(t_maxSpacingX, t_referenceSpacingX)
	t_finalSpaceX = _G.math.max(t_minSpacingX, t_finalSpaceX)
	
	local t_finalSpaceY = _G.math.min(t_maxSpacingY, t_referenceSpacingY)
	t_finalSpaceY = _G.math.max(t_minSpacingY, t_finalSpaceY)
	
	local t_finalWidth = t_finalSpaceX * (t_maxItemsPerRow - 1)	
	local t_finalHeight = t_finalSpaceY * (t_maxItemsPerCol - 1)
	
	g_levelSelectionClippingArea = {x = (screenWidth * 0.5) - (t_finalWidth * 0.5), 
									y = t_y, width = t_finalWidth, height = t_finalHeight, offsetX = t_offsetX, offsetY = t_offsetY}
	
	if deviceModel == "roku" and screenHeight <= 576 then
		--g_levelSelectionClippingArea.y = g_levelSelectionClippingArea.y - 40
	end
	
	--g_levelSelectionClippingArea = {x = referenceX, y = t_y, width = t_width, height = t_height, offsetX = t_offsetX, offsetY = t_offsetY}
	
end



-- prepare current menu page when it is set as active page
function prepareMenuPage(page)
	--print("Preparing menu page: " .. _G.tostring(page.name or nil) .. "\n")
		
	
	
	if page == nil then
		return
	end
		
	if page.backgroundOverlay ~= nil and page ~= loadingPage then
		page.backgroundOverlay.shade = 0
	end
	
	if page == loadingPage then
		local loadingText = getItemByName(page.items, "loadingText")
		loadingText.x, loadingText.y = screenWidth / 2, screenHeight / 2
	end
	
	-- page specific controls
	
	--even though we are calculating dynamically the sizes and positions, some minor tweaks on the play button must be taken
	local t_playButtonPosYRatio = {iphone = 0.59, windows = 0.50, ipad = 0.52}
	
	if page == mainMenu then
	
		if settings.currentMainMenuTheme and settings.currentZoomLevelMainMenu then
			currentMainMenuTheme = settings.currentMainMenuTheme
			currentZoomLevelMainMenu = settings.currentZoomLevelMainMenu
		else
			currentMainMenuTheme = "theme1"
			currentZoomLevelMainMenu = 1.83
			settings.currentZoomLevelMainMenu = 1.83
		end
		
		if isLiteVersion then
			currentMainMenuTheme = "theme1"
		end	
		
		releaseImages( {"SPLASHES"} )
		
		mainMenu.menuButton = about
		
		mainMenuBGParallaxw, mainMenuBGParallaxh = _G.res.getSpriteBounds("", "MENU_LAYER_5")
		mainMenu.state = "READY"
		
		local sw, sh = _G.res.getSpriteBounds("", getItemByName(page.items, "credits").sprite)
		local smallSw, smallSh = _G.res.getSpriteBounds("", getItemByName(page.items, "facebook").sprite)
		
		local play = getItemByName(page.items, "play")
		--play.x, play.y = screenWidth * 0.5, screenHeight * 0.59
		play.x = screenWidth * 0.5
		
		--[[
		if t_playButtonPosYRatio[deviceModel] then
			play.y = screenHeight * t_playButtonPosYRatio[deviceModel]
		else
			play.y = screenHeight * t_playButtonPosYRatio["iphone"]
		end
		]]
		play.y = screenHeight * 0.5
		
		prepareItemForMouseScalingStates(play)
		
		local t_buttonSliderOffset = -30
		local buttonSliderBG = getItemByName(page.items, "buttonSliderBG")
		local bsW, bsH = _G.res.getSpriteBounds("", buttonSliderBG.sprite)
		buttonSliderBG.x, buttonSliderBG.y = screenWidth - bsW * 0.55, screenHeight - bsH * 0.55
		buttonSliderBG.x = buttonSliderBG.x + t_buttonSliderOffset
		
		
		prepareItemForMouseScalingStates(buttonSliderBG)
		
		
		local buttonSlider = getItemByName(page.items, "buttonSlider")
		buttonSlider.x, buttonSlider.y = buttonSliderBG.x, buttonSliderBG.y
		
		prepareItemForMouseScalingStates(buttonSlider, buttonSliderBG)
		
		local t_optionsButtonOffsetX = -130
		
		local buttonSliderBGOptions = getItemByName(page.items, "buttonSliderBGOptions")
		local bsOW, bsOH = _G.res.getSpriteBounds("", buttonSliderBGOptions.sprite)
		buttonSliderBGOptions.x, buttonSliderBGOptions.y = bsOW * 0.55, screenHeight - bsOW * 0.55
		buttonSliderBGOptions.x = buttonSliderBG.x + t_optionsButtonOffsetX
		
		local buttonSliderOptions = getItemByName(page.items, "buttonSliderOptions")
		buttonSliderOptions.x, buttonSliderOptions.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		
		prepareItemForMouseScalingStates(buttonSliderBGOptions)
		prepareItemForMouseScalingStates(buttonSliderOptions, buttonSliderBGOptions)
		
		local buttonQuit = getItemByName(page.items, "buttonQuit")
		local t_quitOffsetX = 60
		local t_quitOffsetY = -35
		buttonQuit.x = t_quitOffsetX
		buttonQuit.y = screenHeight + t_quitOffsetY
		
		prepareItemForMouseScalingStates(buttonQuit)
		
		if deviceModel == "roku" then
			buttonSliderBG.visible = false
			buttonSlider.visible   = false
			buttonSliderBGOptions.x = screenWidth  - bsOW + 5
			buttonSliderBGOptions.y = screenHeight - bsOH + 17
			buttonSliderOptions.x   = buttonSliderBGOptions.x
			buttonSliderOptions.y   = buttonSliderBGOptions.y
			buttonQuit.visible = false
		end
	
		local sliderBGRight = getItemByName(page.items, "sliderBGRight")
		sliderBGRight.x, sliderBGRight.y = buttonSliderBG.x, buttonSliderBG.y
		sliderBGRight.visible = false
		sliderBGRight.width, sliderBGRight.height = bsW * 0.5, 0
		sliderBGRight.maxHeight = bsH / 4
		
		local sliderBGLeft = getItemByName(page.items, "sliderBGLeft")
		sliderBGLeft.x, sliderBGLeft.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		sliderBGLeft.visible = false
		sliderBGLeft.width, sliderBGLeft.height = bsW * 0.5, 0
		sliderBGLeft.maxHeight = bsOH / 4
		--sliderBGLeft.maxHeight = bsOH * 0.25
		
		local buttonUpdateAvailable = getItemByName(page.items, "buttonUpdateAvailable")				
		
		buttonUpdateAvailable.x = 175
		buttonUpdateAvailable.y = buttonSliderBGOptions.y
		buttonUpdateAvailable.visible = deviceModel == "windows" and g_updateCheckFlags.enabled == true and 
										settings.updateNotification.updateNotified == true
		
		prepareItemForMouseScalingStates(buttonUpdateAvailable)
		
		local buttonActivation = getItemByName(page.items, "buttonActivateFullVersion")						
		buttonActivation.x = screenWidth * 0.5
		buttonActivation.y = screenHeight - 60		
		buttonActivation.visible = 	deviceModel == "windows" and g_registrationEnabled == true and
									g_isGameUnlocked == false
		
		prepareItemForMouseScalingStates(buttonActivation)
		
		-- buttonActivation.visible = true
		-- buttonUpdateAvailable.visible = true
		
		for i = 1, #buttonSliderBG.elements do
			sw, sh = _G.res.getSpriteBounds("", buttonSliderBG.elements[i].sprite)
			sliderBGRight.maxHeight = sliderBGRight.maxHeight + sh
			buttonSliderBG.elements[i].yPos = buttonSliderBG.y - sliderBGRight.maxHeight
		end
		
		for i = 1, #buttonSliderBGOptions.elements do
			sw, sh = _G.res.getSpriteBounds("", buttonSliderBGOptions.elements[i].sprite)
			sliderBGLeft.maxHeight = sliderBGLeft.maxHeight + sh
			buttonSliderBGOptions.elements[i].yPos = buttonSliderBGOptions.y - sliderBGLeft.maxHeight
		end
		
		sliderBGRight.maxHeight = sliderBGRight.maxHeight + sh / 2
		sliderBGLeft.maxHeight = sliderBGLeft.maxHeight + sh / 2
		
		local credits = getItemByName(page.items, "credits")
		credits.x, credits.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		prepareItemForMouseScalingStates(credits)
		
		local sfx = getItemByName(page.items, "sfx")
		sfx.x, sfx.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		prepareItemForMouseScalingStates(sfx)
		
		local buttonOff = getItemByName(page.items, "buttonOff")
		buttonOff.x, buttonOff.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		prepareItemForMouseScalingStates(buttonOff, sfx)
		
		local buttonFullScreen = getItemByName(page.items, "fullScreen")
		buttonFullScreen.x, buttonFullScreen.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		prepareItemForMouseScalingStates(buttonFullScreen)
		
		local menuOvi = getItemByName(page.items, "menuOvi")
		menuOvi.x, menuOvi.y = buttonSliderBG.x, buttonSliderBG.y
		
		local menuLogo = getItemByName(page.items, "menuLogo")
		menuLogo.x, menuLogo.y = screenWidth * 0.5, screenHeight * 0.021875
		
		local lite = getItemByName(page.items, "logoLite")
		lite.x, lite.y = menuLogo.x, menuLogo.y
		if isBetaVersion and deviceModel == "android" then
			lite.sprite = "LITE_LOGO"
		end
		
		local trailer = getItemByName(page.items, "trailer")
		trailer.x, trailer.y = buttonSliderBG.x, buttonSliderBG.y
		prepareItemForMouseScalingStates(trailer)
		
		local appStore = getItemByName(page.items, "appStore")
		appStore.x, appStore.y = trailer.x - sw / 2, trailer.y - sh
		
		local facebook = getItemByName(page.items, "facebook")
		facebook.x, facebook.y = buttonSliderBG.x, buttonSliderBG.y
		prepareItemForMouseScalingStates(facebook)
		
		local twitter = getItemByName(page.items, "twitter")
		twitter.x, twitter.y = buttonSliderBG.x, buttonSliderBG.y
		prepareItemForMouseScalingStates(twitter)
		
		if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
			local crystal = getItemByName(page.items, "crystal")
			crystal.x, crystal.y = buttonSliderBG.x, buttonSliderBG.y
		end
		
		if deviceModel == "android" or deviceModel == "palm" then
			if isBetaVersion then
				local reportBug = getItemByName(page.items, "reportBug")
				reportBug.x, reportBug.y = buttonSliderBG.x, buttonSliderBG.y
			end
		end
		
		if buttonSliderBG.state == "open" then
			for i = 1, #buttonSliderBG.elements do
				local item = getItemByName(mainMenu.items, buttonSliderBG.elements[i].name) 
				item.y, item.visible = buttonSliderBG.elements[i].yPos, true
			end
			sliderBGRight.height = sliderBGRight.maxHeight
			sliderBGRight.visible = true
		end
		
		if buttonSliderBGOptions.state == "open" then
			for i = 1, #buttonSliderBGOptions.elements do
				local item = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name) 
				item.y, item.visible = buttonSliderBGOptions.elements[i].yPos, true
				if item.name == "sfx" then
					buttonOff.y = item.y
				end
			end
			sliderBGLeft.height = sliderBGLeft.maxHeight
			sliderBGLeft.visible = true
		end
		
		if gameCenterSupported then
			local leaderboards = getItemByName(page.items, "leaderboards")
			leaderboards.x, leaderboards.y = screenWidth / 2 - bsOW / 2, buttonSliderBG.y
			leaderboards.visible = true
			
			local achievements = getItemByName(page.items, "achievements")
			achievements.x, achievements.y = screenWidth / 2 + bsOW / 2, buttonSliderBG.y
			achievements.visible = true
			
			if gameCenterEnabled then
				leaderboards.callFunction = showLeaderboards
				achievements.callFunction = showAchievements
			else
				leaderboards.callFunction = initGameCenter
				achievements.callFunction = initGameCenter
			end
		end	
		
		if deviceModel == "n900" then
			menuOvi.visible = true
		else
			if isLiteVersion then
				settings.currentLevelSelectionPages.basic = 1
				play.updateFunction = gotoLevelSelection
				play.page = nil
				lite.visible = true
				if deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad" then
					appStore.visible = true
				end
			end
		end
		
		local unlockLevels = getItemByName(page.items, "unlockLevels")
		unlockLevels.x, unlockLevels.y = screenWidth, screenHeight * 0.1
		local lockLevels = getItemByName(page.items, "lockLevels")
		lockLevels.x, lockLevels.y = screenWidth, screenHeight * 0.1

		local resetMightyEagle = getItemByName(page.items, "resetMightyEagle")
		resetMightyEagle.x, resetMightyEagle.y = 0, 0
		if settings.mightyEagleEnabled == true then
			resetMightyEagle.visible = true
		else
			resetMightyEagle.visible = false
		end
		
		if showEditor then
			local editor = getItemByName(page.items, "editor")
			editor.x, editor.y = screenWidth * 0.75, screenHeight * 0.75
			if showEditor then
				editor.visible = true
			else 
				editor.visible = false
			end
		end
				
		if deviceModel == "s60" then
			local oviButton = getItemByName(page.items, "oviButton")
			oviButton.x, oviButton.y = trailer.x - sw, trailer.y
			local unlockLevels = getItemByName(page.items, "unlockLevels")
			unlockLevels.x, unlockLevels.y = screenWidth, screenHeight * 0.1
			local lockLevels = getItemByName(page.items, "lockLevels")
			lockLevels.x, lockLevels.y = screenWidth, screenHeight * 0.1
			unlockLevels.visible = releaseBuild
			lockLevels.visible = not releaseBuild
		else
			unlockLevels.visible = false
			lockLevels.visible = false
			resetMightyEagle.visible = false
		end
		
		if settings.audioEnabled ~= false then
			buttonOff.visible = false
		else
			buttonOff.visible = true
		end
		
		birdSprites = {}
		if settings.tutorials ~= nil then
			for k, v in _G.pairs(settings.tutorials) do
				_G.table.insert(birdSprites, { sprite = k , sheet = "INGAME_BIRDS_1", reward = 0 })
			end
		end
		
		if #birdSprites == 0 then
			_G.table.insert(birdSprites, { sprite = "BIRD_RED", sheet = "INGAME_BIRDS_1", reward = 0 })
		end
		
		if settings.gameCompleted then
			if not isLiteVersion then
				if settings.threeStars then
					_G.table.insert(birdSprites, { sprite = "REWARD_1_STAR", sheet = "MENU_ELEMENTS_1", reward = 1})
					_G.table.insert(birdSprites, { sprite = "REWARD_1_STAR", sheet = "MENU_ELEMENTS_1", reward = 1})
				else
					_G.table.insert(birdSprites, { sprite = "REWARD_1", sheet = "MENU_ELEMENTS_1", reward = 1})
					_G.table.insert(birdSprites, { sprite = "REWARD_1", sheet = "MENU_ELEMENTS_1", reward = 1})
				end
			end
		end
		
		if settings.theme5Completed then
			if settings.threeStarsLP2 then
				_G.table.insert(birdSprites, { sprite = "REWARD_2_STAR", sheet = "MENU_ELEMENTS_1", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_2_STAR", sheet = "MENU_ELEMENTS_1", reward = 1})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_2", sheet = "MENU_ELEMENTS_1", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_2", sheet = "MENU_ELEMENTS_1", reward = 1})
			end
		end
		
		if settings.theme8Completed then
			if settings.threeStarsLP3 then
				_G.table.insert(birdSprites, { sprite = "REWARD_3_STAR", sheet = "MENU_ELEMENTS_1", reward = 2})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_3", sheet = "MENU_ELEMENTS_1", reward = 2})
			end
		end
		
		if settings.theme11Completed then
			if settings.threeStarsLP4 then
				_G.table.insert(birdSprites, { sprite = "REWARD_4_STAR", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_4_STAR", sheet = "", reward = 1})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_4", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_4", sheet = "", reward = 1})
			end
		end
		
		if settings.theme14Completed then
			if settings.threeStarsLP5 then
				_G.table.insert(birdSprites, { sprite = "REWARD_5_STAR", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_5_STAR", sheet = "", reward = 1})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_5", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_5", sheet = "", reward = 1})
			end
		end
		
		-- enable when the REWARD_6(_STAR) sprites are added
		--[[if settings.theme17Completed then
			if settings.threeStarsLP6 then
				_G.table.insert(birdSprites, { sprite = "REWARD_6_STAR", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_6_STAR", sheet = "", reward = 1})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_6", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_6", sheet = "", reward = 1})
			end
		end]]
		
		if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
			checkForAchievements()
		end
		
	--[[	if settings.crystalSplashShown ~= true then
			showCrystalSplash()
			checkForCrystalEnabled = true
			settings.crystalSplashShown = true
		end ]]
		
		if deviceModel == "n900" or deviceModel == "s60" or deviceModel == "android" or deviceModel == "windows" or deviceModel == "osx"then
			mainMenu.back = areYouSurePage
		end
		
		birdSpriteSoundMapping = { BIRD_RED = "bird_01_flying", BIRD_BLUE = "bird_02_flying", 
								   BIRD_YELLOW = "bird_03_flying", BIRD_GREY = "bird_04_flying",
								   BIRD_GREEN = "bird_05_flying", BIRD_BIG_BROTHER = "big_brother_flying",
								   BIRD_BOOMERANG = "bird_06_flying"
								 }
		
	end
	
	if page == betaDisclaimerPage then
		local bg = page.backgroundBox
		bg.x, bg.y = screenWidth / 2, screenHeight / 2
		local disclaimerText = getItemByName(page.items, "disclaimerText")
		disclaimerText.textBoxSize = screenWidth / 2
		prepareTextItem(page, disclaimerText)
		local fl = _G.res.getFontLeading()
		bg.width, bg.height = screenWidth / 2, (#clippedText.lines + 1) * fl
		disclaimerText.x, disclaimerText.y = screenWidth / 2, screenHeight / 2
		
		local okButton = getItemByName(page.items, "okButton")
		local sw, sh = _G.res.getSpriteBounds("", okButton.sprite)
		okButton.x, okButton.y = bg.x + bg.width / 2 - sw / 2, bg.y + bg.height / 2 + sh / 4
		
		local hideArea1 = getItemByName(page.items, "hideArea1")
		hideArea1.x, hideArea1.y = 0, 0
		hideArea1.w, hideArea1.h = (screenWidth - bg.width) / 2, screenHeight
		
		local hideArea2 = getItemByName(page.items, "hideArea2")
		hideArea2.x, hideArea2.y = 0, 0
		hideArea2.w, hideArea2.h = screenWidth, (screenHeight - bg.height) / 2
		
		local hideArea3 = getItemByName(page.items, "hideArea3")
		hideArea3.x, hideArea3.y = screenWidth - hideArea1.w, 0
		hideArea3.w, hideArea3.h = hideArea1.w, screenHeight
		
		local hideArea4 = getItemByName(page.items, "hideArea4")
		hideArea4.x, hideArea4.y = 0, screenHeight - hideArea2.h
		hideArea4.w, hideArea4.h = screenWidth, hideArea2.h
	end	
	
	if page == areYouSurePage then
		
		local bg = page.backgroundBox
		bg.x, bg.y = screenWidth / 2, screenHeight / 2
		local fl = _G.res.getFontLeading()
		local areYouSureText = getItemByName(page.items, "areYouSureText")
		areYouSureText.x, areYouSureText.y = screenWidth / 2, screenHeight / 2 - fl / 6
		
		areYouSureText.text = _G.res.getString("TEXTS_BASIC", "TEXT_EXIT_CONFIRM")
		
		setFont(areYouSureText.font)
		
		local okButton = getItemByName(page.items, "buttonYes")
		local sw, sh = _G.res.getSpriteBounds("", okButton.sprite)
		bg.width, bg.height = _G.res.getStringWidth(areYouSureText.text), _G.math.max(2 * fl, sw) 
	
		okButton.x, okButton.y = (screenWidth / 2) + bg.width / 2 - sw / 1.5, screenHeight / 2 + bg.height / 2 + sh / 6		
		
		local noButton = getItemByName(page.items, "buttonNo")		
		noButton.x, noButton.y = screenWidth / 2 - bg.width / 2 + sw / 1.5, screenHeight / 2 + bg.height / 2 + sh / 6	

		prepareItemForMouseScalingStates(noButton)
		prepareItemForMouseScalingStates(okButton)
		
	end
	
	if page == g_updateNotificationScreen then
		
		local bg = page.backgroundBox
		bg.x, bg.y = screenWidth / 2, screenHeight / 2
		local fl = _G.res.getFontLeading()
		local areYouSureText = getItemByName(page.items, "updateText")
		areYouSureText.x, areYouSureText.y = screenWidth / 2, screenHeight / 2 - fl / 6
		
		-- areYouSureText.text = _G.res.getString("TEXTS_BASIC", "TEXT_EXIT_CONFIRM")
		
		setFont(areYouSureText.font)
		
		local okButton = getItemByName(page.items, "buttonYes")
		local sw, sh = _G.res.getSpriteBounds("", okButton.sprite)
		-- bg.width, bg.height = _G.res.getStringWidth(areYouSureText.text), _G.math.max(2 * fl, sw) 
		bg.width, bg.height = 550, 150
	
		okButton.x, okButton.y = (screenWidth / 2) + bg.width / 2 - sw / 1.5, screenHeight / 2 + bg.height / 2 + sh / 6		
		
		local noButton = getItemByName(page.items, "buttonNo")		
		noButton.x, noButton.y = screenWidth / 2 - bg.width / 2 + sw / 1.5, screenHeight / 2 + bg.height / 2 + sh / 6	

		prepareItemForMouseScalingStates(noButton)
		prepareItemForMouseScalingStates(okButton)
		
	end
	
	if page == invalidResolutionPage then
		local bg = page.backgroundBox
		bg.x, bg.y = screenWidth / 2, screenHeight / 2
		local fl = _G.res.getFontLeading()
		local areYouSureText = getItemByName(page.items, "areYouSureText")
		areYouSureText.x, areYouSureText.y = screenWidth / 2, screenHeight / 2 - fl / 6
		setFont(areYouSureText.font)
		
		local t_boxMinWidth = 350
		areYouSureText.textBoxSize = _G.math.max(t_boxMinWidth, screenWidth * 0.5)
		
		--found this value by experimenting, a box this big should be acceptable for all invalid resolutions
		areYouSureText.textBoxSize = 350
		
		local okButton = getItemByName(page.items, "buttonYes")
		local sw, sh = _G.res.getSpriteBounds("", okButton.sprite)
		--bg.width, bg.height = _G.res.getStringWidth(areYouSureText.text), _G.math.max(2 * fl, sw) 
		bg.width, bg.height = 800, _G.math.max(4 * fl, sw) 
		local t_boxSizeOffsetX = 50
		bg.width = t_boxMinWidth + t_boxSizeOffsetX
		
		--found those values by experimenting, a box this big should be acceptable for all invalid resolutions
		bg.width, bg.height = 400, 112
		bg.width, bg.height = 400, 150
		
		--okButton.x, okButton.y = (screenWidth / 2) + bg.width / 2 - sw / 1.5, screenHeight / 2 + bg.height / 2 + sh / 6		
		okButton.x, okButton.y = (screenWidth / 2), screenHeight / 2 + bg.height / 2 + sh / 6	
		
		prepareItemForMouseScalingStates(okButton)
		areYouSureText.text = _G.res.getString("TEXTS_BASIC", "TEXT_TOO_LOW_RESOLUTION")
		--areYouSureText.text = _G.res.getString("", "TEXT_TOO_LOW_RESOLUTION")
		--areYouSureText.text = "Minimum 1024x768 resolution is needed for optimal gameplay experience."
		
		page.enablePhysicsWhenDone = isPhysicsEnabled()
		setPhysicsEnabled(false)
	end
	
	if page == mightyEaglePurchasePage then
		local whiteBackground = page.backgroundBox
		
		whiteBackground.x, whiteBackground.y = screenWidth / 2, screenHeight / 2
		whiteBackground.width, whiteBackground.height = 0.47 * screenWidth, 0.83 * screenHeight
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = screenWidth / 2, screenHeight / 2
		end
	end
	
	if page == mightyEagleDemoPage then
		local demoBackground = page.backgroundBox
		local buttonOk = getItemByName(page.items, "buttonOk")
		local wButton, hButton = _G.res.getSpriteBounds("", buttonOk.sprite)
		local eagle = getItemByName(page.items, "eagle")
		
		demoBackground.x, demoBackground.y = screenWidth / 2, screenHeight / 2
		demoBackground.width, demoBackground.height = 35 * screenWidth / 64, screenHeight / 2
		
		buttonOk.x, buttonOk.y = screenWidth / 2 + 0.25 * screenWidth, screenHeight / 2 + demoBackground.height / 2 + hButton / 2
		eagle.x, eagle.y = screenWidth / 2, screenHeight / 2
	end
	
	if page == mightyEaglePaymentPage then
		local whiteBackground = page.backgroundBox
		
		whiteBackground.x, whiteBackground.y = screenWidth / 2, screenHeight / 2
		whiteBackground.width, whiteBackground.height = 0.47 * screenWidth, 0.83 * screenHeight
		
		page.items[3].angle = 0
		page.items[2].visible = true
		page.items[4].visible = false
		page.items[5].visible = false
		
		for i = 1, #page.items do
			if page.items[i].name == "confirming" then
				page.items[i].x, page.items[i].y = screenWidth / 2, screenHeight / 2 + 0.06 * screenHeight
			else
				page.items[i].x, page.items[i].y = screenWidth / 2, screenHeight / 2
			end
		end
	end
	
	
	if page == levelComplete then
	
		local background = getItemByName(page.items, "background")
		local _, bh = _G.res.getSpriteBounds(background.sheet, background.box.topMiddle)
		local _, bottomH = _G.res.getSpriteBounds(background.sheet, background.box.bottomMiddle)
		local bw, _ = _G.res.getSpriteBounds(background.sheet, background.box.left)
		local _, bottomBorderH = _G.res.getSpriteBounds(background.sheet, background.box.bottomMiddle)
		local buttonMenu = getItemByName(page.items, "buttonMenu")
		prepareItemForMouseScalingStates(buttonMenu)
		local buttonW, buttonH = _G.res.getSpriteBounds("", buttonMenu.sprite)
		local levelComplete = getItemByName(page.items, "levelComplete")
		local score = getItemByName(page.items, "score")
		prepareTextItem(page, score)
		local scoreNumber = getItemByName(page.items, "scoreNumber")
		prepareTextItem(page, scoreNumber)
		local newHighScore = getItemByName(page.items, "newHighScore")
		local newHighScoreW, newHighScoreH = _G.res.getSpriteBounds("", newHighScore.sprite)
		
		local levelNumber = getItemByName(page.items, "levelNumber")
		if deviceModel == "roku" and screenHeight <= 576 then
			levelNumber.font = "FONT_SCORE"
		end
		prepareTextItem(page, levelNumber)
		local highScoreNumber = getItemByName(page.items, "highScoreNumber")
		local highScoreText = getItemByName(page.items, "highScoreText")
		prepareTextItem(page, highScoreNumber)
		prepareTextItem(page, highScoreText)
		background.x, background.y = screenWidth * 0.5, screenHeight * 0.5 + highScoreText.h
		background.width = buttonW * 3.8
		if background.width < newHighScoreW * 2.8 then
			background.width = newHighScoreW * 2.8
		end
		-- simple hack to solve the problem of a too small window
		if deviceModel == "roku" then
			background.width = _G.math.max(buttonW * 4.5, newHighScoreW * 3.5)
		end
		
		local t_backgroundRealWidth = g_popupBorderRealWidth + background.width
		local t_spacing = ((t_backgroundRealWidth - (g_popupButtonRealWidth * 3) ) / 4)
		local t_startX = background.x - (t_backgroundRealWidth/2) + t_spacing + (g_popupButtonRealWidth / 2)
		local t_buttonSpacing =  t_spacing + g_popupButtonRealWidth
		
		prepareTextItem(page, levelComplete)
		
		
		if #levelComplete.lines >= 2 and levelComplete.w < screenWidth * 0.8 then
			levelComplete.textBoxSize = background.width * 0.8
		else
			levelComplete.textBoxSize = background.width * 0.55
		end
		background.height = levelComplete.h + score.h * 1.5 + scoreNumber.h + buttonH * 0.7
		if background.height < newHighScoreH + buttonH * 0.4 then
			background.height = newHighScoreH + buttonH * 0.4
		end
		
		background.height = background.height + g_popupBoxHeightOffset
		
		
						
		local highScoreNumber = getItemByName(page.items, "highScoreNumber")
		local highScoreText = getItemByName(page.items, "highScoreText")
		prepareTextItem(page, highScoreNumber)
		prepareTextItem(page, highScoreText)
		
		
		
		
		
		local backgroundTop = page.backgroundBox
		local btw, bth = _G.res.getSpriteBounds(background.sheet, backgroundTop.sprites.topMiddle)
		backgroundTop.x, backgroundTop.y = background.x, background.y - background.height * 0.5
		backgroundTop.width, backgroundTop.height = background.width - bw * 0.5, bh * 0.7 + highScoreText.h * 3 - bth  + g_levelPopUpsTopBackgroundHeightOffset
		
		levelNumber.x, levelNumber.y = backgroundTop.x - backgroundTop.width * 0.5 + buttonW * 0.1, backgroundTop.y - bh * 0.7 - (backgroundTop.height - bh * 0.7 + bth) * 0.5
			
		score.x, score.y = levelNumber.x, background.y - buttonH * 0.15
		score.y = score.y +	g_popupLevelClearedScoreLabelOffsetY
		
		levelComplete.x, levelComplete.y = score.x, score.y - levelComplete.h - score.h * 1.5		
		
	
		levelComplete.y = levelComplete.y + g_popupLevelClearedLabelOffsetY
		
		--hack. I really couldnt find out where is the level completed card is setup differently for the golden eggs
		--the flow should enter this clause on the golden eggs card
		if levelComplete.h ~= 29 then
			levelComplete.y = score.y - 29 - score.h * 1.5	
		end
		
		--print("\n XXXXXXXXXXXX preparing menu page y is " .. levelComplete.y .. " " .. score.y .. " " .. levelComplete.h .. " " .. score.h)
		
		prepareTextItem(page, scoreNumber)
		scoreNumber.x, scoreNumber.y = score.x, score.y + scoreNumber.h * 1.1
		scoreNumber.y = scoreNumber.y + g_popupLevelClearedScoreOffsetY
		
		
		local starsCurrent = getItemByName(page.items, "starsCurrent")
		starsCurrent.x, starsCurrent.y = scoreNumber.x + scoreNumber.w, scoreNumber.y
		
		local stars = getItemByName(page.items, "stars")
		local starsW, starsH = _G.res.getSpriteBounds("", stars.sprite)
		highScoreNumber.x, highScoreNumber.y = backgroundTop.x + backgroundTop.width * 0.5 - starsW - buttonW * 0.1, ((backgroundTop.y - bh * 0.7) + (backgroundTop.y - backgroundTop.height - bth)) * 0.5 + highScoreText.h * 1.2
		highScoreNumber.y = highScoreNumber.y + g_popupHighScoreYOffset
		
		stars.x, stars.y = highScoreNumber.x, highScoreNumber.y - highScoreNumber.h * 0.6
		
		highScoreText.x, highScoreText.y = highScoreNumber.x + starsW - (starsW + highScoreNumber.w) * 0.5, highScoreNumber.y - highScoreNumber.h * 1.1
		highScoreText.y = highScoreText.y + g_popupHighScoreLabelYOffset
		
		newHighScore.x, newHighScore.y = background.x + background.width * 0.5 - newHighScoreW * 0.5 - buttonH * 0.1, background.y
				
		prepareTextItem(page, highScoreText)
		local highScoreTextRightSide = highScoreText.x + highScoreText.w * 0.5
		if highScoreTextRightSide > background.x + background.width * 0.5 then
			local move = highScoreTextRightSide - (background.x + background.width * 0.5)
			highScoreNumber.x = highScoreNumber.x - move
			highScoreText.x = highScoreText.x - move
			stars.x = stars.x - move
		end
		
		buttonMenu.x, buttonMenu.y = background.x - background.width * 0.5 + buttonW * 0.5 , background.y + background.height * 0.5 + bottomBorderH * 0.5
		buttonMenu.x = t_startX
		
		local buttonRestart = getItemByName(page.items, "buttonRestart")
		buttonRestart.x, buttonRestart.y = background.x , buttonMenu.y
		buttonRestart.x = t_startX + t_buttonSpacing
		
		prepareItemForMouseScalingStates(buttonRestart)
		
		local buttonNextLevel = getItemByName(page.items, "buttonNextLevel")
		buttonNextLevel.x, buttonNextLevel.y = background.x + background.width * 0.5 - buttonW * 0.5, buttonMenu.y
		buttonNextLevel.x = t_startX + t_buttonSpacing * 2
		
		prepareItemForMouseScalingStates(buttonNextLevel)
		
		-- each cutscene has it's own button
		--for i = 1, 11 do
		
		for i = 1, 17 do
			local tempButton = getItemByName(page.items, "buttonCutscene" .. i)
			tempButton.x, tempButton.y = buttonNextLevel.x, buttonNextLevel.y
			prepareItemForMouseScalingStates(tempButton)
		end
		
		local buttonRio = getItemByName(page.items, "buttonRio")
		buttonRio.x, buttonRio.y = buttonNextLevel.x, buttonNextLevel.y
		prepareItemForMouseScalingStates(buttonRio)
		
		buttonRio.visible = inExtraWorld and currentLevelNumberInTheme == 20
		if deviceModel == "roku" then
			buttonRio.visible = false
		end
		
		
		--local eagleBadge = getItemByName(page.items, "eagleBadge")
		--eagleBadge.x, eagleBadge.y = background.x, background.y - buttonH * 0.15
		
		local totalDestruction = getItemByName(page.items, "totalDestruction")
		totalDestruction.x, totalDestruction.y = background.x, background.y - background.height * 0.5
		
		local eagleScoreNumber = getItemByName(page.items, "eagleScoreNumber")
		prepareTextItem(page, eagleScoreNumber)
		eagleScoreNumber.x, eagleScoreNumber.y = totalDestruction.x + eagleScoreNumber.w * 0.5, totalDestruction.y
		eagleScoreNumber.Text = "0%"
		
		local eagleFeatherEmpty = getItemByName(page.items, "eagleFeatherEmpty")
		eagleFeatherEmpty.x, eagleFeatherEmpty.y = background.x, background.y + buttonH * 0.1
		local eagleFeatherFill = getItemByName(page.items, "eagleFeatherFill")
		eagleFeatherFill.x, eagleFeatherFill.y = eagleFeatherEmpty.x, eagleFeatherEmpty.y
		eagleFeatherFill.fill = 0
		local eagleFeatherFull = getItemByName(page.items, "eagleFeatherFull")
		eagleFeatherFull.x, eagleFeatherFull.y = eagleFeatherEmpty.x, eagleFeatherEmpty.y

		local starEffect = getItemByName(page.items, "starEffect")
		starEffect.x, starEffect.y = eagleFeatherEmpty.x, eagleFeatherEmpty.y
		starEffect.angle = 0
		
		if page.defaultItem ~= nil then
			cursor.x, cursor.y = page.defaultItem.x, page.defaultItem.y
		end
	end
	
	if page == levelFailed then
	
		local background = getItemByName(page.items, "background")
		local _, bh = _G.res.getSpriteBounds(background.sheet, background.box.topMiddle)
		local bw, _ = _G.res.getSpriteBounds(background.sheet, background.box.left)
		local _, bottomBorderH = _G.res.getSpriteBounds(background.sheet, background.box.bottomMiddle)
		local buttonMenu = getItemByName(page.items, "buttonMenu")
		prepareItemForMouseScalingStates(buttonMenu)
		local buttonW, buttonH = _G.res.getSpriteBounds("", buttonMenu.sprite)
		local levelFailed = getItemByName(page.items, "levelFailed")
		
		background.x, background.y = screenWidth * 0.5, screenHeight * 0.6
		levelFailed.x, levelFailed.y = background.x, background.y - buttonH * 0.1
		background.width = buttonW * 3.5
		levelFailed.textBoxSize = background.width
		prepareTextItem(page, levelFailed)
		background.height = levelFailed.h + buttonH * 0.8
		
		local t_backgroundRealWidth = g_popupBorderRealWidth + background.width
		local t_spacing = ((t_backgroundRealWidth - (g_popupButtonRealWidth * 3) ) / 4)
		local t_startX = background.x - (t_backgroundRealWidth/2) + t_spacing + (g_popupButtonRealWidth / 2)
		local t_buttonSpacing =  t_spacing + g_popupButtonRealWidth
		
		
		local levelNumber = getItemByName(page.items, "levelNumber")
		if deviceModel == "roku" and screenHeight <= 576 then
			levelNumber.font = "FONT_SCORE"
		end
		prepareTextItem(page, levelNumber)
		local backgroundTop = page.backgroundBox
		local btw, bth = _G.res.getSpriteBounds(background.sheet, backgroundTop.sprites.topMiddle)
		local highScoreNumber = getItemByName(page.items, "highScoreNumber")
		local highScoreText = getItemByName(page.items, "highScoreText")
		prepareTextItem(page, highScoreText)
		prepareTextItem(page, highScoreNumber)
		
		backgroundTop.x, backgroundTop.y = background.x, background.y - background.height * 0.5
		backgroundTop.width, backgroundTop.height = background.width - bw * 0.5, bh * 0.7 + highScoreText.h * 3 - bth 
		backgroundTop.height = backgroundTop.height + g_levelPopUpsFailTopBackgroundHeightOffset
			
		levelNumber.x, levelNumber.y = backgroundTop.x - backgroundTop.width * 0.5 + buttonW * 0.1, backgroundTop.y - bh * 0.7 - (backgroundTop.height - bh * 0.7 + bth) * 0.5
		
		if deviceModel == "roku" and screenHeight <= 576 and inExtraWorld then
			levelNumber.x = levelNumber.x - 10
		end
		
		setFont("FONT_BIG_NUMBERS")

		
		local t_levelStringWidth = _G.res.getStringWidth(levelNumber.text)
		
		local stars = getItemByName(page.items, "stars")
		local starsW, starsH = _G.res.getSpriteBounds("", "RESULT_STARS_0")
		highScoreNumber.x, highScoreNumber.y = backgroundTop.x + backgroundTop.width * 0.5 - starsW - buttonW * 0.1, levelNumber.y + highScoreText.h * 0.5
		highScoreNumber.y = highScoreNumber.y + g_popupFailHighScoreYOffset
		
		stars.x, stars.y = highScoreNumber.x, highScoreNumber.y
		stars.visible = true
		
		highScoreText.x, highScoreText.y = highScoreNumber.x + starsW - (starsW + highScoreNumber.w) * 0.5, highScoreNumber.y - highScoreNumber.h * 1.1
		prepareTextItem(page, highScoreText)
		
		local highScoreTextRightSide = highScoreText.x + highScoreText.w * 0.5
		if highScoreTextRightSide > background.x + background.width * 0.5 then
			local move = highScoreTextRightSide - (background.x + background.width * 0.5)
			highScoreNumber.x = highScoreNumber.x - move
			highScoreText.x = highScoreText.x - move
			stars.x = stars.x - move
		end
		
		if inExtraWorld == true then
			stars.visible = false
			highScoreNumber.x = highScoreText.x + highScoreNumber.w * 0.5
		end
		
		setFont(fontBasic)
		local t_highScoreStringWidth = _G.res.getStringWidth(highScoreNumber.text)
		
		highScoreText.y = highScoreText.y + g_popupFailHighScoreLabelYOffset
		
		buttonMenu.x, buttonMenu.y = background.x - background.width * 0.5 + buttonW * 0.5, background.y + background.height * 0.5 + bottomBorderH * 0.5
		buttonMenu.x = t_startX
		
		local buttonRestart = getItemByName(page.items, "buttonRestart")
		buttonRestart.x, buttonRestart.y = background.x , buttonMenu.y
		buttonRestart.x = t_startX + t_buttonSpacing
		
		prepareItemForMouseScalingStates(buttonRestart)
		
		local buttonNextLevel = getItemByName(page.items, "buttonNextLevel")
		buttonNextLevel.x, buttonNextLevel.y = background.x + background.width * 0.5 - buttonW * 0.5, buttonMenu.y
		buttonNextLevel.x = t_startX + t_buttonSpacing*2
		
		prepareItemForMouseScalingStates(buttonNextLevel)
		
		local buttonEagle = getItemByName(page.items, "buttonEagle")
		buttonEagle.x, buttonEagle.y = buttonNextLevel.x, buttonNextLevel.y
		
		local buttonEagleLost = getItemByName(page.items, "buttonEagleLost")
		buttonEagleLost.x, buttonEagleLost.y = buttonNextLevel.x, buttonNextLevel.y
		
		local buttonEagleBuy = getItemByName(page.items, "buttonEagleBuy")
		buttonEagleBuy.x, buttonEagleBuy.y = buttonNextLevel.x, buttonNextLevel.y
		
		-- each cutscene has it's own button
		--for i = 1, 11 do
		
		for i = 1, 17 do
			local tempButton = getItemByName(page.items, "buttonCutscene" .. i)
			tempButton.x, tempButton.y = buttonNextLevel.x, buttonNextLevel.y
			prepareItemForMouseScalingStates(tempButton)
		end
		
		--if the texts overlap, increase the box size and recalculate all positions
		if highScoreNumber.x - t_highScoreStringWidth < levelNumber.x + t_levelStringWidth then
			local t_diff = (levelNumber.x + t_levelStringWidth) - (highScoreNumber.x - t_highScoreStringWidth)
			recalculateLevelFailedPositions(page, t_diff)
		end
		
		if page.defaultItem ~= nil then
			cursor.x, cursor.y = page.defaultItem.x, page.defaultItem.y
		end
	end
	
	if page == episodeSelectionPage then
		--if we come back from the level selection screen, the clipping rect would still be the one defined on the level selection drawing method
		_G.res.setClipRect(0, 0, screenWidth, screenHeight)
		local t_useScalableButtons = g_enableMouseOverStates
		
		episodeMenuDragStart = nil
		
		--[[
		for i = 1, page.numEpisodes do
			getItemByName(page.items, "dot" .. i).sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot" .. i).visible = true
		end
		getItemByName(page.items, "dot" .. settings.selectedEpisode).sprite = "LS_DOT_WHITE"
		]]--
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		back.activateOnRelease = true
		
		--local t_backOffsetX = 60
		--local t_backOffsetX = 60
		--local t_backOffsetY = -35
		local t_spriteWidth, t_spriteHeight = _G.res.getSpriteBounds("", "LS_BACK_BUTTON")
		local t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_BACK_BUTTON")
		local t_offsetX, t_offsetY = t_pivotX, -(t_spriteHeight-t_pivotY)
		back.x = t_offsetX
		back.y = screenHeight + t_offsetY
		
		if deviceModel == "roku" then
			back.x = back.x + screenWidth  * 0.05 - 5
			back.y = screenHeight * 0.05 + t_pivotY
		end
		
		prepareItemForMouseScalingStates(back)
		
		--starts relative component positioning 
		local t_referenceScreenWidth = 1920
		local t_referenceScreenHeight = 1200
		--local t_leftNavigation = getItemByName(page.items, "leftNavigation")
		--local t_rightNavigation = getItemByName(page.items, "rightNavigation")
		
		--t_leftNavigation.x, t_leftNavigation.y = (408 / t_referenceScreenWidth) * screenWidth, (562 / t_referenceScreenHeight) * screenHeight
		--t_rightNavigation.x, t_rightNavigation.y= (1515 / t_referenceScreenWidth) * screenWidth, (562 / t_referenceScreenHeight) * screenHeight
		
		
		
		
		local t_title = getItemByName(page.items, "title")
		--t_title.x, t_title.y = screenWidth / 2, (107 / t_referenceScreenHeight) * screenHeight
		t_title.x, t_title.y = screenWidth / 2, (93 / t_referenceScreenHeight) * screenHeight
				
		local t_minDistance = 150
		
		if (g_levelSelectionClippingArea.y - t_title.y) < t_minDistance then
			t_title.y = g_levelSelectionClippingArea.y - t_minDistance
		end
		
		--local t_leftFade = getItemByName(page.items, "leftFade")
		--t_leftFade.useRelativePositioning = true		
		
		--local t_rightFade = getItemByName(page.items, "rightFade")
		--t_rightFade.useRelativePositioning = true	
		
		
		
		--the values below were aquired by measuring on the mockups on a editing tool for the objects which the pivot points do not align to the screen boundaries. 
		--for the other objects that are aligned on screen boundaries or by fractions of it, they were aquired by analyzing the pivots on ggs. Those values represent the location
		--of the sprites on the screen, not taking the pivots into consideration, this way it is easier to scale and align them on any screen resolution
		
		--Some objects need to be scaled equaly on both directions regardless of the screen ratio, like the buttons. For objects like the fading borders, they need to be scaled on
		--both directions so that they match the background correctly
		
		
		--local t_attributes = getSpriteTransforms(0 / t_referenceScreenWidth,  0 / t_referenceScreenHeight, 590 / 1920, 1200 / 1200, "", t_leftFade.sprite)
		--t_leftFade.x, t_leftFade.y, t_leftFade.xs, t_leftFade.ys = t_attributes.x, t_attributes.y, t_attributes.xs, t_attributes.ys
		
		--t_attributes = getSpriteTransforms(1330 / t_referenceScreenWidth,  0 / t_referenceScreenHeight, 591 / 1920, 1200 / 1200, "", t_rightFade.sprite)
		--t_rightFade.x, t_rightFade.y, t_rightFade.xs, t_rightFade.ys = t_attributes.x, t_attributes.y, t_attributes.xs, t_attributes.ys
		
		
		
		--end of relative component positioning 
		
		--the drawing area of the buttons are defined by the boudaries of the fading borders
		--local t_leftFadeRealX = (363 / t_referenceScreenWidth) * screenWidth
		--local t_leftFadeRealY = (353 / t_referenceScreenHeight) * screenHeight
		
		--local t_rightFadeRealX = (1156 / t_referenceScreenWidth) * screenWidth
		--local t_rightFadeRealW = (407 / 1920) * screenWidth
		--local t_fadeRealHeight = (466 / 1200) * screenHeight
		
		--page.drawingArea = {x1 = t_leftFadeRealX, y1 = t_leftFadeRealY, x2 =  t_rightFadeRealX + t_rightFadeRealW, y2 = t_leftFadeRealY + t_fadeRealHeight}
		
		local lsDotY = 10
		local lsDotSpacing = 20
		
		page.goldenEggHitBox.xMin, page.goldenEggHitBox.xMax = 0.44 * screenWidth, 0.56 * screenWidth
		page.goldenEggHitBox.yMin, page.goldenEggHitBox.yMax = 0.87 * screenHeight, 0.95 * screenHeight
		
		--[[
		if deviceModel ~= "android" and deviceModel ~= "palm" then
			local dot1 = getItemByName(page.items, "dot1")
			dot1.x, dot1.y = (screenWidth / 2) - 3 * (lsDotSpacing / 2), screenHeight - lsDotY
			
			local dot2 = getItemByName(page.items, "dot2")
			dot2.x, dot2.y = (screenWidth / 2) - 1.5 *(lsDotSpacing / 2), screenHeight - lsDotY
		
			local dot3 = getItemByName(page.items, "dot3")
			dot3.x, dot3.y = screenWidth / 2, screenHeight - lsDotY
			
			local dot4 = getItemByName(page.items, "dot4")
			dot4.x, dot4.y = (screenWidth / 2) + 1.5 * (lsDotSpacing / 2), screenHeight - lsDotY
			
			local dot5 = getItemByName(page.items, "dot5")
			dot5.x, dot5.y = (screenWidth / 2) + 3 * (lsDotSpacing / 2), screenHeight - lsDotY
		else
			local dot1 = getItemByName(page.items, "dot1")
			dot1.x, dot1.y = (screenWidth / 2) - 3 * (lsDotSpacing / 2), screenHeight - lsDotY
			
			local dot2 = getItemByName(page.items, "dot2")
			dot2.x, dot2.y = (screenWidth / 2) - (lsDotSpacing / 2), screenHeight - lsDotY
			
			local dot3 = getItemByName(page.items, "dot3")
			dot3.x, dot3.y = (screenWidth / 2) + (lsDotSpacing / 2), screenHeight - lsDotY
			
			local dot4 = getItemByName(page.items, "dot4")
			dot4.x, dot4.y = (screenWidth / 2) + 3 * (lsDotSpacing / 2), screenHeight - lsDotY
		end
		]]--
		
		local biggestSpriteW, biggestSpriteH = 0, 0
		local longestString = 0
		for i = 1, episodeSelectionPage.numEpisodes do
			local index = i
			if i == episodeSelectionPage.numEpisodes then
				index = "G"
			end
			local spriteItem = getItemByName(page.items, "ep" .. index .. "Sprite")
			if spriteItem then
				local width, height = _G.res.getSpriteBounds("", spriteItem.sprite)
				
				if width > biggestSpriteW then
					biggestSpriteW = width
				end
				if height > biggestSpriteH then
					biggestSpriteH = height
				end
			end
			local stringItem = getItemByName(page.items, "episode" .. index .. "Text")
			if stringItem then
				setFont(stringItem.font)
				local stringWidth = _G.res.getStringWidth(stringItem.text)
				if stringWidth > longestString then
					longestString = stringWidth
				end
			end
		end
		
		g_episodeSpacing = screenWidth / 2
		
		
		--found by experimenting
		--local t_cardsSize = 180 
		local t_cardsSize = 190 
		
		--local t_screenSpacing = {"1024" = 2.5, "1280" = 2.5, "1366" = 2.5, "1440" = 2.5, "1680" = 2.5, "1920" = 2.5}
		local t_screenSpacing = {}
		t_screenSpacing[1024] = 2.5
		t_screenSpacing[1280] = 2.5
		t_screenSpacing[1366] = 3.5
		t_screenSpacing[1440] = 3.5
		t_screenSpacing[1680] = 4.5
		t_screenSpacing[1920] = 4.5				
		
		local t_targetSpacing = t_screenSpacing[screenWidth]
		
		if t_screenSpacing[screenWidth] == nil then
			g_episodeSpacing = _G.math.min(t_cardsSize, screenWidth / 4.5)
		else
			g_episodeSpacing = screenWidth / t_screenSpacing[screenWidth]
		end
		
		--ep1
		
		
		local ep1Sprite = getItemByName(page.items, "ep1Sprite")
		ep1Sprite.x, ep1Sprite.y = 0, 0
		
		setFont(fontBasic)
		local fh = _G.res.getFontHeight()
		local _, sh2 = _G.res.getSpriteBounds("", "EPISODE1_TOP_MIDDLE")
		
		
		
		
		
		--g_episodeSpacing = screenWidth / 2
		g_episodeCardsY = (565 / 1200) * screenHeight
		--local t_episodeScoreTextOffset = -2
		local t_episodeScoreOffset = 2
		
		
		
		local episode1 = getItemByName(page.items, "episode1")
		--episode1.x, episode1.y = (1 - settings.selectedEpisode) * g_episodeSpacing + g_episodeSpacing, screenHeight / 2
		episode1.x, episode1.y = (1 - settings.selectedEpisode) * g_episodeSpacing + (screenWidth/2), g_episodeCardsY
		
		local episode1Text = getItemByName(page.items, "episode1Text")
		--episode1.width, episode1.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		--episode1.width, episode1.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), _G.math.max(longestString * 0.8, biggestSpriteW * 0.95)
		episode1.width, episode1.height = t_cardsSize, t_cardsSize
		episode1Text.x, episode1Text.y = 0, -episode1.height / 2.1
		
		local episode1YellowLine = getItemByName(page.items, "episode1YellowLine")
		episode1YellowLine.x, episode1YellowLine.y = 0, episode1Text.y + fh / 1.75
		episode1YellowLine.width, episode1YellowLine.height = episode1.width, 1
		
		local episode1Score = getItemByName(page.items, "episode1Score")
		setFont(episode1Score.font)
		fh = _G.res.getFontHeight()
		
		local ep1ScoreBox1 = getItemByName(page.items, "ep1ScoreBox1")
		local sw, sh = _G.res.getSpriteBounds("", getItemByName(page.items, "episode1ScoreText").sprite)
		local starW, starH = _G.res.getSpriteBounds("", "LS_STAR_GOLD")
		ep1ScoreBox1.width, ep1ScoreBox1.height = _G.math.max(episode1.width / 2.25, sw), fh + starH
		ep1ScoreBox1.x, ep1ScoreBox1.y = -episode1.width / 2, episode1.height / 2 + sh2 / 6
		
		local ep1ScoreBox2 = getItemByName(page.items, "ep1ScoreBox2")
		ep1ScoreBox2.width, ep1ScoreBox2.height = _G.math.min(episode1.width / 2.25, (episode1.width / 2.25) - (ep1ScoreBox1.width - (episode1.width / 2.25))), fh + starH
		ep1ScoreBox2.x, ep1ScoreBox2.y = episode1.width / 2, episode1.height / 2 + sh2 / 6
		
		episode1Score.x, episode1Score.y = -episode1.width / 2 + ep1ScoreBox1.width / 2, ep1ScoreBox1.y + t_episodeScoreOffset
		
		local episode1ScoreText = getItemByName(page.items, "episode1ScoreText")
		episode1ScoreText.x, episode1ScoreText.y = ep1ScoreBox1.x + ep1ScoreBox1.width / 2, ep1ScoreBox1.y - 0.8 * ep1ScoreBox1.height
		
		local episode1Stars = getItemByName(page.items, "episode1Stars")
		episode1Stars.x, episode1Stars.y = episode1.width / 2 - ep1ScoreBox2.width / 2, ep1ScoreBox2.y + t_episodeScoreOffset
		
		local sw, sh = _G.res.getSpriteBounds("", "LS_STAR_GOLD")
		local ep1StarSprite = getItemByName(page.items, "ep1StarSprite")
		ep1StarSprite.x, ep1StarSprite.y = ep1ScoreBox2.x - ep1ScoreBox2.width / 2, ep1ScoreBox1.y - 0.8 * ep1ScoreBox1.height
		
		local lock = getItemByName(page.items[1].children, "lock")
		lock.x, lock.y = 0, 0
		
		if gameCenterSupported then
			local ep1MeterBG = getItemByName(page.items[1].children, "ep1MeterBG")
			local ep1MeterIndicator = getItemByName(page.items[1].children, "ep1MeterIndicator")
			local meterW, meterH = _G.res.getSpriteBounds("" ,ep1MeterBG.sprite)
			ep1MeterBG.x, ep1MeterBG.y = -episode1.width / 2 - meterW * 1.1, episode1.height / 2 - meterH / 7
			ep1MeterIndicator.x, ep1MeterIndicator.y = ep1MeterBG.x, ep1MeterIndicator.y or 46
			if gameCenterEnabled then
				ep1MeterBG.visible = true
				ep1MeterIndicator.visible = true
			else
				ep1MeterBG.visible = false
				ep1MeterIndicator.visible = false
			end
			
		end
		
		--ep2
		local ep2Sprite = getItemByName(page.items, "ep2Sprite")
		ep2Sprite.x, ep2Sprite.y = 0, 0
		
		setFont(fontBasic)
		fh = _G.res.getFontHeight()
		_, sh2 = _G.res.getSpriteBounds("", "EPISODE2_TOP_MIDDLE")
		
		local episode2 = getItemByName(page.items, "episode2")
		
		episode2.x, episode2.y = (2 - settings.selectedEpisode) * g_episodeSpacing + (screenWidth / 2), g_episodeCardsY
		
		local episode2Text = getItemByName(page.items, "episode2Text")
		--episode2.width, episode2.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		--episode2.width, episode2.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), _G.math.max(longestString * 0.8, biggestSpriteW * 0.95)
		episode2.width, episode2.height = t_cardsSize, t_cardsSize
		episode2Text.x, episode2Text.y = episode1Text.x, episode1Text.y
		
		local episode2YellowLine = getItemByName(page.items, "episode2YellowLine")
		episode2YellowLine.x, episode2YellowLine.y = episode1YellowLine.x, episode1YellowLine.y
		episode2YellowLine.width, episode2YellowLine.height = episode2.width, 1
		
		local episode2Score = getItemByName(page.items, "episode2Score")
		setFont(episode2Score.font)
		fh = _G.res.getFontHeight()
		
		local ep2ScoreBox1 = getItemByName(page.items, "ep2ScoreBox1")
		ep2ScoreBox1.width, ep2ScoreBox1.height = ep1ScoreBox1.width, ep1ScoreBox1.height
		ep2ScoreBox1.x, ep2ScoreBox1.y = -episode2.width / 2, episode2.height / 2 + sh2 / 6
		
		local ep2ScoreBox2 = getItemByName(page.items, "ep2ScoreBox2")
		ep2ScoreBox2.width, ep2ScoreBox2.height = ep1ScoreBox2.width, ep1ScoreBox2.height
		ep2ScoreBox2.x, ep2ScoreBox2.y = episode2.width / 2, episode2.height / 2 + sh2 / 6
		
		episode2Score.x, episode2Score.y = -episode2.width / 2 + ep2ScoreBox2.width / 2, ep2ScoreBox1.y + t_episodeScoreOffset
		
		local episode2ScoreText = getItemByName(page.items, "episode2ScoreText")
		episode2ScoreText.x, episode2ScoreText.y = ep2ScoreBox1.x + ep2ScoreBox1.width / 2, ep2ScoreBox1.y - 0.8 * ep2ScoreBox1.height

		local episode2Stars = getItemByName(page.items, "episode2Stars")
		episode2Stars.x, episode2Stars.y = episode2.width / 2 - ep2ScoreBox2.width / 2, ep2ScoreBox2.y + t_episodeScoreOffset
		
		local ep2StarSprite = getItemByName(page.items, "ep2StarSprite")
		ep2StarSprite.x, ep2StarSprite.y = ep2ScoreBox2.x - ep2ScoreBox2.width / 2, ep2ScoreBox1.y - 0.8 * ep2ScoreBox1.height
		
		local lock = getItemByName(page.items[2].children, "lock")
		lock.x, lock.y = 0, 0
		
		local appStore = getItemByName(page.items[2].children, "appStore")
		appStore.x, appStore.y = 0, 0
		
		if gameCenterSupported then
			local ep2MeterBG = getItemByName(page.items[2].children, "ep2MeterBG")
			local ep2MeterIndicator = getItemByName(page.items[2].children, "ep2MeterIndicator")
			local meterW, meterH = _G.res.getSpriteBounds("", ep2MeterBG.sprite)
			ep2MeterBG.x, ep2MeterBG.y = -episode2.width / 2 - meterW * 1.1, episode2.height / 2 - meterH / 7
			ep2MeterIndicator.x, ep2MeterIndicator.y = ep2MeterBG.x, ep2MeterIndicator.y or 46
			if gameCenterEnabled then
				ep2MeterBG.visible = true
				ep2MeterIndicator.visible = true
			else
				ep2MeterBG.visible = false
				ep2MeterIndicator.visible = false
			end
		end
		
		--ep3
		local ep3Sprite = getItemByName(page.items, "ep3Sprite")
		ep3Sprite.x, ep3Sprite.y = 0, 0
		
		setFont(fontBasic)
		fh = _G.res.getFontHeight()
		_, sh2 = _G.res.getSpriteBounds("", "EPISODE3_TOP_MIDDLE")
		
		local episode3 = getItemByName(page.items, "episode3")
		--episode3.x, episode3.y = ((3 - settings.selectedEpisode) * g_episodeSpacing + g_episodeSpacing) , screenHeight / 2
		episode3.x, episode3.y = ((3 - settings.selectedEpisode) * g_episodeSpacing + (screenWidth/2)) , g_episodeCardsY
		
		local episode3Text = getItemByName(page.items, "episode3Text")
		--episode3.width, episode3.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		--episode3.width, episode3.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), _G.math.max(longestString * 0.8, biggestSpriteW * 0.95)
		episode3.width, episode3.height = t_cardsSize, t_cardsSize
		episode3Text.x, episode3Text.y = episode1Text.x, episode1Text.y
		
		local episode3YellowLine = getItemByName(page.items, "episode3YellowLine")
		episode3YellowLine.x, episode3YellowLine.y = episode1YellowLine.x, episode1YellowLine.y
		episode3YellowLine.width, episode3YellowLine.height = episode3.width, 1
		
		local episode3Score = getItemByName(page.items, "episode3Score")
		setFont(episode3Score.font)
		fh = _G.res.getFontHeight()
		
		local ep3ScoreBox1 = getItemByName(page.items, "ep3ScoreBox1")
		ep3ScoreBox1.width, ep3ScoreBox1.height = ep1ScoreBox1.width, ep1ScoreBox1.height
		ep3ScoreBox1.x, ep3ScoreBox1.y = -episode3.width / 2, episode3.height / 2 + sh2 / 6
		
		local ep3ScoreBox2 = getItemByName(page.items, "ep3ScoreBox2")
		ep3ScoreBox2.width, ep3ScoreBox2.height = ep1ScoreBox2.width, ep1ScoreBox2.height
		ep3ScoreBox2.x, ep3ScoreBox2.y = episode3.width / 2, episode3.height / 2 + sh2 / 6
		
		episode3Score.x, episode3Score.y = -episode3.width / 2 + ep3ScoreBox2.width / 2, ep3ScoreBox1.y + t_episodeScoreOffset
		
		local episode3ScoreText = getItemByName(page.items, "episode3ScoreText")
		episode3ScoreText.x, episode3ScoreText.y = ep3ScoreBox1.x + ep3ScoreBox1.width / 2, ep3ScoreBox1.y - 0.8 * ep3ScoreBox1.height

		local episode3Stars = getItemByName(page.items, "episode3Stars")
		episode3Stars.x, episode3Stars.y = episode3.width / 2 - ep3ScoreBox2.width / 2, ep3ScoreBox2.y + t_episodeScoreOffset
		
		local ep3StarSprite = getItemByName(page.items, "ep3StarSprite")
		ep3StarSprite.x, ep3StarSprite.y = ep3ScoreBox2.x - ep3ScoreBox2.width / 2, ep3ScoreBox1.y - 0.8 * ep3ScoreBox1.height
		
		local lock = getItemByName(page.items[3].children, "lock")
		lock.x, lock.y = 0, 0
		
		local appStore = getItemByName(page.items[3].children, "appStore")
		appStore.x, appStore.y = 0, 0
		
		if gameCenterSupported then
			local ep3MeterBG = getItemByName(page.items[3].children, "ep3MeterBG")
			local ep3MeterIndicator = getItemByName(page.items[3].children, "ep3MeterIndicator")
			local meterW, meterH = _G.res.getSpriteBounds("", ep3MeterBG.sprite)
			ep3MeterBG.x, ep3MeterBG.y = -episode3.width / 2 - meterW * 1.1, episode3.height / 2 - meterH / 7
			ep3MeterIndicator.x, ep3MeterIndicator.y = ep3MeterBG.x, ep3MeterIndicator.y or 46
			if gameCenterEnabled then
				ep3MeterBG.visible = true
				ep3MeterIndicator.visible = true
			else
				ep3MeterBG.visible = false
				ep3MeterIndicator.visible = false
			end
		end
		
		local episode4
		local ep4Sprite
		local episode4Text
		local episode4YellowLine
		local episode4Score
		local ep4ScoreBox1
		local ep4ScoreBox2
		local episode4ScoreText
		local episode4Stars
		local ep4StarSprite
		--ep4
		if deviceModel ~= "android" and deviceModel ~= "palm" then
			ep4Sprite = getItemByName(page.items, "ep4Sprite")
			ep4Sprite.x, ep4Sprite.y = 0, 0
			
			setFont(fontBasic)
			fh = _G.res.getFontHeight()
			_, sh2 = _G.res.getSpriteBounds("", "EPISODE4_TOP_MIDDLE")
			
			episode4 = getItemByName(page.items, "episode4")
			--episode4.x, episode4.y = ((4 - settings.selectedEpisode) * g_episodeSpacing + g_episodeSpacing), screenHeight / 2
			episode4.x, episode4.y = ((4 - settings.selectedEpisode) * g_episodeSpacing + (screenWidth/2)), g_episodeCardsY
			
			episode4Text = getItemByName(page.items, "episode4Text")
			--episode4.width, episode4.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
			--episode4.width, episode4.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), _G.math.max(longestString * 0.8, biggestSpriteW * 0.95)
			episode4.width, episode4.height = t_cardsSize, t_cardsSize
			episode4Text.x, episode4Text.y = episode1Text.x, episode1Text.y
			
			episode4YellowLine = getItemByName(page.items, "episode4YellowLine")
			episode4YellowLine.x, episode4YellowLine.y = episode1YellowLine.x, episode1YellowLine.y
			episode4YellowLine.width, episode4YellowLine.height = episode4.width, 1
			
			episode4Score = getItemByName(page.items, "episode4Score")
			setFont(episode4Score.font)
			fh = _G.res.getFontHeight()
			
			ep4ScoreBox1 = getItemByName(page.items, "ep4ScoreBox1")
			ep4ScoreBox1.width, ep4ScoreBox1.height = ep1ScoreBox1.width, ep1ScoreBox1.height
			ep4ScoreBox1.x, ep4ScoreBox1.y = -episode4.width / 2, episode4.height / 2 + sh2 / 6
			
			ep4ScoreBox2 = getItemByName(page.items, "ep4ScoreBox2")
			ep4ScoreBox2.width, ep4ScoreBox2.height = ep1ScoreBox2.width, ep1ScoreBox2.height
			ep4ScoreBox2.x, ep4ScoreBox2.y = episode4.width / 2, episode4.height / 2 + sh2 / 6
			
			episode4Score.x, episode4Score.y = -episode4.width / 2 + ep4ScoreBox2.width / 2, ep4ScoreBox1.y + t_episodeScoreOffset
			
			episode4ScoreText = getItemByName(page.items, "episode4ScoreText")
			episode4ScoreText.x, episode4ScoreText.y = ep4ScoreBox1.x + ep4ScoreBox1.width / 2, ep4ScoreBox1.y - 0.8 * ep4ScoreBox1.height

			episode4Stars = getItemByName(page.items, "episode4Stars")
			episode4Stars.x, episode4Stars.y = episode4.width / 2 - ep4ScoreBox2.width / 2, ep4ScoreBox2.y + t_episodeScoreOffset
			
			ep4StarSprite = getItemByName(page.items, "ep4StarSprite")
			ep4StarSprite.x, ep4StarSprite.y = ep4ScoreBox2.x - ep4ScoreBox2.width / 2, ep4ScoreBox1.y - 0.8 * ep4ScoreBox1.height
			
			local lock = getItemByName(page.items[4].children, "lock")
			lock.x, lock.y = 0, 0
			
			local appStore = getItemByName(page.items[4].children, "appStore")
			appStore.x, appStore.y = 0, 0
			
			if gameCenterSupported then
				local ep4MeterBG = getItemByName(page.items[4].children, "ep4MeterBG")
				local ep4MeterIndicator = getItemByName(page.items[4].children, "ep4MeterIndicator")
				local meterW, meterH = _G.res.getSpriteBounds("", ep4MeterBG.sprite)
				ep4MeterBG.x, ep4MeterBG.y = -episode4.width / 2 - meterW * 1.1, episode4.height / 2 - meterH / 7
				ep4MeterIndicator.x, ep4MeterIndicator.y = ep4MeterBG.x, ep4MeterIndicator.y or 46
				if gameCenterEnabled then
					ep4MeterBG.visible = true
					ep4MeterIndicator.visible = true
				else
					ep4MeterBG.visible = false
					ep4MeterIndicator.visible = false
				end
			end
		end
		
		
		
		
		
		if gameCenterEnabled then
			setIndicatorPositions()
			gameCenter.safeToRefresh = true
		end
		
		local t_goldCardWidth = 395
		local t_goldCardHeight = 45
		--found by measuring the mockup
		local t_goldCardEggsOffsetX = -155
		local t_goldCardStarOffsetX = 145
		local t_goldCardStarTextOffsetY = 4
		local t_goldenEggTextOffset = -2
		
		local episodeG = getItemByName(page.items, "episodeG")
		episodeG.x, episodeG.y = ((episodeSelectionPage.numEpisodes - settings.selectedEpisode) * g_episodeSpacing + g_episodeSpacing), screenHeight / 2
		episodeG.x, episodeG.y = ((episodeSelectionPage.numEpisodes - settings.selectedEpisode) * g_episodeSpacing + (screenWidth/2)), g_episodeCardsY
		
		
		
		--episodeG.width, episodeG.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		episodeG.width, episodeG.height = t_goldCardWidth, t_goldCardHeight
		
		local epGSprite = getItemByName(page.items, "epGSprite")
		epGSprite.x, epGSprite.y = 0, -episodeG.height * 0.05
		
		
		local epGStarText = getItemByName(page.items, "epGStarText")
		local goldenEggStars = calculateStarsFromGoldenEggLevels()
		if goldenEggStars > 0 then
			epGStarText.text = "" .. goldenEggStars
			getItemByName(page.items, "episodeButtonStarsG").text = "" .. goldenEggStars
		else
			getItemByName(page.items, "episodeButtonStarsG").text = ""
		end
		
		

		
		--local epGScoreBox = getItemByName(page.items, "epGScoreBox")
		--epGScoreBox.x, epGScoreBox.y = 0, episodeG.height / 2 + sh2 / 6
		--epGScoreBox.width, epGScoreBox.height = ep1ScoreBox1.width / 2, ep1ScoreBox1.height 
		
		--epGStarText.x, epGStarText.y = epGScoreBox.x , epGScoreBox.y - epGScoreBox.height / 2 - fh / 8
		--epGStarText.x, epGStarText.y = 0,0
		epGStarText.x, epGStarText.y = t_goldCardStarOffsetX, t_goldCardStarTextOffsetY
		
		--local epGYellowLine = getItemByName(page.items, "epGYellowLine")
		--epGYellowLine.x, epGYellowLine.y = episode1YellowLine.x, episode1YellowLine.y
		--epGYellowLine.width, epGYellowLine.height = episodeG.width, 1
		
		local sw, sh = _G.res.getSpriteBounds("", "SCORE_BOTTOM_MIDDLE")
	
		local epGStar = getItemByName(page.items, "epGStar")
		--epGStar.x, epGStar.y = 0, epGScoreBox.y - epGScoreBox.height / 2.3 - sh / 2
		epGStar.x, epGStar.y = t_goldCardStarOffsetX, 0
		
		
		local epGEggs = getItemByName(page.items, "epGEggs")
		epGEggs.x, epGEggs.y = t_goldCardEggsOffsetX, 0

		
		local epGEpisodeText = getItemByName(page.items, "epGEpisodeText")
		--epGEpisodeText.x, epGEpisodeText.y = episode1Text.x, episode1Text.y
		epGEpisodeText.x, epGEpisodeText.y = 0,t_goldenEggTextOffset
		
		if deviceModel == "n900" then
			local pack1buy = getItemByName(page.items, "pack1buy")
			pack1buy.x, pack1buy.y = 0, -10
			if not hasLevelPack1() then
				pack1buy.visible = true
				pack1buy.selectable = true
			else
				pack1buy.visible = false
				pack1buy.selectable = false
			end
		end
		
		
		-- Prepare base game icon if available
		local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
		getItemByName(page.items[1].children, "episode1Score").text = _G.string.format("%d", score)
		getItemByName(page.items[1].children, "episode1Stars").text = gainedStars .. "/" .. totalStars
		getItemByName(page.items[1].children, "episode1ScoreText").visible = true
		getItemByName(page.items[2].children, "episode2ScoreText").visible = true
		getItemByName(page.items[3].children, "episode3ScoreText").visible = true
		
		
		getItemByName(page.items, "episodeButtonScore1").text = _G.string.format("%d", score)
		getItemByName(page.items, "episodeButtonStars1").text = gainedStars .. "/" .. totalStars

		
	
		
		--aligns all episodes
		--values found by measuring the mockup, since the mockup was based on the ipad resolution, we use those dimensions as reference
		--local t_episodeReferenceSpacing = 238
		local t_episodeReferenceSpacing = 245
		local t_referenceScreenHeight = 768
		local t_referenceScreenWidth = 1024
		
		--indexed by screenWidths
		local t_episodesSpacingMultipliers = {}
		t_episodesSpacingMultipliers[1920] = 0.7
		
		local t_episodeSpacingMultiplier = t_episodesSpacingMultipliers[screenWidth] or 1
		
		
		local t_episodeSpacing = ((t_episodeReferenceSpacing / t_referenceScreenWidth) * screenWidth) * t_episodeSpacingMultiplier
		
		local t_referenceCardY = 332
		
		local t_cardWidth = episode1.width
		
		--local t_goldCardReferenceY = 502
		local t_goldCardReferenceY = 510
		
		local t_totalEpisodes = 4
		
		local t_firstX = (screenWidth - ((t_totalEpisodes - 1) * t_episodeSpacing)) / 2
		
		for i = 1, 4 do
			local t_item = getItemByName(page.items, "episode" ..i)
			t_item.visible = not t_useScalableButtons
			t_item.x = t_firstX + t_episodeSpacing * (i-1)
			t_item.y = screenHeight * (t_referenceCardY / t_referenceScreenHeight)
			
			if t_useScalableButtons then
			
				local t_button = getItemByName(page.items, "episodeButton" ..i)
				t_button.x, t_button.y  = t_item.x, t_item.y
				
				local t_scoreField = getItemByName(page.items, "episodeButtonScore" ..i)
				local t_starsField = getItemByName(page.items, "episodeButtonStars" ..i)
				local t_buttonLock = getItemByName(page.items, "episodeButtonLock" ..i)
				
				t_buttonLock.x, t_buttonLock.y = t_button.x, t_button.y
				
				local t_scoreOffsetX = -52
				local t_scoreOffsetY = 95
				
				if deviceModel == "roku" then
					t_scoreOffsetX = -52
					t_scoreOffsetY = 95
				end
				
				local t_starsOffsetX = 52
				local t_starsOffsetY = 95
				
				t_scoreField.x, t_scoreField.y = t_button.x + t_scoreOffsetX, t_button.y + t_scoreOffsetY
				--t_scoreField.x, t_scoreField.y = 10, 10
				t_starsField.x, t_starsField.y = t_button.x + t_starsOffsetX, t_button.y + t_starsOffsetY
				
				--t_scoreField.text = "132465"
				--t_starsField.text = "12"
				
				t_scoreField.scaleText = true
				t_starsField.scaleText = true
				
				t_scoreField.font = "FONT_LS_SMALL"
				t_starsField.font = "FONT_LS_SMALL"
				
				if deviceModel == "roku" and screenHeight <= 576 then
					t_scoreField.font = "FONT_LS_SMALLER"
					t_starsField.font = "FONT_LS_SMALLER"
				end
				
				
				prepareItemForMouseScalingStates(t_button)
				
				prepareItemForMouseScalingStates(t_scoreField,t_button)
				prepareItemForMouseScalingStates(t_starsField,t_button)
				prepareItemForMouseScalingStates(t_buttonLock,t_button)
				
			else
				local t_button = getItemByName(page.items, "episodeButton" ..i)
				t_button.visible = false
				local t_scoreField = getItemByName(page.items, "episodeButtonScore" ..i)
				local t_starsField = getItemByName(page.items, "episodeButtonStars" ..i)
				local t_buttonLock = getItemByName(page.items, "episodeButtonLock" ..i)
				
				t_scoreField.visible = false
				t_starsField.visible = false
				t_buttonLock.visible = false
			end
		end
		
		episodeG.x = screenWidth * 0.50
		episodeG.y = (t_goldCardReferenceY / t_referenceScreenHeight) * screenHeight
		
		episodeG.visible = not t_useScalableButtons
		
		
		local t_diffY = episodeG.y -  episode2.y
	
		--found by experimenting
		local t_minDistance =  180
		t_diffY = _G.math.max(t_diffY,t_minDistance)
		
		episodeG.y = episode2.y + t_diffY
		
		local t_button = getItemByName(page.items, "episodeButtonG")
		local t_starsField = getItemByName(page.items, "episodeButtonStarsG")
				
		t_button.x, t_button.y  = episodeG.x, episodeG.y
		t_button.visible = t_useScalableButtons
		local t_starsOffsetX = 154
		local t_starsOffsetY = 13
		
		t_starsField.x, t_starsField.y = t_button.x + t_starsOffsetX, t_button.y + t_starsOffsetY
		--t_starsField.text = "12"
		t_starsField.visible = t_useScalableButtons
		t_starsField.scaleText = true
		t_starsField.font = "FONT_LS_SMALL"
		
		
		prepareItemForMouseScalingStates(t_button)
		prepareItemForMouseScalingStates(t_starsField, t_button)
				
		
		
		
		
		if deviceModel ~= "android" and deviceModel ~= "palm" then
			getItemByName(page.items[4].children, "episode4ScoreText").visible = true
		end

		getItemByName(page.items[1].children, "lock").visible = false
		local t_buttonLock1 = getItemByName(page.items, "episodeButtonLock1")
		t_buttonLock1.visible = false
		
		if t_useScalableButtons then
			local t_packs = {"pack3", "pack5", "pack8"}
			for k = 2, 4,1 do 
				local t_totalLevelsPerPage = #levelOrder[ t_packs[k-1] ]
				local t_targetPack = levelOrder[ t_packs[k-1] ]
				local t_targetLevel = t_targetPack[t_totalLevelsPerPage]
				--print("\n target level " ..  t_targetLevel)
				local t_lastLevelOfPreviousWorldScore = highscores[ t_targetLevel ]
				
				local t_buttonLock = getItemByName(page.items, "episodeButtonLock" .. k)
				local t_episodeButton = getItemByName(page.items, "episodeButton" .. k)
				
				if releaseBuild then
					if t_lastLevelOfPreviousWorldScore == nil then
						t_buttonLock.visible = true
						t_episodeButton.disableUpdateFunctionChange = true
					else
						local t_isUnlocked = t_lastLevelOfPreviousWorldScore.score > 0
						t_buttonLock.visible = not t_isUnlocked
						t_episodeButton.disableUpdateFunctionChange = not t_isUnlocked
						
						
					end
				else
					t_buttonLock.visible = false
					t_episodeButton.disableUpdateFunctionChange = false
				end
				
				if settings.gameCompleted then
					t_buttonLock.visible = false
					t_episodeButton.disableUpdateFunctionChange = false
				end
				
				
			end
			
			
		end
		
		
		
		-- Prepare Level Pack 2 icon if available
		if hasLevelPack2() == true then
			
			
			local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packOne)
			
			episode2.selectable = true
			episode2.updateFunction = gotoLevelSelectionExtra
			episode2Text.visible = true
			episode2Score.text = _G.string.format("%d", score)
			episode2Score.visible = true
			episode2Stars.text = gainedStars .. "/" .. totalStars
			
			getItemByName(page.items, "episodeButtonScore2").text = _G.string.format("%d", score)
			getItemByName(page.items, "episodeButtonStars2").text = gainedStars .. "/" .. totalStars

			
			episode2Stars.visible = true
			episode2ScoreText.visible = true
			getItemByName(page.items[2].children, "appStore").visible = false
			
			if deviceModel == "n900" or score > 0 or settings.gameCompleted then 
				getItemByName(page.items[2].children, "lock").visible = false
				
				
				
			else
				getItemByName(page.items[2].children, "lock").visible = true
				
			end
			
			
		else
			getItemByName(page.items, "episode2").selectable = true
			if deviceModel == "n900" or deviceModel == "s60" then
				episode2.updateFunction = gotoOviStore
			else
				episode2.callFunction = gotoFullVersionInAppStore
				episode2.updateFunction = nil
			end
			if deviceModel == "n900" then
				episode2.box = {left = "EPISODE_LOCKED_LEFT", bottomLeft = "EPISODE_LOCKED_BOTTOM_LEFT",
								bottomMiddle = "EPISODE_LOCKED_BOTTOM_MIDDLE", bottomRight = "EPISODE_LOCKED_BOTTOM_RIGHT",
								right = "EPISODE_LOCKED_RIGHT", topRight = "EPISODE_LOCKED_TOP_RIGHT",
								topMiddle = "EPISODE_LOCKED_TOP_MIDDLE", topLeft = "EPISODE_LOCKED_TOP_LEFT",
								center = "EPISODE_LOCKED_CENTER"}
			end
			
			ep2Sprite.visible = false
			episode2Text.visible = true
			episode2Score.visible = false
			episode2Stars.visible = false
			episode2ScoreText.visible = true
			getItemByName(page.items[2].children, "lock").visible = false
			getItemByName(page.items[2].children, "appStore").visible = true

		end
		
		if hasLevelPack3() == true then
		
			local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packThree)
			episode3.selectable = true
			episode3.updateFunction = gotoLevelSelectionPack3
			episode3.callFunction = nil
			ep3Sprite.visible = true
			episode3Text.visible = true
			episode3Score.visible = true
			episode3Score.text = _G.string.format("%d", score)
			episode3Stars.visible = true
			episode3Stars.text = gainedStars .. "/" .. totalStars
			episode3ScoreText.visible = true
			getItemByName(page.items[3].children, "appStore").visible = false
			
			getItemByName(page.items, "episodeButtonScore3").text = _G.string.format("%d", score)
			getItemByName(page.items, "episodeButtonStars3").text = gainedStars .. "/" .. totalStars

			
			if deviceModel == "n900" or settings.gameCompleted or score > 0 then
				getItemByName(page.items[3].children, "lock").visible = false
				
				
				
			else
				getItemByName(page.items[3].children, "lock").visible = true
				
			end
		else
			getItemByName(page.items, "episode3").selectable = true
			
			if deviceModel == "n900" or deviceModel == "s60" then
				episode3.updateFunction = gotoOviStore
			else
				episode3.callFunction = gotoFullVersionInAppStore
				episode3.updateFunction = nil
			end
			
			if deviceModel == "n900" then
				episode3.box = {left = "EPISODE_LOCKED_LEFT", bottomLeft = "EPISODE_LOCKED_BOTTOM_LEFT",
								bottomMiddle = "EPISODE_LOCKED_BOTTOM_MIDDLE", bottomRight = "EPISODE_LOCKED_BOTTOM_RIGHT",
								right = "EPISODE_LOCKED_RIGHT", topRight = "EPISODE_LOCKED_TOP_RIGHT",
								topMiddle = "EPISODE_LOCKED_TOP_MIDDLE", topLeft = "EPISODE_LOCKED_TOP_LEFT",
								center = "EPISODE_LOCKED_CENTER"}
			end
				
			ep3Sprite.visible = false
			episode3Text.visible = true
			episode3Score.visible = false
			episode3Stars.visible = false
			episode3ScoreText.visible = true
			getItemByName(page.items[3].children, "lock").visible = false
			getItemByName(page.items[3].children, "appStore").visible = true

		end
		
		if deviceModel ~= "android" and deviceModel ~= "palm" then
			if hasLevelPack4() == true then
			
				local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packFour)
				episode4.selectable = true
				episode4.updateFunction = gotoLevelSelectionPack4
				episode4.callFunction = nil
				ep4Sprite.visible = true
				episode4Text.visible = true
				episode4Score.visible = true
				episode4Score.text = _G.string.format("%d", score)
				episode4Stars.visible = true
				episode4Stars.text = gainedStars .. "/" .. totalStars
				episode4ScoreText.visible = true
				
				getItemByName(page.items, "episodeButtonScore4").text = _G.string.format("%d", score)
				getItemByName(page.items, "episodeButtonStars4").text = gainedStars .. "/" .. totalStars

				
				getItemByName(page.items[4].children, "appStore").visible = false
				
				if deviceModel == "n900" or deviceModel == "s60" or settings.gameCompleted or score > 0 then
					getItemByName(page.items[4].children, "lock").visible = false	
					
					
				
				else
					getItemByName(page.items[4].children, "lock").visible = true
					
					
				end
			else
				episode4.selectable = true
				if deviceModel == "n900" or deviceModel == "s60" then
					episode4.updateFunction = gotoOviStore
				else
					episode4.callFunction = gotoFullVersionInAppStore
					episode4.updateFunction = nil
				end
				
				if deviceModel == "n900" then
				episode4.box = {left = "EPISODE_LOCKED_LEFT", bottomLeft = "EPISODE_LOCKED_BOTTOM_LEFT",
								bottomMiddle = "EPISODE_LOCKED_BOTTOM_MIDDLE", bottomRight = "EPISODE_LOCKED_BOTTOM_RIGHT",
								right = "EPISODE_LOCKED_RIGHT", topRight = "EPISODE_LOCKED_TOP_RIGHT",
								topMiddle = "EPISODE_LOCKED_TOP_MIDDLE", topLeft = "EPISODE_LOCKED_TOP_LEFT",
								center = "EPISODE_LOCKED_CENTER"}
				end
					
				ep4Sprite.visible = false
				episode4Text.visible = true
				episode4Score.visible = false
				episode4Stars.visible = false
				episode4ScoreText.visible = true
				getItemByName(page.items[4].children, "lock").visible = false
				getItemByName(page.items[3].children, "appStore").visible = true

			end
		end
	end
	
	if page == about then
		
		page.menuButton = mainMenu
		aboutDragStart = nil	
		dragSpeed = 0
		about.scrollTimer = 1.5
		
		local birds2 = getItemByName(page.items, "birds2")
		local sw, _ = _G.res.getSpriteBounds("", birds2.sprite)
		local textAbout = getItemByName(page.items, "textAbout")
		--textAbout.textBoxSize = _G.math.max(sw, 200 * (screenWidth / 480))
		textAbout.textBoxSize = _G.math.max(sw, 150 * (screenWidth / 480))
		if deviceModel == "roku" and screenHeight <= 576 then
			textAbout.textBoxSize = 400
		end
		
		prepareTextItem(page, textAbout)
 		
		page.backgroundBox.x, page.backgroundBox.y = 0, 0
		page.backgroundBox.width, page.backgroundBox.height = textAbout.w * 1.5, screenHeight + 1
		local aboutTextXPos = page.backgroundBox.width * 0.53
		
		textAbout.x, textAbout.y = aboutTextXPos, 240
		birds2.x, birds2.y = aboutTextXPos, 480
		
		local textCredits = getItemByName(page.items, "textCredits")
		textCredits.textBoxSize = _G.math.max(sw, 250 * (screenWidth / 480))
		textCredits.x, textCredits.y = aboutTextXPos, 480
		
		--true == windows, false == mac
		
		if deviceModel == "roku" then
			textCredits.text = "TEXT_CREDITS_ORIGINAL"
		elseif doesMouseClickSetsTouchCount() then
			textCredits.text = "TEXT_CREDITS_PC"
		else
			textCredits.text = "TEXT_CREDITS_MAC"
		end
		
		local birds1 = getItemByName(page.items, "birds1")
		birds1.x, birds1.y = aboutTextXPos, 480
			
		local goldenEgg = getItemByName(page.items, "goldenEgg")
		goldenEgg.x, goldenEgg.y = aboutTextXPos, 480
		
		local birds1_2 = getItemByName(page.items, "birds1_2")
		birds1_2.x, birds1_2.y = aboutTextXPos, 480
		
		local textCreditsOrig = getItemByName(page.items, "textCreditsOrig")
		textCreditsOrig.textBoxSize = _G.math.max(sw, 250 * (screenWidth / 480))
		textCreditsOrig.x, textCreditsOrig.y = aboutTextXPos, 480
		
		if deviceModel == "roku" then
			textCreditsOrig.text = "TEXT_CREDITS_ROKU"
		end
		
		local birds2_2 = getItemByName(page.items, "birds2_2")
		birds2_2.x, birds2_2.y = aboutTextXPos, 480
		
		local textCreditsAdditional = getItemByName(page.items, "textCreditsAdditional")
		textCreditsAdditional.textBoxSize = _G.math.max(sw, 250 * (screenWidth / 480))
		textCreditsAdditional.x, textCreditsAdditional.y = aboutTextXPos, 480
		
		local borderSw, _ = _G.res.getSpriteBounds("", "MAIN_SETTINGS_LEFT")
		local arrow = getItemByName(page.items, "arrow")
		--arrow.x, arrow.y = page.backgroundBox.width + borderSw / 2, screenHeight - 30* screenHeight / 320
		arrow.x, arrow.y = page.backgroundBox.width + borderSw, screenHeight - 30* screenHeight / 320
		prepareItemForMouseScalingStates(arrow)
		
		local hideArea = getItemByName(page.items, "hideArea")
		hideArea.x, hideArea.y = page.backgroundBox.width, 0
		hideArea.w, hideArea.h = screenWidth - page.backgroundBox.width, screenHeight
		
		setFont(fontBasic)
		local fh = _G.res.getFontLeading()
		local fontHeight = _G.res.getFontHeight()

		local margin = 30
		local currentHeight = 55 * screenHeight / 320
		
		
		for i = page.scrollStart, page.scrollEnd do
			if about.items[i].text ~= nil then
				clipText("TEXTS_BASIC", about.items[i].text, about.items[i].textBoxSize)
				local textHeight = #clippedText.lines * fh
				about.items[i].h = textHeight
				about.items[i].y = textHeight * 0.5 + currentHeight
				currentHeight = currentHeight + textHeight + margin
			end
			
			if about.items[i].sprite ~= nil then	
				local w, h = _G.res.getSpriteBounds("", about.items[i].sprite)
				about.items[i].h = h
				about.items[i].y = h * 0.5 + currentHeight
				currentHeight = currentHeight + h + margin				
			end				
		end
		
	end
	
	if page == settingsPage then
		-- if settings.audioEnabled == false then
			-- page.items[2].visible = true
		-- else
			-- page.items[2].visible = false
		-- end
		-- if settings.musicEnabled == false then
			-- page.items[4].visible = true
		-- else
			-- page.items[4].visible = false
		-- end
		--[[
		if settings.lastOpenLevel == 1 then
			page.items[7].sprite = "BUTTON_BIG_DISABLED"
		else
			page.items[7].sprite = "BUTTON_BIG"
		end
		--]]
		--page.items[5].sprite = languageSprites[currentLanguage]
	end
	
	if page == g_ingamePausePage  then
	
		local t_buttonPause = getItemByName(page.items, "ingameButtonPause")
		local t_buttonRestart = getItemByName(page.items, "ingameButtonRestart")
		
		local t_pauseWidth, t_pauseHeight =  _G.res.getSpriteBounds(t_buttonPause.sheet, t_buttonPause.sprite)
		local t_restartWidth, t_restartHeight =  _G.res.getSpriteBounds(t_buttonRestart.sheet, t_buttonRestart.sprite)
		local t_pausePX, t_pausePY =  _G.res.getSpritePivot(t_buttonPause.sheet, t_buttonPause.sprite)
		local t_restartPX, t_restartPY =  _G.res.getSpritePivot(t_buttonRestart.sheet, t_buttonRestart.sprite)
		
		
		local t_hudButtonsLowestTargetScale = 0.6
		local t_hudButtonsLowestTargetWidth = 1024
		local t_hudButtonsHighestTargetWidth = 1920
		local t_hudButtonsTargetScale = (screenWidth - t_hudButtonsLowestTargetWidth) / (t_hudButtonsHighestTargetWidth - t_hudButtonsLowestTargetWidth)
		t_hudButtonsTargetScale = _G.math.max(t_hudButtonsTargetScale, 0)
		t_hudButtonsTargetScale = _G.math.min(t_hudButtonsTargetScale, 1)
		
		local t_hudButtonsScale = t_hudButtonsLowestTargetScale + (1 - t_hudButtonsLowestTargetScale) * t_hudButtonsTargetScale
		
		local t_buttonOffsetX = 5
		local t_buttonOffsetY = 5
		local t_buttonSpacing = 5

		if deviceModel == "roku" then
			t_buttonOffsetX = screenWidth * 0.03
			t_buttonOffsetY = t_buttonOffsetX
			t_buttonSpacing = 10
		end
		
		t_buttonPause.x = t_buttonOffsetX + t_pausePX * t_hudButtonsScale
		t_buttonPause.y = t_buttonOffsetY + t_pausePY * t_hudButtonsScale
		t_buttonRestart.x = t_buttonOffsetX + t_pauseWidth * t_hudButtonsScale + t_buttonSpacing + t_restartPX * t_hudButtonsScale
		t_buttonRestart.y = t_buttonPause.y
		
		t_buttonPause.xs = t_hudButtonsScale
		t_buttonPause.ys = t_hudButtonsScale
		t_buttonRestart.xs = t_hudButtonsScale
		t_buttonRestart.ys = t_hudButtonsScale				
		
		--dirty hack!
		if not g_ingameButtonsPrepared then
			g_ingameButtonsPrepared = true
			prepareItemForMouseScalingStates(t_buttonPause)
			prepareItemForMouseScalingStates(t_buttonRestart)
		end
	end
	
	if page == pausePage then
		
		pausePage.menuButton = "goToGame"
		local buttonSfx = getItemByName(page.items, "buttonSfx")
		local sw, sh = _G.res.getSpriteBounds("", buttonSfx.sprite)
		
		prepareItemForMouseScalingStates(buttonSfx)
		
		page.backgroundBox.x, page.backgroundBox.y = 0, 0
		local showButtonEagle = false
		if eagleBaitLaunched ~= true and (settings.mightyEagleEnabled == true or (deviceModel == "s60" and isLiteVersion)) then 
			showButtonEagle = true
		end
		if inExtraWorld == true or ((highscores[levelName] == nil or highscores[levelName].score == 0) and 
		   ((levelSelectionPages == levelSelectionPagesBasic and settings.eaglesAvailable.basic < 1) or
			(levelSelectionPages == levelSelectionPagesExtra and settings.eaglesAvailable.extra < 1) or
			(levelSelectionPages == levelSelectionPagesPack3 and settings.eaglesAvailable.pack3 < 1) or
			(levelSelectionPages == levelSelectionPagesPack4 and settings.eaglesAvailable.pack4 < 1))) then
			showButtonEagle = false
		end
		
		if showButtonEagle == true then
			page.backgroundBox.width = sw * 3.75
			buttonSfx.x, buttonSfx.y = page.backgroundBox.width / 2 - sw * 1.08, screenHeight - sh * 0.66
			
			local buttonOff = getItemByName(page.items, "buttonOff")
			buttonOff.x, buttonOff.y = page.backgroundBox.width / 2 - sw * 1.08, screenHeight - sh * 0.66
			
			local buttonTutorials = getItemByName(page.items, "buttonTutorials")
			buttonTutorials.x, buttonTutorials.y = page.backgroundBox.width / 2, screenHeight - sh * 0.66
			
			if settings.mightyEagleEnabled then
				local buttonEagle = getItemByName(page.items, "buttonEagle")
				buttonEagle.x, buttonEagle.y = page.backgroundBox.width / 2 + sw * 1.08, screenHeight - sh * 0.66
				buttonEagle.visible = true
			else
				local buttonOvi = getItemByName(page.items, "buttonOvi")
				buttonOvi.x, buttonOvi.y = page.backgroundBox.width / 2 + sw * 1.08, screenHeight - sh * 0.66
				buttonOvi.visible = true
			end
		else
			page.backgroundBox.width = sw * 2.5
			buttonSfx.x, buttonSfx.y = page.backgroundBox.width / 2 - sw * 0.54, screenHeight - sh * 0.66
			
			local buttonOff = getItemByName(page.items, "buttonOff")
			buttonOff.x, buttonOff.y = page.backgroundBox.width / 2 - sw * 0.54, screenHeight - sh * 0.66
			
			prepareItemForMouseScalingStates(buttonOff, buttonSfx, true)
		
			local buttonTutorials = getItemByName(page.items, "buttonTutorials")
			buttonTutorials.x, buttonTutorials.y = page.backgroundBox.width / 2 + sw * 0.54, screenHeight - sh * 0.66
			
			prepareItemForMouseScalingStates(buttonTutorials)
			
			local buttonEagle = getItemByName(page.items, "buttonEagle")
			buttonEagle.visible = false
			
			if deviceModel == "s60" and isLiteVersion then
				local buttonOvi = getItemByName(page.items, "buttonOvi")
				buttonOvi.visible = false
			end
		end
		page.backgroundBox.height = screenHeight + 1
			
		local buttonMenu = getItemByName(page.items, "buttonMenu")
		buttonMenu.x, buttonMenu.y = page.backgroundBox.width / 2, screenHeight / 2 
		
		local buttonRestart = getItemByName(page.items, "buttonRestart")
		buttonRestart.x, buttonRestart.y = page.backgroundBox.width / 2, screenHeight / 2 - (sh * 1.4)
		
		local buttonMainMenu = getItemByName(page.items, "buttonMainMenu")
		buttonMainMenu.x, buttonMainMenu.y = page.backgroundBox.width / 2, screenHeight / 2 + (sh * 1.4)
		
		if deviceModel == "roku" then
			buttonMenu.y    = screenHeight / 2 - (sh * 0.7)
			buttonRestart.y = screenHeight / 2 + (sh * 0.7)
		end
		
		prepareItemForMouseScalingStates(buttonMenu)
		prepareItemForMouseScalingStates(buttonRestart)
		prepareItemForMouseScalingStates(buttonMainMenu)
		
		local borderSw, _ = _G.res.getSpriteBounds("", "MAIN_SETTINGS_LEFT")
		local buttonResume = getItemByName(page.items, "buttonResume")
		buttonResume.x, buttonResume.y = page.backgroundBox.width + borderSw / 2, screenHeight/2
		prepareItemForMouseScalingStates(buttonResume)
		
		local buttonResumeW, _ = _G.res.getSpriteBounds("", buttonResume.sprite)
		pauseBGw = page.backgroundBox.width + buttonResumeW
		
		local hideArea = getItemByName(page.items, "hideArea")
		hideArea.x, hideArea.y = pauseBGw, 0
		hideArea.w, hideArea.h = screenWidth, screenHeight
		
		local levelText = getItemByName(page.items, "levelText")
		levelText.x, levelText.y = page.backgroundBox.width / 2, sh * 0.65	
		
		if deviceModel == "n900" or deviceModel == "s60" then
			local taskSwitcher = getItemByName(page.items, "taskSwitcher")
			taskSwitcher.x, taskSwitcher.y = 0, 0
		end	
		
		if settings.audioEnabled == false then
			getItemByName(page.items, "buttonOff").visible = true
		else
			getItemByName(page.items, "buttonOff").visible = false
		end

		if inExtraWorld == true then
			getItemByName(page.items, "buttonMenu").page = levelSelectionPagesGoldenEggs[settings.currentLevelSelectionPages.goldeneggs]
			--getItemByName(page.items, "levelText").text = "^-" .. currentLevelNumberInTheme
			
			if currentLevelNumberInTheme == 20 then
				getItemByName(page.items, "levelText").text = "*"
			else
				getItemByName(page.items, "levelText").text = "^-" .. currentLevelNumberInTheme
			end
			
		else
			if currentWorldNumber <= 3 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesBasic
			elseif currentWorldNumber <= 5 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesExtra
			elseif currentWorldNumber <= 8 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack3
			elseif currentWorldNumber <= 11 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack4
			elseif currentWorldNumber <= 14 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack5
			elseif currentWorldNumber <= 17 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack6
			end
			getItemByName(page.items, "levelText").text = currentWorldNumber .. "-" .. currentLevelNumberInTheme
		end
		
		if deviceModel == "roku" and screenHeight <= 576 then
			levelText.font = "FONT_INGAME_SCORE"
		end
	end
	
	if page == g_gesturePausePage then
		--print("\n preparing pause")
		g_gesturePausePage.menuButton = "goToGame"													
		
		local t_axisLength = 150
			
		local buttonMenu = getItemByName(page.items, "buttonMenu")
		buttonMenu.x, buttonMenu.y = screenWidth / 2 + t_axisLength, screenHeight / 2
		
		prepareItemForMouseScalingStates(buttonMenu, nil, nil, true)
		
		local buttonRestart = getItemByName(page.items, "buttonRestart")
		buttonRestart.x, buttonRestart.y = screenWidth / 2, screenHeight / 2 + t_axisLength
		
		prepareItemForMouseScalingStates(buttonRestart, nil, nil, true)
		
		local buttonMainMenu = getItemByName(page.items, "buttonMainMenu")
		buttonMainMenu.x, buttonMainMenu.y = screenWidth / 2 - t_axisLength, screenHeight / 2
		
		prepareItemForMouseScalingStates(buttonMainMenu, nil, nil, true)
		
		local buttonResume = getItemByName(page.items, "buttonResume")
		buttonResume.x, buttonResume.y = screenWidth / 2, screenHeight / 2 - t_axisLength
		prepareItemForMouseScalingStates(buttonResume, nil, nil, true)								

		if inExtraWorld == true then
			getItemByName(page.items, "buttonMenu").page = levelSelectionPagesGoldenEggs[settings.currentLevelSelectionPages.goldeneggs]			
		else
			if currentWorldNumber <= 3 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesBasic
			elseif currentWorldNumber <= 5 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesExtra
			elseif currentWorldNumber <= 8 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack3
			elseif currentWorldNumber <= 11 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack4
			elseif currentWorldNumber <= 14 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack5
			elseif currentWorldNumber <= 17 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack6
			end
			
		end
	end	
	
	local t_navigationButtonOffsetX = 100
	if deviceModel == "roku" and screenHeight <= 576 then
		t_navigationButtonOffsetX = 50
	end
	
	local t_spriteWidth, t_spriteHeight = _G.res.getSpriteBounds("", "LS_BACK_BUTTON")
	local t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_BACK_BUTTON")
	local t_levelSelectionBackOffsetX, t_levelSelectionBackOffsetY = t_pivotX, -(t_spriteHeight-t_pivotY)
	
	if deviceModel == "roku" then
		t_levelSelectionBackOffsetX = t_levelSelectionBackOffsetX + screenWidth  * 0.05 - 5
		t_levelSelectionBackOffsetY = -screenHeight * 0.95 + t_pivotY
	end
	
	if page == levelSelectionPagesBasic or levelSelectionPagesExtra or levelSelectionPagesPack3 or levelSelectionPagesPack3 then
		calculateLevelSelectionClippingArea()
	end
	
	if page == levelSelectionPagesBasic then
		
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = {red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue =  page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesBasic.firstLevelIndex, #levelSelectionPagesBasic.items do
			levelSelectionPagesBasic.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.basic = levelSelectionPagesBasic.currentPage

		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		--local textY = 22
		local textY = 0.03 * screenHeight + 15
		if deviceModel == "roku" then
			textY = 0.059 * screenHeight
			lsDotY = textY - 25
			if screenHeight <= 576 then
				textY = 0.07 * screenHeight
				lsDotY = textY - 18
			end
		end
		local yDividerMultiplier = 1.16
		
		
		local contentAreaWidth = screenWidth * 0.83
		if isLiteVersion then
			contentAreaWidth = screenWidth * 0.7
			yDividerMultiplier = 1.3
		end
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		back.x, back.y = 0 + t_levelSelectionBackOffsetX, screenHeight + t_levelSelectionBackOffsetY
		
		prepareItemForMouseScalingStates(back)
		
		
		
		local text1 = getItemByName(page.items, "text_1")
		text1.x, text1.y = screenWidth / 2 - lsDotSpacing, screenHeight - textY
		local text2 = getItemByName(page.items, "text_2")
		text2.x, text2.y = screenWidth / 2, screenHeight - textY
		local text3 = getItemByName(page.items, "text_3")
		text3.x, text3.y = screenWidth / 2 + lsDotSpacing, screenHeight - textY
		
	
		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = screenWidth / 2 - lsDotSpacing, screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = screenWidth / 2, screenHeight - lsDotY
		local dot3 = getItemByName(page.items, "dot3")
		dot3.x, dot3.y = screenWidth / 2 + lsDotSpacing, screenHeight - lsDotY
		
	
		local t_title = getItemByName(page.items, "title")
		--t_title.x, t_title.y = screenWidth / 2, (81 / 1200) * screenHeight
		t_title.x, t_title.y = screenWidth / 2, (93 / 1200) * screenHeight
		
		
		
		local t_minDistance = 150
		
		if (g_levelSelectionClippingArea.y - t_title.y) < t_minDistance then
			t_title.y = g_levelSelectionClippingArea.y - t_minDistance
		end
		if deviceModel == "roku" and screenHeight <= 576 then
			t_title.y = t_title.y + 50
		end
		
		--print("\n T DIFF " .. g_levelSelectionButtonsVisibleAreaY .. " " .. t_title.y)
		
		local t_leftNavigation = getItemByName(page.items, "leftNavigation")
		local t_rightNavigation = getItemByName(page.items, "rightNavigation")
		
		prepareItemForMouseScalingStates(t_leftNavigation)
		prepareItemForMouseScalingStates(t_rightNavigation)
		
		--t_leftNavigation.x, t_leftNavigation.y = (210 / t_referenceScreenWidth) * screenWidth, (619 / t_referenceScreenHeight) * screenHeight
		
		--t_leftNavigation.x, t_leftNavigation.y = (210 / t_referenceScreenWidth) * screenWidth, (1100 / t_referenceScreenHeight) * screenHeight
		--t_rightNavigation.x, t_rightNavigation.y= (1710 / t_referenceScreenWidth) * screenWidth, (619 / t_referenceScreenHeight) * screenHeight
		--t_rightNavigation.x, t_rightNavigation.y= (1710 / t_referenceScreenWidth) * screenWidth, (1100 / t_referenceScreenHeight) * screenHeight
		
		--t_leftNavigation.x = t_leftNavigation.x - t_navigationButtonOffset
		--t_rightNavigation.x = t_rightNavigation.x + t_navigationButtonOffset
		
		
		local t_visibleAreaOverlayOffsetX = g_levelSelectionClippingArea.offsetX
		local t_visibleAreaOverlayOffsetY = g_levelSelectionClippingArea.offsetY
		
		local t_height = g_levelSelectionClippingArea.height + t_visibleAreaOverlayOffsetY * 2
		local t_y = g_levelSelectionClippingArea.y - t_visibleAreaOverlayOffsetY		
		
		t_leftNavigation.y = t_y + (t_height * 0.5)
		t_rightNavigation.y = t_leftNavigation.y
		
		t_leftNavigation.x = g_levelSelectionClippingArea.x - t_navigationButtonOffsetX
		t_rightNavigation.x = g_levelSelectionClippingArea.x + g_levelSelectionClippingArea.width + t_navigationButtonOffsetX
		
		
		local t_overlay = getItemByName(page.items, "scrollAreaOverlay")
		t_overlay.x, t_overlay.y = g_levelSelectionClippingArea.x + g_levelSelectionClippingArea.width / 2, g_levelSelectionClippingArea.y + g_levelSelectionClippingArea.height / 2
		
		--t_overlay.xs = 0.5
		--t_overlay.ys = 0.5
		
		
		local itemsPerPage = 21
		local itemsPerLine = 7
		local linesPerPage = 3
		local pages = 3
		
		if isLiteVersion then
			itemsPerPage = 16
			itemsPerLine = 5
			linesPerPage = 4
			pages = 1
		end
		
		
		--new level selection
		--local t_pivotX, t_pivotY = _G.res.getSpritePivot("", page.items[page.firstLevelIndex].sprite)
		local t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_LEVEL_BG_NORMAL_OPEN_HD_1")
		--local t_width, t_height = _G.res.getSpriteBounds("", page.items[page.firstLevelIndex].sprite)
		local t_width, t_height = _G.res.getSpriteBounds("", "LS_LEVEL_BG_NORMAL_OPEN_HD_1")
		
		if screenWidth < 1920 or (g_levelSelectionMultipleAssets ~= true) then
			t_width, t_height = _G.res.getSpriteBounds("", "LS_LEVEL_BG_NORMAL_OPEN_1")
			t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_LEVEL_BG_NORMAL_OPEN_1")
		end
		
		local t_spaceX = (g_levelSelectionClippingArea.width - t_width) / (itemsPerLine - 1)
		--t_spaceX = t_spaceX  - 25
		local t_totalLines = itemsPerPage / itemsPerLine
		local t_spaceY = (g_levelSelectionClippingArea.height - t_height) / (t_totalLines - 1)
		--t_spaceY = t_spaceY - 60
		
		g_levelSelectionScrollOffset = g_levelSelectionClippingArea.width + (t_spaceX)			
		
		contentAreaWidth = g_levelSelectionClippingArea.width - (t_pivotX * 2)
		--new level selection	
		
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		
		
		local offset = 0
		
		--new level selection
		levelSelectionPagesBasic.currentOffset = (levelSelectionPagesBasic.currentPage - 1) * -g_levelSelectionScrollOffset		
		levelSelectionPagesBasic.targetOffset = levelSelectionPagesBasic.currentOffset
		
		for k = 0, pages - 1 do		
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				
				--new level selection
				local t_itemIndex = page.firstLevelIndex - 1 + i + (k * itemsPerPage)
				
				page.items[t_itemIndex].relativeX =  offset + g_levelSelectionClippingArea.x + t_pivotX + (indexInLine - 1) * t_spaceX
				--page.items[t_itemIndex].x = offset + levelSelectionPagesBasic.currentOffset + g_levelSelectionClippingArea.x + t_pivotX + (indexInLine - 1) * t_spaceX				
				page.items[t_itemIndex].x = levelSelectionPagesBasic.currentOffset +  page.items[t_itemIndex].relativeX					
				page.items[t_itemIndex].y = g_levelSelectionClippingArea.y + t_pivotY + ( (line-1) * t_spaceY )
				
				prepareItemForMouseScalingStates(page.items[t_itemIndex])
				
				--new level selection
				
				--[[
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = offset + (indexInLine-1) * t_spaceX
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX = page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x - g_levelSelectionButtonsVisibleAreaW
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = g_levelSelectionButtonsVisibleAreaY + (line - 1) * t_spaceY
				]]--
			end						
			
			--offset = offset + screenWidth / 2
			
			--new level selection
			offset = offset + g_levelSelectionScrollOffset
			
		end
		
		
		
		-- check if player has theme 2 and 3 for n900
		if deviceModel == "n900" then
			if not hasLevelPack1() then 
				getItemByName(page.items, "overlay").visible = true
				local itm = getItemByName(page.items, "button1")
				itm.visible, itm.selectable = true, true
				itm = getItemByName(page.items, "button2")
				itm.visible, itm.selectable = true, true
				
			else
				getItemByName(page.items, "overlay").visible = false
				local itm = getItemByName(page.items, "button1")
				itm.visible, itm.selectable = false, false
				itm = getItemByName(page.items, "button2")
				itm.visible, itm.selectable = false, false
			end
		end	
		
		local t_openLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_OPEN_HD_"
		local t_closedLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_HD_CLOSED"
		
		if screenWidth < 1920 or (g_levelSelectionMultipleAssets ~= true) then
			t_openLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_OPEN_"
			t_closedLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_CLOSED"
		end
		
		local t_gameUnlocked = 	(deviceModel == "windows" and g_registrationEnabled == true and g_isGameUnlocked == true) or 
								(deviceModel ~= "windows") or 
								(g_registrationEnabled == false)
		
		if not limitLevels then
			for i = 1, #page.items do
				if page.items[i].levelIndex ~= nil then
					themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
					if 	( 	(settings.lastOpenLevel >= page.items[i].levelIndex) or
							(highscores[page.items[i].filename] ~= nil) ) and
							(t_gameUnlocked == true or page.items[i].levelIndex < 23) then
							
						page.items[i].text = "" .. page.items[i].pageLevelIndex						
						--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. page.themes[themeIndex]
						page.items[i].sprite = t_openLevelSpritePrefix .. page.themes[themeIndex]
						
						page.items[i].selectable = true
					else
						page.items[i].text = nil
						--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
						page.items[i].sprite = t_closedLevelSpritePrefix
						page.items[i].selectable = false
					end
				end
			end
		else
			for i = 1, #page.items do
				if page.items[i].levelIndex ~= nil then
					page.items[i].text = ""
					page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					page.items[i].selectable = false
				
					for j = 1, #openDemoLevels do
						if page.items[i].levelIndex == openDemoLevels[j] then
							page.items[i].text = "" .. page.items[i].pageLevelIndex
							page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. page.themes[page.currentPage]
							page.items[i].selectable = true
						end
					end
				end
			end		
		end
		
		for k = 0, pages - 1 do		
			for i = 1, itemsPerPage do				
				local t_itemIndex = page.firstLevelIndex - 1 + i + (k * itemsPerPage)				
				prepareItemForMouseScalingStates(page.items[t_itemIndex])				
			end															
		end
		
	
		
		if not isLiteVersion and (levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0) then
			getItemByName(page.items, "text_1").visible = page.currentPage == 1
			getItemByName(page.items, "text_2").visible = page.currentPage == 2
			getItemByName(page.items, "text_3").visible = page.currentPage == 3
			
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot3").sprite = "LS_DOT_BLACK"
			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true
			getItemByName(page.items, "dot3").visible = true
		end
		
		if isLiteVersion then
			levelSelectionPagesBasic.items[#levelSelectionPagesBasic.items].x = screenWidth*0.5
			levelSelectionPagesBasic.items[#levelSelectionPagesBasic.items].y = levelSelectionPagesBasic.items[#levelSelectionPagesBasic.items].y + 16
		end
		
		--if oldMenuPage ~= mainMenu and oldMenuPage ~= episodeSelectionPage then
			--_G.res.stopAllAudio()
		--end
		if _G.res.isAudioPlaying("title_theme") == false then
			_G.res.playAudio("title_theme", 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
	end	
	
	if page == levelSelectionPagesExtra then
		
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesExtra.firstLevelIndex, #levelSelectionPagesExtra.items do
			levelSelectionPagesExtra.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.extra = page.currentPage		
		
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		local textY = 0.03 * screenHeight + 15
		local yDividerMultiplier = 1.16
		if deviceModel == "roku" then
			textY = 0.059 * screenHeight
			lsDotY = textY - 25
			if screenHeight <= 576 then
				textY = 0.07 * screenHeight
				lsDotY = textY - 18
			end
		end
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		--back.x, back.y = 0, screenHeight
		back.x, back.y = 0 + t_levelSelectionBackOffsetX, screenHeight + t_levelSelectionBackOffsetY
		
		local text1 = getItemByName(page.items, "text_4")
		text1.x, text1.y = screenWidth / 2 - lsDotSpacing / 2, screenHeight - textY
		local text2 = getItemByName(page.items, "text_5")
		text2.x, text2.y = screenWidth / 2 + lsDotSpacing / 2, screenHeight - textY

		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = screenWidth / 2 - lsDotSpacing / 2, screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = screenWidth / 2 + lsDotSpacing / 2, screenHeight - lsDotY
		
		local t_title = getItemByName(page.items, "title")
		t_title.x, t_title.y = screenWidth / 2, (93 / 1200) * screenHeight
		
		local t_minDistance = 150
		
		if (g_levelSelectionClippingArea.y - t_title.y) < t_minDistance then
			t_title.y = g_levelSelectionClippingArea.y - t_minDistance
		end
		
		if deviceModel == "roku" and screenHeight <= 576 then
			t_title.y = t_title.y + 50
		end
		
		local t_leftNavigation = getItemByName(page.items, "leftNavigation")
		local t_rightNavigation = getItemByName(page.items, "rightNavigation")
		
		--t_leftNavigation.x, t_leftNavigation.y = (210 / t_referenceScreenWidth) * screenWidth, (619 / t_referenceScreenHeight) * screenHeight
		--t_leftNavigation.x, t_leftNavigation.y = (210 / t_referenceScreenWidth) * screenWidth, (1100 / t_referenceScreenHeight) * screenHeight
		--t_rightNavigation.x, t_rightNavigation.y= (1710 / t_referenceScreenWidth) * screenWidth, (619 / t_referenceScreenHeight) * screenHeight
		--t_rightNavigation.x, t_rightNavigation.y= (1710 / t_referenceScreenWidth) * screenWidth, (1100 / t_referenceScreenHeight) * screenHeight
		
		--t_leftNavigation.x = g_levelSelectionClippingArea.x - t_navigationButtonOffsetX
		--t_rightNavigation.x = g_levelSelectionClippingArea.x + g_levelSelectionClippingArea.width + t_navigationButtonOffsetX
		
		local t_visibleAreaOverlayOffsetX = g_levelSelectionClippingArea.offsetX
		local t_visibleAreaOverlayOffsetY = g_levelSelectionClippingArea.offsetY
		
		local t_height = g_levelSelectionClippingArea.height + t_visibleAreaOverlayOffsetY * 2
		local t_y = g_levelSelectionClippingArea.y - t_visibleAreaOverlayOffsetY		
		
		t_leftNavigation.y = t_y + (t_height * 0.5)
		t_rightNavigation.y = t_leftNavigation.y
		
		t_leftNavigation.x = g_levelSelectionClippingArea.x - t_navigationButtonOffsetX
		t_rightNavigation.x = g_levelSelectionClippingArea.x + t_navigationButtonOffsetX + g_levelSelectionClippingArea.width
		
		
		prepareItemForMouseScalingStates(back)
		prepareItemForMouseScalingStates(t_leftNavigation)
		prepareItemForMouseScalingStates(t_rightNavigation)
				
		
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 0.023 * screenWidth
		local lsDotY = 0.03 * screenHeight
		local textY = 0.03 * screenHeight + 15
		local yDividerMultiplier = 1.16
			
		local contentAreaWidth = screenWidth * 0.83
		
		
		
		
		local itemsPerPage = 21
		local itemsPerLine = 7
		local linesPerPage = 3
		local pages = 2
		
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		
		--new level selection
		--local t_pivotX, t_pivotY = _G.res.getSpritePivot("", page.items[page.firstLevelIndex].sprite)
		local t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_LEVEL_BG_NORMAL_OPEN_HD_1")
		--local t_width, t_height = _G.res.getSpriteBounds("", page.items[page.firstLevelIndex].sprite)
		local t_width, t_height = _G.res.getSpriteBounds("", "LS_LEVEL_BG_NORMAL_OPEN_HD_1")
				
		if screenWidth < 1920 or (g_levelSelectionMultipleAssets ~= true) then
			t_width, t_height = _G.res.getSpriteBounds("", "LS_LEVEL_BG_NORMAL_OPEN_1")
			t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_LEVEL_BG_NORMAL_OPEN_1")
		end		
		
		local t_spaceX = (g_levelSelectionClippingArea.width - t_width) / (itemsPerLine - 1)
		local t_totalLines = itemsPerPage / itemsPerLine
		local t_spaceY = (g_levelSelectionClippingArea.height - t_height) / (t_totalLines - 1)
		
		g_levelSelectionScrollOffset = g_levelSelectionClippingArea.width + (t_spaceX)			
		
		contentAreaWidth = g_levelSelectionClippingArea.width - (t_pivotX * 2)
		--new level selection	
		
		
		
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		
		--new level selection
		levelSelectionPagesExtra.currentOffset = (levelSelectionPagesExtra.currentPage - 1) * -g_levelSelectionScrollOffset		
		levelSelectionPagesExtra.targetOffset = levelSelectionPagesExtra.currentOffset
		
		
		local offset = 0
		for k = 0, pages - 1 do
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				
				--new level selection
				local t_itemIndex = page.firstLevelIndex - 1 + i + (k * itemsPerPage)
				
				page.items[t_itemIndex].x = offset + levelSelectionPagesExtra.currentOffset + g_levelSelectionClippingArea.x + t_pivotX + (indexInLine - 1) * t_spaceX				
				page.items[t_itemIndex].relativeX =  offset + g_levelSelectionClippingArea.x + t_pivotX + (indexInLine - 1) * t_spaceX
				page.items[t_itemIndex].y = g_levelSelectionClippingArea.y + t_pivotY + ( (line-1) * t_spaceY )
				--new level selection
				
				prepareItemForMouseScalingStates(page.items[t_itemIndex])
				
				
				--[[
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = offset + contentAreaStart + (indexInLine - 1) * contentItemStep + levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX =  offset + page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x - levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = screenHeight * yDivider + ySpaceAdd
				]]--
			end
				
			--offset = offset + screenWidth / 2
			--new level selection
			offset = offset + g_levelSelectionScrollOffset
		end
		
		local t_openLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_OPEN_HD_"
		local t_closedLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_HD_CLOSED"
		
		if screenWidth < 1920 or (g_levelSelectionMultipleAssets ~= true) then
			t_openLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_OPEN_"
			t_closedLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_CLOSED"
		end
		
		
		for i = 1, #page.items do
			if page.items[i].levelIndex ~= nil then
				themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
				if settings.lastOpenLevelLP2 >= page.items[i].levelIndex or highscores[page.items[i].filename] ~= nil then
					page.items[i].text = "" .. page.items[i].pageLevelIndex
					--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. page.themes[themeIndex]
					page.items[i].sprite = t_openLevelSpritePrefix .. page.themes[themeIndex]
					page.items[i].selectable = true
				else
					page.items[i].text = nil
					--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					page.items[i].sprite = t_closedLevelSpritePrefix
					page.items[i].selectable = false
				end
			end
		end
		
		for k = 0, pages - 1 do
			for i = 1, itemsPerPage do
				local t_itemIndex = page.firstLevelIndex - 1 + i + (k * itemsPerPage)
				prepareItemForMouseScalingStates(page.items[t_itemIndex])
			end
		end
		
		if not isLiteVersion and (levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0) then
			getItemByName(page.items, "text_4").visible = page.currentPage == 1
			getItemByName(page.items, "text_5").visible = page.currentPage == 2
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true
		end
		
		--if oldMenuPage ~= mainMenu and 
		--	oldMenuPage ~= episodeSelectionPage then
		--	_G.res.stopAllAudio()
		--end
		if _G.res.isAudioPlaying("title_theme") == false then
			_G.res.playAudio("title_theme", 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
	end	
	
	if levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1] then
		g_levelSelectionScrollOffset = screenWidth
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		local lsDotSpacing = 15
		local lsDotY = 10
		local puzzledBird = getItemByName(page.items, "puzzledBird")
		local pbx, pby = _G.res.getSpritePivot("","GOLDEN_EGG_PUZZLED_BIRD")
		local pbw, pbh = _G.res.getSpriteBounds("","GOLDEN_EGG_PUZZLED_BIRD")
		local textY = 0.03 * screenHeight + 15
		if deviceModel == "roku" then
			textY = 0.059 * screenHeight
			lsDotY = textY - 25
			if screenHeight <= 576 then
				textY = 0.07 * screenHeight
				lsDotY = textY - 18
			end
		end
		local goldenEggPositions = {}
		if(customer == "Intel") then
			goldenEggPositions = {{x = 0.29 * screenWidth, y = 0.21 * screenHeight}, 
							{x = 0.68 * screenWidth, y = 0.21 * screenHeight},
							{x = 0.1 * screenWidth, y = 0.45 * screenHeight}, 
							{x = 0.5 *  screenWidth, y = 0.48 * screenHeight},
							{x = 0.81 * screenWidth, y = 0.53 * screenHeight}, 
							{x = 0.27 * screenWidth, y = 0.82 * screenHeight},
							{x = 0.58 * screenWidth, y = 0.84 * screenHeight}, 
							--{x = 0.32 * screenWidth, y = 0.53 * screenHeight},
							{x = 0.35 * screenWidth, y = 0.5 * screenHeight},
							{x = 0.8 * screenWidth, y = 0.83 * screenHeight}, 
							{x = 0.91 * screenWidth, y = 0.16 * screenHeight},
							{x = 0.08 * screenWidth, y = 0.17 * screenHeight}, 
							{x = 0.5 * screenWidth, y = 0.24 * screenHeight}, -- 3.
							{x = 0.08 * screenWidth, y = 0.67 * screenHeight}, -- 4.
							{x = 0.61 * screenWidth, y = 0.54 * screenHeight}, -- 1.
							{x = 0.48 * screenWidth, y = 0.72 * screenHeight}, -- 2.
							--{x = 1.44 * screenWidth, y = 0.75 * screenHeight},
							--{x = 1.5 *  screenWidth, y = 0.48 * screenHeight},
							{x = 0.81 * screenWidth, y = 0.32 * screenHeight},
							{x = 0.7 *  screenWidth, y = 0.71 * screenHeight},
							
							{x = 0.2 *  screenWidth, y = 0.35 * screenHeight},
							{x = 0.93 *  screenWidth, y = 0.39 * screenHeight},									
							{x = 0.23 *  screenWidth, y = 0.59 * screenHeight},
							
							{x = 0.80 *  screenWidth, y = 0.11 * screenHeight},
							{x = 0.165 *  screenWidth, y = 0.87 * screenHeight},
							
							{x = 0.19 * screenWidth, y = 0.13 * screenHeight}, 
							{x = 0.59 * screenWidth, y = 0.33 * screenHeight}, 
							{x = 0.37 * screenWidth, y = 0.73 * screenHeight}, 
							{x = 0.40 * screenWidth, y = 0.33 * screenHeight}, 
							
							
							{x = 0.4 * screenWidth, y = 0.11 * screenHeight}, -- 1. Intel
							{x = 0.58 * screenWidth, y = 0.12 * screenHeight}, -- 2. Intel
							{x = 0.70 * screenWidth, y = 0.42 * screenHeight}, -- 3. Intel
							{x = 0.92 * screenWidth, y = 0.60 * screenHeight}, -- 4. Intel
							{x = 0.45 * screenWidth, y = 0.9 * screenHeight}, -- 5. Intel
						 }
			
		else
		
			goldenEggPositions = {{x = 0.29 * screenWidth, y = 0.21 * screenHeight}, 
									{x = 0.68 * screenWidth, y = 0.21 * screenHeight},
									{x = 0.1 * screenWidth, y = 0.45 * screenHeight}, 
									{x = 0.5 *  screenWidth, y = 0.48 * screenHeight},
									{x = 0.81 * screenWidth, y = 0.53 * screenHeight}, 
									{x = 0.27 * screenWidth, y = 0.82 * screenHeight},
									{x = 0.58 * screenWidth, y = 0.84 * screenHeight}, 
									--{x = 0.32 * screenWidth, y = 0.53 * screenHeight},
									{x = 0.35 * screenWidth, y = 0.5 * screenHeight},
									{x = 0.8 * screenWidth, y = 0.83 * screenHeight}, 
									{x = 0.91 * screenWidth, y = 0.16 * screenHeight},
									{x = 0.08 * screenWidth, y = 0.17 * screenHeight}, 
									{x = 0.5 * screenWidth, y = 0.19 * screenHeight},
									{x = 0.08 * screenWidth, y = 0.72 * screenHeight},
									{x = 0.66 * screenWidth, y = 0.52 * screenHeight},
									{x = 0.48 * screenWidth, y = 0.75 * screenHeight},
									--{x = 1.44 * screenWidth, y = 0.75 * screenHeight},
									--{x = 1.5 *  screenWidth, y = 0.48 * screenHeight},
									{x = 0.81 * screenWidth, y = 0.32 * screenHeight},
									{x = 0.7 *  screenWidth, y = 0.71 * screenHeight},
									
									{x = 0.2 *  screenWidth, y = 0.35 * screenHeight},
									{x = 0.93 *  screenWidth, y = 0.39 * screenHeight},									
									{x = 0.23 *  screenWidth, y = 0.59 * screenHeight},
									
									{x = 0.80 *  screenWidth, y = 0.11 * screenHeight},
									{x = 0.165 *  screenWidth, y = 0.87 * screenHeight},
									
									{x = 0.19 * screenWidth, y = 0.13 * screenHeight}, 
									{x = 0.59 * screenWidth, y = 0.33 * screenHeight}, 
									{x = 0.37 * screenWidth, y = 0.76 * screenHeight}, 
									{x = 0.40 * screenWidth, y = 0.31 * screenHeight}, 
								 }
		end
		
		local tipBubblePositions = {{x = screenWidth - 3.5 * pbw, y = screenHeight - 1.5 * pbh}, 
									{x = 1.5 * pbw, y = 0.75 * pbh}, 
									{x = 2 * pbw, y = pbh}}
									
		
		if _G.res.isAudioPlaying("title_theme") == false then
			_G.res.playAudio("title_theme", 0.8, true, 7)
		end
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		-- set puzzled bird and back button position
		
		page.items[1].x, page.items[1].y = screenWidth, screenHeight
		--getItemByName(page.items, "back").x, getItemByName(page.items, "back").y = 0, screenHeight
		local back = getItemByName(page.items, "back")
		back.x, back.y = 0 + t_levelSelectionBackOffsetX, screenHeight + t_levelSelectionBackOffsetY
		
		if deviceModel == "roku" then
			back.y = screenHeight * 0.95 - (t_spriteHeight - t_pivotY) + 21
		end
		
		prepareItemForMouseScalingStates(back)
		
		-- set golden egg positions
		
		for i = 0, page.levelCount - 1 do
			page.items[page.firstLevelIndex + i].x, page.items[page.firstLevelIndex + i].y = goldenEggPositions[i+1].x, goldenEggPositions[i+1].y
			page.items[page.firstLevelIndex + i].relativeX = goldenEggPositions[i+1].x
			page.items[page.firstLevelIndex + i].selectable = false
			if i < 7 then
				page.items[page.firstLevelIndex + i].children[1].x, page.items[page.firstLevelIndex + i].children[1].y = screenWidth / 2 - goldenEggPositions[i+1].x, screenHeight / 2 - goldenEggPositions[i+1].y
			end
			
			-- set stars positions
			page.items[page.firstLevelIndex + page.levelCount + i].x = goldenEggPositions[i+1].x
			page.items[page.firstLevelIndex + page.levelCount + i].y = goldenEggPositions[i+1].y
			page.items[page.firstLevelIndex + page.levelCount + i].relativeX = goldenEggPositions[i+1].x	
		end
		
		if settings.openGoldenEggLevels["Level1"] ~= nil or highscores[goldenEggLevelMapping["Level1"]] ~= nil then
			page.items[page.firstLevelIndex].sprite = "GOLDEN_EGG_3"
			page.items[page.firstLevelIndex].disableSelection = false
			page.items[page.firstLevelIndex].updateFunction = updateGame
		else
			page.items[page.firstLevelIndex].sprite = "EGG_SILHOUETTE_2"
			page.items[page.firstLevelIndex].disableSelection = true
			page.items[page.firstLevelIndex].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level2"] ~= nil or highscores[goldenEggLevelMapping["Level2"]] ~= nil then
			page.items[page.firstLevelIndex + 1].sprite = "GOLDEN_EGG_2"
			page.items[page.firstLevelIndex + 1].disableSelection = false
			page.items[page.firstLevelIndex + 1].updateFunction = updateGame
		else
			page.items[page.firstLevelIndex + 1].sprite = "EGG_SILHOUETTE_4"
			page.items[page.firstLevelIndex + 1].disableSelection = true
			page.items[page.firstLevelIndex + 1].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level3"] ~= nil or highscores[goldenEggLevelMapping["Level3"]] ~= nil then
			page.items[page.firstLevelIndex + 2].sprite = "GOLDEN_EGG_1"
			page.items[page.firstLevelIndex + 2].disableSelection = false
			page.items[page.firstLevelIndex + 2].updateFunction = updateGame
		else
			page.items[page.firstLevelIndex + 2].sprite = "EGG_SILHOUETTE_1"
			page.items[page.firstLevelIndex + 2].disableSelection = true
			page.items[page.firstLevelIndex + 2].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level4"] ~= nil or highscores[goldenEggLevelMapping["Level4"]] ~= nil then
			page.items[page.firstLevelIndex + 3].sprite = "GOLDEN_EGG_5"
			page.items[page.firstLevelIndex + 3].disableSelection = false
			page.items[page.firstLevelIndex + 3].updateFunction = updateSoundboard
		else
			page.items[page.firstLevelIndex + 3].sprite = "EGG_SILHOUETTE_3"
			page.items[page.firstLevelIndex + 3].disableSelection = true
			page.items[page.firstLevelIndex + 3].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level5"] ~= nil or highscores[goldenEggLevelMapping["Level5"]] ~= nil then
			page.items[page.firstLevelIndex + 4].sprite = "GOLDEN_EGG_3"
			page.items[page.firstLevelIndex + 4].disableSelection = false
			page.items[page.firstLevelIndex + 4].updateFunction = updateGame
			--page.items[page.firstLevelIndex + 4].updateFunction = updatePictureLevel
		else
			page.items[page.firstLevelIndex + 4].sprite = "EGG_SILHOUETTE_5"
			page.items[page.firstLevelIndex + 4].disableSelection = true
			page.items[page.firstLevelIndex + 4].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level6"] ~= nil or highscores[goldenEggLevelMapping["Level6"]] ~= nil then
			page.items[page.firstLevelIndex + 5].sprite = "GOLDEN_EGG_2"
			page.items[page.firstLevelIndex + 5].disableSelection = false
			page.items[page.firstLevelIndex + 5].updateFunction = updateGame
			--page.items[page.firstLevelIndex + 5].updateFunction = updatePictureLevel
		else
			page.items[page.firstLevelIndex + 5].sprite = "EGG_SILHOUETTE_7"
			page.items[page.firstLevelIndex + 5].disableSelection = true
			page.items[page.firstLevelIndex + 5].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level7"] ~= nil or highscores[goldenEggLevelMapping["Level7"]] ~= nil then
			page.items[page.firstLevelIndex + 6].sprite = "GOLDEN_EGG_4"
			page.items[page.firstLevelIndex + 6].disableSelection = false
			page.items[page.firstLevelIndex + 6].updateFunction = updateSoundboard
		else
			page.items[page.firstLevelIndex + 6].sprite = "EGG_SILHOUETTE_6"
			page.items[page.firstLevelIndex + 6].disableSelection = true
			page.items[page.firstLevelIndex + 6].updateFunction = nil
		end
		
		page.items[page.firstLevelIndex + 7].visible = settings.openGoldenEggLevels["Level8"] ~= nil or highscores[goldenEggLevelMapping["Level8"]] ~= nil
		page.items[page.firstLevelIndex + 8].visible = settings.openGoldenEggLevels["Level9"] ~= nil or highscores[goldenEggLevelMapping["Level9"]] ~= nil
		page.items[page.firstLevelIndex + 9].visible = settings.openGoldenEggLevels["Level10"] ~= nil or highscores[goldenEggLevelMapping["Level10"]] ~= nil
		page.items[page.firstLevelIndex + 10].visible = settings.openGoldenEggLevels["Level11"] ~= nil or highscores[goldenEggLevelMapping["Level11"]] ~= nil
		page.items[page.firstLevelIndex + 11].visible = settings.openGoldenEggLevels["Level12"] ~= nil or highscores[goldenEggLevelMapping["Level12"]] ~= nil
		page.items[page.firstLevelIndex + 12].visible = settings.openGoldenEggLevels["Level13"] ~= nil or highscores[goldenEggLevelMapping["Level13"]] ~= nil
		page.items[page.firstLevelIndex + 13].visible = settings.openGoldenEggLevels["Level14"] ~= nil or highscores[goldenEggLevelMapping["Level14"]] ~= nil
		page.items[page.firstLevelIndex + 14].visible = settings.openGoldenEggLevels["Level15"] ~= nil or highscores[goldenEggLevelMapping["Level15"]] ~= nil
		page.items[page.firstLevelIndex + 15].visible = settings.openGoldenEggLevels["Level16"] ~= nil or highscores[goldenEggLevelMapping["Level16"]] ~= nil
		page.items[page.firstLevelIndex + 16].visible = settings.openGoldenEggLevels["Level17"] ~= nil or highscores[goldenEggLevelMapping["Level17"]] ~= nil
		page.items[page.firstLevelIndex + 17].visible = settings.openGoldenEggLevels["Level18"] ~= nil or highscores[goldenEggLevelMapping["Level18"]] ~= nil
		page.items[page.firstLevelIndex + 18].visible = settings.openGoldenEggLevels["Level19"] ~= nil or highscores[goldenEggLevelMapping["Level19"]] ~= nil
		page.items[page.firstLevelIndex + 19].visible = settings.openGoldenEggLevels["Level20"] ~= nil or highscores[goldenEggLevelMapping["Level20"]] ~= nil
		
		page.items[page.firstLevelIndex + 20].visible = settings.openGoldenEggLevels["Level21"] ~= nil or highscores[goldenEggLevelMapping["Level21"]] ~= nil
		page.items[page.firstLevelIndex + 21].visible = settings.openGoldenEggLevels["Level22"] ~= nil or highscores[goldenEggLevelMapping["Level22"]] ~= nil
		
		page.items[page.firstLevelIndex + 22].visible = settings.openGoldenEggLevels["Level23"] ~= nil or highscores[goldenEggLevelMapping["Level23"]] ~= nil
		page.items[page.firstLevelIndex + 23].visible = settings.openGoldenEggLevels["Level24"] ~= nil or highscores[goldenEggLevelMapping["Level24"]] ~= nil
		page.items[page.firstLevelIndex + 24].visible = settings.openGoldenEggLevels["Level25"] ~= nil or highscores[goldenEggLevelMapping["Level25"]] ~= nil
		page.items[page.firstLevelIndex + 25].visible = settings.openGoldenEggLevels["Level26"] ~= nil or highscores[goldenEggLevelMapping["Level26"]] ~= nil
		
		if(customer == "Intel") then
			page.items[page.firstLevelIndex + 26].visible = true
			page.items[page.firstLevelIndex + 27].visible = true
			page.items[page.firstLevelIndex + 28].visible = true
			page.items[page.firstLevelIndex + 29].visible = true		
			page.items[page.firstLevelIndex + 30].visible = true		
		end
		
		--stars on eggs
		for i = 1, page.levelCount do
			page.items[page.firstLevelIndex + page.levelCount + i - 1].visible = settings.openGoldenEggLevels["Level" .. i] == 2
			
			if highscores[goldenEggLevelMapping["Level" .. i]] ~= nil and highscores[goldenEggLevelMapping["Level" .. i]].completed then
	
				page.items[page.firstLevelIndex + page.levelCount + i - 1].visible = true
				
			end
			
			if customer == "Intel" and i > 26 then
				local num_stars = 1
				local score = 0
				if highscores[goldenEggLevelMapping["Level" .. i]] ~= nil then
					score = highscores[goldenEggLevelMapping["Level" .. i]].score
				end
				if score >= starTable[goldenEggLevelMapping["Level" .. i]].silverScore then
					num_stars = 2
				end
				if score >= starTable[goldenEggLevelMapping["Level" .. i]].goldScore then
					num_stars = 3
				end
				page.items[page.firstLevelIndex + page.levelCount + i - 1].sprite = "INTEL_" .. num_stars .. "_STAR"
			end
			
			prepareItemForMouseScalingStates(page.items[page.firstLevelIndex + page.levelCount + i - 1], page.items[page.firstLevelIndex + i - 1])
			prepareItemForMouseScalingStates(page.items[page.firstLevelIndex + (i-1)])
		end
		
		local tipItem = getItemByName(page.items, "tipBubble")
		tipItem.visible = false
		tipItem.x, tipItem.y = tipBubblePositions[1].x, tipBubblePositions[1].y
		tipItem.children[1].x, tipItem.children[1].y = tipBubblePositions[2].x, tipBubblePositions[2].y
		tipItem.children[2].x, tipItem.children[2].y = tipBubblePositions[3].x, tipBubblePositions[3].y
		
		local tipContent = getItemByName(page.items, "tipContent")
		tipContent.x, tipContent.y, tipContent.visible = tipBubblePositions[1].x, tipBubblePositions[1].y, false
		
		if settings.threeStars  == true then
			goldenEggAchieved("Level4")
		end
		
		if settings.threeStarsLP2 == true then
			goldenEggAchieved("Level7")
		end
		
		if settings.threeStarsLP3 == true then
			goldenEggAchieved("Level12")
		end
		
		if settings.threeStarsLP4 == true then
			goldenEggAchieved("Level17")
		end
		
		if settings.threeStarsLP5 == true then
			goldenEggAchieved("Level21")
		end

		if settings.threeStarsLP6 == true then
			goldenEggAchieved("Level25")
		end
		
		getItemByName(page.items, "overlay").shade = 0
		getItemByName(page.items, "overlay").visible = false
		
		if not isLiteVersion and (levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0) then
			page.items[2].visible = page.currentPage == 1
			page.items[2].x, page.items[2].y = screenWidth / 2 - (lsDotSpacing / 3), screenHeight - 2.5 * lsDotY
			page.items[3].visible = page.currentPage == 2
			page.items[3].x, page.items[3].y = screenWidth / 2 + (lsDotSpacing / 3), screenHeight - 2.5 * lsDotY
			page.items[4].sprite = "LS_DOT_BLACK"
			page.items[4].x, page.items[4].y = (screenWidth / 2) - (lsDotSpacing / 3), screenHeight - lsDotY
			page.items[5].sprite = "LS_DOT_BLACK"
			page.items[5].x, page.items[5].y = (screenWidth / 2) +  (lsDotSpacing / 3), screenHeight - lsDotY
			page.items[3 + page.currentPage].sprite = "LS_DOT_WHITE"
			page.items[2].visible = false
			page.items[3].visible = false
			page.items[4].visible = false
			page.items[5].visible = false
		end
		page.currentOffset = page.targetOffset
	end
	
	if page == levelSelectionPagesPack3 then
	
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesPack3.firstLevelIndex, #levelSelectionPagesPack3.items do
			levelSelectionPagesPack3.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.pack3 = page.currentPage
			
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		local textY = 0.03 * screenHeight + 15
		local yDividerMultiplier = 1.16
		if deviceModel == "roku" then
			textY = 0.059 * screenHeight
			lsDotY = textY - 25
			if screenHeight <= 576 then
				textY = 0.07 * screenHeight
				lsDotY = textY - 18
			end
		end
	
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		--back.x, back.y = 0, screenHeight
		back.x, back.y = 0 + t_levelSelectionBackOffsetX, screenHeight + t_levelSelectionBackOffsetY
		
		local text6 = getItemByName(page.items, "text_6")
		text6.x, text6.y = screenWidth / 2 - lsDotSpacing, screenHeight - textY
		local text7 = getItemByName(page.items, "text_7")
		text7.x, text7.y = screenWidth / 2, screenHeight - textY
		local text8 = getItemByName(page.items, "text_8")
		text8.x, text8.y = screenWidth / 2 + lsDotSpacing, screenHeight - textY
		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = screenWidth / 2 - lsDotSpacing, screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = screenWidth / 2, screenHeight - lsDotY
		local dot3 = getItemByName(page.items, "dot3")
		dot3.x, dot3.y = screenWidth / 2 + lsDotSpacing, screenHeight - lsDotY
		
		local t_title = getItemByName(page.items, "title")
		t_title.x, t_title.y = screenWidth / 2, (93 / 1200) * screenHeight
		
		local t_minDistance = 150
		
		if (g_levelSelectionClippingArea.y - t_title.y) < t_minDistance then
			t_title.y = g_levelSelectionClippingArea.y - t_minDistance
		end
		
		if deviceModel == "roku" and screenHeight <= 576 then
			t_title.y = t_title.y + 50
		end
		
		local t_leftNavigation = getItemByName(page.items, "leftNavigation")
		local t_rightNavigation = getItemByName(page.items, "rightNavigation")
		
		--t_leftNavigation.x, t_leftNavigation.y = (210 / t_referenceScreenWidth) * screenWidth, (619 / t_referenceScreenHeight) * screenHeight
		--t_leftNavigation.x, t_leftNavigation.y = (210 / t_referenceScreenWidth) * screenWidth, (1100 / t_referenceScreenHeight) * screenHeight
		--t_rightNavigation.x, t_rightNavigation.y= (1710 / t_referenceScreenWidth) * screenWidth, (619 / t_referenceScreenHeight) * screenHeight
		--t_rightNavigation.x, t_rightNavigation.y= (1710 / t_referenceScreenWidth) * screenWidth, (1100 / t_referenceScreenHeight) * screenHeight
		
		--t_leftNavigation.x = t_leftNavigation.x - t_navigationButtonOffset
		--t_rightNavigation.x = t_rightNavigation.x + t_navigationButtonOffset
		
		local t_visibleAreaOverlayOffsetX = g_levelSelectionClippingArea.offsetX
		local t_visibleAreaOverlayOffsetY = g_levelSelectionClippingArea.offsetY
		
		local t_height = g_levelSelectionClippingArea.height + t_visibleAreaOverlayOffsetY * 2
		local t_y = g_levelSelectionClippingArea.y - t_visibleAreaOverlayOffsetY		
		
		t_leftNavigation.y = t_y + (t_height * 0.5)
		t_rightNavigation.y = t_leftNavigation.y
		
		t_leftNavigation.x = g_levelSelectionClippingArea.x - t_navigationButtonOffsetX
		t_rightNavigation.x = g_levelSelectionClippingArea.x + g_levelSelectionClippingArea.width + t_navigationButtonOffsetX
		

		prepareItemForMouseScalingStates(back)
		prepareItemForMouseScalingStates(t_leftNavigation)
		prepareItemForMouseScalingStates(t_rightNavigation)
		
		
		local itemsPerPage = 15
		local itemsPerLine = 5
		local linesPerPage = 3
		local pages = 3
		local contentAreaWidth = screenWidth * 0.74	
		
		--new level selection
		--local t_pivotX, t_pivotY = _G.res.getSpritePivot("", page.items[page.firstLevelIndex].sprite)
		--local t_width, t_height = _G.res.getSpriteBounds("", page.items[page.firstLevelIndex].sprite)
		
		local t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_LEVEL_BG_NORMAL_OPEN_HD_1")
		local t_width, t_height = _G.res.getSpriteBounds("", "LS_LEVEL_BG_NORMAL_OPEN_HD_1")
				
		if screenWidth < 1920 or (g_levelSelectionMultipleAssets ~= true) then
			t_width, t_height = _G.res.getSpriteBounds("", "LS_LEVEL_BG_NORMAL_OPEN_1")
			t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_LEVEL_BG_NORMAL_OPEN_1")
		end		
		
		
		
		local t_spaceX = (g_levelSelectionClippingArea.width - t_width) / (itemsPerLine - 1)
		local t_totalLines = itemsPerPage / itemsPerLine
		local t_spaceY = (g_levelSelectionClippingArea.height - t_height) / (t_totalLines - 1)
		
		g_levelSelectionScrollOffset = g_levelSelectionClippingArea.width + (t_spaceX)			
		
		contentAreaWidth = g_levelSelectionClippingArea.width - (t_pivotX * 2)
		--new level selection	
		
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		--new level selection
		levelSelectionPagesPack3.currentOffset = (levelSelectionPagesPack3.currentPage - 1) * -g_levelSelectionScrollOffset		
		levelSelectionPagesPack3.targetOffset = levelSelectionPagesPack3.currentOffset
		
		
		local offset = 0
		for k = 0, pages - 1 do
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				
				--new level selection
				local t_itemIndex = page.firstLevelIndex - 1 + i + (k * itemsPerPage)
				
				page.items[t_itemIndex].x = offset + levelSelectionPagesPack3.currentOffset + g_levelSelectionClippingArea.x + t_pivotX + (indexInLine - 1) * t_spaceX				
				page.items[t_itemIndex].relativeX =  offset + g_levelSelectionClippingArea.x + t_pivotX + (indexInLine - 1) * t_spaceX
				page.items[t_itemIndex].y = g_levelSelectionClippingArea.y + t_pivotY + ( (line-1) * t_spaceY )
				prepareItemForMouseScalingStates(page.items[t_itemIndex])
				
				
				--new level selection
				
				--[[
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = offset + contentAreaStart + (indexInLine - 1) * contentItemStep + levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX =  offset + page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x - levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = screenHeight * yDivider + ySpaceAdd
				]]--
			end	
			if k == pages - 1 then
				local goldenEgg = getItemByName(page.items, "goldenEgg")
				goldenEgg.x = g_levelSelectionScrollOffset * 3.25 + levelSelectionPagesPack3.currentOffset
				--goldenEgg.relativeX = g_levelSelectionScrollOffset * 3.25
				goldenEgg.relativeX = g_levelSelectionClippingArea.x + g_levelSelectionScrollOffset * 2.95
				goldenEgg.y = screenHeight / 2
				goldenEgg.y = g_levelSelectionClippingArea.y + g_levelSelectionClippingArea.height / 2
			end
			--offset = offset + screenWidth / 2
			--new level selection
			offset = offset + g_levelSelectionScrollOffset
		end
		
		local t_openLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_OPEN_HD_"
		local t_closedLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_HD_CLOSED"
		
		if screenWidth < 1920 or (g_levelSelectionMultipleAssets ~= true) then
			t_openLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_OPEN_"
			t_closedLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_CLOSED"
		end
		
		
		for i = 1, #page.items do
			if page.items[i].levelIndex ~= nil then
				themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
				if settings.lastOpenLevelLP3 >= page.items[i].levelIndex or highscores[page.items[i].filename] ~= nil then
					page.items[i].text = "" .. page.items[i].pageLevelIndex
					--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. page.themes[themeIndex]
					page.items[i].sprite = t_openLevelSpritePrefix .. page.themes[themeIndex]
					page.items[i].selectable = true
				else
					page.items[i].text = nil
					--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					page.items[i].sprite = t_closedLevelSpritePrefix
					page.items[i].selectable = false
				end
			end
		end
		
		for k = 0, pages - 1 do		
			for i = 1, itemsPerPage do				
				local t_itemIndex = page.firstLevelIndex - 1 + i + (k * itemsPerPage)				
				prepareItemForMouseScalingStates(page.items[t_itemIndex])				
			end															
		end
				
		if levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0 then	
			getItemByName(page.items, "text_6").visible = page.currentPage == 1
			getItemByName(page.items, "text_7").visible = page.currentPage == 2
			getItemByName(page.items, "text_8").visible = page.currentPage == 3
	
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot3").sprite = "LS_DOT_BLACK"
			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true
			getItemByName(page.items, "dot3").visible = true
			
		end
		
		--if oldMenuPage ~= mainMenu and 
		--	oldMenuPage ~= episodeSelectionPage then
		--	_G.res.stopAllAudio()
		--end
		if _G.res.isAudioPlaying("title_theme") == false then
			_G.res.playAudio("title_theme", 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
		getItemByName(page.items, "goldenEgg").visible = settings.openGoldenEggLevels["Level11"] == nil
	
	end
	
	if page == levelSelectionPagesPack4 then
	
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesPack4.firstLevelIndex, #levelSelectionPagesPack4.items do
			levelSelectionPagesPack4.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.pack4 = page.currentPage
		
		
		
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		local textY = 0.03 * screenHeight + 15
		local yDividerMultiplier = 1.16
		if deviceModel == "roku" then
			textY = 0.059 * screenHeight
			lsDotY = textY - 25
			if screenHeight <= 576 then
				textY = 0.07 * screenHeight
				lsDotY = textY - 18
			end
		end
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		--back.x, back.y = 0, screenHeight
		back.x, back.y = 0 + t_levelSelectionBackOffsetX, screenHeight + t_levelSelectionBackOffsetY
		
		local text9 = getItemByName(page.items, "text_9")
		text9.x, text9.y = screenWidth / 2 - lsDotSpacing, screenHeight - textY
		local text10 = getItemByName(page.items, "text_10")
		text10.x, text10.y = screenWidth / 2, screenHeight - textY
		local text11 = getItemByName(page.items, "text_11")
		text11.x, text11.y = screenWidth / 2 + lsDotSpacing, screenHeight - textY
		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = screenWidth / 2 - lsDotSpacing, screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = screenWidth / 2, screenHeight - lsDotY
		local dot3 = getItemByName(page.items, "dot3")
		dot3.x, dot3.y = screenWidth / 2 + lsDotSpacing, screenHeight - lsDotY
		
		local t_title = getItemByName(page.items, "title")
		t_title.x, t_title.y = screenWidth / 2, (93 / 1200) * screenHeight
		
		local t_minDistance = 150
		
		if (g_levelSelectionClippingArea.y - t_title.y) < t_minDistance then
			t_title.y = g_levelSelectionClippingArea.y - t_minDistance
		end
		
		if deviceModel == "roku" and screenHeight <= 576 then
			t_title.y = t_title.y + 50
		end
		
		local t_leftNavigation = getItemByName(page.items, "leftNavigation")
		local t_rightNavigation = getItemByName(page.items, "rightNavigation")
		
		prepareItemForMouseScalingStates(back)
		prepareItemForMouseScalingStates(t_leftNavigation)
		prepareItemForMouseScalingStates(t_rightNavigation)
		
		--t_leftNavigation.x, t_leftNavigation.y = (210 / t_referenceScreenWidth) * screenWidth, (619 / t_referenceScreenHeight) * screenHeight
		--t_leftNavigation.x, t_leftNavigation.y = (210 / t_referenceScreenWidth) * screenWidth, (1100 / t_referenceScreenHeight) * screenHeight
		--t_rightNavigation.x, t_rightNavigation.y= (1710 / t_referenceScreenWidth) * screenWidth, (619 / t_referenceScreenHeight) * screenHeight
		--t_rightNavigation.x, t_rightNavigation.y= (1710 / t_referenceScreenWidth) * screenWidth, (1100 / t_referenceScreenHeight) * screenHeight
		
		--t_leftNavigation.x = t_leftNavigation.x - t_navigationButtonOffset
		--t_rightNavigation.x = t_rightNavigation.x + t_navigationButtonOffset
		
		local t_visibleAreaOverlayOffsetX = g_levelSelectionClippingArea.offsetX
		local t_visibleAreaOverlayOffsetY = g_levelSelectionClippingArea.offsetY
		
		local t_height = g_levelSelectionClippingArea.height + t_visibleAreaOverlayOffsetY * 2
		local t_y = g_levelSelectionClippingArea.y - t_visibleAreaOverlayOffsetY		
		
		t_leftNavigation.y = t_y + (t_height * 0.5)
		t_rightNavigation.y = t_leftNavigation.y
		
		t_leftNavigation.x = g_levelSelectionClippingArea.x - t_navigationButtonOffsetX
		t_rightNavigation.x = g_levelSelectionClippingArea.x + g_levelSelectionClippingArea.width + t_navigationButtonOffsetX
		
		local itemsPerPage = 15
		local itemsPerLine = 5
		local linesPerPage = 3
		local pages = 3
		local contentAreaWidth = screenWidth * 0.74
		
		--new level selection
		--local t_pivotX, t_pivotY = _G.res.getSpritePivot("", page.items[page.firstLevelIndex].sprite)
		--local t_width, t_height = _G.res.getSpriteBounds("", page.items[page.firstLevelIndex].sprite)
		
		local t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_LEVEL_BG_NORMAL_OPEN_HD_1")
		local t_width, t_height = _G.res.getSpriteBounds("", "LS_LEVEL_BG_NORMAL_OPEN_HD_1")
				
		if screenWidth < 1920 or (g_levelSelectionMultipleAssets ~= true) then
			t_width, t_height = _G.res.getSpriteBounds("", "LS_LEVEL_BG_NORMAL_OPEN_1")
			t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_LEVEL_BG_NORMAL_OPEN_1")
		end		
		
		local t_spaceX = (g_levelSelectionClippingArea.width - t_width) / (itemsPerLine - 1)
		local t_totalLines = itemsPerPage / itemsPerLine
		local t_spaceY = (g_levelSelectionClippingArea.height - t_height) / (t_totalLines - 1)
		
		g_levelSelectionScrollOffset = g_levelSelectionClippingArea.width + (t_spaceX)			
		
		contentAreaWidth = g_levelSelectionClippingArea.width - (t_pivotX * 2)
		--new level selection	
			
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		--new level selection
		levelSelectionPagesPack4.currentOffset = (levelSelectionPagesPack4.currentPage - 1) * -g_levelSelectionScrollOffset		
		levelSelectionPagesPack4.targetOffset = levelSelectionPagesPack4.currentOffset
		
		
		local offset = 0
		for k = 0, pages - 1 do
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				
				--new level selection
				local t_itemIndex = page.firstLevelIndex - 1 + i + (k * itemsPerPage)
				
				page.items[t_itemIndex].x = offset + levelSelectionPagesPack4.currentOffset + g_levelSelectionClippingArea.x + t_pivotX + (indexInLine - 1) * t_spaceX				
				page.items[t_itemIndex].relativeX =  offset + g_levelSelectionClippingArea.x + t_pivotX + (indexInLine - 1) * t_spaceX
				page.items[t_itemIndex].y = g_levelSelectionClippingArea.y + t_pivotY + ( (line-1) * t_spaceY )
				--new level selection
				prepareItemForMouseScalingStates(page.items[t_itemIndex])
				
				
				--[[
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = offset + contentAreaStart + (indexInLine - 1) * contentItemStep + levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX =  offset + page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x - levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = screenHeight * yDivider + ySpaceAdd
				]]--
			end	
			--offset = offset + screenWidth / 2
			--new level selection
			offset = offset + g_levelSelectionScrollOffset
		end
		
		local t_openLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_OPEN_HD_"
		local t_closedLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_HD_CLOSED"
		
		if screenWidth < 1920 or (g_levelSelectionMultipleAssets ~= true) then
			t_openLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_OPEN_"
			t_closedLevelSpritePrefix = "LS_LEVEL_BG_NORMAL_CLOSED"
		end
		
		for i = 1, #page.items do
			if page.items[i].levelIndex ~= nil then
				themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
				if settings.lastOpenLevelLP4 >= page.items[i].levelIndex or highscores[page.items[i].filename] ~= nil then
					page.items[i].text = "" .. page.items[i].pageLevelIndex
					if themeIndex == 1 then
						--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_6" 
						page.items[i].sprite = t_openLevelSpritePrefix .. "6"
					elseif themeIndex == 2 then
						--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_5" 
						page.items[i].sprite = t_openLevelSpritePrefix .. "5" 
					else
						--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_2"
						page.items[i].sprite = t_openLevelSpritePrefix .. "2"
					end
					page.items[i].selectable = true
				else
					page.items[i].text = nil
					--page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					page.items[i].sprite = t_closedLevelSpritePrefix
					page.items[i].selectable = false
				end
			end
		end
		
		for k = 0, pages - 1 do		
			for i = 1, itemsPerPage do				
				local t_itemIndex = page.firstLevelIndex - 1 + i + (k * itemsPerPage)				
				prepareItemForMouseScalingStates(page.items[t_itemIndex])				
			end															
		end
				
		if levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0 then
			getItemByName(page.items, "text_9").visible = page.currentPage == 1
			getItemByName(page.items, "text_10").visible = page.currentPage == 2
			getItemByName(page.items, "text_11").visible = page.currentPage == 3
	
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot3").sprite = "LS_DOT_BLACK"
			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true
			getItemByName(page.items, "dot3").visible = true
		end
		
		--if oldMenuPage ~= mainMenu and 
		--	oldMenuPage ~= episodeSelectionPage then
		--	_G.res.stopAllAudio()
		--end
		if _G.res.isAudioPlaying("title_theme") == false then
			_G.res.playAudio("title_theme", 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
	end
	
	--prepare levelselectionpages for faster drawing
	if page == levelSelectionPagesBasic or page == levelSelectionPagesExtra or page == levelSelectionPagesPack3 or page == levelSelectionPagesPack4 then
		levelSelectionButtonIndeces = {}
		for k, v in _G.pairs(page.items) do
			if v.filename then
				local eagle = false
				for k2, v2 in _G.pairs(settings.eaglesUsedIn) do
					if v2.world == v.worldNumber and v2.level == v.pageLevelIndex then
						eagle = true
					end
				end
				_G.table.insert(levelSelectionButtonIndeces, {index = k, stars = 0, eagleUsed = eagle })
			end
		end
		
		local t_starSpritePrefix = "LS_STARS_HD_"
		local t_HD = true
		if screenWidth < 1920 or (g_levelSelectionMultipleAssets ~= true) then
			t_starSpritePrefix = "LS_STARS_"
			t_HD = false
		end		
				
		for i = 1, #levelSelectionButtonIndeces do
			local ci = page.items[levelSelectionButtonIndeces[i].index]
			
			--ugly hack to fix #3047
			local t_starOffset = 0
			if t_HD then t_starOffset = -16 end
			
			ci.spriteWidth, ci.spriteHeight = _G.res.getSpriteBounds("", ci.sprite)
			if highscores[ci.filename] ~= nil then
				if highscores[ci.filename].score > 0 then
					--levelSelectionButtonIndeces[i].starSprite = "LS_STARS_1"
					levelSelectionButtonIndeces[i].starSprite = t_starSpritePrefix .. "1"
					--ci.starItem = {sprite = "LS_STARS_1", x = ci.x, y = ci.y + ci.spriteHeight * 0.5}
					ci.starItem = {sprite =  t_starSpritePrefix .. "1", x = ci.x, y = ci.y + ci.spriteHeight * 0.5 + t_starOffset}
					prepareItemForMouseScalingStates(ci.starItem, ci)
				end
				if starTable[ci.filename] ~= nil then
					if highscores[ci.filename].score >= starTable[ci.filename].silverScore then
						--levelSelectionButtonIndeces[i].starSprite = "LS_STARS_2"
						levelSelectionButtonIndeces[i].starSprite = t_starSpritePrefix .. "2"
						--ci.starItem = {sprite = "LS_STARS_2", x = ci.x, y = ci.y + ci.spriteHeight * 0.5}
						ci.starItem = {sprite = t_starSpritePrefix .. "2", x = ci.x, y = ci.y + ci.spriteHeight * 0.5 + t_starOffset}
						prepareItemForMouseScalingStates(ci.starItem, ci)
					end
					if highscores[ci.filename].score >= starTable[ci.filename].goldScore then
						--levelSelectionButtonIndeces[i].starSprite = "LS_STARS_3"
						levelSelectionButtonIndeces[i].starSprite = t_starSpritePrefix .. "3"
						--ci.starItem = {sprite = "LS_STARS_3", x = ci.x, y = ci.y + ci.spriteHeight * 0.5}
						ci.starItem = {sprite = t_starSpritePrefix .. "3", x = ci.x, y = ci.y + ci.spriteHeight * 0.5 + t_starOffset}
						prepareItemForMouseScalingStates(ci.starItem, ci)
					end
					if settings.mightyEagleEnabled == true and highscores[ci.filename].eagleScore ~= nil and 
					    ((starTable[ci.filename].eagleFeatherScore ~= nil and highscores[ci.filename].eagleScore >= starTable[ci.filename].eagleFeatherScore) or 
					     (starTable[ci.filename].eagleFeatherScore == nil and highscores[ci.filename].eagleScore > 0)) then
						levelSelectionButtonIndeces[i].featherSprite = "LS_EAGLE_FEATHER"
					end
				end
			end
		end
		
	end
	
	if page == upsellPage then
		if deviceModel == "n900" then
		
		elseif deviceModel == "s60" then
		
		else
			local backgroundWidth, backgroundHeight = _G.res.getSpriteBounds("", "UPSELL_BG")
			page.backgroundSprite.x, page.backgroundSprite.y = 0, 0
				
			if screenHeight ~= backgroundHeight then
				page.backgroundSprite.scale = true
				page.backgroundSprite.ys = screenHeight / backgroundHeight
				page.backgroundSprite.xs = screenHeight / backgroundHeight
				local newWidth = backgroundWidth * page.backgroundSprite.xs
				if newWidth < screenWidth then
					page.backgroundSprite.x = (screenWidth - newWidth) / 2
				else
					page.backgroundSprite.ys = screenWidth / backgroundWidth
					page.backgroundSprite.xs = screenWidth / backgroundWidth
					local newHeight = backgroundHeight * page.backgroundSprite.ys
					if newHeight < screenHeight then
						page.backgroundSprite.y = (screenHeight - newHeight) / 2
					end
				end
			elseif screenWidth ~= backgroundWidth then
				page.backgroundSprite.x = (screenWidth - backgroundWidth) / 2
			end
			
			local back = getItemByName(page.items, "back")
			if deviceModel == "roku" then
				back.x, back.y = screenWidth * 0.05 - 5, screenHeight * 0.95 + 21
			else
				back.x, back.y = 0, screenHeight
			end
			
			local button = getItemByName(page.items, "button")
			button.x, button.y = screenWidth * 0.5, screenHeight * 0.5
			
		end
	end
	
	if page == tutorials then
		
		local maxW, maxH = 0, 0
		for i = 1, #tutorials.items do
			local itm = tutorials.items[i]
			itm.x, itm.y = screenWidth / 2, screenHeight / 2
			local x1, y1, x2, y2 = _G.res.getCompoSpriteBounds("", itm.sprite)
			if x2 - x1 > maxW then
				maxW = x2 - x1
			end
			if y2 - y1 > maxH then
				maxH = y2 - y1
			end
		end
		
		maxW = maxW + 32
		maxH = maxH + 32
		
		local _, borderH = _G.res.getSpriteBounds("", "TUTORIAL_BOTTOM_MIDDLE")
		local borderW, _ = _G.res.getSpriteBounds("", "TUTORIAL_LEFT")
		page.backgroundBox.x, page.backgroundBox.y = _G.math.floor(screenWidth / 2), _G.math.floor(screenHeight / 2)
		page.backgroundBox.width, page.backgroundBox.height = _G.math.floor(maxW) - borderW * 2, _G.math.floor(maxH) - borderH * 1.5
		local sw, sh = _G.res.getSpriteBounds("", "TUTORIAL_OK")
		if deviceModel == "roku" then
			sw, sh = _G.res.getSpriteBounds("", "ROKU_TUTORIAL_OK")
		end
		local gew, geh = _G.res.getSpriteBounds("", "GOLDEN_EGG_1")
		
		page.okButtonX, page.okButtonY = page.backgroundBox.x + page.backgroundBox.width / 2 - sw / 3, _G.math.floor(page.backgroundBox.y + page.backgroundBox.height / 2 + borderH * 0.7)
		
		local t_okButton = getItemByName(page.items, "okButton")
		
		t_okButton.x, t_okButton.y = page.okButtonX, page.okButtonY
		
		for i = 1, #tutorials.items do
			local itm = tutorials.items[i]			
			local t_isTrackPadTutorial = (itm.trackpadTutorial == true)			
			if not t_isTrackPadTutorial then							
				itm.okButtonX, itm.okButtonY = t_okButton.x, t_okButton.y
			end
		end
		
		
		prepareItemForMouseScalingStates(t_okButton)
		
		tutorialGoldenEggPosition.x, tutorialGoldenEggPosition.y = (page.backgroundBox.x + page.backgroundBox.width / 6) * 1.54, (page.backgroundBox.y - page.backgroundBox.height / 7) * 1.54
		tutorialGoldenEggPosition.hitBoxMinX, tutorialGoldenEggPosition.hitBoxMaxX = tutorialGoldenEggPosition.x * 0.65 - gew, tutorialGoldenEggPosition.x * 0.65 + gew
		tutorialGoldenEggPosition.hitBoxMinY, tutorialGoldenEggPosition.hitBoxMaxY = tutorialGoldenEggPosition.y * 0.65 - geh, tutorialGoldenEggPosition.y * 0.65 + geh
		
		
	end
	
	if page == gameComplete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_outro", 1, false, 7)
		getItemByName(page.items, "storyEnd1").visible = true
		getItemByName(page.items, "storyEnd2").visible = true
		getItemByName(page.items, "storyEndEyeNormal").visible = true
		page.timer = 2.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		
		page.tuneTimer = 3	
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local _, endStoryHeight = _G.res.getSpriteBounds("", "STORY_END_1_1")
		page.backgroundWidth = getCutsceneBackgroundWidth(page.items)

		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, endStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - endStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
		
		setGameOn(true)
	end
	
	if page == theme5Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_outro", 1, false, 7)
		page.items[1].visible = true
		getItemByName(page.items, "storyBg").visible = true
		getItemByName(page.items, "storyBoss").visible = true
		getItemByName(page.items, "storyTongue").visible = true
		getItemByName(page.items, "storyEggs").visible = true
		getItemByName(page.items, "storyKing").visible = true
		getItemByName(page.items, "storyEyeOpen").visible = true
		getItemByName(page.items, "storyEyePeek").visible = false
		getItemByName(page.items, "storyEyeWink").visible = false
		getItemByName(page.items, "storySmile").visible = false
		page.timer = 2.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 1.002
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local endStoryWidth, endStoryHeight = _G.res.getSpriteBounds("", "STORY_BOSS_BG")
		page.backgroundWidth = endStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, endStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - endStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
		
		setGameOn(true)
	end
	
		
	if page == gameStart then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5
		page.tuneTimer = 8.62
		page.offsetX = 0
		page.animationState = "SCROLL"		
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local storyBegin1 = getItemByName(page.items, "storyBegin1")
		storyBegin1.selectable = true
		getItemByName(page.items, "cutSceneBg").selectable = true

		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", storyBegin1.sprite)
		page.backgroundWidth = beginStoryWidth 
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, beginStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - beginStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
		
		if settings.gameStarted ~= true then
			getItemByName(page.items, "storyBegin1").selectable = false
			getItemByName(page.items, "cutSceneBg").selectable = false
		end
		
		setGameOn(true)
	end	
	
	if page == theme1Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_boss", 1, false, 7)
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.dontScroll = false
		page.scale = false
		page.xs, page.ys = 1, 1
		page.tuneTimer = 1.002
		
		local storyBg = getItemByName(page.items, "storyBg")
		local bossStoryWidth, bossStoryHeight = _G.res.getSpriteBounds("", storyBg.sprite)
		page.backgroundWidth = bossStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, bossStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - bossStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
		
		setGameOn(true)
		
		if isLiteVersion then
			getItemByName(page.items, "storyBoss").visible = false
		end
	end
	
	if page == theme4Start then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5
		page.offsetX = 0
		page.tuneTimer = 8.62
		page.animationState = "SCROLL"		
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_BG_1")
		page.backgroundWidth = getCutsceneBackgroundWidth(page.items)	
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, beginStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - beginStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
		
		getItemByName(page.items, "storyBg").selectable = true
		getItemByName(page.items, "storyBegin1").selectable = true
		getItemByName(page.items, "cutSceneBg").selectable = true
		if settings.lp2Started ~= true then
			getItemByName(page.items, "storyBg").selectable = false
			getItemByName(page.items, "storyBegin1").selectable = false
			getItemByName(page.items, "cutSceneBg").selectable = false
		end
	
		setGameOn(true)
	end	
	
	if page == theme6Start then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5
		page.offsetY = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 8.62
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_BG_1")
		
		local _, pigsHeight = _G.res.getSpriteBounds("", "STORY_FLYING_PIGS_1")
		local _, py = _G.res.getSpritePivot("", "STORY_FLYING_PIGS_1")
		
		page.backgroundWidth = beginStoryWidth / 2
		page.backgroundHeight = py
		if deviceModel == "roku" then page.backgroundHeight = py + beginStoryHeight + pigsHeight / 2 end
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		if deviceModel == "roku" then
			prepareCutScene(page, page.backgroundWidth, page.backgroundHeight)
			page.offsetX = page.clipX
			page.offsetY = _G.math.max(0, screenHeight - beginStoryHeight * page.ys + 1)
			page.cutSceneOffset = page.offsetX
			theme6Start.maxOffsetY = py * page.ys
			page.scrollSpeed = theme6Start.maxOffsetY / page.tuneTimer
		else
			prepareCutScene(page, page.backgroundWidth, beginStoryHeight, page.tuneTimer)
			page.offsetX = _G.math.max(0, (screenWidth - 1024) / 2)
			page.offsetY = (screenHeight - beginStoryHeight) / 2
			page.cutSceneOffset = page.offsetY
			theme6Start.maxOffsetY = py + page.offsetY
			page.scrollSpeed = page.backgroundHeight / page.tuneTimer
		end
		
		if deviceModel ~= "roku" then
			page.clipX = (screenWidth - 1024) / 2
			page.clipY = (screenHeight - beginStoryHeight) / 2
			page.clipW = 1024
			page.clipH = 659
		end
		
		for i = 1, #page.items do
			local itm = page.items[i]
			if not itm.dontOffset then
				itm.clip = true
			end
		end
		
		local blueRect = getItemByName(page.items, "blueRect")
		blueRect.x, blueRect.y = page.offsetX, page.offsetY
		blueRect.width, blueRect.height = 1024, 659
	
		getItemByName(page.items, "storyBg").selectable = true
		getItemByName(page.items, "cutSceneBg").selectable = true
		if settings.lp3Started ~= true then
			getItemByName(page.items, "storyBg").selectable = false
			getItemByName(page.items, "cutSceneBg").selectable = false
		end
		setGameOn(true)
	end
	
	if page == theme9Start then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5 
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 8.62	
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_BG_1")
		page.backgroundWidth = getCutsceneBackgroundWidth(page.items)
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, beginStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - beginStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
		
		getItemByName(page.items, "storyBg1").selectable = true
		getItemByName(page.items, "cutSceneBg").selectable = true
		if settings.lp4Started ~= true then
			getItemByName(page.items, "storyBg1").selectable = false
			getItemByName(page.items, "cutSceneBg").selectable = false
		end
		
		setGameOn(true)
	end	
	
	--prepare
	if page == theme12Start then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5 
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 8.62
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", "STORY_WESTERN_BEGIN")
		--page.backgroundWidth = getCutsceneBackgroundWidth(page.items)	
		page.backgroundWidth = beginStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, beginStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - beginStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
		
		getItemByName(page.items, "storyBg1").selectable = true
		getItemByName(page.items, "cutSceneBg").selectable = true
		if settings.lp5Started ~= true then
			getItemByName(page.items, "storyBg1").selectable = false
			getItemByName(page.items, "cutSceneBg").selectable = false
		end
		
		setGameOn(true)
	end
	
	if page == theme15Start then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 8.62
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", getItemByName(page.items, "storyBg").sprite)
		--page.backgroundWidth = getCutsceneBackgroundWidth(page.items)	
		page.backgroundWidth = beginStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, beginStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - beginStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
		
		getItemByName(page.items, "storyBg").selectable = true
		getItemByName(page.items, "cutSceneBg").selectable = true
		if settings.lp5Started ~= true then
			getItemByName(page.items, "storyBg").selectable = false
			getItemByName(page.items, "cutSceneBg").selectable = false
		end
		
		setGameOn(true)
		
	end
	
	--prepare
	if page == theme2Complete or page == theme4Complete or page == theme6Complete 
		or page == theme7Complete or page == theme9Complete or page == theme10Complete
		or page == theme11Complete or page == theme8Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		if page == theme11Complete or page == theme8Complete then
			_G.res.playAudio("birds_outro", 1, false, 7)
		else
			_G.res.playAudio("birds_boss", 1, false, 7)
		end
		if page == theme11Complete then
			getItemByName(page.items, "storyKingPeak").visible = false
			getItemByName(page.items, "storyKingWink").visible = true
		end
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.dontScroll = false
		page.scale = false
		page.xs, page.ys = 1, 1
		page.tuneTimer = 1.002
		
		local bossStoryWidth, bossStoryHeight = _G.res.getSpriteBounds("", "STORY_BOSS_BG")
		page.backgroundWidth = bossStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, bossStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - bossStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
	
		setGameOn(true)
	end
	
	--prepare
	if page == theme12Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		if page == theme11Complete or page == theme8Complete then
			_G.res.playAudio("birds_outro", 1, false, 7)
		else
			_G.res.playAudio("birds_boss", 1, false, 7)
		end
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.dontScroll = false
		page.scale = false
		page.xs, page.ys = 1, 1
		page.tuneTimer = 1.002
		
		local bossStoryWidth, bossStoryHeight = _G.res.getSpriteBounds("", "STORY_BOSS_BG")
		page.backgroundWidth = bossStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, bossStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - bossStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
	
		setGameOn(true)
			
	end
	
	--prepare
	if page == theme13Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_boss", 1, false, 7)
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.dontScroll = false
		page.scale = false
		page.xs, page.ys = 1, 1
		page.tuneTimer = 1.002
		
		local bossStoryWidth, bossStoryHeight = _G.res.getSpriteBounds("", "STORY_BOSS_BG")
		page.backgroundWidth = bossStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, bossStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - bossStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
	
		setGameOn(true)
	end
	
	if page == theme14Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_boss", 1, false, 7)
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.dontScroll = false
		page.scale = false
		page.xs, page.ys = 1, 1
		page.tuneTimer = 1.002
		
		local bossStoryWidth, bossStoryHeight = _G.res.getSpriteBounds("", "STORY_BOSS_BG")
		page.backgroundWidth = bossStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, bossStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - bossStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
	
		setGameOn(true)
	end
	
	if page == theme15Complete or page == theme16Complete or page == theme17Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_boss", 1, false, 7)
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 1.002
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local bossStoryWidth, bossStoryHeight = _G.res.getSpriteBounds("", getItemByName(page.items, "storyBg").sprite)
		page.backgroundWidth = bossStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, bossStoryHeight)
		page.offsetX = page.clipX
		page.offsetY = (screenHeight - bossStoryHeight) / 2
		page.cutSceneOffset = page.offsetX
		if deviceModel == "roku" then page.offsetY = 0 end
	
		setGameOn(true)
	end
	
	if page == gameFinished or page == gameFinishedLP2 or page == gameFinishedLP3 or page == gameFinishedLP4 or page == gameFinishedLP5 or
	   page == gameFinishedThreeStars or page == gameFinishedThreeStarsLP2 or page == gameFinishedThreeStarsLP3 or page == gameFinishedThreeStarsLP4 or page == gameFinishedThreeStarsLP5 then
		page.items[4].textBoxSize = 0.56 * screenWidth
		if page.items[4].textBoxSize > 395 then
			page.items[4].textBoxSize = 395
		end
		
		local text = page.items[4]
		local text2 = page.items[5]
		prepareTextItem(page, text)
		prepareTextItem(page, text2)
		local textRows = text.h / text2.h
		local borderW, borderH = _G.res.getSpriteBounds("POPUPS_SHEET_1", "POPUP_TOP_MIDDLE")
		
		-- background box
		page.backgroundBox.x, page.backgroundBox.y = screenWidth / 2, screenHeight / 2 + text.h * 0.2
		page.backgroundBox.width, page.backgroundBox.height = page.items[4].textBoxSize, text.h * 1.25
		-- star effect
		page.items[1].x, page.items[1].y = screenWidth / 2 + page.backgroundBox.width / 2.5, page.backgroundBox.y - page.backgroundBox.height / 2 - borderH
		-- reward
		page.items[3].x, page.items[3].y = screenWidth / 2 + page.backgroundBox.width / 2.5, page.backgroundBox.y - page.backgroundBox.height / 2 - borderH 
		-- yes button
		page.items[2].x, page.items[2].y = screenWidth * 0.5 + page.items[4].textBoxSize / 2.75, screenHeight / 2 + text.h
		prepareItemForMouseScalingStates(page.items[2])
		-- texts
		page.items[4].x, page.items[4].y = screenWidth * 0.5 - page.items[4].textBoxSize / 2, screenHeight * 0.5
		
		page.items[5].x, page.items[5].y = screenWidth * 0.5 - page.items[4].textBoxSize / 2, page.backgroundBox.y - page.backgroundBox.height / 2 - borderH 

	end

	if page == achievementPopUpPage then
		if gameCenterEnabled and gameCenter and gameCenter.achievements then
			local achi = gameCenter.achievements[gameCenter.achievements.showPopUpID]
			local achiText = getItemByName(page.items, "achievementText")
			achiText.text = achi.achievedText or "Earned an achievement."
			local achiTitle = getItemByName(page.items, "achievementTitle")
			achiTitle.text = achi.title or "Achievement Title"
			
			local achiIcon = getItemByName(achievementPopUpPage.items, "achievementIcon")
			if page.icons[achi.title] then
				achiIcon.sprite = page.icons[achi.title]
			end
			
			setFont(achiTitle.font)
			local fh1 = _G.res.getFontHeight()
			local sw1 = _G.res.getStringWidth(achiTitle.text)
			setFont(achiText.font)
			local fh2 = _G.res.getFontHeight()
			local sw2 = _G.res.getStringWidth(achiText.text)
			local sw3, sh3 = _G.res.getSpriteBounds("", "ACHIEVEMENT_BG_RIGHT")
			local sw4, sh4 = _G.res.getSpriteBounds("", achiIcon.sprite)
			local bgBox = getItemByName(page.items, "achievementBox")
			bgBox.width = _G.math.max(sw1, sw2 + sw4) * 1.2
			bgBox.height = sh3
			bgBox.x, bgBox.y = screenWidth - sw3, screenHeight
			
			
			achiIcon.x, achiIcon.y = -bgBox.width * 0.9, bgBox.height * 0.5
			
			
			achiTitle.x, achiTitle.y = -bgBox.width * 0.5, bgBox.height * 0.1
			achiText.x, achiText.y = achiIcon.x + sw4, bgBox.height * 0.63
			
			
			page.animationState = "MOVEUP"
			page.animationTimer = 0.3
		end
	end
		
	if page == goldenEggAchievedPage then
		_G.res.playAudio("goldenegg", 1, false)
		page.enablePhysicsWhenDone = isPhysicsEnabled()
		setPhysicsEnabled(false)
		page.animationState = "FADEIN"
		page.fadeInLength = 0.8
		page.fadedLength = 1.5
		page.fadeOutLength = 0.8
		page.fullyShaded = 0.75
		page.timer = page.fadeInLength
		page.items[1].angle = 0
		page.items[1].visible = false
		page.items[1].x = screenWidth*0.5
		page.items[1].y = screenHeight*0.5
	end
	
	if page == goldenEggStarAchievedPage then
		page.enablePhysicsWhenDone = isPhysicsEnabled()
		setPhysicsEnabled(false)
		page.animationState = "FADEIN"
		page.fadeInLength = 0.8
		page.fadedLength = 1.5
		page.fadeOutLength = 0.8
		page.fullyShaded = 0.75
		page.timer = page.fadeInLength
		page.items[1].angle = 0
		page.items[1].visible = false
		page.items[1].x = screenWidth*0.5
		page.items[1].y = screenHeight*0.5
	end
	
	if page == boomerangBirdAchievedPage then
		g_releaseGEOnPopupExit = true
		loadGoldenEggSprites()
		setPhysicsEnabled(false)
		page.animationState = "FADEIN"
		page.fadeInLength = 0.8
		page.fadedLength = 1.5
		page.fadeOutLength = 0.8
		page.fullyShaded = 0.75
		page.timer = page.fadeInLength
		page.items[1].angle = 0
		page.items[1].visible = false
		page.items[1].x = screenWidth*0.5
		page.items[1].y = screenHeight*0.5
	end
	
	-- page specific controls end
	
	if deviceModel == "n900" or deviceModel == "s60" then
		getItemByName(overlayMenuPage.items, "close").x = screenWidth
	elseif deviceModel == "android" and isBetaVersion then
		local betaUp = getItemByName(overlayMenuPage.items, "betaUp")
		betaUp.x, betaUp.y = 0, 0
	end
	
	
	--page.prepared = true
	
	-- prepare all text items
	if page.items ~= nil then
		local i = 1
		while i <= #page.items do
			local ci = page.items[i]
			prepareTextItem(page, ci)
			if ci.children ~= nil then
				for j = 1, #ci.children do
					prepareTextItem(page, ci.children[j])
				end
			end
			i = i + 1
		end
	end
	
	if page == about then
		local textAbout = getItemByName(page.items, "textAbout")
		local k = 1
		while k <= #textAbout.lines do
			local beginIndex, endIndex = _G.string.find(textAbout.lines[k], "$GAME_VERSION")
			if beginIndex ~= nil and beginIndex >= 1 then
				local s = _G.string.gsub(textAbout.lines[k], "(%$GAME_VERSION)", gameVersionNumber)
				textAbout.lines[k] = s
			end
			k = k + 1
		end
	end
end

function setLevelButtonLocked(page, i)
	page.items[i].text = nil
	page.items[i].selectable = false						
end

function recalculateLevelFailedPositions(levelFailedPage, boxWidthIncrease)
	
	local background = getItemByName(levelFailedPage.items, "background")
	local _, bh = _G.res.getSpriteBounds(background.sheet, background.box.topMiddle)
	local bw, _ = _G.res.getSpriteBounds(background.sheet, background.box.left)
	local _, bottomBorderH = _G.res.getSpriteBounds(background.sheet, background.box.bottomMiddle)
	local buttonMenu = getItemByName(levelFailedPage.items, "buttonMenu")
	prepareItemForMouseScalingStates(buttonMenu)
	local buttonW, buttonH = _G.res.getSpriteBounds("", buttonMenu.sprite)
	local levelFailed = getItemByName(levelFailedPage.items, "levelFailed")
	
	background.x, background.y = screenWidth * 0.5, screenHeight * 0.6
	levelFailed.x, levelFailed.y = background.x, background.y - buttonH * 0.1
	background.width = buttonW * 3.5 + boxWidthIncrease
	levelFailed.textBoxSize = background.width
	prepareTextItem(levelFailedPage, levelFailed)
	background.height = levelFailed.h + buttonH * 0.8
	
	local t_backgroundRealWidth = g_popupBorderRealWidth + background.width
	local t_spacing = ((t_backgroundRealWidth - (g_popupButtonRealWidth * 3) ) / 4)
	local t_startX = background.x - (t_backgroundRealWidth/2) + t_spacing + (g_popupButtonRealWidth / 2)
	local t_buttonSpacing =  t_spacing + g_popupButtonRealWidth
			
			
	local levelNumber = getItemByName(levelFailedPage.items, "levelNumber")
	prepareTextItem(levelFailedPage, levelNumber)
	local backgroundTop = levelFailedPage.backgroundBox
	local btw, bth = _G.res.getSpriteBounds(background.sheet, backgroundTop.sprites.topMiddle)
	local highScoreNumber = getItemByName(levelFailedPage.items, "highScoreNumber")
	local highScoreText = getItemByName(levelFailedPage.items, "highScoreText")
	prepareTextItem(levelFailedPage, highScoreText)
	prepareTextItem(levelFailedPage, highScoreNumber)
	
	backgroundTop.x, backgroundTop.y = background.x, background.y - background.height * 0.5
	backgroundTop.width, backgroundTop.height = background.width - bw * 0.5, bh * 0.7 + highScoreText.h * 3 - bth 
	backgroundTop.height = backgroundTop.height + g_levelPopUpsFailTopBackgroundHeightOffset
		
	levelNumber.x, levelNumber.y = backgroundTop.x - backgroundTop.width * 0.5 + buttonW * 0.1, backgroundTop.y - bh * 0.7 - (backgroundTop.height - bh * 0.7 + bth) * 0.5
		
	local stars = getItemByName(levelFailedPage.items, "stars")
	local starsW, starsH = _G.res.getSpriteBounds("", "RESULT_STARS_0")
	highScoreNumber.x, highScoreNumber.y = backgroundTop.x + backgroundTop.width * 0.5 - starsW - buttonW * 0.1, levelNumber.y + highScoreText.h * 0.5
	highScoreNumber.y = highScoreNumber.y + g_popupFailHighScoreYOffset
	
	stars.x, stars.y = highScoreNumber.x, highScoreNumber.y
	stars.visible = true
	
	highScoreText.x, highScoreText.y = highScoreNumber.x + starsW - (starsW + highScoreNumber.w) * 0.5, highScoreNumber.y - highScoreNumber.h * 1.1
	prepareTextItem(levelFailedPage, highScoreText)
	
	local highScoreTextRightSide = highScoreText.x + highScoreText.w * 0.5
	if highScoreTextRightSide > background.x + background.width * 0.5 then
		local move = highScoreTextRightSide - (background.x + background.width * 0.5)
		highScoreNumber.x = highScoreNumber.x - move
		highScoreText.x = highScoreText.x - move
		stars.x = stars.x - move
	end
	
	if inExtraWorld == true then
		stars.visible = false
		highScoreNumber.x = highScoreText.x + highScoreNumber.w * 0.5
	end	
	
	highScoreText.y = highScoreText.y + g_popupFailHighScoreLabelYOffset
	
	buttonMenu.x, buttonMenu.y = background.x - background.width * 0.5 + buttonW * 0.5, background.y + background.height * 0.5 + bottomBorderH * 0.5
	buttonMenu.x = t_startX
	
	local buttonRestart = getItemByName(levelFailedPage.items, "buttonRestart")
	buttonRestart.x, buttonRestart.y = background.x , buttonMenu.y
	buttonRestart.x = t_startX + t_buttonSpacing
	
	prepareItemForMouseScalingStates(buttonRestart)
	
	local buttonNextLevel = getItemByName(levelFailedPage.items, "buttonNextLevel")
	buttonNextLevel.x, buttonNextLevel.y = background.x + background.width * 0.5 - buttonW * 0.5, buttonMenu.y
	buttonNextLevel.x = t_startX + t_buttonSpacing*2
	
	prepareItemForMouseScalingStates(buttonNextLevel)
	
	local buttonEagle = getItemByName(levelFailedPage.items, "buttonEagle")
	buttonEagle.x, buttonEagle.y = buttonNextLevel.x, buttonNextLevel.y
	
	local buttonEagleLost = getItemByName(levelFailedPage.items, "buttonEagleLost")
	buttonEagleLost.x, buttonEagleLost.y = buttonNextLevel.x, buttonNextLevel.y
	
	local buttonEagleBuy = getItemByName(levelFailedPage.items, "buttonEagleBuy")
	buttonEagleBuy.x, buttonEagleBuy.y = buttonNextLevel.x, buttonNextLevel.y
	
	-- each cutscene has it's own button
	--for i = 1, 11 do
		
	for i = 1, 17 do
		local tempButton = getItemByName(levelFailedPage.items, "buttonCutscene" .. i)
		tempButton.x, tempButton.y = buttonNextLevel.x, buttonNextLevel.y
		prepareItemForMouseScalingStates(tempButton)
	end	
	
end

-- scale the cutscene to fill the screen
function prepareCutSceneRoku(page, storyWidth, storyHeight)

	local t_scaleDirection
	if storyWidth >= storyHeight and screenHeight ~= storyHeight then
		local scalingFactor = screenHeight / storyHeight
		page.scale = true
		page.xs, page.ys = scalingFactor, scalingFactor
		t_scaleDirection = "horizontal"
	elseif storyHeight > storyWidth and screenWidth ~= storyWidth then
		local scalingFactor = screenWidth / storyWidth
		page.scale = true
		page.xs, page.ys = scalingFactor, scalingFactor
		t_scaleDirection = "vertical"
	end

	page.clipX = _G.math.max((screenWidth  - storyWidth * page.xs)  / 2, 0)
	page.clipY = _G.math.max((screenHeight - storyHeight * page.ys) / 2, 0)
	page.clipW = screenWidth  - page.clipX
	page.clipH = screenHeight - page.clipY

	if t_scaleDirection == "horizontal" then
		page.scrollSpeed = _G.math.max(0, (storyWidth * page.xs - screenWidth) / page.tuneTimer)
	else
		page.scrollSpeed = _G.math.max(0, (storyHeight * page.ys - screenHeight) / page.tuneTimer)
	end
end

-- scale the cutscene to fill a clip area with a width of 1024 (default)
function prepareCutSceneDefault(page, storyWidth, storyHeight)

	local cutSceneBg = getItemByName(page.items, "cutSceneBg")
	cutSceneBg.x, cutSceneBg.y = screenWidth / 2, screenHeight / 2
	if screenHeight > 1024 or screenWidth > 1024 then
		local scalingFactor = _G.math.max(screenWidth / 1024, screenHeight / 1024)
		cutSceneBg.scale = true
		cutSceneBg.xs, cutSceneBg.ys = scalingFactor, scalingFactor
	end
	
	local cutSceneFilmTop = getItemByName(page.items, "cutSceneFilmTop")
	cutSceneFilmTop.x, cutSceneFilmTop.y = screenWidth / 2, (screenHeight / 2) - (storyHeight / 2)
	
	local cutSceneFilmBottom = getItemByName(page.items, "cutSceneFilmBottom")
	cutSceneFilmBottom.x, cutSceneFilmBottom.y = screenWidth / 2, (screenHeight / 2) + (storyHeight / 2)
	
	local cutSceneFilmLeft = getItemByName(page.items, "cutSceneFilmLeft")
	cutSceneFilmLeft.x, cutSceneFilmLeft.y = ((screenWidth - 1024) / 2), (screenHeight / 2) - (storyHeight / 2)
	
	local cutSceneFilmRight = getItemByName(page.items, "cutSceneFilmRight")
	cutSceneFilmRight.x, cutSceneFilmRight.y = screenWidth - cutSceneFilmLeft.x - 1, (screenHeight / 2) - (storyHeight / 2)

	if screenWidth > 1024 then
		for i = 1, #page.items do
			local itm = page.items[i]
			if not itm.dontOffset then
				itm.clip = true
			end
		end
		page.clipX = (screenWidth - 1024) / 2
		page.clipY = 0
		page.clipW = 1024
		page.clipH = screenHeight
	else
		page.clipX = 0
		page.clipY = 0
		page.clipW = screenWidth
		page.clipH = screenHeight
	end
	
	page.scrollSpeed = -(1024 - page.backgroundWidth) / page.tuneTimer
	
end

-- decide which prepare function we want to use
prepareCutScene = deviceModel == "roku" and prepareCutSceneRoku or prepareCutSceneDefault

function handleGameModeChange(page, selectedMenuItem)	
	-- game specific
	
	if levelSelectionPages == levelSelectionPagesGoldenEggs then
		if currentGameMode == updateGame or currentGameMode == updatePictureLevel or currentGameMode == updateSoundboard then
			if settings.openGoldenEggLevels["Level" .. selectedMenuItem - levelSelectionPagesGoldenEggs[1].firstLevelIndex + 1] == 0 then
				-- mark golden egg level as visited
				settings.openGoldenEggLevels["Level" .. selectedMenuItem - levelSelectionPagesGoldenEggs[1].firstLevelIndex + 1] = 1
				saveLuaFileWrapper("settings.lua", "settings", true)
			end
		end
	end
	
	if currentGameMode == updateGame then
		currentLevelNumberInTheme = page.items[selectedMenuItem].pageLevelIndex or currentLevelNumberInTheme
		currentWorldNumber = page.items[selectedMenuItem].worldNumber or currentWorldNumber
		
		if levelSelectionPages == levelSelectionPagesGoldenEggs then -- if we're starting an extra level

			if page.items[selectedMenuItem].restartLevel == nil then
				levelName = page.items[selectedMenuItem].filename
				levelFolder = page.items[selectedMenuItem].folder
				
				numberOfAttemptsInLevel = 1
				--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
				logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]) 
				--logEvent("level_started", "LEVELSELECTION_MENU", "G", currentLevelNumberInTheme, nil, numberOfAttemptsInLevel, 0, "", "")
			else
				-- level restarted
				settings.gameRestarted = settings.gameRestarted + 1
				--print("FlurryEventWithParam: Golden egg level restarted, Level, " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
				logFlurryEventWithParam("Golden egg level restarted", "Level", "" .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]) 
				--logEvent("level_restarted", levelRestartedFrom, "G", currentLevelNumberInTheme, nil, numberOfAttemptsInLevel, score, birdsShot, birdsCounter)
				numberOfAttemptsInLevel = numberOfAttemptsInLevel + 1
			end
			currentThemeNumber = 1
			inExtraWorld = true
		else
			if page.items[selectedMenuItem].restartLevel == nil then
				levelName = page.items[selectedMenuItem].filename
				levelFolder = page.items[selectedMenuItem].folder
				
				numberOfAttemptsInLevel = 1
				levelRestartedFlurryParams = {}
				levelRestartedFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
				levelRestartedFlurryParams["From"] = "levelselection menu"
				logFlurryEventWithParams("Level started", "levelRestartedFlurryParams") 
				--print("FlurryEventWithParam: Level started, Level, " .. currentWorldNumber .. "-" ..currentLevelNumberInTheme .. "\n")
				--logEvent("level_started", "LEVELSELECTION_MENU", currentWorldNumber, currentLevelNumberInTheme, nil, numberOfAttemptsInLevel, 0, "", "")
			else
				-- level restarted
				settings.gameRestarted = settings.gameRestarted + 1
				
				levelRestartedFlurryParams = {}
				levelRestartedFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
				levelRestartedFlurryParams["Attempts"] = "" .. numberOfAttemptsInLevel
				levelRestartedFlurryParams["Birds used"] = "" .. birdsShot
				levelRestartedFlurryParams["Birds available"] = "" .. birdsCounter
				levelRestartedFlurryParams["From"] = "" .. levelRestartedFrom
				
				logFlurryEventWithParams("Level restarted", "levelRestartedFlurryParams")

				--print("FlurryEventWithParam: Level restarted, Level, " .. currentWorldNumber .. "-" ..currentLevelNumberInTheme .. "\n")
				--logEvent("level_restarted", levelRestartedFrom, currentWorldNumber, currentLevelNumberInTheme, nil, numberOfAttemptsInLevel, score, birdsShot, birdsCounter)
				numberOfAttemptsInLevel = numberOfAttemptsInLevel + 1
			end
			inExtraWorld = false
		end
		
		setEditing(false)
		setPhysicsEnabled(false)
		currentLevelNumber = page.items[selectedMenuItem].levelIndex or currentLevelNumber
		currentThemeNumber = page.items[selectedMenuItem].themeIndex or currentThemeNumber
		currentPageNumber = page.pageNumber or currentPageNumber
		loading = true
		setGameMode(updateLoading)
		
	end
		
	if currentGameMode == updatePictureLevel then
		pictureLevelName = page.items[selectedMenuItem].pictureLevel
		if pictureLevelName ~= nil then
			currentPictureLevel = pictureLevelName
			currentLevelNumberInTheme = page.items[selectedMenuItem].pageLevelIndex
			initPictureLevel()
		end
	end
	
	if currentGameMode == updateSoundboard then
		soundboardName = page.items[selectedMenuItem].soundboard
		if soundboardName ~= nil then
			currentSoundboard = soundboardName
			currentLevelNumberInTheme = page.items[selectedMenuItem].pageLevelIndex
			initSoundboard()
		end
	end
	
	if currentGameMode == updateEditor then
		_G.res.stopAudio("title_theme")
		levelName = page.items[selectedMenuItem].filename
		levelFolder = page.items[selectedMenuItem].folder
		setEditing(true)
		setPhysicsEnabled(physicsEnabled)
		currentLevelNumberInTheme = page.items[selectedMenuItem].pageLevelIndex or currentLevelNumberInTheme		
		currentLevelNumber = page.items[selectedMenuItem].levelIndex or currentLevelNumber
		currentThemeNumber = page.items[selectedMenuItem].themeIndex or currentThemeNumber
		currentWorldNumber = page.items[selectedMenuItem].worldNumber or currentWorldNumber
		currentPageNumber = page.pageNumber or currentPageNumber
		loadLevelInternal(levelFolder .. levelName)
	end
end


function updateLoading(dt)
	if loadingPageDrawn == false then
		if deviceModel == "roku" then
			loadingPage.backgroundOverlay.shade = 1.0
		else
			loadingPage.backgroundOverlay.shade = 0.65
		end
		drawMenu()
		loadingPageDrawn = true
		loadLevelDelayed = levelFolder .. levelName
		loadLevelInternal(loadLevelDelayed)
		changeResolution = true
		wantedResolution = "FULL"
	end
end

function updateLoadingEx(dt)
	if loadingPageDrawn == false then
		if deviceModel == "roku" then
			loadingPage.backgroundOverlay.shade = 1.0
		else
			loadingPage.backgroundOverlay.shade = 0.65
		end
		loading = true
		drawMenu()
		loadingPageDrawn = true
		if loadingPage.nextPage.bgColor ~= nil then
			loadingPage.nextPage.bgColor = { red = loadingPage.nextPage.bgColor.red, green = loadingPage.nextPage.bgColor.green, blue = loadingPage.nextPage.bgColor.blue}
		end
		setActiveMenuPage(loadingPage.nextPage)
		popupPage = nil
		loadingPageDrawn = false
		loading = false
		--drawMenu()
		setGameMode(updateMenu)
	end
end

function releaseCutScenes()
	releaseCompoSprites({"CUTSCENES_COMPOSPRITES"})
	releaseImages( {"CUTSCENES"} )
	if deviceModel == "roku" then
		loadRokuAssetsAfter("cutscenes")
	end
end

function loadCutScenes()
	cutScenesReleased = false
	if deviceModel == "roku" then
		releaseRokuAssetsFor("cutscenes")
	end
	loadImages( {"CUTSCENES"}  )
	loadCompoSprites( {"CUTSCENES_COMPOSPRITES"} )	
end


function releaseRokuAssetsFor(scene)
	if scene == "cutscenes" then
		releaseImages({"INGAME", "LEVELSELECTION", "GOLDEN_EGGS", "OTHER_2"})
		if(currentGFXSet ~= nil) then
			print("- - Releasing graphics set : "..currentGFXSet.."\n")
			releaseImages({currentGFXSet})
			releaseCompoSprites({currentGFXSet.."_COMPOSPRITES"})
			currentGFXSet = nil
		end
		local path = getRokuImagePath("BUTTONS_SHEET_1.dat")
		_G.res.releaseSpriteSheet(path)
		if screenHeight > 576 then
			path = getRokuImagePath("BUTTONS_SHEET_2.dat")
			_G.res.releaseSpriteSheet(path)
		else
			path = getRokuImagePath("MENU_SHEET_1.dat")
			_G.res.releaseSpriteSheet(path)
		end
		path = getRokuImagePath("CURSORS_SHEET_1.dat")
		_G.res.releaseSpriteSheet(path)
		path = getRokuImagePath("POPUPS_SHEET_1.dat")
		_G.res.releaseSpriteSheet(path)
		path = getRokuImagePath("INGAME_PARALLAX_CRANES.dat")
		_G.res.releaseSpriteSheet(path)
		path = getRokuImagePath("TUTORIALS_composprites.dat")
		_G.res.releaseCompoSpriteSet(path)
		path = getRokuImagePath("TUTORIALS_SHEET_1.dat")
		_G.res.releaseSpriteSheet(path)
	end
end

function loadRokuAssetsAfter(scene)
	if scene == "cutscenes" then
		local themeName = currentTheme or "theme1"
		loadThemeGraphics(themeName)
		if screenHeight > 576 then
			loadImages({"OTHER_2"})
		end
		local path = getRokuImagePath("BUTTONS_SHEET_1.dat")
		_G.res.createSpriteSheet(path)
		if screenHeight > 576 then
			path = getRokuImagePath("BUTTONS_SHEET_2.dat")
			_G.res.createSpriteSheet(path)
		else
			path = getRokuImagePath("MENU_SHEET_1.dat")
			_G.res.createSpriteSheet(path)
		end
		path = getRokuImagePath("CURSORS_SHEET_1.dat")
		_G.res.createSpriteSheet(path)
		path = getRokuImagePath("POPUPS_SHEET_1.dat")
		_G.res.createSpriteSheet(path)
		path = getRokuImagePath("INGAME_PARALLAX_CRANES.dat")
		_G.res.createSpriteSheet(path)
		path = getRokuImagePath("TUTORIALS_SHEET_1.dat")
		_G.res.createSpriteSheet(path)	
		path = getRokuImagePath("TUTORIALS_composprites.dat")
		_G.res.createCompoSpriteSet(path)
	end
end

function gotoLevelSelection(dt)
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesBasic
	if levelSelectionPagesBasic.currentPage ~= settings.currentLevelSelectionPages.basic then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesBasic.currentPage = settings.currentLevelSelectionPages.basic
	end
	setActiveMenuPage(levelSelectionPagesBasic)
	
	drawMenu()
	releaseCutScenes()
	if deviceModel == "roku" then
		loadImages( {"LEVELSELECTION"} )
	end
end

function gotoLevelSelectionExtra(dt)
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesExtra
	if levelSelectionPagesExtra.currentPage ~= settings.currentLevelSelectionPages.extra then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesExtra.currentPage = settings.currentLevelSelectionPages.extra
	end
	setActiveMenuPage(levelSelectionPagesExtra)

	drawMenu()
	releaseCutScenes()
	if deviceModel == "roku" then
		loadImages( {"LEVELSELECTION"} )
	end
end

function gotoLevelSelectionGoldenEggs(dt)
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesGoldenEggs
	setActiveMenuPage(levelSelectionPagesGoldenEggs[1], true)
	drawMenu()
end

function gotoLevelSelectionPack3(dt)
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesPack3
	if levelSelectionPagesPack3.currentPage ~= settings.currentLevelSelectionPages.pack3 then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesPack3.currentPage = settings.currentLevelSelectionPages.pack3
	end
	setActiveMenuPage(levelSelectionPagesPack3)

	drawMenu()
	releaseCutScenes()
	if deviceModel == "roku" then
		if settings.openGoldenEggLevels["Level11"] == nil then
			loadGoldenEggSprites()
		end
		loadImages( {"LEVELSELECTION"} )
	end
end

function gotoLevelSelectionPack4(dt)
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesPack4
	if levelSelectionPagesPack4.currentPage ~= settings.currentLevelSelectionPages.pack4 then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesPack4.currentPage = settings.currentLevelSelectionPages.pack4
	end
	setActiveMenuPage(levelSelectionPagesPack4)

	drawMenu()
	releaseCutScenes()
	if deviceModel == "roku" then
		loadImages( {"LEVELSELECTION"} )
	end
end

function gotoLevelSelectionPack5(dt)
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesPack5
	if levelSelectionPagesPack5.currentPage ~= settings.currentLevelSelectionPages.pack5 then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesPack5.currentPage = settings.currentLevelSelectionPages.pack5
	end
	setActiveMenuPage(levelSelectionPagesPack5)

	drawMenu()
	releaseCutScenes()
	if deviceModel == "roku" then
		loadImages( {"LEVELSELECTION"} )
	end
end

function gotoLevelSelectionPack6(dt)
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesPack6
	if levelSelectionPagesPack6.currentPage ~= settings.currentLevelSelectionPages.pack6 then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesPack6.currentPage = settings.currentLevelSelectionPages.pack6
	end
	setActiveMenuPage(levelSelectionPagesPack6)

	drawMenu()
	releaseCutScenes()
	if deviceModel == "roku" then
		loadImages( {"LEVELSELECTION"} )
	end
end

function gotoABShop()
	setGameMode(updateMenu)
	setActiveMenuPage(episodeSelectionPage, true)	
	drawMenu()
	logFlurryEvent("ABshop link clicked")
	openURL(ABSHOP_URL)
end

function loadPreviousLevel(dt)
	drawGame()
	drawMenu()
	if  levelSelectionPages == levelSelectionPagesBasic or levelSelectionPages == levelSelectionPagesExtra or levelSelectionPages == levelSelectionPagesPack3 or levelSelectionPages == levelSelectionPagesPack4 or levelSelectionPages == levelSelectionPagesPack5 or levelSelectionPages == levelSelectionPagesPack6 then
		if currentLevelNumberInTheme <= 1 then
			levelSelectionPages.currentPage = levelSelectionPages.currentPage - 1
			if levelSelectionPages.currentPage <= 0 then
				if levelSelectionPages == levelSelectionPagesBasic then
					levelSelectionPages.currentPage = 1
				else
					if levelSelectionPages == levelSelectionPagesExtra then
						levelSelectionPages = levelSelectionPagesBasic
					elseif levelSelectionPages == levelSelectionPagesPack3 then
						levelSelectionPages = levelSelectionPagesExtra
					elseif levelSelectionPages == levelSelectionPagesPack4 then
						levelSelectionPages = levelSelectionPagesPack3
					elseif levelSelectionPages == levelSelectionPagesPack5 then
						levelSelectionPages = levelSelectionPagesPack4
					elseif levelSelectionPages == levelSelectionPagesPack6 then
						levelSelectionPages = levelSelectionPagesPack5
					end
					levelSelectionPages.currentPage = levelSelectionPages.pageCount
					currentLevelNumberInTheme = levelSelectionPages.levelsPerPage
					currentLevelNumber = levelSelectionPages.pageCount * levelSelectionPages.levelsPerPage
					currentThemeNumber = currentThemeNumber	- 1
					currentWorldNumber = currentWorldNumber - 1
				end
			else
				currentLevelNumberInTheme = levelSelectionPages.levelsPerPage
				currentLevelNumber = currentLevelNumber - 1
				currentThemeNumber = currentThemeNumber	- 1
				currentWorldNumber = currentWorldNumber - 1
			end

		else
			currentLevelNumberInTheme = currentLevelNumberInTheme - 1
			currentLevelNumber = currentLevelNumber - 1
		end
		
		local index = (levelSelectionPages.currentPage - 1) * levelSelectionPages.levelsPerPage + levelSelectionPages.firstLevelIndex		
		levelName = levelSelectionPages.items[currentLevelNumberInTheme + index - 1].filename
		levelFolder = levelSelectionPages.items[currentLevelNumberInTheme + index - 1].folder
			
	end
	
	loading = true
	setGameMode(updateLoading)
end

function loadNextLevel(dt)

	
	
	local t_lockedLevel = ((currentLevelNumberInTheme) == levelSelectionPages.levelsPerPage) and (levelSelectionPages == levelSelectionPagesBasic)
	
	if deviceModel == "windows" and g_registrationEnabled == true and g_isGameUnlocked == false and t_lockedLevel == true then	
		-- local buttonNextLevel = getItemByName(levelComplete.items, "buttonNextLevel")
		-- buttonNextLevel.visible = false
		
		
		
		g_isFullScreenBeforeOpeningRegistration = settings.fullScreen
		if (g_isFullScreenBeforeOpeningRegistration == true) then
			g_updateCount = 0
			-- sm:changeScene("pause")	
			setFullScreenMode(false)	
			return
		else			
			local t_returnedKey = openRegistrationDialog("Activate the full game!",g_registrationURLs.validationURL, g_registrationURLs.registrationURL, g_registrationKeys.fullGame)
			
			if t_returnedKey ~= "" then
				g_isGameUnlocked = true
				
				_G.table.insert(settings.license.registeredKeyTypes, g_registrationKeys.fullGame)
				
				settings.license.hardwareID = getDeviceID()
				-- buttonNextLevel.visible = true
				
			else
				-- menuengine.instance.sceneManager:changeScene("mainMenu") 
				return
			end
		end
		
	end	
	
	--drawGame()
	--drawMenu()
	if levelSelectionPages == levelSelectionPagesBasic or levelSelectionPages == levelSelectionPagesExtra or levelSelectionPages == levelSelectionPagesPack3 or levelSelectionPages == levelSelectionPagesPack4 or levelSelectionPages == levelSelectionPagesPack5 or levelSelectionPages == levelSelectionPagesPack6 then
		if currentLevelNumberInTheme >= levelSelectionPages.levelsPerPage then
			levelSelectionPages.currentPage = levelSelectionPages.currentPage + 1
			if levelSelectionPages.currentPage > levelSelectionPages.pageCount then
				if levelSelectionPages == levelSelectionPagesPack6 then
					levelSelectionPages.currentPage = levelSelectionPages.pageCount
				else
					if levelSelectionPages == levelSelectionPagesBasic then
						levelSelectionPages = levelSelectionPagesExtra
					elseif levelSelectionPages == levelSelectionPagesExtra then
						levelSelectionPages = levelSelectionPagesPack3
					elseif levelSelectionPages == levelSelectionPagesPack3 then
						levelSelectionPages = levelSelectionPagesPack4	
					elseif levelSelectionPages == levelSelectionPagesPack4 then
						levelSelectionPages = levelSelectionPagesPack5	
					elseif levelSelectionPages == levelSelectionPagesPack5 then
						levelSelectionPages = levelSelectionPagesPack6
					end
					levelSelectionPages.currentPage = 1
					currentLevelNumberInTheme = 1
					currentLevelNumber = 1
					currentThemeNumber = currentThemeNumber	+ 1
					currentWorldNumber = currentWorldNumber + 1
				end
			else				
				currentLevelNumberInTheme = 1
				currentLevelNumber = currentLevelNumber + 1
				currentThemeNumber = currentThemeNumber	+ 1
				currentWorldNumber = currentWorldNumber + 1
			end
		else
			currentLevelNumberInTheme = currentLevelNumberInTheme + 1
			currentLevelNumber = currentLevelNumber + 1
		end
		
		numberOfAttemptsInLevel = 1
		
		levelStartedFlurryParams = {}
		levelStartedFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
		levelStartedFlurryParams["From"] = "" .. levelRestartedFrom
		logFlurryEventWithParams("Level started", "levelStartedFlurryParams") 
		--print("FlurryEventWithParam: Level started, Level, " .. currentWorldNumber .. "-" ..currentLevelNumberInTheme .. "\n")
		--logEvent("level_started", "COMPLETED_MENU", currentWorldNumber, currentLevelNumberInTheme, nil, numberOfAttemptsInLevel, 0, "", "")
		
		local index = (levelSelectionPages.currentPage - 1) * levelSelectionPages.levelsPerPage + levelSelectionPages.firstLevelIndex
		levelName = levelSelectionPages.items[currentLevelNumberInTheme + index - 1].filename
		levelFolder = levelSelectionPages.items[currentLevelNumberInTheme + index - 1].folder
	end
	
	levelRestartedFrom = nil
	loading = true
	setGameMode(updateLoading)
end

function hasLevelPack1()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesBasic.levelsPerPage + levelSelectionPagesBasic.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesBasic.items[index].folder .. levelSelectionPagesBasic.items[index].filename .. ".lua")
	end
end

function hasLevelPack2()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesExtra.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesExtra.items[index].folder .. levelSelectionPagesExtra.items[index].filename .. ".lua")
	end
end

function hasLevelPack3()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesPack3.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesPack3.items[index].folder .. levelSelectionPagesPack3.items[index].filename .. ".lua")
	end
end

function hasLevelPack4()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesPack4.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesPack4.items[index].folder .. levelSelectionPagesPack4.items[index].filename .. ".lua")
	end
end

function hasLevelPack5()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesPack5.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesPack5.items[index].folder .. levelSelectionPagesPack5.items[index].filename .. ".lua")
	end
end

function hasLevelPack6()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesPack6.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesPack6.items[index].folder .. levelSelectionPagesPack6.items[index].filename .. ".lua")
	end
end

-- about
function showLeftMenu(dt)
	logFlurryEvent("About menu viewed")
	if isLiteVersion or settings.openGoldenEggLevels["Level5"] ~= nil then
		about.items[9].sprite = "ABOUT_BIRDS_3"
		about.items[9].callFunction = nil
	else
		loadGoldenEggSprites()
		about.items[9].sprite = "GOLDEN_EGG_5"
		about.items[9].callFunction = aboutGoldenEggAchieved
	end
	
	about.items[1].visible = true
	about.items[2].visible = true
	about.items[3].visible = true
	about.items[4].visible = true
	about.items[5].visible = true
	about.items[6].visible = true
	about.items[7].visible = true
	about.items[8].visible = true
	about.items[9].visible = true
	about.items[10].visible = true
	about.items[11].visible = true
	
	setAnimationState("aboutPageScroll", "ENTERING")
	setActiveMenuPage(about)
end

function toggleFullScreen()
	--print("\n TOGGLE!")
	
	settings.fullScreen = not settings.fullScreen
	
	setFullScreenMode(settings.fullScreen)		
	
	setGameMode(updateMenu)
	--setActiveMenuPage(pausePage, true)
	drawMenu()
end


function hideLeftMenu(dt)
	about.items[1].visible = false
	about.items[2].visible = false
	about.items[3].visible = false
	about.items[4].visible = false
	about.items[5].visible = false
	about.items[6].visible = false
	about.items[7].visible = false
	about.items[8].visible = false
	about.items[9].visible = false
	about.items[10].visible = false
	about.items[11].visible = false
		
	setAnimationState("aboutPageScroll", "EXITING")
	setActiveMenuPage(mainMenu, false)
end

-- about
function showPauseMenu(dt)
	if deviceModel ~= "roku" then captureMouse(false) end
	levelRestartedFrom = "pause menu"
	setAnimationState("ingamePausePageScroll", "ENTERING")
	changeResolution = true
	wantedResolution = "HALF"
	setActiveMenuPage(pausePage, true)
	setGameMode(updateMenu)
		
	--stop looping rolling sounds
	_G.res.stopAudio("wood_rolling")
	_G.res.stopAudio("rock_rolling")
	_G.res.stopAudio("light_rolling")
	drawMenu()
end

function showGesturePauseMenu(dt)
	if not g_gesturePausePageEnablingFlags.simulateTouchOnWindows then
		if deviceModel ~= "roku" then captureMouse(false) end
	end
	
	for k,v in _G.pairs(g_gesturePausePage.items) do
		setItemMouseOverState(v, "up")
	end
	
	levelRestartedFrom = "pause menu"
	
	setAnimationState("ingameGesturePausePageScroll", "ENTERING")
	changeResolution = true
	wantedResolution = "HALF"
	setActiveMenuPage(g_gesturePausePage, true)
	setGameMode(updateMenu)
	
	--g_gesturePausePage.currentDragX = touches[g_gesturePausePage.touchOneID].x
	--g_gesturePausePage.currentDragY = touches[g_gesturePausePage.touchOneID].y
	
	for k,v in _G.pairs(g_gesturePausePage.items) do
		simulateMouseOverState(v, false)
		v.sprite = v.spriteNormal		
	end
		
	--stop looping rolling sounds
	_G.res.stopAudio("wood_rolling")
	_G.res.stopAudio("rock_rolling")
	_G.res.stopAudio("light_rolling")
	drawMenu()
end

function goToLevelSelectionFromPause()
	_G.res.stopAllAudio()	
end

function goToMainMenuFromPause()
	_G.res.stopAllAudio()	
end

function hideGesturePauseMenu(dt)
	--print("\n hidding!")
	setAnimationState("ingameGesturePausePageScroll", "EXITING")						
	setGameMode(updateMenu)	
	drawMenu()	
end

function hidePauseMenu(dt)
	setAnimationState("ingamePausePageScroll", "EXITING")
	setGameMode(updateMenu)
	drawMenu()
	--forceInputStateToTrackpad()
end

function showIngameResolutionChangedPopUp(dt)
	--setPhysicsEnabled(false)
	
	levelRestartedFrom = "pause menu"
	invalidResolutionPage.fromMainMenu = false
	invalidResolutionPage.enablePhysicsWhenDone = isPhysicsEnabled()
	
	setGameMode(updateMenu)
	drawMenu()
	
	
end

function launchEagleBaitFromPauseMenu(dt)
	eagleSoundPlayed = nil
	setAnimationState("ingamePausePageScroll", "EXITING")
	setActiveMenuPage(pausePage, false)
	
	rubberBandPos.x = levelStartPosition.x
	rubberBandPos.y = levelStartPosition.y
	rubberBandSpeed = 0
	
	if currentBirdName ~= nil and objects.world[currentBirdName].shot ~= true then
		removeBird(objects.world[currentBirdName])
	elseif birdToSlingshotBirdName ~= nil then 
		removeBird(objects.world[birdToSlingshotBirdName])
		currentBirdIndex = currentBirdIndex + 1
	end
	local nextBirdName = nil
	repeat
		currentBirdIndex = currentBirdIndex + 1
		nextBirdName = getNextBird(currentBirdIndex)
		if nextBirdName ~= nil then
			removeBird(objects.world[nextBirdName])
		end
	until nextBirdName == nil
	currentBirdIndex = currentBirdIndex - 1
	birdToSlingshotBirdName = nil
	currentBirdName = nil
	launchEagleBait(dt)
	fillInNextBird = true
end

function launchEagleBait(dt)
	cameraFunction = launchCamera
	castleCameraTimer = 2.5
	eagleBaitLaunched = true
	levelCompleteTimer = 0
	levelFailedTimer = -200
	
	-- baitsardine is the next bird
	--baitSardine.x, baitSardine.y = levelStartPosition.x, levelStartPosition.y
	local obj = baitSardine
	local name = createObject(blockTable, obj.definition, obj.name, obj.x*scaleFactor, obj.y*scaleFactor)

	-- clamp angle to 0 - 2*PI range
	obj.angle = _G.math.fmod(obj.angle, _G.math.pi*2)
	if obj.angle < 0 then
		obj.angle = obj.angle + _G.math.pi*2
	end
	
	setRotation(name, obj.angle)
	setMaterial(name, objects.world[name].material)
	if objects.world[name].texture ~= nil then
		setTexture(name, objects.world[name].texture)
	end
	
	if objects.world[name].controllable then
		birdsCounter = birdsCounter + 1
		objects.world[name].startNumber = birdsCounter
	end
	objects.world[name].animTimer = 3
	objects.world[name].jumpTimer = 3
	birds[name] = objects.world[name]
	local sprites = getDamageSprite(objects.world[name], blockTable.blocks)
	objects.world[name].damageSprite = sprites.sprite
	objects.world[name].blinkSprite = sprites.blink		
	objects.world[name].smileSprite = sprites.smile		
	objects.world[name].frozen = false
	objects.world[name].isEagleBait = true
	objects.world[name].recordTrajectory = false
	
	if settings.tutorials[objects.world[name].sprite] == nil then
		settings.tutorials[objects.world[name].sprite] = {}
		settings.tutorials[objects.world[name].sprite].sprite = blockTable.blocks[objects.world[name].definition].tutorialInfo
		_G.table.insert(birdTutorialPopups, blockTable.blocks[objects.world[name].definition].tutorialInfo)
	end
	
	changeResolution = true
	wantedResolution = "FULL"
	setGameMode(updateGame)
	setPhysicsEnabled(true)
	nextBirdTimer = 0.1
	--animateBirdToSlingShot(dt)
end

-- settings
function showRightMenu(dt)
	setAnimationState("settingsPageScroll", "ENTERING")
	setActiveMenuPage(settingsPage)
	setGameMode(updateMenu)
	drawMenu()
end

function hideRightMenu(dt)
	setAnimationState("settingsPageScroll", "EXITING")
	setActiveMenuPage(mainMenu, false)
	setGameMode(updateMenu)
	drawMenu()
end

function setEffectsVolume(volume)
	_G.res.setTrackVolume(volume, 0)
	_G.res.setTrackVolume(volume, 1)
	_G.res.setTrackVolume(volume, 2)
	_G.res.setTrackVolume(volume, 3)
	_G.res.setTrackVolume(volume, 4)
end

function setMusicVolume(volume)
	_G.res.setTrackVolume(volume, 7)
end

function changeAudio()
	if settings.audioEnabled ~= false then
		audioRampVolume = _G.res.getTrackVolume(7)
		audioRampLength = -0.5
		pausePage.items[2].visible = true
		getItemByName(mainMenu.items, "buttonOff").visible = true
		settings.audioEnabled = false
	else
		audioRampVolume = _G.res.getTrackVolume(7)
		audioRampLength = 0.5
		--settingsPage.items[2].visible = false
		pausePage.items[2].visible = false
		--mainMenu.items[7].visible = false
		getItemByName(mainMenu.items, "buttonOff").visible = false
		settings.audioEnabled = true
		_G.res.startAudioOutput()
		 if currentGameMode == updateMenu and _G.res.isAudioPlaying("title_theme") == false and (currentMenuPage and currentMenuPage == levelSelectionPagesBasic 
		   or currentMenuPage == levelSelectionPagesExtra or currentMenuPage == levelSelectionPagesPack3
		   or currentMenuPage == levelSelectionPagesPack4 or currentMenuPage == levelSelectionPagesPack5
		   or currentMenuPage == levelSelectionPagesPack6
		   or (levelSelectionPagesGoldenEggs and currentMenuPage == levelSelectionPagesGoldenEggs[1])
		   or currentMenuPage == mainMenu or currentMenuPage == episodeSelectionPage) then
			 _G.res.playAudio("title_theme", 0.8, true, 7)
		 end
	end
	saveLuaFileWrapper("settings.lua", "settings", true)
end

function gotoFirstLevel()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesBasic, levelSelectionPagesBasic.firstLevelIndex)
	drawMenu()	
end

function gotoFirstLevelLP2()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesExtra, levelSelectionPagesExtra.firstLevelIndex)
	drawMenu()
end

function gotoFirstLevelLP3()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesPack3, levelSelectionPagesPack3.firstLevelIndex)
	drawMenu()
end

function gotoFirstLevelLP4()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesPack4, levelSelectionPagesPack4.firstLevelIndex)
	drawMenu()
end

function gotoFirstLevelLP5()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesPack5, levelSelectionPagesPack5.firstLevelIndex)
	drawMenu()
end

function gotoFirstLevelLP6()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesPack6, levelSelectionPagesPack6.firstLevelIndex)
	drawMenu()
end

function gotoAbout()
	releaseCutScenes()
	if deviceModel == "roku" then
		loadImages({"INGAME"})
		local themeName = currentTheme or "theme1"
		loadThemeGraphics(themeName)
	end
	setAnimationState("aboutPageScroll", "VISIBLE")
	setGameMode(updateMenu)
	showLeftMenu()
	about.backgroundOverlay.shade = 0.65
	_G.res.stopAudio("birds_outro")
	_G.res.playAudio("title_theme", 0.8, true, 7)
	drawMenu()
end

function gotoReportBug()
	openURL(REPORT_BUG_URL)
end

function gotoFullVersionInAppStore()
	openURL(APP_STORE_FULL_VERSION_URL)
end

function gotoAndroidMarket()
	openURL(ANDROID_MARKET_FULL_VERSION_URL)
end

function gotoFacebook()
	logFlurryEvent("Facebook link clicked")
	openURL(FACEBOOK_URL)
end

function gotoTwitter()
	logFlurryEvent("Twitter link clicked")
	--openURL(TWITTER_URL)
	openURL(TWITTER_URL)
end

function gotoAngryBirdsTrailer()
	--logFlurryEvent("Trailer link clicked")
	openURL(ANGRY_BIRDS_TRAILER_URL)
	
	--playVideo( "videos/lite_iPhone.m4v" )
end

function gotoAngryBirdsRioTrailer()
	--logFlurryEvent("Trailer link clicked")
	openURL(RIO_CONTEST_URL)
	
	--playVideo( "videos/lite_iPhone.m4v" )
end

function gotoOviStore(dt)
	if deviceModel == "n900" then
		openURL(OVI_STORE_URL)
	elseif deviceModel == "s60" then
		openURL(OVI_STORE_URL_S60)
	end
	setGameMode(updateMenu)
end

function gotoMoreOnOviStore()
	openURL(OVI_STORE_MORE_GAMES_URL_S60)
	removePopupMenu()
end

function openURL(url)
	--losing the focus when in full screen mode causes the game to hang on windows
	if isInFullScreenMode() then
		setFullScreenMode(false)
		g_restoreFullScreenOnReactivate = true
	end
	_G.res.openURL(url)
end


function showTutorials()
	--print("\n show tutorials")
	logFlurryEvent("Tutorials viewed")	
	if settings.tutorials["BIRD_RED"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_RED"].sprite)
	end
	if settings.tutorials["BIRD_BLUE"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_BLUE"].sprite)
	end
	if settings.tutorials["BIRD_YELLOW"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_YELLOW"].sprite)
	end
	if settings.tutorials["BIRD_GREY"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_GREY"].sprite)
	end
	if settings.tutorials["BIRD_GREEN"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_GREEN"].sprite)
		if not isLiteVersion then
			loadGoldenEggSprites()
			showTutorialGoldenEgg = true
		end
	end
	if settings.tutorials["BIRD_BOOMERANG"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_BOOMERANG"].sprite)
	end
	if settings.tutorials["BIRD_BIG_BROTHER"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_BIG_BROTHER"].sprite)
	end
	if settings.tutorials["BAIT_SARDINE"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BAIT_SARDINE"].sprite)
	end
	
	if deviceModel ~= "roku" then
		if not g_mouseOrTouchStates.isUsingMouse and settings.fullScreen == true then
			_G.table.insert(birdTutorialPopups, "TUTORIAL_9")
			_G.table.insert(birdTutorialPopups, "TUTORIAL_10")
			_G.table.insert(birdTutorialPopups, "TUTORIAL_11")
		end
	else
		_G.table.insert(birdTutorialPopups, "TUTORIAL_9")
		_G.table.insert(birdTutorialPopups, "TUTORIAL_10")
	end
	setGameMode(hidePauseMenu)
	pausePage.backgroundOverlay.shade = 0
	if #birdTutorialPopups > 0 then
		prepareMenuPage(tutorials)
	end
	drawMenu()
end

--[[
function changeVibra()
	if settings.vibraEnabled ~= false then
		settingsPage.items[5].visible = true
		pausePage.items[5].visible = true
		settings.vibraEnabled = false
	else
		settingsPage.items[5].visible = false
		pausePage.items[5].visible = false
		settings.vibraEnabled = true	
	end
	saveLuaFileWrapper("settings.lua", "settings", true)
end
--]]

function changeLanguage()
	currentLanguageId = currentLanguageId + 1
	if currentLanguageId > #languageNames then
		currentLanguageId = 1
	end

	currentLanguage = languageNames[currentLanguageId]
	--print("current language " .. currentLanguage .. "\n")
	settings.currentLanguage = languageNames[currentLanguageId]
	settingsPage.items[5].sprite = languageSprites[settings.currentLanguage]
	_G.res.loadLocale("TEXTS_BASIC", settings.currentLanguage)
	_G.res.useLocale(settings.currentLanguage)		
end

function addPopupMenu()
end

function removePopupMenu()
end

function animateBirds(dt)
	local itemsPerCategory = 3
	local itemsInTotal = #birdSprites * itemsPerCategory
	
	if #birdAnimations < itemsInTotal and _G.math.random(1,5) == 1 then
		local layer = _G.math.random(1, 5)
		local tx = _G.math.random(-screenWidth * 0.75, screenWidth * 0.75)
		local ty = screenHeight + 50*screenHeight / 320
		
		local scale = layer * 0.2
		local txVel = _G.math.random(100, 350) * scale * (screenWidth / 480 + 1) / 2
		local tyVel = _G.math.random(-400, -150) * scale * (screenHeight / 320 + 1) / 2
		
		if layer == 1 then
			tyVel = tyVel * 1.75 
			txVel = txVel * 1.75 
		end		
		
		local tempBirdSprite = birdSprites[_G.math.random(#birdSprites)]
		local sprite = tempBirdSprite.sprite
		local sheet = tempBirdSprite.sheet
		local reward = tempBirdSprite.reward
		local angleSpeed = 0
		
		local _, spriteHeight = _G.res.getSpriteBounds("", sprite)
		if reward == 1 then
			angleSpeed = _G.math.random() * _G.math.pi * 1.5
		elseif reward == 2 then
			tx = _G.math.random(screenWidth * 0.1, screenWidth * 0.9)
			tyVel = _G.math.random(-250, -150) * scale * (screenHeight / 320 + 1) * 0.175
			txVel = 0
		end

		_G.table.insert(birdAnimations, { sheet = sheet, sprite = sprite, angle = 0, angleSpeed = angleSpeed, x = tx, y = ty, xVel = txVel, yVel = tyVel, scale = scale, layer = layer, spriteHeight = spriteHeight, reward = reward} )
	end

	for i = #birdAnimations, 1, -1 do
		local v = birdAnimations[i]
		if v.reward == 2 then -- balloon movement
			v.angle = _G.math.sin(v.angleSpeed) * 0.15
			v.angleSpeed = (v.angleSpeed + dt * 2) % (_G.math.pi * 2)
			v.x = v.x - v.angle * v.layer / 2
		else
			v.yVel = v.yVel + 150*dt
			v.angle = v.angle + v.angleSpeed * dt
		end
		v.x = v.x + v.xVel * dt
		v.y = v.y + v.yVel * dt
		
		if v.y > screenHeight + 50 * screenHeight / 320 or ((v.reward == 2 or v.reward == 2) and v.y < -v.spriteHeight) then
			_G.table.remove(birdAnimations, i)
		end 
		
	end
	
	if keyPressed["LBUTTON"] and currentMenuPage ~= about then
		for i = 1, #birdAnimations do
			if birdAnimations[i].layer == 5 then
				birdAnimations[i].renderState = true
				if SpriteItem.checkBounds(birdAnimations[i], cursor.x, cursor.y) 
				   and birdAnimations[i].yelling ~= true 
				   and _G.string.sub(birdAnimations[i].sprite, 1, 4) == "BIRD" then
					birdAnimations[i].yelling = true
					_G.res.playAudio(birdSpriteSoundMapping[birdAnimations[i].sprite], 1.0, false, 0)
					birdAnimations[i].sprite = birdAnimations[i].sprite .. "_YELL"
				end
			end
		end
	end
	
end


--xPosRatio and yPosRatio are based on the on the image real boudaries
function getSpriteTransformsUniformScale(targetXPosRatio, targetYPosRatio, targetWidthRatio, spriteSheet, spriteName, a_debug)
	local t_pivotX, t_pivotY = _G.res.getSpritePivot(spriteSheet, spriteName)
	local t_width, t_height = _G.res.getSpriteBounds(spriteSheet, spriteName)
	
	local t_targetWidth = targetWidthRatio * screenWidth	
	
	local t_returnList = {}
	
	local t_finalScale = t_targetWidth / t_width
	
	t_returnList.xs = t_finalScale
	t_returnList.ys = t_finalScale
	
	local t_realX = (targetXPosRatio * screenWidth)
	local t_realY = (targetYPosRatio * screenHeight)
	
	local t_toDrawX = t_realX + (t_pivotX * t_finalScale)
	local t_toDrawY = t_realY + (t_pivotY * t_finalScale)
	
	
	
	if a_debug then
		setRenderState(0, 0, 1, 1, 0)
		drawLine2D(0, t_toDrawY, screenWidth, t_toDrawY, 2, 255, 0, 0, 255)
		drawLine2D(t_toDrawX, 0, t_toDrawX, screenHeight, 2, 255, 0, 0, 255)
		
		print("\n to draw " .. t_toDrawX .. " " .. t_toDrawY)
		
		setRenderState(0, 0, 1, 1, 0)
		drawLine2D(0, t_realY, screenWidth, t_realY, 2, 255, 0, 0, 255)
		drawLine2D(t_realX, 0, t_realX, screenHeight, 2, 255, 0, 0, 255)
		
		print("\n to draw2 " .. t_realX .. " " .. t_realY)
	end
	
	
	t_returnList.x = t_toDrawX / t_returnList.xs
	t_returnList.y = t_toDrawY / t_returnList.ys
	
	return t_returnList
end

--xPosRatio and yPosRatio are based on the on the image real boudaries
function getSpriteTransforms(targetXPosRatio, targetYPosRatio, targetWidthRatio, targetHeightRatio, spriteSheet, spriteName, a_debug)
	local t_pivotX, t_pivotY = _G.res.getSpritePivot(spriteSheet, spriteName)
	local t_width, t_height = _G.res.getSpriteBounds(spriteSheet, spriteName)
	
	local t_targetWidth = targetWidthRatio * screenWidth	
	local t_targetHeight = targetHeightRatio * screenHeight	
	
	local t_returnList = {}
	
	t_returnList.xs = t_targetWidth / t_width
	t_returnList.ys = t_targetHeight / t_height
	
	local t_realX = (targetXPosRatio * screenWidth)
	local t_realY = (targetYPosRatio * screenHeight)
	
	local t_toDrawX = t_realX + (t_pivotX * t_returnList.xs)
	local t_toDrawY = t_realY + (t_pivotY * t_returnList.ys)
	
	
	
	if a_debug then
		setRenderState(0, 0, 1, 1, 0)
		drawLine2D(0, t_toDrawY, screenWidth, t_toDrawY, 2, 255, 0, 0, 255)
		drawLine2D(t_toDrawX, 0, t_toDrawX, screenHeight, 2, 255, 0, 0, 255)
		
		print("\n to draw " .. t_toDrawX .. " " .. t_toDrawY)
		
		setRenderState(0, 0, 1, 1, 0)
		drawLine2D(0, t_realY, screenWidth, t_realY, 2, 255, 0, 0, 255)
		drawLine2D(t_realX, 0, t_realX, screenHeight, 2, 255, 0, 0, 255)
		
		print("\n to draw2 " .. t_realX .. " " .. t_realY)
	end
	
	
	t_returnList.x = t_toDrawX / t_returnList.xs
	t_returnList.y = t_toDrawY / t_returnList.ys
	
	return t_returnList
end

function getSpriteRealPos(ax, ay, spriteSheet, spriteName)
	local t_pivotX, t_pivotY = _G.res.getSpritePivot(spriteSheet, spriteName)
	return {x = (ax - t_pivotX), y = (ay - t_pivotY)  }
end

function drawSpriteBasedOnRatios(x, y, xs, ys, spriteSheet, spriteName)
	
	setRenderState(x, y, xs, ys, 0)
	_G.res.drawSprite("", spriteName, 0, 0)
	
end

-------------------------------------------------------------------------------

-- This function only draws the menu without any logic
-- some major changes in here, all components of this screen are now using ratios from the elements heights/screenHeight
--and elements Y / screenHeight, using the iPhone profile as reference
function drawMenu()

	local xs = 1
	local ys = 1
	
	--for the parallax layers
	local t_layerSpeeds = {50, 33, 22, 15, 10}
	local t_layerBirdsScale = {0.75, 0.5, 0.5, 0.65, 1}
	local t_birdsScaleOffsets = {0.5, 0.5, 0.2, 0.125, 0}
	
	--gathered from the iphone version, these are the ratios between the layer height and the screen height. Those are the "real heights" (not considering the pivots)
	local t_targetLayerHeightRatios = {0.24, 0.282532, 0.24, 0.218734, 0.230886}
	local t_targetLayerPosRatios = {1.00304, 0.963544, 0.951392, 0.851139, 0.820759}
	
	local t_sunHeightRatio = 0.33
	local t_sunPosYRatio = 0.73
	
	local t_sunRaysHeightRatio = 0.9
	local t_sunRaysPosYRatio = 0.45
	
	if currentMenuPage == mainMenu or currentMenuPage == about or currentMenuPage == settingsPage then
		-- draw main menu theme according to the last theme played, halloween theme is an exception see above
		episode4BGCranes = { startX = 64 }
		local bW, bH = _G.res.getSpriteBounds("","BUTTON_EMPTY")
		local worldScale = 0.5 * screenHeight / 320
		--if worldScale > 0.75 then
			--worldScale = 0.75
		--end
		local worldScale = (0.5 * screenHeight / 400) / (currentZoomLevelMainMenu * 0.66)
		local topCamera = (-2*screenHeight) / (screenHeight / (450 * currentZoomLevelMainMenu * 0.585)) + ((bH * 1.6  )/ (screenHeight / (450 * currentZoomLevelMainMenu * 0.5)))
		setTopLeft(50*time,topCamera )
		setWorldScale(worldScale)
		
		setTheme(currentMainMenuTheme)
		if not g_gfxLowQuality then
			drawBackgroundNative()	
		end
		-- setWorldScale(0.5)
		-- setTopLeft(50*time,-2*screenHeight + bH * 1.6 )
		-- end of main menu draw for every theme but halloween
		
		--the birds were too small, so we added those multipliers for the scaling factors, indexed by the layer numbers
		if g_birdAnimationScaleMultipliers == nil then
			g_birdAnimationScaleMultipliers = {}
			g_birdAnimationScaleMultipliers[3] = 1.5
			g_birdAnimationScaleMultipliers[4] = 1.3
			g_birdAnimationScaleMultipliers[5] = 1
		end
		
			
		-- draw birds, rewards..
			for k, v in _G.pairs(birdAnimations) do
				if v.layer == 3  then
					local scale = v.scale * g_birdAnimationScaleMultipliers[v.layer]
					setRenderState(0, 0, scale, scale, v.angle, _G.res.getSpritePivot(v.sheet, v.sprite))
					_G.res.drawSprite("", v.sprite, _G.math.floor(v.x/scale), _G.math.floor(v.y/scale - screenHeight * 0.2 / scale))
				end
			end	
			
		
			for k, v in _G.pairs(birdAnimations) do
				if v.layer == 4 then
					local scale = v.scale  * g_birdAnimationScaleMultipliers[v.layer]
					setRenderState(0, 0, scale, scale, v.angle, _G.res.getSpritePivot(v.sheet, v.sprite))
					_G.res.drawSprite("", v.sprite, _G.math.floor(v.x/scale), _G.math.floor(v.y/scale - screenHeight * 0.125 / scale))
				end
			end		
			
			
			for k, v in _G.pairs(birdAnimations) do
				if v.layer == 5 then
					local scale = v.scale  * g_birdAnimationScaleMultipliers[v.layer]
					setRenderState(0, 0,scale, scale, v.angle, _G.res.getSpritePivot(v.sheet, v.sprite))
					_G.res.drawSprite("", v.sprite, _G.math.floor(v.x/scale), _G.math.floor(v.y/scale))
				end
			end		
			
		drawForegroundNative()				
		xs = 1
		ys = 1
		
		setRenderState(0, 0, 1, 1, 0, 0, 0)
		drawMenuPage(mainMenu)

		if elementAnimations.aboutPageScroll ~= 0 then
			setRenderState(0, 0, 1, ys, 0)
			drawAboutPage()
		end
		-- settingsPage.backgroundOverlay.visible = false
		-- settingsPage.items[7].visible = false
		-- if currentMenuPage == settingsPage then
			-- settingsPage.items[7].visible = true
			-- settingsPage.backgroundOverlay.visible = true
		-- end	
		
		setRenderState(0, 0, 1, ys, 0)
		drawSettingsPage()
		
	--elseif currentMenuPage == levelComplete and deviceModel == "s60" then 
	elseif currentMenuPage == levelComplete then -- japanese version
		drawMenuPage(currentMenuPage)
		local newHighScore = getItemByName(currentMenuPage.items, "newHighScore")
		if newHighScore.visible == true and inExtraWorld ~= true then
			local spriteName = _G.res.getString("TEXTS_BASIC", "TEXT_HIGHSCORE_SPRITE")
			setRenderState(0, 0, 1, 1, 0.471238898, _G.res.getSpritePivot("", spriteName))
			_G.res.drawSprite("", spriteName, newHighScore.x+2, newHighScore.y-2)
			setRenderState(0, 0, 1, 1, 0, 0, 0)
		end
		
	else
		drawMenuPage(currentMenuPage)
	end
	
	--[[local testBoxSprites = { --topLeft = "POPUP_TOP_LEFT", 
							 --topMiddle = "POPUP_TOP_MIDDLE", 
							 --topRight = "POPUP_TOP_RIGHT",
							 
							 left = "POPUP_LEFT", 
							 right = "POPUP_RIGHT",
							 
							 --bottomLeft = "POPUP_BOTTOM_LEFT", 
							 --bottomMiddle = "POPUP_BOTTOM_MIDDLE", 
							 --bottomRight = "POPUP_BOTTOM_RIGHT",
							 
							 center = "POPUP_CENTER",}

	drawBox(testBoxSprites, "", screenWidth / 2, screenHeight / 2, _G.math.floor(cos(time)*200+200), _G.math.floor(sin(time)*200+200), "HCENTER", "VCENTER", nil)
	]]
	if popupPage ~= nil then
		drawMenuPage(popupPage)
	end
	
	if loading then
		prepareMenuPage(loadingPage)
		drawMenuPage(loadingPage)
	end
	
	if (deviceModel == "n900" or deviceModel == "s60") and currentMenuPage.animationState == nil and currentMenuPage ~= upsellPage and currentMenuPage ~= pausePage then
		drawMenuPage(overlayMenuPage)	
	elseif deviceModel == "android" and isBetaVersion then
		drawMenuPage(overlayMenuPage)
	end
	
	
	--this is useful for gethering the ratios on the reference profile, DO NOT DELETE IT
	--[[
	local t_colors = {{0,0,0,255}, {0,0,255,255}, {0,255,0,255}, {0,255,255,255}, {255,0,0,255}}
	local t_drawLimits = false
	for i=1,5,1 do 
		t_pivotX, t_pivotY = _G.res.getSpritePivot("", "MENU_LAYER_" .. i)
		t_width, t_height = _G.res.getSpriteBounds("", "MENU_LAYER_" .. i)
		t_y = screenHeight - ( (t_pivotY -t_height)  * ys)
		t_y2 = t_y - (t_height * ys) 
		
		if t_drawLimits then
			drawLine2D(0, t_y, screenWidth, t_y, 2, t_colors[i][1], t_colors[i][2], t_colors[i][3], t_colors[i][4])
			--drawLine2D(0, t_y2, screenWidth, t_y2, 2, t_colors[i][1], t_colors[i][2], t_colors[i][3], t_colors[i][4])
		end
		print("\n dis MENU_LAYER_" .. i .. " " .. (t_y - t_y2) .. " ratio " .. ((t_y - t_y2)/screenHeight) .. " height " .. t_height .. " final ratio " .. (t_y/screenHeight))
	end	
	
	]]--
	
	
	
	
end


function drawMenuPage(page)
	
	if page == nil then
		return
	end
	
	-- if page.prepared ~= true then
		-- print("MenuPage not prepared! " .. page.name .. "\n")
	-- end
	
	setRenderState(0, 0, 1, 1, 0)
	if page.backgroundDrawFunction ~= nil then
		page.backgroundDrawFunction(page)
	end

	if page.backgroundOverlay ~= nil then
		if page.backgroundOverlay.sprite ~= nil and page.backgroundOverlay.visible ~= false then
			if page.backgroundOverlay.sprite == "DIM_BLOCK" and page.backgroundOverlay.shade ~= nil then
				if page.backgroundOverlay.shade ~= 0 then
					drawRect( 0, 0, 0, page.backgroundOverlay.shade, 0, 0, screenWidth, screenHeight, false)
				end
			else
				w, h = _G.res.getSpriteBounds("", page.backgroundOverlay.sprite)
				for y = 0, screenHeight/h do
					for x = 0, screenWidth/w do
						_G.res.drawSprite("", page.backgroundOverlay.sprite, _G.math.floor(x*w), _G.math.floor(y*h))
					end
				end
			end
		end
	end
	

	drawMenuBackground(page)
	
	drawMenuItems(page)
	drawMenuTitle(page)	
	
end

function drawMenuBackground(page)

	
	if page.backgroundBox ~= nil then
		local sx, sy = 0, 0

		if page.backgroundBox.x ~= nil then
			sx = page.backgroundBox.x
		end
		if page.backgroundBox.y ~= nil then
			sy = page.backgroundBox.y
		end
		
		local x, y = offsetCoordinates(page, sx, sy)
		local sheet = ""
		if page.backgroundBox.sheet ~= nil then
			sheet = page.backgroundBox.sheet
		end
		
		setRenderState(0, 0, 1, 1, 0, 0, 0)
		if page.backgroundBox.color ~= nil then
			local r,g,b,a = 1.0, 1.0, 1.0, 1.0
			if page.backgroundBox.color.red ~= nil then
				r = page.backgroundBox.color.red
			end
			if page.backgroundBox.color.green ~= nil then
				g = page.backgroundBox.color.green
			end
			if page.backgroundBox.color.blue ~= nil then
				b = page.backgroundBox.color.blue
			end
			if page.backgroundBox.color.alpha ~= nil then
				a = page.backgroundBox.color.alpha
			end
			
			drawBox(page.backgroundBox.sprites, sheet, _G.math.floor(x), _G.math.floor(y), _G.math.floor(page.backgroundBox.width), _G.math.floor(page.backgroundBox.height), page.backgroundBox.hanchor, page.backgroundBox.vanchor, { red = r, green = g, blue = b, alpha = a })
		else
			drawBox(page.backgroundBox.sprites, sheet, _G.math.floor(x), _G.math.floor(y), _G.math.floor(page.backgroundBox.width), _G.math.floor(page.backgroundBox.height), page.backgroundBox.hanchor, page.backgroundBox.vanchor, nil)
		end
	
	elseif page.backgroundSprite ~= nil then
		if page.backgroundSprite.scale and page.backgroundSprite.xs and page.backgroundSprite.ys then
			setRenderState(0, 0, page.backgroundSprite.xs, page.backgroundSprite.ys, 0)
			_G.res.drawSprite("", page.backgroundSprite.name, _G.math.floor(page.backgroundSprite.x) / page.backgroundSprite.xs, _G.math.floor(page.backgroundSprite.y) / page.backgroundSprite.ys)
			setRenderState(0, 0, 1, 1, 0)
		else
			local sx, sy = 0, 0

			if page.backgroundSprite.x ~= nil then
				sx = page.backgroundSprite.x
			end
			if page.backgroundSprite.y ~= nil then
				sy = page.backgroundSprite.y
			end
			
			local x, y = offsetCoordinates(page, sx, sy)
				
			setRenderState(0, 0, 1, 1, 0)
			_G.res.drawSprite("", page.backgroundSprite.name, _G.math.floor(x), _G.math.floor(y))
		end
	end
	
end

function drawMenuTitle(page)
	if page.title == nil then
		return
	end
	
	local title = page.title
	
	local x = 0
	local y = 0
	
	if title.text ~= nil then
		x = screenWidth * 0.5
		y = (_G.res.getFontMaxAscending() + _G.res.getFontMaxDescending()) * 0.75
	end
	
	if title.x ~= nil then
		x = title.x
	end		
	if title.y ~= nil then
		y = title.y
	end		

	x, y = offsetCoordinates(page, x, y)

	setRenderState(0, 0, 1, 1, 0)
	if title.text ~= nil then
		local hanchor = "HCENTER"
		local vanchor = "VCENTER"
		hanchor = title.hanchor and title.hanchor or hanchor
		vanchor = title.vanchor and title.vanchor or vanchor
		
		--[[if deviceModel == "s60" then
			setFont(defaultMenuFont)
		else
			setFont(fontMenu)
		end--]]
		setFont(defaultMenuFont) --japanese version

		if title.font ~= nil then
			setFont(title.font)
		end
		_G.res.drawString("TEXTS_BASIC", title.text, _G.math.floor(x), _G.math.floor(y), hanchor, vanchor)
	end

	if title.sprite ~= nil then
		_G.res.drawSprite("", title.sprite, _G.math.floor(x), _G.math.floor(y))
	end
end

function drawMenuItems(page)

	if (page == levelSelectionPagesBasic or page == levelSelectionPagesExtra or page == levelSelectionPagesPack3 or page == levelSelectionPagesPack4 or page == levelSelectionPagesPack5 or page == levelSelectionPagesPack6) then
		return drawLevelSelectionItems(page)
	end
	
	-- check if user want's to draw one whole item at a time or all sprites (and boxes) first and then text
	local drawSprites = true
	local drawText = true
	local loops = 0
	if page.drawSpritesFirst == true then
		drawText = false
		loops = 1
	end
	
	if levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1] then
		-- draw effect for new golden egg levels
		_G.res.setClipRect(0,0,screenWidth,screenHeight)
		setRenderState(0, 0, 1, 1, goldenEggsStarEffectAngle, _G.res.getSpritePivot("", "GOLDEN_EGG_STAR_EFFECT"))
		for i = 1, page.levelCount do
			if settings.openGoldenEggLevels["Level" .. i] == 0 then
				_G.res.drawSprite("", "GOLDEN_EGG_STAR_EFFECT", page.items[levelSelectionPagesGoldenEggs[1].firstLevelIndex - 1 + i].x, page.items[levelSelectionPagesGoldenEggs[1].firstLevelIndex - 1 + i].y)
			end
		end
		setRenderState(0, 0, 1, 1, 0)
	end
	
	if page == goldenEggAchievedPage and page.items[1].visible == true then
		local starEffectSprite = "GOLDEN_EGG_STAR_EFFECT"
		setRenderState(0, 0, 1, 1, page.items[1].angle, _G.res.getSpritePivot("", starEffectSprite))
		_G.res.drawSprite("", starEffectSprite, page.items[1].x, page.items[1].y)
		setRenderState(0, 0, 1, 1, 0)
	end
	
	if page == boomerangBirdAchievedPage and page.items[1].visible == true then
		local starEffectSprite = "GOLDEN_EGG_STAR_EFFECT"
		setRenderState(0, 0, 1, 1, page.items[1].angle, _G.res.getSpritePivot("", starEffectSprite))
		_G.res.drawSprite("", starEffectSprite, page.items[1].x, page.items[1].y)
		setRenderState(0, 0, 1, 1, 0)
	end
	
	if page == mightyEaglePaymentPage and page.items[3].angle < 1080 then		
		setRenderState(0, 0, 1, 1, page.items[3].angle, _G.res.getSpritePivot("", page.items[3].sprite))
		_G.res.drawSprite("", page.items[3].sprite, page.items[3].x, page.items[3].y)
		setRenderState(0, 0, 1, 1, 0)
	end
	
	if page == goldenEggStarAchievedPage and page.items[1].visible == true and page.items[2].visible == true then
		local starEffectSprite = "GOLDEN_EGG_STAR_EFFECT"
		setRenderState(0, 0, 1, 1, page.items[1].angle, _G.res.getSpritePivot("", starEffectSprite))
		_G.res.drawSprite("", starEffectSprite, page.items[1].x, page.items[1].y)
		setRenderState(0, 0, 1, 1, 0)
	end
	
	-- draw normal menu items
	for k = 0, loops do
		local i = 1
		while i <= #page.items do
			local ci = page.items[i]
			if ci.visible ~= false then
				-- calculate position
				local x = screenWidth/2
				local y = screenHeight/(#page.items + 1) * i
				
				x = ci.x and ci.x or x
				y = ci.y and ci.y or y
				if ci.dontOffset ~= true then
					x, y = offsetCoordinates(page, x, y)
				end
				if ci.itemDrawFunction ~= nil then
					ci.itemDrawFunction(page, ci, x, y, drawSprites, drawText)
				else
					
					drawMenuItem(page, ci, _G.math.floor(x), _G.math.floor(y), drawSprites, drawText)
				end
			end
			i = i + 1
		end
		drawSprites = not drawSprites
		drawText = not drawText
	end
end

--updates the scaling of the item based on its mouse over states, no drawing here, just changing
--the xs and ys attributes
function setItemMouseOverScaling(item)
	if item.mouseState ~= nil then
		if item.mouseState == "up" then			
			item.xs = item.xs or 1
			item.ys = item.ys or 1			
			item.scale = true
		elseif item.mouseState == "down" then
			--t_restoreScale = true
			
			if item.xs ~= nil and item.ys ~= nil then
				item.xs = item.xs * item.mouseStateTargetScale
				item.ys = item.ys * item.mouseStateTargetScale
			else
				item.xs = item.mouseStateTargetScale
				item.ys = item.mouseStateTargetScale
			end

			item.scale = true
			
		
		elseif item.mouseState == "overIn" then
			--t_restoreScale = true
			
			local t_scaleFactor = item.tweenFunction(item.mouseStateTime, 1, item.mouseStateTargetScale - 1, item.mouseStateTargetTime)
			
			if item.xs ~= nil and item.ys ~= nil then
				item.xs = item.xs * t_scaleFactor
				item.ys = item.ys * t_scaleFactor
			else
				item.xs = t_scaleFactor
				item.ys = t_scaleFactor
			end
			
			item.scale = true
			
		elseif item.mouseState == "overOut" then
			--t_restoreScale = true
			
			local t_scaleFactor = item.tweenFunction(item.mouseStateTime, item.mouseStateTargetScale,  1 - item.mouseStateTargetScale, item.mouseStateTargetTime)
									
			if item.xs ~= nil and item.ys ~= nil then
				item.xs = item.xs * t_scaleFactor
				item.ys = item.ys * t_scaleFactor
			else
				item.xs = t_scaleFactor
				item.ys = t_scaleFactor
			end
			
			item.scale = true
			
		elseif item.mouseState == "over" then
			--t_restoreScale = true
			
			if item.xs ~= nil and item.ys ~= nil then
				item.xs = item.xs * item.mouseStateTargetScale
				item.ys = item.ys * item.mouseStateTargetScale
			else
				item.xs = item.mouseStateTargetScale
				item.ys = item.mouseStateTargetScale
			end
			
			item.scale = true
			
		end
	end
end

function drawMouseScalingItem(sheet,item, x, y)
							
	if item.mouseStateReferenceItem ~= nil then
		if item.mouseStateReferenceItem.visible == false then
			return
		end
	end
	
	--local t_x, t_y = x or item.mouseStateReferenceItem.x, y or item.mouseStateReferenceItem.y
	local t_x, t_y = item.mouseStateReferenceItem.x or x, item.mouseStateReferenceItem.y or y
	
	if item.useSprites == true then
		local t_xs = item.xs or 1
		local t_ys = item.ys or 1
		local t_angle = item.angle or 0
		
		
		local t_spritePivotX, t_spritePivotY = _G.res.getSpritePivot(item.spriteUp.sheet or "", item.spriteUp.sprite)
		local t_pivotX, t_pivotY = item.pivotX or t_spritePivotX, item.pivotY or t_spritePivotY			
			
		setRenderState(_G.math.floor(t_x) / t_xs , _G.math.floor(t_y) / t_ys, t_xs, t_ys, t_angle, t_pivotX, t_pivotY)
		
		
		if item.mouseState == "up" then
			_G.res.drawSprite("", item.spriteUp.sprite, 0, 0)
		elseif item.mouseState == "down" then
			_G.res.drawSprite("", item.spriteDown.sprite, 0, 0)
		elseif item.mouseState == "over" then
			_G.res.drawSprite("", item.spriteOver.sprite, 0, 0)
		elseif item.mouseState == "overIn" then
			_G.res.drawSprite("", item.spriteOver.sprite, 0, 0)
		elseif item.mouseState == "overOut" then
			_G.res.drawSprite("", item.spriteUp.sprite, 0, 0)
		end
		
			
			
		
	else
		--saving initial scales
		local t_oldScales = {}														
		t_oldScales.x = item.xs
		t_oldScales.y = item.ys
		t_oldScales.scale = item.scale

		setItemMouseOverScaling(item)	

		local t_itemXS = item.xs or 1
		local t_itemYS = item.ys or 1	
		local t_itemAngle = item.angle or 0
		
		local t_pivotX, t_pivotY = 0, 0
		
		if item.sprite ~= nil then
			local t_spritePivotX, t_spritePivotY = _G.res.getSpritePivot(sheet or "", item.sprite)
			t_pivotX, t_pivotY = item.pivotX or t_spritePivotX, item.pivotY or t_spritePivotY			
		end
		
		
		local t_diffX, t_diffY = (item.x - item.mouseStateReferenceItem.x) * t_itemXS, (item.y - item.mouseStateReferenceItem.y) * t_itemYS
		
		--local t_x, t_y = item.mouseStateReferenceItem.x + t_diffX, item.mouseStateReferenceItem.y + t_diffY
		t_x, t_y = t_x + t_diffX, t_y + t_diffY
		
		if item == item.mouseStateReferenceItem then
			t_x = x
			t_y = y
		end
		
		--[[
		local t_areaW = item.mouseStateAreaWidth
		local t_areaH = item.mouseStateAreaHeight
		local t_areaX = item.mouseStateAreaPivotX
		local t_areaY = item.mouseStateAreaPivotY
		
		setRenderState(0,0,1,1,0)	
		
		drawRect(	1,0,0, 0.5, 
					item.mouseStateReferenceItem.x - t_areaX, 
					item.mouseStateReferenceItem.y - t_areaY, 
					item.mouseStateReferenceItem.x - t_areaX + t_areaW, 
					item.mouseStateReferenceItem.y - t_areaY + t_areaH, false)
		
		
		]]
		
		

			
		setRenderState(_G.math.floor(t_x) / t_itemXS, _G.math.floor(t_y) / t_itemYS, t_itemXS, t_itemYS, t_itemAngle, t_pivotX, t_pivotY)
		
		sheet = sheet or ""
		
		--setRenderState(_G.math.floor(t_finalX), _G.math.floor(t_finalY), t_itemXS, t_itemYS)
		if item.scaleText == true and item.text ~= nil then		
			setFont(item.font)
			_G.res.drawString("", item.text, 0,0, "HCENTER", "BOTTOM")				
		else
			
			_G.res.drawSprite("", item.sprite, 0, 0)
		end
		setRenderState(0, 0, 1, 1)	
		
		--restoring initial scales
		item.xs = t_oldScales.x
		item.ys = t_oldScales.y
		item.scale = t_oldScales.scale	

	end
	
	
	
end

function drawMenuItem(page, item, x, y, drawSprites, drawText)
	
	if item.visible == false then
		return
	end
	
	local ci = item
	
	-- get anchor data
	local hanchor = ci.hanchor and ci.hanchor or "HCENTER"
	local vanchor = ci.vanchor and ci.vanchor or "VCENTER"

	-- local xs = 1
	-- local ys = 1
	-- local angle = 0
	
	-- if item.xs ~= nil then xs = item.xs	end
	-- if item.ys ~= nil then ys = item.ys	end
	-- if item.angle ~= nil then angle = item.angle	end
	
	-- setRenderState(0, 0, xs, ys, angle)

	
	
	if drawSprites == true then
		if ci.sprite ~= nil then
			local sheet = ""
			if ci.sheet ~= nil then
				sheet = ci.sheet
			end
			if page.scale and page.xs and page.ys then
				if ci.useRelativePositioning ~= nil then
					--ignoring the pages scaling
					setRenderState(_G.math.floor(x), _G.math.floor(y), ci.xs, ci.ys)
					_G.res.drawSprite("", ci.sprite, 0,0)
					setRenderState(0, 0, 1, 1)
				else
					setRenderState(0, 0, page.xs, page.ys)
					_G.res.drawSprite("", ci.sprite, _G.math.floor(x) / page.xs, _G.math.floor(y) / page.ys)
					setRenderState(0, 0, 1, 1)		
				end
			else	
				--print("\n no scale " .. ci.name)
				if ci.isCompoSprite then
					--_G.res.drawCompoSprite(ci.sprite, ci.x, ci.y)
					--print("\n compo " .. ci.name)
					if ci.clip then
						--print("\n x is " .. ci.name .. " " .. x)
						setRenderState(0, 0, 1, 1)
						_G.res.setClipRect(page.clipX, page.clipY, page.clipW, page.clipH)
						_G.res.drawCompoSprite(ci.sprite, _G.math.floor(x) + ci.x, _G.math.floor(y) + ci.y)
						_G.res.setClipRect(0, 0, screenWidth, screenHeight)
					else
						setRenderState(0, 0, 1, 1)
						
						
						_G.res.drawCompoSprite(ci.sprite, _G.math.floor(x) + ci.x, _G.math.floor(y) + ci.y)
					end
					
					
				else
					--print("\n not a compo x is " .. x)
					if ci.mouseState ~= nil then
						drawMouseScalingItem(sheet,ci, x, y)
					
					elseif ci.useRelativePositioning ~= nil then	
						setRenderState(_G.math.floor(x), _G.math.floor(y), ci.xs, ci.ys)
						_G.res.drawSprite("", ci.sprite, 0,0)
						setRenderState(0, 0, 1, 1)
					elseif ci.scale then
						setRenderState(_G.math.floor(x) / ci.xs, _G.math.floor(y) / ci.ys, ci.xs, ci.ys)
						_G.res.drawSprite("", ci.sprite, 0, 0)
						setRenderState(0, 0, 1, 1)
					elseif ci.rectangle then
						drawRect(ci.color.red, ci.color.green, ci.color.blue, 1.0, _G.math.floor(x), _G.math.floor(y), _G.math.floor(ci.width + x), _G.math.floor(ci.height + y), false)
					elseif ci.clip then
						_G.res.setClipRect(page.clipX, page.clipY, page.clipW, page.clipH)
						_G.res.drawSprite("", ci.sprite, _G.math.floor(x), _G.math.floor(y))
						_G.res.setClipRect(0, 0, screenWidth, screenHeight)
					else
						_G.res.drawSprite("", ci.sprite, _G.math.floor(x), _G.math.floor(y))
					end
				end
			end
		elseif ci.box ~= nil then
		--[[	local x, y = 0, 0

			if ci.x ~= nil then
				x = ci.x
			end
			if ci.y ~= nil then
				y = ci.y
			end]]
			
			local sheet = ""
			if ci.sheet ~= nil then
				sheet = ci.sheet
			end
			
			if ci.color ~= nil then
				local r,g,b,a = 1.0, 1.0, 1.0, 1.0
				if ci.color.red ~= nil then
					r = ci.color.red
				end
				if ci.color.green ~= nil then
					g = ci.color.green
				end
				if ci.color.blue ~= nil then
					b = ci.color.blue
				end
				if ci.color.alpha ~= nil then
					a = ci.color.alpha
				end
				
				drawBox(ci.box, sheet, _G.math.floor(x), _G.math.floor(y), _G.math.floor(ci.width), _G.math.floor(ci.height), ci.hanchor, ci.vanchor, { red = r, green = g, blue = b, alpha = a })
			else
				drawBox(ci.box, sheet, _G.math.floor(x), _G.math.floor(y), _G.math.floor(ci.width), _G.math.floor(ci.height), ci.hanchor, ci.vanchor, nil)
			end
		end
	end
	
	if drawText == true then
		if ci.lines ~= nil then
			if ci.mouseState ~= nil then
				drawMouseScalingItem(sheet,ci, x, y)
			else
				--check font
				setFont(ci.font)

				local fh = _G.res.getFontLeading()			
				local k = 1
				while k <= #ci.lines do
					_G.res.drawString("", ci.lines[k], _G.math.floor(x), _G.math.floor(y - ci.h * 0.5 + fh * (k-0.5)), hanchor, vanchor)
					k = k + 1
				end	
			end
		else
			if ci.mouseState ~= nil then
				--drawMouseScalingItem(sheet,ci, x, y)
			end
		end
	end
	
	if ci.children ~= nil then
		for i = 1, #ci.children do
			local childItem = ci.children[i]
			drawMenuItem(page, childItem, childItem.x + x, childItem.y + y, drawSprites, drawText)
		end
	end
	
end


function drawLevelSelectionItems(page)

	local i = 1
	
	
	
	--we only need to clip the level buttons, since those are the last ones to be added, we only apply a clipping rect 
	--if the index is greater than the first level index
	local t_firstLevelIndex = page.firstLevelIndex or 1000
	
	
	
	--draws the items, the level buttons backgrounds are items as well
	local t_visibleAreaOverlayOffsetX = g_levelSelectionClippingArea.offsetX
	local t_visibleAreaOverlayOffsetY = g_levelSelectionClippingArea.offsetY
	local t_overlay = getItemByName(page.items, "scrollAreaOverlay")
	--draws the overlay behind all items
	_G.res.drawSprite("", t_overlay.sprite, g_levelSelectionClippingArea.x - t_visibleAreaOverlayOffsetX, g_levelSelectionClippingArea.y - t_visibleAreaOverlayOffsetY, "LEFT", "TOP", g_levelSelectionClippingArea.width + (t_visibleAreaOverlayOffsetX*2), g_levelSelectionClippingArea.height + (t_visibleAreaOverlayOffsetY*2))					
	
	--those values were found by measuring themockup
	--local t_clipW = (1543 / 1920) * screenWidth - (378 / 1920) * screenWidth
	local t_clipW = (1551 / 1920) * screenWidth - (366 / 1920) * screenWidth
	local t_clipH = (877 / 1200) * screenHeight - (273 / 1200) * screenHeight
	--local t_clipX = (378 / 1920) * screenWidth
	local t_clipX = (366 / 1920) * screenWidth
	local t_clipY = (330 / 1200) * screenHeight
	
	t_clipX = t_clipX - t_visibleAreaOverlayOffsetX
	t_clipW = t_clipW + (t_visibleAreaOverlayOffsetX * 2)
	
	t_clipY = t_clipY - t_visibleAreaOverlayOffsetY
	t_clipH = t_clipH + (t_visibleAreaOverlayOffsetY * 2)
	
	t_clipX = g_levelSelectionClippingArea.x - t_visibleAreaOverlayOffsetX
	t_clipY = g_levelSelectionClippingArea.y - t_visibleAreaOverlayOffsetY
	t_clipW = g_levelSelectionClippingArea.width + (t_visibleAreaOverlayOffsetX * 2)
	t_clipH = g_levelSelectionClippingArea.height + (t_visibleAreaOverlayOffsetY * 2)
	
	while i <= #page.items do
		local ci = page.items[i]
		if ci.visible ~= false and ci.sprite then-- and ci.name == nil then
			local sheet = ci.sheet or ""
			if not ci.filename or ci.x >= 0 - ci.spriteWidth and ci.x <= screenWidth + ci.spriteWidth then 
				
				if i >= t_firstLevelIndex then
					_G.res.setClipRect(t_clipX, t_clipY, t_clipW, t_clipH)
				else
					_G.res.setClipRect(0, 0, screenWidth, screenHeight)
				end
				
				if ci.name == "scrollAreaOverlay" then
					
					--setRenderState(0, 0, 1, 1, 0)
					--_G.res.drawSprite("", ci.sprite, g_levelSelectionButtonsVisibleAreaX - t_visibleAreaOverlayOffset, g_levelSelectionButtonsVisibleAreaY - t_visibleAreaOverlayOffset, "LEFT", "TOP", g_levelSelectionButtonsVisibleAreaW + (t_visibleAreaOverlayOffset*2), g_levelSelectionButtonsVisibleAreaH + (t_visibleAreaOverlayOffset*2))					
				elseif ci.name == "leftNavigation" then
					if page.currentPage > 1 then
						--_G.res.drawSprite("", ci.sprite, _G.math.floor(ci.x), _G.math.floor(ci.y))
						--mouse over scaling
						if ci.mouseState ~= nil then
							
							drawMouseScalingItem(sheet,ci, ci.x, ci.y)
							
						else
							_G.res.drawSprite("", ci.sprite, _G.math.floor(ci.x), _G.math.floor(ci.y))
						end
					end
				elseif ci.name == "rightNavigation" then
					if page.currentPage < page.pageCount then
						
						--_G.res.drawSprite("", ci.sprite, _G.math.floor(ci.x), _G.math.floor(ci.y))
							
						--mouse over scaling
						if ci.mouseState ~= nil then
							
							drawMouseScalingItem(sheet,ci, ci.x, ci.y)
							
						else
							_G.res.drawSprite("", ci.sprite, _G.math.floor(ci.x), _G.math.floor(ci.y))
						end
						
						
						
					end
				else
					--_G.res.drawSprite("", ci.sprite, _G.math.floor(ci.x), _G.math.floor(ci.y))
					if ci.mouseState ~= nil then							
						drawMouseScalingItem(sheet,ci, ci.x, ci.y)						
					else
						_G.res.drawSprite("", ci.sprite, _G.math.floor(ci.x), _G.math.floor(ci.y))
					end
						
				end
				
				
				if settings.mightyEagleEnabled then
					for k, v in _G.pairs(settings.eaglesUsedIn) do
						if v.world == ci.worldNumber and v.level == ci.pageLevelIndex then
							_G.res.drawSprite("", "LS_EAGLE_BUTTON", _G.math.floor(ci.x), _G.math.floor(ci.y))
						end
					end
				end
			end
		end
		i = i + 1
	end
	
	
	_G.res.setClipRect(t_clipX, t_clipY, t_clipW, t_clipH)
	--draws level starts and feathers
	
	for i = 1, #levelSelectionButtonIndeces do
		local ci = page.items[levelSelectionButtonIndeces[i].index]
		if ci.visible ~= false and ci.x >= 0 - ci.spriteWidth and ci.x <= screenWidth + ci.spriteWidth then	
			if levelSelectionButtonIndeces[i].starSprite then
				if ci.starItem then
					if ci.starItem.mouseState ~= nil then
						drawMouseScalingItem("LEVELSELECTION_SHEET_1",ci.starItem)
					else
						_G.res.drawSprite("", levelSelectionButtonIndeces[i].starSprite, _G.math.floor(ci.x), _G.math.floor(ci.y + ci.spriteHeight * 0.5))			
					end
				else
					_G.res.drawSprite("", levelSelectionButtonIndeces[i].starSprite, _G.math.floor(ci.x), _G.math.floor(ci.y + ci.spriteHeight * 0.5))			
				end
				
				--drawMouseScalingItem("",ci.starItem)
			end
			if settings.mightyEagleEnabled == true and levelSelectionButtonIndeces[i].featherSprite ~= nil then
				_G.res.drawSprite("", levelSelectionButtonIndeces[i].featherSprite, _G.math.floor(ci.x), _G.math.floor(ci.y))			
			end
		end
	end
	
			
	
	--draws level numbers
	for i = 1, #levelSelectionButtonIndeces do
		local ci = page.items[levelSelectionButtonIndeces[i].index]
		if ci.text ~= nil and ci.visible ~= false and ci.lines and ci.x >= 0 - ci.spriteWidth and ci.x <= screenWidth + ci.spriteWidth and (levelSelectionButtonIndeces[i].eagleUsed ~= true or settings.mightyEagleEnabled ~= true) then
			setFont(ci.font)
			
			if ci.mouseState ~= nil then
				--this draw routine is pretty much the same as in drawMouseScalingItem
				--I added it here because those texts are not added as textitems
				local t_oldScales = {}														
				t_oldScales.x = ci.xs
				t_oldScales.y = ci.ys
				t_oldScales.scale = ci.scale

				setItemMouseOverScaling(ci)	

				local t_itemXS = ci.xs or 1
				local t_itemYS = ci.ys or 1
				
				setRenderState(_G.math.floor(ci.x)/t_itemXS, _G.math.floor(ci.y)/t_itemYS, t_itemXS, t_itemYS)
				
				_G.res.drawString("", ci.lines[1], 0,0, "HCENTER", "VCENTER")
				
				setRenderState(0, 0, 1, 1)	
				
				--restoring initial scales
				ci.xs = t_oldScales.x
				ci.ys = t_oldScales.y
				ci.scale = t_oldScales.scale	
			else
				_G.res.drawString("", ci.lines[1], _G.math.floor(ci.x), _G.math.floor(ci.y), "HCENTER", "VCENTER")
			end
			
		end
	end
	
	
	_G.res.setClipRect(0, 0, screenWidth, screenHeight)
	if deviceModel == "n900" and page == levelSelectionPagesBasic and getItemByName(page.items, "overlay").visible then
		local itm = getItemByName(page.items, "overlay")
		drawRect( 0, 0, 0, itm.shade, itm.x, itm.y, screenWidth, screenHeight, false)
		itm = getItemByName(page.items, "button1")
		_G.res.drawSprite("", itm.sprite, itm.x, itm.y)
		itm = getItemByName(page.items, "button2")
		_G.res.drawSprite("", itm.sprite, itm.x, itm.y)
	end
	
	local back = page.items[1]
	--_G.res.drawSprite("",  back.sprite, back.x, back.y)
	
	
	
	local _, textIndex = getItemByName(page.items, "text_" .. page.themes[1])
	for i = textIndex, page.pageCount + textIndex - 1 do
		local numberText = page.items[i]
		if numberText.visible and numberText.lines then
			setFont(numberText.font)
			_G.res.drawString("", numberText.lines[1], numberText.x, numberText.y, "HCENTER", "VCENTER")
		end
	end
	
	--drawRect( 0, 0, 0, 0.5, (378 / 1920) * screenWidth, (273 / 1200) * screenHeight, (1543 / 1920) * screenWidth, (877 / 1200) * screenHeight, false)
		
	
end

function goldenEggMenuDimDraw(page, item, x, y, drawSprites, drawText)
	if getItemByName(page.items, "overlay").visible then
		local itm = getItemByName(page.items, "overlay")
		drawRect( 0, 0, 0, itm.shade, itm.x, itm.y, screenWidth, screenHeight, false)
	end
end

-- Menu stuff ends
-------------------------------------------------------------------------------

function drawLevelSelectionBackground(page)
	
	setRenderState(0, 0, -1, 1, 0)
	_G.res.drawSprite("", "LS_BACKGROUND", -screenWidth, 0, "LEFT", "TOP", _G.math.ceil(screenWidth / 2), screenHeight)
	setRenderState(0, 0, 1, 1, 0)
	_G.res.drawSprite("", "LS_BACKGROUND", 0, 0, "LEFT", "TOP", _G.math.floor(screenWidth / 2), screenHeight)
	setRenderState(0, 0, 1, 1, 0)	
end

function drawAboutPage()
	drawMenuPage(about)
end

function drawSettingsPage()
	drawMenuPage(settingsPage)
end

function starEffectItemDraw(page, item, x, y, drawSprites, drawText)
	local ci = item
	local starEffectSprite = "GOLDEN_EGG_STAR_EFFECT"
	if ci.sprite ~= nil then
		starEffectSprite = ci.sprite
	end
	setRenderState(0, 0, 1, 1, ci.angle, _G.res.getSpritePivot("", starEffectSprite))
	_G.res.drawSprite("", starEffectSprite, ci.x, ci.y)
	setRenderState(0, 0, 1, 1, 0)
--	ci.angle = ci.angle + 1.6 * dt
end

function buttonSliderDraw(page, item, x, y, drawSprites, drawText)
	local ci = item
	local buttonSprite = "BUTTON_SLIDER"
	if ci.sprite ~= nil then
		buttonSprite = ci.sprite
	end
	--old implementation without mouse over state
	--setRenderState(0, 0, 1, 1, ci.angle, _G.res.getSpritePivot("", buttonSprite))
	--_G.res.drawSprite("", buttonSprite, ci.x, ci.y)
	--setRenderState(0, 0, 1, 1, 0)	
			
	if (item.mouseState ~= nil) then
				
		local t_oldScales = {}		
		
		t_oldScales.x = item.xs
		t_oldScales.y = item.ys
		t_oldScales.scale = item.scale

		setItemMouseOverScaling(item)				
		
		setRenderState(_G.math.floor(x / ci.xs), _G.math.floor(y / ci.ys), ci.xs, ci.ys, ci.angle, _G.res.getSpritePivot("", buttonSprite))
		_G.res.drawSprite("", buttonSprite, 0, 0)
		setRenderState(0, 0, 1, 1, 0)
		
		ci.xs = t_oldScales.x
		ci.ys = t_oldScales.y
		ci.scale = t_oldScales.scale
		
	else
		setRenderState(0, 0, 1, 1, ci.angle, _G.res.getSpritePivot("", buttonSprite))
		_G.res.drawSprite("", buttonSprite, ci.x, ci.y)
		setRenderState(0, 0, 1, 1, 0)	
	end
end

function buttonSliderOptionsDraw(page, item, x, y, drawSprites, drawText)
	local ci = item
	local buttonSprite = "BUTTON_SLIDER"
	if ci.sprite ~= nil then
		buttonSprite = ci.sprite
	end
	
	--old implementation without mouse over state
	--setRenderState(0, 0, 1, 1, ci.angle, _G.res.getSpritePivot("", buttonSprite))
	--_G.res.drawSprite("", buttonSprite, ci.x, ci.y)
	--setRenderState(0, 0, 1, 1, 0)	
	
	if (item.mouseState ~= nil) then
	
		local t_oldScales = {}
		t_oldScales.x = item.xs
		t_oldScales.y = item.ys
		t_oldScales.scale = item.scale

		setItemMouseOverScaling(item)
		
		setRenderState(_G.math.floor(x) / ci.xs, _G.math.floor(y) / ci.ys, ci.xs, ci.ys, ci.angle, _G.res.getSpritePivot("", buttonSprite))
		_G.res.drawSprite("", buttonSprite, 0, 0)
		setRenderState(0, 0, 1, 1, 0)
		
		ci.xs = t_oldScales.x
		ci.ys = t_oldScales.y
		ci.scale = t_oldScales.scale
		
	else
		setRenderState(0, 0, 1, 1, ci.angle, _G.res.getSpritePivot("", buttonSprite))
		_G.res.drawSprite("", buttonSprite, ci.x, ci.y)
		setRenderState(0, 0, 1, 1, 0)
	end
end

function eagleFeatherFillDraw(page, item, x, y, drawSprites, drawText)
	local ci = item
	local fillEffectSprite = "EAGLE_METER_FILL"
	if ci.sprite ~= nil then
		fillEffectSprite = ci.sprite
	end
	local w, h = _G.res.getSpriteBounds("", fillEffectSprite)
	local px, py = _G.res.getSpritePivot("", fillEffectSprite)
	local left = x - px
	local top = y - py
	
	_G.res.setClipRect(left, 0, _G.math.floor(w * (ci.fill / 100)), screenHeight)
	_G.res.drawSprite("", fillEffectSprite, ci.x, ci.y)
	_G.res.setClipRect(0, 0, screenWidth, screenHeight)
end
-------------------------------------------------------------------------------

function filterLoadedLevel()
	if currentGameMode ~= updateEditor then
		if currentLevelNumberInTheme == 7 and currentWorldNumber == 4 then
			if settings.openGoldenEggLevels["Level9"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 19 and currentWorldNumber == 5 then
			if settings.openGoldenEggLevels["Level2"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 15 and currentWorldNumber == 8 then
			if settings.openGoldenEggLevels["Level13"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if (currentLevelNumberInTheme == 4 and currentWorldNumber == 6 and settings.boomerangBirdAchieved == true) or 
		   (currentLevelNumberInTheme == 5 and currentWorldNumber == 9 and settings.boomerangBirdAchieved2 == true) then
			loadedObjects.world["ExtraBoomerangBird_1"] = nil
		end
		
		if currentLevelNumberInTheme == 14 and currentWorldNumber == 9 then
			if settings.openGoldenEggLevels["Level14"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 15 and currentWorldNumber == 11 then
			if settings.openGoldenEggLevels["Level16"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
	end
end

function loadLevelInternal(levelFileName)
	
	releaseCutScenes()
	prepareMenuPage(loadingPage)
	prepareMenuPage(tutorials)
	
	--[[ BEGIN FPS DEBUG CODE --
	FPSFrames = 0
	FPSTime = 0
	FPSMin = nil
	FPSMax = nil
	drawFPSStatistics = false
	-- END FPS DEBUG CODE --]] 

	setAnimationState("ingamePausePageScroll", "HIDDEN")
	pausePage.offsetX = elementAnimations["ingamePausePageScroll"].percentage / 100 * pauseBGw - pauseBGw
	pausePage.backgroundOverlay.shade = elementAnimations["ingamePausePageScroll"].percentage / 100 * 0.65
	_G.res.stopAllAudio()
	-- print("-Object table-\n")
	-- for k, v in _G.pairs(objects) do
		-- print("Object: " .. k .. " - " .. v.name .. "\n")
	-- end
	
	quadClick = false
	quadClickCounter = 0	
	eagleBaitLaunched = false
	eagleTimer = nil
	cameraShake = nil
	
	birdToSlingshotAnimationTimer = 0
	birdToSlingshotAnimationAngle = 135 / 180 * _G.math.pi
	birdToSlingshotSurplusAngle =  birdToSlingshotAnimationAngle - _G.math.pi * 0.5
	birdToSlingshotAnimationHeight = 0
	birdToSlingshotAnimationStartX = 0
	birdToSlingshotAnimationStartY = 0
	birdToSlingshotBirdName = nil	
	
	currentBirdIndex = 1
	currentBirdName = nil
	flyingBird = nil
	birdSpecialtyAvailable = false
	birdFired = false
	birdReady = false
	fillInNextBird = false
	birdSelected = false
	showTapIcon = true
	birdsShot = 0

	tapStarted = false
	tapCount = 0
	tapTimer = 0
	tapPosition = { x = 0, y = 0 }
	doubleClickTimer = 0
	levelCompleteTimer = 0
	levelCompleted = false
	levelFailedTimer = 0
	birdBuffTimer = 0
	castleCameraTimer = 0
	dragCursorIndex = 1
	dragCursorTable = { {dx = 0, dy = 0, dt = 1} }
	
	rubberBandAngle = 0
	rubberBandLength = 0
	oldRubberBandLength = 0

	cameraResetTimer = 0
	showTapTimer = 0
	nextBirdTimer = 0.5
	zoomLevel = 0
	oldZoomLevel = 0
	worldScale = 1
	oldScoreLen = 0
	
	sweepSpeed = 0
	particleAmount = 0
	
	levelLeftEdge = 100000
	levelRightEdge = -100000
	
	--local birdsCounter = 0
	birdsCounter = 0
	objectCounts = {}

	floatingScores = {}
	score = 0
	scoreTable = {}
	scoreTable.blocks = { score = 0, blockDestroyedScore = blockDestroyedScoreIncrement }
	scoreTable.birds = { score = 0 }
	
	selectedObjects = { }
	cameraTargetObject = nil
	allowResetToBirdCamera = false
	
	particles = {}
	birdTutorialPopups = {}
	showTutorialGoldenEgg = false
	
	--print("-Load-\n")
	if objects.world ~= nil then
		if objects.world["MightyEagle_a"] ~= nil then
			removeObject("MightyEagle_a")
			objects.world["MightyEagle_a"] = nil
		end
		for k, v in _G.pairs(objects.world) do
			--print("Removing world object: " .. k .. "\n")
			objects.world[k] = nil
		end
	end

	birds = {}
	levelGoals = {}
	
	flyingGrenades = {}
	birdTrajectory = { {}, {}, {} }
	otherBirds = {}
	
	 --print("-Object table-\n")
	 --for k, v in _G.pairs(objects) do
		--print("Object: " .. k .. " - " .. v.name .. "\n")
	 --end

	--print("Loading level\n")
	
	--episode4BGCranes = { startX = (wx1 + wx2) * 0.5 }
	episode4BGCranes = { startX = 64 }
	
	loadLevel(levelFileName)
	
	filterLoadedLevel()

	currentThemeIndex = 1

	objects.world = {}
	objects.joints = {}
	objects.counts = {}
	objects.physicsToWorld = physicsToWorld
	objects.theme = "theme1"
	objects.castleCameraData = nil --{ px = 0, py = 0, sx = 1, sy = 1, }
	objects.birdCameraData = nil --{ px = 0, py = 0, sx = 1, sy = 1, }
	-- flyCameraData = { px = 0, py = 0, sx = 1, sy = 1, }
	
	-- Reset scale and screen position
	setWorldScale(worldScale)
	screen.x = 0
	screen.y = 0
	levelStartPosition.x = 0
	levelStartPosition.y = 0
	rubberBandPos.x = 0
	rubberBandPos.y = 0
	rubberBandSpeed = 0
	
	-- level was not found
	if loadedObjects == nil then
		-- find the current theme based on the theme index in blocktable
		for k0, v0 in _G.pairs(blockTable.themes) do
			if v0.index ~= nil and v0.index == currentThemeIndex then
				currentTheme = k0
			end
		end		
		
		createBox("ground", "", (levelLeftEdge + levelRightEdge)*0.5, 5, 2000, 10, 0, 0.8, 0, true, false, 0)
		objects.world["ground"].material = "staticGround"
		objects.world["ground"].definition = "Ground"
		objects.world["ground"].strength = 30
		objects.world["ground"].defence = 1000000		
		
		setTheme(currentTheme)
		return		
	end

	-- init counts table
	local countsSaved = false
	if loadedObjects.counts ~= nil then
		countsSaved = true
		for k, v in _G.pairs(loadedObjects.counts) do
			objects.counts[k] = v
		end
	end

	-- temp code for testing the right scale
	local pscale = 100
	if loadedObjects.physicsToWorld ~= nil then
		pscale = loadedObjects.physicsToWorld
	end
	scaleFactor = pscale/physicsToWorld
	
	--print("Creating objects\n")
	if loadedObjects.world ~= nil then
		for k, v in _G.pairs(loadedObjects.world) do
			local obj = v
			-- quick fix to disable ground block creation from the level data
			if obj.name ~= "ground" then
				local name = createObject(blockTable, obj.definition, obj.name, obj.x*scaleFactor, obj.y*scaleFactor)

				-- clamp angle to 0 - 2*PI range
				obj.angle = _G.math.fmod(obj.angle, _G.math.pi*2)
				if obj.angle < 0 then
					obj.angle = obj.angle + _G.math.pi*2
				end
				
				setRotation(name, obj.angle)
				setMaterial(name, objects.world[name].material)
				if objects.world[name].texture ~= nil then
					setTexture(name, objects.world[name].texture)
				end
				
				if objects.world[name].controllable then
					birdsCounter = birdsCounter + 1
					if obj.startNumber ~= nil then
						objects.world[name].startNumber = obj.startNumber
					else
						objects.world[name].startNumber = birdsCounter
					end
				end
				
				local width = objects.world[name].width
				if width == nil then width = objects.world[name].radius end
				if objects.world[name].x - width < levelLeftEdge then
					levelLeftEdge = objects.world[name].x - width
				end
				if objects.world[name].x + width > levelRightEdge then
					levelRightEdge = objects.world[name].x + width
				end
			end
		end
	end

	createBox("ground", "", (levelLeftEdge + levelRightEdge)*0.5, 5, 2000, 10, 0, 0.8, 0, true, false, 0)
	objects.world["ground"].material = "staticGround"
	objects.world["ground"].definition = "Ground"
	objects.world["ground"].strength = 30
	objects.world["ground"].defence = 1000000
	
	countsSaved = true

	--print("Creating joints\n")
	if loadedObjects.joints ~= nil then
		for k, v in _G.pairs(loadedObjects.joints) do
			createJoint(v.name, v.end1, v.end2, v.type, v.coordType, v.x1, v.y1, v.x2, v.y2)
		end
	end

	-- level camera data
	objects.castleCameraData = loadedObjects.castleCameraData
	objects.birdCameraData = loadedObjects.birdCameraData
	
	-- level end condition
	objects.doNotWaitForMovingObjects = loadedObjects.doNotWaitForMovingObjects

	-- handle theme
	if loadedObjects.theme ~= nil then
		objects.theme = loadedObjects.theme
		currentThemeIndex = blockTable.themes[objects.theme].index
		-- find the current theme based on the theme index in blocktable
		for k0, v0 in _G.pairs(blockTable.themes) do
			if v0.index ~= nil and v0.index == currentThemeIndex then
				currentTheme = k0
			end
		end
	end
	
	for k, v in _G.pairs(loadedObjects) do
		loadedObjects[k] = nil
	end
	loadedObjects.cameraData = nil
	selectedBird = nil
	
	
	-- if starTable[levelName] == nil then
		-- starTable[levelName] = { silverScore = 25000, goldScore = 75000 }
		-- saveLuaFileWrapper("scripts/starLimits.lua", "starTable", false)
	-- end
	
	local maxScore = 0
		
	for k, v in _G.pairs(objects.world) do
		if v.controllable == true then
			-- add bird to bird table for faster access
			v.animTimer = _G.math.random(10, 30) / 10
			v.jumpTimer = _G.math.random(10, 30) / 10
			setRotation(v.name, 0)
			setObjectParameter(v.name, 2, 0)
			birds[k] = v
			if blockTable.blocks[v.definition].tutorialInfo ~= nil then
				if settings.tutorials[v.sprite] == true then
					settings.tutorials[v.sprite] = nil
				end
				if settings.tutorials[v.sprite] == nil then
					settings.tutorials[v.sprite] = {}
					settings.tutorials[v.sprite].sprite = blockTable.blocks[v.definition].tutorialInfo
					_G.table.insert(birdTutorialPopups, blockTable.blocks[v.definition].tutorialInfo)
					
					if settings.tutorials["BIRD_BLUE"] ~= nil then
						addToAchievementUnlockQueue("Split it!")
					end
					if settings.tutorials["BIRD_YELLOW"] ~= nil then
						addToAchievementUnlockQueue("Speed is the Essence")
					end
					if settings.tutorials["BIRD_GREY"] ~= nil then
						addToAchievementUnlockQueue("Boom Boom!")
					end
					if settings.tutorials["BIRD_GREEN"] ~= nil then
						addToAchievementUnlockQueue("Mother of all Bombs")
					end
					if settings.tutorials["BIRD_BOOMERANG"] ~= nil then
						addToAchievementUnlockQueue("Return to Sender")
					end
					if settings.tutorials["BIRD_BIG_BROTHER"] ~= nil then
						addToAchievementUnlockQueue("Seeing Red") 
					end
				end
			end
		end
		if v.levelGoal then
			v.blinkTimer = _G.math.random(5, 30) / 10
			v.oinkTimer = _G.math.random(5, 30) / 10			
			levelGoals[k] = v
			setObjectParameter(k, 1, 1) -- set this object as level goal
		end
		local sprites = getDamageSprite(v, blockTable.blocks)
		v.damageSprite = sprites.sprite
		v.blinkSprite = sprites.blink		
		v.smileSprite = sprites.smile		
		v.frozen = false
		
		if v.controllable  then
			maxScore = maxScore + birdsLeftScoreIncrement
		elseif v.levelGoal then
			maxScore = maxScore + v.strength * 10 + pigletteDestroyedScoreIncrement
		elseif v.defence <= 1000 then
			
			maxScore = maxScore + v.strength * 10
			
			destroyedBonus = blockDestroyedScoreIncrement
			if blockTable.blocks[v.definition].destroyedScoreInc ~= nil then
				destroyedBonus = blockTable.blocks[v.definition].destroyedScoreInc
			end
			maxScore = maxScore + destroyedBonus
		end
	end
	
	-- one bird must be shot...
	maxScore = maxScore - birdsLeftScoreIncrement
	print("Max score for " .. currentWorldNumber .. "-" .. currentLevelNumberInTheme .. ": " .. maxScore .. "\n")
	
	-- init level positions
	levelStartTimer = 0
	local startObjectName = getNextBird(1)
	if startObjectName ~= nil then
		setObjectParameter(startObjectName, 2, 1)
	end

	if startObjectName ~= nil and objects.world[startObjectName] ~= nil then
		local px, py = _G.res.getSpritePivot("", "SLING_SHOT_01_BACK")
		local sw, sh = _G.res.getSpriteBounds("", "SLING_SHOT_01_BACK")
		local r = objects.world[startObjectName].radius
		if r == nil then
			r = 0
		end
		levelStartPosition.x = objects.world[startObjectName].x
		levelStartPosition.y = objects.world[startObjectName].y - (sh - py) * physicsScale + r + 0.2
		rubberBandPos.x = levelStartPosition.x - 0.1
		rubberBandPos.y = levelStartPosition.y - 0.1
		baitSardine.x, baitSardine.y = objects.world[startObjectName].x, objects.world[startObjectName].y
		
		-- createBox("slingShotPole", "", levelStartPosition.x, levelStartPosition.y + 115 * physicsScale, sw * physicsScale, 110 * physicsScale, 0, 0.8, 0, true, false)
		-- objects.world["slingShotPole"].material = "immovable"
		-- objects.world["slingShotPole"].definition = "Ground"
		-- objects.world["slingShotPole"].strength = 30
		-- objects.world["slingShotPole"].defence = 1000000		
	end

	local c = blockTable.themes[objects.theme].color
	setBGColor(c.r, c.g, c.b)
	cameraFunction = levelStartCamera
	
	if objects.castleCameraData ~= nil then
	
		-- Check if level has camera data for current device
		if objects.castleCameraData[deviceModel] == nil then
		
			-- Check if file has camera data for iphone
			if objects.castleCameraData["iphone"] then
				objects.castleCameraData[deviceModel] = {}
				objects.castleCameraData[deviceModel].px = objects.castleCameraData["iphone"].px
				objects.castleCameraData[deviceModel].py = objects.castleCameraData["iphone"].py
				objects.castleCameraData[deviceModel].sx = objects.castleCameraData["iphone"].sx
				objects.castleCameraData[deviceModel].sy = objects.castleCameraData["iphone"].sy
				objects.castleCameraData[deviceModel].screenWidth = objects.castleCameraData["iphone"].screenWidth
				objects.castleCameraData[deviceModel].screenHeight = objects.castleCameraData["iphone"].screenHeight
			elseif objects.castleCameraData.px ~= nil then
				-- Check if has data generic camera data
				objects.castleCameraData[deviceModel] = {}
				objects.castleCameraData[deviceModel].px = objects.castleCameraData.px
				objects.castleCameraData[deviceModel].py = objects.castleCameraData.py
				objects.castleCameraData[deviceModel].sx = objects.castleCameraData.sx
				objects.castleCameraData[deviceModel].sy = objects.castleCameraData.sy
				objects.castleCameraData[deviceModel].screenWidth = objects.castleCameraData.screenWidth
				objects.castleCameraData[deviceModel].screenHeight = objects.castleCameraData.screenHeight
			else
				objects.castleCameraData[deviceModel] = {}
				objects.castleCameraData[deviceModel].px = screen.x
				objects.castleCameraData[deviceModel].py = screen.y
				objects.castleCameraData[deviceModel].sx = 1
				objects.castleCameraData[deviceModel].sy = 1
				objects.castleCameraData[deviceModel].screenWidth = screenWidth
				objects.castleCameraData[deviceModel].screenHeight = screenHeight
			end
		end
	
		local ccd = objects.castleCameraData[deviceModel]
		
		if ccd.screenWidth == nil then
			ccd.screenWidth = 1680
		end
		if ccd.screenHeight == nil then
			ccd.screenHeight = 1050
		end

		local cameraAspectRation = ccd.screenWidth / ccd.screenHeight
		local currentAspectRation = screenWidth / screenHeight
		
		if currentAspectRation >= cameraAspectRation then
			-- Current aspect ratio is wider than the one used to make the level, expand horizontally
			ccd.sx = ccd.sx * screenHeight / ccd.screenHeight
			ccd.sy = ccd.sy * screenHeight / ccd.screenHeight
		else
			-- Current aspect ratio is narrower than the one used to make the level, expand vertically
			ccd.sx = ccd.sx * screenWidth / ccd.screenWidth
			ccd.sy = ccd.sy * screenWidth / ccd.screenWidth
		end
		if objects.castleCameraData.version == nil then
			-- old version has the screen center position in wrong place
			worldScale = ccd.sx
			setWorldScale(worldScale)
			screen.left = ccd.px - screenWidth * 0.5
			screen.top = ccd.py - screenHeight * 0.5
			screen.right = screen.left + screenWidth / worldScale
			screen.bottom = screen.top + screenHeight / worldScale
			screen.x = (screen.right + screen.left) * 0.5
			screen.y = (screen.bottom + screen.top) * 0.5
			--print("CScreen: " .. screen.left .. ", " .. screen.top .. " - " .. screen.right .. ", " .. screen.bottom .. "\n")
			--print("CScreen: " .. screen.x .. ", " .. screen.y .. "\n")
			ccd.px = screen.x
			ccd.py = screen.y
			--updateScale()
		else
			worldScale = ccd.sx
			setWorldScale(worldScale)
			screen.x = ccd.px
			screen.y = ccd.py
			screen.left = screen.x - screenWidth * 0.5 / worldScale
			screen.top = screen.y - screenHeight * 0.5 / worldScale
			screen.right = screen.x + screenWidth * 0.5 / worldScale
			screen.bottom = screen.y + screenHeight * 0.5 / worldScale
			--updateScale()
		end
	else
		-- camera not defined set default camera
		objects.castleCameraData = {}
		objects.castleCameraData[deviceModel] = {}
		local ccd = objects.castleCameraData[deviceModel]
		ccd.sx = 1
		ccd.sy = 1
		ccd.px = screen.x
		ccd.py = screen.y
	end
	
	local ccd = objects.castleCameraData[deviceModel]
	ccd.top = screen.top
	ccd.left = screen.left
	ccd.right = screen.right
	ccd.bottom = screen.bottom
	cameraAnimationSlider = 1
	cameraAnimationSliderTarget = 1
	defaultCamera()
	
	local wx1, _ = worldToPhysicsTransform(ccd.left, ccd.top)
	local wx2, _ = worldToPhysicsTransform(ccd.right, ccd.bottom)
	setTheme(currentTheme)
	
	if objects.birdCameraData ~= nil then
	
		-- Check if leevl has camera data for current device
		if objects.birdCameraData[deviceModel] == nil then
			
			-- Check if file has camera data for iphone
			if objects.birdCameraData["iphone"] then
				objects.birdCameraData[deviceModel] = {}
				objects.birdCameraData[deviceModel].px = objects.birdCameraData["iphone"].px
				objects.birdCameraData[deviceModel].py = objects.birdCameraData["iphone"].py
				objects.birdCameraData[deviceModel].sx = objects.birdCameraData["iphone"].sx
				objects.birdCameraData[deviceModel].sy = objects.birdCameraData["iphone"].sy
				objects.birdCameraData[deviceModel].screenWidth = objects.birdCameraData["iphone"].screenWidth
				objects.birdCameraData[deviceModel].screenHeight = objects.birdCameraData["iphone"].screenHeight
			elseif objects.birdCameraData.px ~= nil then
				objects.birdCameraData[deviceModel] = {}
				objects.birdCameraData[deviceModel].px = objects.birdCameraData.px
				objects.birdCameraData[deviceModel].py = objects.birdCameraData.py
				objects.birdCameraData[deviceModel].sx = objects.birdCameraData.sx
				objects.birdCameraData[deviceModel].sy = objects.birdCameraData.sy
				objects.birdCameraData[deviceModel].screenWidth = objects.birdCameraData.screenWidth
				objects.birdCameraData[deviceModel].screenHeight = objects.birdCameraData.screenHeight
			else
				objects.birdCameraData[deviceModel] = {}
				objects.birdCameraData[deviceModel].px = screen.x
				objects.birdCameraData[deviceModel].py = screen.y
				objects.birdCameraData[deviceModel].sx = 1
				objects.birdCameraData[deviceModel].sy = 1
				objects.birdCameraData[deviceModel].screenWidth = screenWidth
				objects.birdCameraData[deviceModel].screenHeight = screenHeight
			end
		end
	
		local bcd = objects.birdCameraData[deviceModel]
		
		if bcd.screenWidth == nil then
			bcd.screenWidth = 1680
		end
		if bcd.screenHeight == nil then
			bcd.screenHeight = 1050
		end

		local cameraAspectRation = bcd.screenWidth / bcd.screenHeight
		local currentAspectRation = screenWidth / screenHeight
		
		if currentAspectRation >= cameraAspectRation then
			-- Current aspect ratio is wider than the one used to make the level, expand horizontally
			bcd.sx = bcd.sx * screenHeight / bcd.screenHeight
			bcd.sy = bcd.sy * screenHeight / bcd.screenHeight
		else
			-- Current aspect ratio is narrower than the one used to make the level, expand vertically
			bcd.sx = bcd.sx * screenWidth / bcd.screenWidth
			bcd.sy = bcd.sy * screenWidth / bcd.screenWidth
		end
		
		if objects.birdCameraData.version == nil then
			-- old version has the screen center position in wrong place
			scale = bcd.sx
			bcd.left = bcd.px - screenWidth * 0.5
			bcd.top = bcd.py - screenHeight * 0.5
			bcd.right = screen.left + screenWidth / scale
			bcd.bottom = screen.top + screenHeight / scale
			bcd.px = (screen.right + screen.left) * 0.5
			bcd.py = (screen.bottom + screen.top) * 0.5
			--print("BScreen: " .. screen.left .. ", " .. screen.top .. " - " .. screen.right .. ", " .. screen.bottom .. "\n")
			--print("BScreen: " .. screen.x .. ", " .. screen.y .. "\n")
		else
			bcd.left = bcd.px - screenWidth * 0.5 / bcd.sx
			bcd.top = bcd.py - screenHeight * 0.5 / bcd.sy
			bcd.right = screen.left + screenWidth / bcd.sx
			bcd.bottom = screen.top + screenHeight / bcd.sy
		end
	else
		-- bird camera not defined
		objects.birdCameraData = {}
		objects.birdCameraData[deviceModel] = {}
		local bcd = objects.birdCameraData[deviceModel]
		bcd.sx = 1
		bcd.sy = 1
		bcd.px = screen.x
		bcd.py = screen.y
		bcd.left = bcd.px - screenWidth * 0.5
		bcd.top = bcd.py - screenHeight * 0.5
		bcd.right = screen.left + screenWidth * 0.5
		bcd.bottom = screen.top + screenHeight * 0.5
	end

	local bcd = objects.birdCameraData[deviceModel]
	ccd.screenWidth = screenWidth
	ccd.screenHeight = screenHeight
	bcd.screenWidth = screenWidth
	bcd.screenHeight = screenHeight
		
	leftLimit = bcd.left - screenWidth * 0.20
	rightLimit = ccd.right + screenWidth * 0.20
	
	local leftLimitPhysics, rightLimitPhysics = worldToPhysicsTransform(leftLimit, rightLimit)
	if rightLimitPhysics > levelRightEdge then
		levelRightEdge = rightLimitPhysics
	end
	if leftLimitPhysics < levelLeftEdge then
		levelLeftEdge = leftLimitPhysics
	end
	-- set level left and right limit, other values do not affect at the moment
	levelLimitMinX = levelLeftEdge - screenWidth*0.75*physicsScale
	levelLimitMaxX = levelRightEdge + screenWidth*0.75*physicsScale
	setLevelLimits(levelLimitMinX, -10000, levelLimitMaxX, 20)
	
	-- calculate minimum scale. ie the player can't see the world smaller than this size
	maxLevelWidth = rightLimit - leftLimit
	minWorldScale = screenWidth / maxLevelWidth
	groundLimit = bcd.bottom
	if groundLimit < ccd.bottom then
		groundLimit = ccd.bottom
	end
	groundLimit = screenHeight / (minWorldScale * 5)
	if levelRestartedFrom == nil or startedFromEditor == true then 
		currentZoomedScale = bcd.sx
		if currentZoomedScale < ccd.sx then
			currentZoomedScale = ccd.sx
		end
	end
	
	startedFromEditor = false
	loadedObjects = nil
	loading = false
	loadingPageDrawn = false
	--print("level load complete\n")
	
	_G.collectgarbage("collect")
end

-- Creates object from definition (blocks.lua)
function createObject(definitions, objectDefinition, objName, xpos, ypos)
	local name = ""
	
	local blockDef = definitions.blocks[objectDefinition]
	local materialDef = definitions.materials[blockDef.material]

	-- get basic data from block definition
	local density = blockDef.density
	local friction = blockDef.friction
	local restitution = blockDef.restitution
	local controllable = blockDef.controllable
	local strength = blockDef.strength
	local defence = blockDef.defence
	local levelGoal = blockDef.levelGoal
	local collision = blockDef.collision
	local damageFactors = blockDef.damageFactors
	local useLegacyCollisionPath = blockDef.useLegacyCollisionPath
	local z_order = blockDef.z_order

	local pivotx, pivoty

	-- get rest of the information from material if it has not been overridden in the block definition
	if materialDef ~= nil then
		if density == nil then
			density = materialDef.density
			definitions.blocks[objectDefinition].density = density
		end
		if friction == nil then
			friction = materialDef.friction
			definitions.blocks[objectDefinition].friction = friction
		end
		if restitution == nil then
			restitution = materialDef.restitution
			definitions.blocks[objectDefinition].restitution = restitution
		end
		if controllable == nil then
			controllable = materialDef.controllable
			definitions.blocks[objectDefinition].controllable = controllable
		end
		if strength == nil then
			strength = materialDef.strength
			definitions.blocks[objectDefinition].strength = strength
		end
		if defence == nil then
			defence = materialDef.defence
			definitions.blocks[objectDefinition].defence = defence
		end
		if z_order == nil then
			z_order = materialDef.z_order
			definitions.blocks[objectDefinition].z_order = z_order
		end		
	end

	-- failsafe if z_order not defined
	if z_order == nil then
		z_order = 0
		definitions.blocks[objectDefinition].z_order = z_order
	end
	
	--set object names using cumulative counter
	if countsSaved == false or objName == nil then
		if objects.counts[objectDefinition] == nil then
			objects.counts[objectDefinition] = 0
		end
		objects.counts[objectDefinition] = objects.counts[objectDefinition] + 1
		name = objectDefinition .. "_" .. objects.counts[objectDefinition]
	else
		name = objName
	end

	local sprite = blockDef.sprite
	local w, h = 1, 1
	local sizeFactor = 0.92
	
	-- if sprite has not been set use the first damage sprite
	if sprite == nil then
		if blockDef.damageSprites ~= nil then
			sprite = blockDef.damageSprites.damage1.sprite
		end
	end
	
	-- set physics related settings
	if blockDef.type == "box" then
		-- use sprite if available if not use defined width and height
		if sprite ~= "" and sprite ~= nil then
			w, h = _G.res.getSpriteBounds("", sprite)
			-- immovable walls have always the sprites size to prevent gaps
			if blockDef.density == 0 then
				sizeFactor = 1
			end
			w = w * physicsScale * sizeFactor
			h = h * physicsScale * sizeFactor
			pivotx, pivoty = _G.res.getSpritePivot("", sprite)
		else
			w = blockDef.width
			h = blockDef.height
		end

		if collision == nil then
			collision = true
		end
		
		createBox(name, sprite, xpos, ypos, w, h, density, friction, restitution, collision, controllable, z_order)
		
		-- set damage factors for birds
		if controllable then
			objects.world[name].damageFactors = damageFactors
			objects.world[name].useLegacyCollisionPath = useLegacyCollisionPath
		end
	end

	-- set physics related settings
	if blockDef.type == "polygon" then
			--use sprite if available if not use defined width and height
		if sprite ~= "" and sprite ~= nil then
			w, h = _G.res.getSpriteBounds("", sprite)
			--immovable walls have always the sprites size to prevent gaps
			if blockDef.density == 0 then
				sizeFactor = 1
			end
			w = w * physicsScale * sizeFactor
			h = h * physicsScale * sizeFactor
			pivotx, pivoty = _G.res.getSpritePivot("", sprite)
		else
			w = blockDef.width
			h = blockDef.height
		end

		if collision == nil then
			collision = true
		end

		clearVertices()
		if blockDef.vertices ~= nil then
			for i = 1, #blockDef.vertices do
				local vert = blockDef.vertices[i]
				addVertex(vert.x * w - w * 0.5, vert.y * h - h * 0.5)
			end
		end
		
		createPolygon(name, sprite, xpos, ypos, w, h, density, friction, restitution, collision, controllable, z_order)
	
		-- set damage factors for birds
		if controllable then
			objects.world[name].damageFactors = damageFactors
			objects.world[name].useLegacyCollisionPath = useLegacyCollisionPath
		end
	end	
	
	if blockDef.type == "circle" then
		-- use sprite if available if not use defined width and height
		if blockDef.radius ~= nil then
			w = blockDef.radius
		else
			if sprite ~= "" and sprite ~= nil then
				w, h = _G.res.getSpriteBounds("", sprite)
				w = w * 0.5 * physicsScale * sizeFactor
			end
		end
		pivotx, pivoty = _G.res.getSpritePivot("", sprite)
		createCircle(name, sprite, xpos, ypos, w, density, friction, restitution, controllable, z_order)
		
		-- set damage factors for birds
		if controllable then
			objects.world[name].damageFactors = damageFactors
			objects.world[name].useLegacyCollisionPath = useLegacyCollisionPath
		end
	end

	-- set general settings
	objects.world[name].definition = objectDefinition
	objects.world[name].damageSprite = sprite	
	objects.world[name].controllable = controllable
	objects.world[name].strength = strength
	objects.world[name].defence = defence
	objects.world[name].material = blockDef.material
	objects.world[name].texture = blockDef.texture
	objects.world[name].levelGoal = levelGoal
	objects.world[name].spritePivotX = pivotx
	objects.world[name].spritePivotY = pivoty
	return name
end

-------------------------------------------------------------------------------
-- Editor stuff starts

function checkDirectories()
	if not checkDirectory(levelFolder) then
		createDirectory(levelFolder)
	end
	if not checkDirectory(levelFolder .. "temp/") then
		createDirectory(levelFolder .. "temp/")
	end		
end

-- updates current cursor object to match theme
function updateCursorObjectAccordingToTheme()
	for k, v in _G.pairs(blockTable.blocks) do
		-- check the group
		if v.group == currentGroup and v.groupIndex == currentGroupIndex then
			--print("Object candidate " .. k .. " group:" .. v.group .. " groupIndex:" .. v.groupIndex .. "\n")
			--if theme is defined check if it matches the current theme
			if v.theme == nil or v.theme == currentTheme then
				--print("Selected object to add " .. k .. "\n")
				objectToAdd = k
				selectedObjects = { }
			end
		end
	end
end

function getObjectListBounds(objects)
	local w, h, px, py
	local minx = 1000000 
	local maxx = -1000000
	local miny = 1000000 
	local maxy = -1000000

	for k, v in _G.pairs(objects) do
		local width = v.width
		local height = v.height
		if width == nil then
			width = v.radius
			height = v.radius
		else
			width = width * 0.5
			height = height * 0.5
		end
		
		if v.x - width < minx then
			minx = v.x - width
		end
		if v.x + width > maxx then
			maxx = v.x + width
		end

		if v.y - height < miny then
			miny = v.y - height
		end
		if v.y + height > maxy then
			maxy = v.y + height
		end
	end
	
	w = maxx - minx
	h = maxy - miny
	px = (maxx + minx) * 0.5
	py = (maxy + miny) * 0.5
	
	return px, py, w, h
end



function updateEditor(dt, time)
-- editor can be preprocessed out by defining "STRIP_EDITOR"
--#ifndef STRIP_EDITOR

	if oldZoomLevel ~= zoomLevel then
		worldScale = worldScale + zoomLevel - oldZoomLevel
		setWorldScale(worldScale)
		oldZoomLevel = zoomLevel
	end	

	updateScale()
	cursorPhysics.x, cursorPhysics.y = screenToPhysicsTransform(cursor.x, cursor.y)
	cursorWorld.x, cursorWorld.y = screenToWorldTransform(cursor.x, cursor.y)

	--print("cp.x_ " .. cursorPhysics.x .. " - cp.y: " .. cursorPhysics.y .. "\n")
	--print("cw.x_ " .. cursorWorld.x .. " - cw.y: " .. cursorWorld.y .. "\n")

	-- Handle input
	if keyPressed["ESCAPE"] or keyPressed["F1"] then
		setGameMode(updateMenu)
		setPhysicsEnabled(false)
		physicsEnabled = false
		setActiveMenuPage(levelSelectionEdit[currentThemeNumber])
	end

	if keyHold["CONTROL"] and keyPressed["S"] then
		checkDirectories()
		saveLevel(levelFolder .. levelName)
		saveLevel(levelFolder .. "temp/" .. levelName .. ".temp")
		levelSaved = true
	end

	if not keyHold["CONTROL"] and keyHold["SHIFT"] and keyPressed["C"] then
		if objects.castleCameraData == nil then
			objects.castleCameraData = {}
		end
		
		objects.castleCameraData.version = "0.02"
		objects.castleCameraData[deviceModel] = { px = screen.x,
												  py = screen.y,
												  sx = worldScale,
												  sy = worldScale,
												  screenWidth = screenWidth,
												  screenHeight = screenHeight }
		levelSaved = false
	end

	if not keyHold["CONTROL"] and keyHold["SHIFT"] and keyPressed["B"] then
		if objects.birdCameraData == nil then
			objects.birdCameraData = {}
		end
		
		objects.birdCameraData.version = "0.02"
		objects.birdCameraData[deviceModel] = { px = screen.x,
												py = screen.y,
												sx = worldScale,
												sy = worldScale,
												screenWidth = screenWidth,
												screenHeight = screenHeight }
		levelSaved = false
	end
	
	--debug camera
	
	if keyHold["CONTROL"] and keyHold["SHIFT"] and keyPressed["SPACE"] then 
		 
		if g_debugCameras == nil then
			g_debugCameras = true
		else 
			g_debugCameras = not g_debugCameras	
			g_cameraToDraw	= nil
		end								
		
	end
	
	if g_debugCameras and keyPressed["LBUTTON"] then								
		for i = 1, #g_camerasList, 1 do
			local t_initialX = 20
			local t_initialY = 150
			
			local t_offsetY = 50
			
			if checkTextBounds("TEXTS_BASIC", g_camerasList[i], "LEFT", "BOTTOM", t_initialX, t_initialY + (t_offsetY * (i-1)), cursor.x, cursor.y) then
				g_cameraToDraw = g_camerasList[i]
				break
			end
		end
	end

	if keyHold["SHIFT"] and keyPressed["P"] then
		setEditing(false)
		setPhysicsEnabled(false)
		local name = "temp/" .. levelName .. ".temp.playtest"
		checkDirectories()
		saveLevel(levelFolder .. name)
		loadLevelInternal(levelFolder .. name)
		startedFromEditor = true
		setGameMode(updateGame)
		levelSelectionPageNumber = currentThemeNumber
		currentThemeNumber = currentThemeIndex
	end

	if keyPressed["TAB"] then
		physicsEnabled = not physicsEnabled
		if physicsEnabled then
			checkDirectories()
			saveLevel(levelFolder .. "temp/" .. levelName .. ".temp")
		else
			loadLevelInternal(levelFolder .. "temp/" .. levelName .. ".temp")
		end
		setPhysicsEnabled(physicsEnabled)
	end

	if keyPressed["MBUTTON"] then
		if keyPressed["SHIFT"] then
			setWorldScale(1)
			worldScale = 1
		else
			setWorldScale(1)
			worldScale = 1
			screen.x = 0
			screen.y = 0
		end
	end

	-- set active theme
	if keyHold["SHIFT"] and keyPressed[blockTable.themes.settings.keyCode] then
		currentThemeIndex = currentThemeIndex + 1
		if currentThemeIndex > blockTable.themes.settings.themeAmount then
			currentThemeIndex = 1
		end

		for k0, v0 in _G.pairs(blockTable.themes) do
			if v0.index ~= nil and v0.index == currentThemeIndex then
				currentTheme = k0
				setTheme(currentTheme)
				-- replace all blocks that are theme dependent
				for k1, v1 in _G.pairs(objects.world) do
					v1def = blockTable.blocks[v1.definition]
					if v1def.theme ~= nil and v1def.theme ~= currentTheme then
						-- go through all block definitions to find the correct block to replace this one
						for k2, v2 in _G.pairs(blockTable.blocks) do
							-- if this block definition's group is the same as the one on the current block and the group indexes match then check the theme
							if v2.group == v1def.group and v2.groupIndex == v1def.groupIndex then
								-- does the theme match to the current theme requirements
								if v2.theme == nil or v2.theme == currentTheme then
									-- we found a replacement, update values accordingly
									v1.definition = k2
									v1.sprite = v2.sprite
									v1.damageSprite = v1.sprite
									setSprite(k1, v1.sprite)
									levelSaved = false
								end
							end
						end
					end
				end

				-- update the cursor object
				if objectToAdd ~= nil then
					updateCursorObjectAccordingToTheme()
				end
				-- replace level defines
				objects.theme = currentTheme

			end
		end
	end

	birdSelected = false
	if selectedObjects[1] ~= nil then
		if selectedObjects[1].controllable then
			birdSelected = true
			for i = 1, #numberKeys do
				if keyPressed[numberKeys[i]] then
					selectedObjects[1].startNumber = i
				end
			end
		end
	end


	-- create blocks from the blocks.lua definitions
	if keyHold["CONTROL"] == false and keyHold["SHIFT"] == false and birdSelected == false then
		for k, v in _G.pairs(blockTable.groups) do
			local groupDataUpdate = false
			if keyPressed[v.keyUp] then
				-- update group information
				if currentGroup == k then
					currentGroupIndex = currentGroupIndex + 1
				else
					currentGroup = k
				end
				groupDataUpdate = true
			end
			if keyPressed[v.keyDown] then
				-- update group information
				if currentGroup == k then
					currentGroupIndex = currentGroupIndex - 1
				else
					currentGroup = k
				end
				groupDataUpdate = true
			end
			-- find the next object to add based on group information
			if groupDataUpdate then
				if currentGroupIndex > blockTable.groups[currentGroup].lastIndex then
					currentGroupIndex = blockTable.groups[currentGroup].firstIndex
				end
				if currentGroupIndex < blockTable.groups[currentGroup].firstIndex then
					currentGroupIndex = blockTable.groups[currentGroup].lastIndex
				end

				--print("Searching for group " .. currentGroup .. " " .. currentGroupIndex .. "\n")
				updateCursorObjectAccordingToTheme()
			end
		end
	end

	if keyPressed["RBUTTON"] then
		if copiedObjects ~= nil then
			copiedObjects = nil
		end
		
		if objectToAdd ~= nil then
			objectToAdd = nil
		else
			if not keyHold["SHIFT"] and not keyHold["ALT"] then
				selectedObjects = { }
			end
			selectedObjectPos.x = 0
			selectedObjectPos.y = 0

			draggingStartPosWorld.x = cursorWorld.x
			draggingStartPosWorld.y = cursorWorld.y

			--find object that was clicked
			for k, v in _G.pairs(objects.world) do
				object = v
				if object.type == "polygon" then
					x = object.x
					y = object.y
					--print(object.name .. " ")
					if checkPolygonObjectBounds(x, y, object.width, object.height, object.angle, getObjectDefinition(k).vertices, cursorPhysics.x, cursorPhysics.y) then
						addObjectToSelection(object, true)
					end
				end
				if object.type == "box" then
					x = object.x
					y = object.y
					--print(object.name .. " ")
					if checkObjectBounds(x, y, object.width, object.height, object.angle, cursorPhysics.x, cursorPhysics.y) then
						addObjectToSelection(object, true)
					end
				end
				if object.type == "circle" then
					if distance(object.x, object.y, cursorPhysics.x, cursorPhysics.y) < object.radius then
						addObjectToSelection(object, true)
					end
				end
			end
		end
	end

	if keyHold["RBUTTON"] then
		selectionRectActive = true
	end

	-- this is here so that the dragging position is not set on this frame if LBUTTON is released
	if keyReleased["RBUTTON"] then
		if objectToAdd ~= nil and selectedObjects == nil or #selectedObjects < 1 then
			selectedObjects = getObjectsInsideRect(draggingStartPosWorld.x, draggingStartPosWorld.y, cursorWorld.x, cursorWorld.y)
		else
			if keyHold["SHIFT"] then
				local tempObjects = getObjectsInsideRect(draggingStartPosWorld.x, draggingStartPosWorld.y, cursorWorld.x, cursorWorld.y)
				for k, v in _G.pairs(tempObjects) do
					addObjectToSelection(object, false)
				end
			end
			if keyHold["ALT"] then
				local tempObjects = getObjectsInsideRect(draggingStartPosWorld.x, draggingStartPosWorld.y, cursorWorld.x, cursorWorld.y)
				for k, v in _G.pairs(tempObjects) do
					for soi = 1, #selectedObjects do
						if selectedObjects[soi] == v then
							_G.table.remove(selectedObjects, soi)
							soi = #selectedObjects
						end
					end
				end				
			end
		end
		selectionRectActive = false
	end

	if keyPressed["LBUTTON"] then
		oldCursor.x = cursor.x
		oldCursor.y = cursor.y
		if not keyHold["SPACE"] then
			if objectToAdd ~= nil then
				local name = createObject(blockTable, objectToAdd, nil, cursorPhysics.x, cursorPhysics.y)
				setRotation(name, objectToAddAngle)
				selectedObjects = {}
				_G.table.insert(selectedObjects, objects.world[name])
				levelSaved = false
			end
			if copiedObjects ~= nil then
				for k, v in _G.pairs(copiedObjects) do
					local name = createObject(blockTable, v.definition, nil, cursorPhysics.x + v.x, cursorPhysics.y + v.y)
					setRotation(name, v.angle)
				end
			end
		end
	end

	if keyHold["LBUTTON"] then
		if keyHold["SPACE"] then
			screen.x = screen.x - (cursorWorld.x - draggingStartPosWorld.x) * 0.5
			screen.y = screen.y - (cursorWorld.y - draggingStartPosWorld.y) * 0.5
		else
			if objectToAdd ~= nil then
				-- do not allow object selection if object to add is active
			elseif selectedObjects ~= nil and #selectedObjects > 0 then
				for k, v in _G.pairs(selectedObjects) do
					object = v
					x, y = worldToPhysicsTransform(cursor.x - oldCursor.x, cursor.y - oldCursor.y)
					x = x / worldScale
					y = y / worldScale
					setSleeping(object.name, false)
					if keyHold["CONTROL"] then
						setRotation(object.name, object.angle + (cursor.x - oldCursor.x)/180 * _G.math.pi )
					else
						setPosition(object.name, x + object.x, y + object.y)
					end
				end
				levelSaved = false
			end
		end
	end

	if not keyHold["LBUTTON"] and not keyHold["RBUTTON"] then
		draggingStartPosWorld.x = cursorWorld.x
		draggingStartPosWorld.y = cursorWorld.y
	end

	-- handle key input
	if selectedObjects ~= nil and #selectedObjects > 0 then
		local moveAmount = 1
		if keyHold["SHIFT"] then
			moveAmount = 10
		end	
		if keyHold["SHIFT"] and keyHold["CONTROL"] then
			moveAmount = 100
		end
		if not keyHold["SHIFT"] and keyHold["CONTROL"] then
			-- remove movement if only control pressed
			moveAmount = 0
		end
		
		if keyReleased["DELETE"] then
			for k, v in _G.pairs(selectedObjects) do
				local name = v.name
				objects.world[name] = nil
				removeObject(name)
			end
			selectedObjects = {}
			levelSaved = false
		end
		
		local moveKeyDown = false

		if keyHold["LEFT"] or keyHold["RIGHT"] or keyHold["UP"] or keyHold["DOWN"] then
			moveKeyDown = true
		end
		
		if blockMoveTimer == 0 or blockMoveTimer > 0.3 then
			if keyHold["LEFT"] then
				setPositions(-moveAmount, 0)
			end
			if keyHold["RIGHT"] then
				setPositions(moveAmount, 0)
			end
			if keyHold["UP"] then
				setPositions(0, -moveAmount)
			end
			if keyHold["DOWN"] then
				setPositions(0, moveAmount)
			end
		end
		
		if moveKeyDown then
			blockMoveTimer = blockMoveTimer + dt
		else
			blockMoveTimer = 0
		end
	end

	if keyHold["SHIFT"] then
		if keyPressed["R"] then
			if copiedObjects ~= nil then
				local px, py, w, h = getObjectListBounds(copiedObjects)
				for k, v in _G.pairs(copiedObjects) do
					local angle = _G.math.pi/4
					v.angle = v.angle + angle
					
					-- move to origin
					local cx = v.x - px
					local cy = v.y - py
					
					-- rotate around origin
					local tcx = cx * _G.math.cos(angle) - cy * _G.math.sin(angle)
					local tcy = cx * _G.math.sin(angle) + cy * _G.math.cos(angle)
	
					-- move back
					v.x = tcx + px
					v.y = tcy + py
					--print("Rotating copied object: " .. k .. "\n")
				end
			else
				if objectToAdd ~= nil then
					objectToAddAngle = objectToAddAngle + _G.math.pi/4
				else
					if selectedObjects ~= nil and #selectedObjects > 0 then
						for k, v in _G.pairs(selectedObjects) do
							setRotation(v.name, v.angle + _G.math.pi/4)
						end
						levelSaved = false
					end
				end
			end
		end
		
		if keyPressed["J"] then
			if #selectedObjects == 2 then
				createJoint(selectedObjects[1].name .. selectedObjects[2].name, selectedObjects[1].name, selectedObjects[2].name, 1, 2, 0, 0, 0, 0)
				levelSaved = false
			end
		end
	end
		
	if not keyHold["SHIFT"] and keyHold["CONTROL"] then		
		if keyPressed["LEFT"] or keyPressed["RIGHT"] then
			if selectedObjects ~= nil and #selectedObjects > 0 then
				local px, py, w, h = getObjectListBounds(selectedObjects)
								
				for k, v in _G.pairs(selectedObjects) do
					setPosition(v.name, px + (px - v.x), v.y)
				end
				levelSaved = false
			end			
		end
	
		if keyPressed["UP"] or keyPressed["DOWN"] then
			if selectedObjects ~= nil and #selectedObjects > 0 then
				local px, py, w, h = getObjectListBounds(selectedObjects)
								
				for k, v in _G.pairs(selectedObjects) do
					setPosition(v.name, v.x, py + (py - v.y))
				end
				levelSaved = false
			end
		end
	end
	
	if keyHold["SHIFT"] and keyHold["CONTROL"] and (keyPressed["B"] or keyPressed["HOME"]) then
		if objects.birdCameraData and objects.birdCameraData[deviceModel] ~= nil then
			screen.x = objects.birdCameraData[deviceModel].px
			screen.y = objects.birdCameraData[deviceModel].py
			worldScale = objects.birdCameraData[deviceModel].sx
			setWorldScale(worldScale)
			oldScale = worldScale
		end
	end
	
	if keyHold["SHIFT"] and keyHold["CONTROL"] and (keyPressed["C"] or keyPressed["END"]) then
		if objects.castleCameraData ~= nil and objects.castleCameraData[deviceModel]then
			screen.x = objects.castleCameraData[deviceModel].px
			screen.y = objects.castleCameraData[deviceModel].py
			worldScale = objects.castleCameraData[deviceModel].sx
			setWorldScale(worldScale)
			oldScale = worldScale
		end
	end
	
	if not keyHold["SHIFT"] and not keyHold["CONTROL"] and keyPressed["END"] then
		if objects.doNotWaitForMovingObjects ~= nil then
			objects.doNotWaitForMovingObjects = nil
		else
			objects.doNotWaitForMovingObjects = true
		end
	end
	
	if not keyHold["SHIFT"] and keyHold["CONTROL"] and keyPressed["C"] then
		copiedObjects = {}
		local x, y, w, h = getObjectListBounds(selectedObjects)
		for k, v in _G.pairs(selectedObjects) do
			--print("Adding to copied objects: " .. v.name .. "\n")
			copiedObjects[v.name] = { name = v.name, definition = v.definition, x = v.x - x, y = v.y - y, angle = v.angle }
			if v.width == nil then
				copiedObjects[v.name].width = v.radius
				copiedObjects[v.name].height = v.radius
			else
				copiedObjects[v.name].width = v.width
				copiedObjects[v.name].height = v.height
			end
		end
		selectedObjects = {}
	end
	
	defaultCamera(dt)

	oldCursor.x = cursor.x
	oldCursor.y = cursor.y	
	
	drawGame()
--#endif
end

function returnToEditor()
	setEditing(true)
	local name = "temp/" .. levelName .. ".temp.playtest"
	currentThemeNumber = levelSelectionPageNumber
	loadLevelInternal(levelFolder .. name)
	setGameMode(updateEditor)
	setPhysicsEnabled(false)
end

function goToMenu()
	pausePage.offsetX = -pauseBGw
	--we store the touchcount in the pausepage table because we need to compare the previous touch count.
	--In order to switch back to the game, the player must perform a 3 fingers tap, which is only allowed if
	--the player has released all fingers at least once. This will probably change when the pause menu changes
	--to support multitouch gestures
	pausePage.has3FingerBeenReleased = false
	setGameMode(showPauseMenu)
	setPhysicsEnabled(false)
end

function goToGesturePauseMenu()
	setActiveMenuPage(g_gesturePausePage, true)
	setGameMode(showGesturePauseMenu)
	setPhysicsEnabled(false)
end

function addObjectToSelection(object, removeDuplicate)
	local objectFound = false
	for soi = 1, #selectedObjects do
		if selectedObjects[soi] == object then
			if removeDuplicate then
				_G.table.remove(selectedObjects, soi)
			end
			objectFound = true
			soi = #selectedObjects
		end
	end
	if not objectFound then
		_G.table.insert(selectedObjects, object)
	end
end

function addToAchievementUnlockQueue(desc, inFront)
	
	if achievements ~= nil and achievements[desc] ~= nil then
		local id = achievements[desc]
		for i = 1, #achievementUnlockQueue do
			if achievementUnlockQueue[i].id == id then
				return
			end
		end
		inFront = inFront or false
		if inFront then
			_G.table.insert(achievementUnlockQueue, 1, {id = id, desc = desc} )
		else
			_G.table.insert(achievementUnlockQueue, {id = id, desc = desc} )
		end
	end
end

function checkForAchievements()

	local totalBlocks = 0
	if settings.woodBlocksDestroyed ~= nil then
		totalBlocks = totalBlocks + settings.woodBlocksDestroyed
	end
	if settings.iceBlocksDestroyed ~= nil then
		totalBlocks = totalBlocks + settings.iceBlocksDestroyed
	end
	if settings.rockBlocksDestroyed ~= nil then
		totalBlocks = totalBlocks + settings.rockBlocksDestroyed
	end

	if settings.theme1Completed == true then
		addToAchievementUnlockQueue("Herr Helmet")
	end
	
	if settings.wilhelmTell == true then
		addToAchievementUnlockQueue("Wilhelm Tell")
	end
	
	if settings.bullsEye == true then
		addToAchievementUnlockQueue("Bull's Eye")
	end
	
	if settings.theme2Completed == true then
		addToAchievementUnlockQueue("Mr Moustache")
	end
	
	if settings.gameCompleted == true then
		addToAchievementUnlockQueue("Defeat of The King")
	end
	
	if settings.theme4Completed == true then
		addToAchievementUnlockQueue("The Imposter")
	end
	
	if settings.theme5Completed == true then
		addToAchievementUnlockQueue("The Mysterious Escape")
	end
		
	if settings.theme6Completed == true then
		addToAchievementUnlockQueue("Hovering Helmet")
	end
	
	if settings.theme7Completed == true then
		addToAchievementUnlockQueue("Mounting Moustache")
	end
	
	if settings.theme8Completed == true then
		addToAchievementUnlockQueue("Green Baron") 
	end
	
	if settings.theme9Completed == true then
		addToAchievementUnlockQueue("Hardhat Hidalgo")  
	end
	
	if settings.theme10Completed == true then
		addToAchievementUnlockQueue("Mason Moustache")  
	end
	
	local episode1TotalScore, episode1Stars, episode1TotalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
	if episode1Stars >= episode1TotalStars then
		addToAchievementUnlockQueue("Episode 1 - Total Destruction")
	end
	if episode1TotalScore >= 4000000 then
		addToAchievementUnlockQueue("Episode 1 - Score Addict")
	end

	local episode2TotalScore, episode2Stars, episode2TotalStars = calculateTotalScoreAndStars(levelOrder_packOne)
	if episode2Stars >= episode2TotalStars then
		addToAchievementUnlockQueue("Episode 2 - Total Destruction")
	end
	if episode2TotalScore >= 3300000 then
		addToAchievementUnlockQueue("Episode 2 - Score Addict")
	end
	
	local episode3TotalScore, episode3Stars, episode3TotalStars = calculateTotalScoreAndStars(levelOrder_packThree)
	if episode3Stars >= episode3TotalStars then
		addToAchievementUnlockQueue("Episode 3 - Total Destruction")
	end
	if episode3TotalScore >= 4800000 then 
		addToAchievementUnlockQueue("Episode 3 - Score Addict")
	end
	
	local episode4TotalScore, episode4Stars, episode4TotalStars = calculateTotalScoreAndStars(levelOrder_packFour)
	if episode4Stars >= episode4TotalStars then
		addToAchievementUnlockQueue("Episode 4 - Total Destruction")
	end
	if episode4TotalScore >= 3900000 then 
		addToAchievementUnlockQueue("Episode 4 - Score Addict")
	end

	if settings.tutorials["BIRD_BLUE"] ~= nil then
		addToAchievementUnlockQueue("Split it!")
	end
	
	if settings.tutorials["BIRD_YELLOW"] ~= nil then
		addToAchievementUnlockQueue("Speed is the Essence")
	end
	
	if settings.tutorials["BIRD_GREY"] ~= nil then
		addToAchievementUnlockQueue("Boom Boom!")
	end
	
	if settings.tutorials["BIRD_GREEN"] ~= nil then
		addToAchievementUnlockQueue("Mother of all Bombs")
	end
	
	if settings.tutorials["BIRD_BOOMERANG"] ~= nil then
		addToAchievementUnlockQueue("Return to Sender")
	end
	
	if settings.tutorials["BIRD_BIG_BROTHER"] ~= nil then
		addToAchievementUnlockQueue("Seeing Red")
	end
	
	if settings.backwardsBirdCount ~= nil and settings.backwardsBirdCount >= 10 then
		addToAchievementUnlockQueue("Backward Compatibility", true)
	end
	
	if totalBlocks >= 50000 then
		addToAchievementUnlockQueue("Block Smasher", true)
	end
	
	if totalBlocks >= 500000 then
		addToAchievementUnlockQueue("Smash Maniac", true)
	end
	
	if settings.woodBlocksDestroyed ~= nil and settings.woodBlocksDestroyed >= 5000 then
		addToAchievementUnlockQueue("Woodpecker", true)
	end
	
	if settings.iceBlocksDestroyed ~= nil and settings.iceBlocksDestroyed >= 5000 then
		addToAchievementUnlockQueue("Icepicker", true)
	end
	
	if settings.rockBlocksDestroyed ~= nil and settings.rockBlocksDestroyed >= 5000 then
		addToAchievementUnlockQueue("Stonecutter", true)
	end
	
	if settings.pigsDestroyed ~= nil and settings.pigsDestroyed >= 1000 then
		addToAchievementUnlockQueue("Pig Popper", true)
	end
	
	if calculateOpenGoldenEggLevels() >= 10 then
		addToAchievementUnlockQueue("Egg Hunter")
	end
	
	if calculateStarsFromGoldenEggLevels() >= 10 then
		addToAchievementUnlockQueue("Egg Cracker")
	end
	
	if settings.gameCompleted == true then
		addToAchievementUnlockQueue("Ready For More")
	end
	
	if settings.threeStars == true then
		addToAchievementUnlockQueue("Total Destruction Lite")
	end
	
	if totalBlocks >= 500 then
		addToAchievementUnlockQueue("Block Smasher Lite", true)
	end
	
	if settings.woodBlocksDestroyed ~= nil and settings.woodBlocksDestroyed >= 100 then
		addToAchievementUnlockQueue("Woodpecker Lite", true)
	end
	
	if settings.iceBlocksDestroyed ~= nil and settings.iceBlocksDestroyed >= 100 then
		addToAchievementUnlockQueue("Icepicker Lite", true)
	end
	
	if settings.playtime ~= nil and (settings.playtime * 1) >= 18000 and (settings.playtime * 1) < 54000 then
		addToAchievementUnlockQueue("Angry Birds Fan", true)
	end
	
	if settings.playtime ~= nil and (settings.playtime * 1) >= 54000 and (settings.playtime * 1) < 108000 then
		addToAchievementUnlockQueue(" True Angry Birds Fan", true)
	end
	
	if settings.playtime ~= nil and (settings.playtime * 1) >= 108000 then
		addToAchievementUnlockQueue("Angry Birds Addicted", true)
	end
	
	if settings.cumulativeStars ~= nil and settings.cumulativeStars >= 750 and settings.cumulativeStars < 1500 then
		addToAchievementUnlockQueue("Star Collector", true)
	end
	
	if settings.cumulativeStars ~= nil and settings.cumulativeStars >= 1500 then
		addToAchievementUnlockQueue("Star Gatherer", true)
	end
	
	if settings.birdsShooted >= 5000 then
		addToAchievementUnlockQueue("Bird Slinger", true)
	end
end


function postTotalHighScores()
	if postHighscores == true then
		if not isLiteVersion then
			
			local totalScore, gainedStars, maxStars = calculateTotalScoreAndStars(levelOrder_allLevels)
			if totalScore > 0 then
				postLevelHighScore("totalScore", totalScore)
			end
			
			for i = 1, 11 do
				local totalScoreWorld, gainedStars, maxStars = calculateTotalScoreAndStars({levelOrder["pack" .. i]})
				if totalScoreWorld > 0 then
					postLevelHighScore("totalScoreWorld" .. i, totalScoreWorld)
				end
			end
			
			
			local totalScoreEpisode1, gainedStars, maxStars = calculateTotalScoreAndStars(levelOrder_packBasic)
			if totalScoreEpisode1 > 0 then
				postLevelHighScore("totalScoreEpisode1", totalScoreEpisode1)
			end
		
			local totalScoreEpisode2, gainedStars, maxStars = calculateTotalScoreAndStars(levelOrder_packOne)
			if totalScoreEpisode2 > 0 then
				postLevelHighScore("totalScoreEpisode2", totalScoreEpisode2)
			end
			
			local totalScoreEpisode3, gainedStars, maxStars = calculateTotalScoreAndStars(levelOrder_packThree)
			if totalScoreEpisode3 > 0 then
				postLevelHighScore("totalScoreEpisode3", totalScoreEpisode3)
			end
			
			local totalScoreEpisode4, gainedStars, maxStars = calculateTotalScoreAndStars(levelOrder_packFour)
			if totalScoreEpisode4 > 0 then
				postLevelHighScore("totalScoreEpisode4", totalScoreEpisode4)
			end
			

		else
			local liteTotalScore, gainedStars, maxStars = calculateTotalScoreAndStars(levelOrder_packBasic)
			if liteTotalScore > 0 then
				postLevelHighScore("liteTotalScore", liteTotalScore);
			end
		end
	end
end

function postLevelHighScore(levelName, score)
	if postHighscores == true then
		if leaderboards ~= nil then
			leaderboardid = leaderboards[levelName]
			if leaderboardid ~= nil then
				print("Posting highscore for level " .. levelName .. " (score = " .. score ..  " leaderboard = " .. leaderboardid .. ")\n")
				postHighscore(leaderboardid, score)
			else
				print("Leaderboard id for level " .. levelName .. " not found!\n")
			end
		end
	end
end



function ingameHideOrShowHUDButtons(show)

	local t_ingamePause = getItemByName(g_ingamePausePage.items, "ingameButtonPause")
	local t_ingameRestart = getItemByName(g_ingamePausePage.items, "ingameButtonRestart")
	
	t_ingamePause.visible = (show == true)
	t_ingameRestart.visible = (show == true)
	
end

function cancelBirdDrag()
	if selectedBird ~= nil then
		
		setPosition(selectedBird.name, levelStartPosition.x, levelStartPosition.y)
		--setPosition(selectedBird.name, 0,0)
		g_birdDragOnTouchAttributes.dragging = false
		selectedBird = nil
		g_currentCursorName = "CURSOR_HAND_POINT"
		
		rubberBandPos.x = levelStartPosition.x
		rubberBandPos.y = levelStartPosition.y
		rubberBandSpeed = 0
		
		rubberBandLength = 0
		
		--captureMouse(false)
		
	end
end

function calculateRubberPosition(diffX, diffY, currentRubberX, currentRubberY)

	local t_targetX = currentRubberX + diffX
	local t_targetY = currentRubberY + diffY
	
	local t_distToRest = distance(t_targetX, t_targetY, levelStartPosition.x, levelStartPosition.y)
	--local t_vecToRest = { x = g_birdDragOnTouchAttributes.dragStartPosPhysics.x - t_cursorPhysics.x, y = g_birdDragOnTouchAttributes.dragStartPosPhysics.y - t_cursorPhysics.y }
	local t_vecToRest = { x = levelStartPosition.x - t_targetX, y = levelStartPosition.y - t_targetY }
	
	local shootMaxLength = rubberBandMaximumLength()
	if t_distToRest < shootMaxLength then
		
		return {x=t_targetX,y=t_targetY,distance = t_distToRest}
	else	

		local t_ratio = shootMaxLength / t_distToRest
		return {x=levelStartPosition.x - (t_vecToRest.x * t_ratio),y=levelStartPosition.y - (t_vecToRest.y * t_ratio), distance=shootMaxLength}
		
	end

end

--[[
function forceInputStateToMouse()
	g_mouseOrTouchStates.isUsingMouse = true
	ingameHideOrShowHUDButtons(true)
	g_mouseOrTouchStates.releaseTouchTime = -1		
end
]]

--[[
function forceInputStateToTrackpad()
	g_mouseOrTouchStates.isUsingMouse = false
	ingameHideOrShowHUDButtons(false)
	g_mouseOrTouchStates.releaseTouchTime = -1		
end
]]
function updateMultipleInputSystemStates(dt)
	
	settings.fullScreen = isInFullScreenMode()
	
	--this will always be true on windows, so we use it to bypass the mutitouch altogether
	if g_mouseOrTouchStates.doesMouseClickSetsCount == true then
		if g_mouseOrTouchStates.isUsingMouse~= true then
			captureMouse(false)
		end
		g_mouseOrTouchStates.isUsingMouse = true
		ingameHideOrShowHUDButtons(true)
		return
	end
	
				
	
	if settings.fullScreen == true and deviceModel ~= "roku" then
		--print("\n fullscreen")
		if g_gesturePausePageEnablingFlags.enablePage == true then
			if (g_mouseOrTouchStates.isUsingMouse == true) then
				if isMouseCaptured() == true then
					captureMouse(false)
				end
			else
				if (currentGameMode ~= updateGame) and currentMenuPage ~= g_gesturePausePage then
					captureMouse(false)
				elseif birdTutorialPopups ~= nil and #birdTutorialPopups > 0 then
					captureMouse(false)
				else
					captureMouse(true)
				end
			end
		else
			if (currentGameMode ~= updateGame) or (g_mouseOrTouchStates.isUsingMouse == true) then 		
				if isMouseCaptured() == true then
					captureMouse(false)
				end
			end
		end
	elseif not settings.fullScreen then
		--print("\n windowed")
		if g_mouseOrTouchStates.isUsingMouse~= true then
			captureMouse(false)
		end
		g_mouseOrTouchStates.isUsingMouse = true
		ingameHideOrShowHUDButtons(true)
		return
	end
	
	if g_mouseOrTouchStates.lastCursorPosition.x == nil and g_mouseOrTouchStates.lastCursorPosition.y == nil then
		g_mouseOrTouchStates.isUsingMouse = false
		g_mouseOrTouchStates.lastCursorPosition.x = cursor.x
		g_mouseOrTouchStates.lastCursorPosition.y = cursor.y
	else
		if g_mouseOrTouchStates.isUsingMouse then
			g_mouseOrTouchStates.isUsingMouse = touchcount == 0 or deviceModel == "roku"
			ingameHideOrShowHUDButtons(g_mouseOrTouchStates.isUsingMouse)
			g_mouseOrTouchStates.releaseTouchTime = -1
		else
			
			--if touchcount == 0 and ( (cursor.x ~= g_mouseOrTouchStates.lastCursorPosition.x) or (cursor.y ~= g_mouseOrTouchStates.lastCursorPosition.y) ) then
			if touchcount == 0  then
				--mouse coordinates have changed due to a mouse movement
				
				if g_mouseOrTouchStates.releaseTouchTime > -1 then
					
					g_mouseOrTouchStates.releaseTouchTime = g_mouseOrTouchStates.releaseTouchTime + dt
					
					if g_mouseOrTouchStates.releaseTouchTime > 0.2 and ((cursor.x ~= g_mouseOrTouchStates.lastCursorPosition.x) or (cursor.y ~= g_mouseOrTouchStates.lastCursorPosition.y)) then
						g_mouseOrTouchStates.isUsingMouse = true		
						ingameHideOrShowHUDButtons(true)
						g_mouseOrTouchStates.releaseTouchTime = -1
					else
					
					end
					
				else
					g_mouseOrTouchStates.releaseTouchTime = 0
				end
				
				
			else
				g_mouseOrTouchStates.isUsingMouse = false
				ingameHideOrShowHUDButtons(false)
				g_mouseOrTouchStates.releaseTouchTime = -1
			end
		end
		
		--on windows, there is a framework issue that a mouse press sets the touchcount to 1, this check avoids trackpad/mouse conflicts
		if keyHold["LBUTTON"] and g_mouseOrTouchStates.doesMouseClickSetsCount == true then
			g_mouseOrTouchStates.isUsingMouse = true
			ingameHideOrShowHUDButtons(true)
		end
		
		
		if touchcount > 1 then
			cancelBirdDrag()
		end
		
		
		
		 
		g_mouseOrTouchStates.lastCursorPosition.x = cursor.x
		g_mouseOrTouchStates.lastCursorPosition.y = cursor.y
	end
end

function isAnyKeyPressed()
	for k,v in _G.pairs(keyPressed) do
		if v == true then
			return true
		end
	end
	
	return false
end


-------------------------------------------------------------------------------
-- GAME
--
currentFrame = 0
function updateGame(dt, time)

	if deviceModel == "roku" and not rokuOnWindows then
		-- motion sensor capture safe-guards
		if not selectedBird and isMouseCaptured() then
			captureMouse(false)
		elseif selectedBird and not isMouseCaptured() then
			captureMouse(true)
		end
	elseif rokuOnWindows then
		cursor.dx = cursor.x - oldCursor.x
		cursor.dy = cursor.y - oldCursor.y
	end

	--this fixes issue 599
	local t_isInFullScreen = isInFullScreenMode()
	
	if t_isInFullScreen ~= g_mouseOrTouchStates.fullScreen then
		cancelBirdDrag()
		prepareMenuPage(g_ingamePausePage)
	end
	
	g_mouseOrTouchStates.fullScreen = t_isInFullScreen
--[[
	if keyHold["L"] then
		touchcount = 1
		touches ={{},{}}
		touches[1].x = cursor.x
		touches[1].y = cursor.y
	else
		touchcount = 0
	end
]]
	
	
	--[[ BEGIN FPS DEBUG CODE -- 
	
	if drawFPSStatistics or FPSFrames > 1 then
	
		if not drawFPSStatistics then
			drawFPSStatistics = true
			FPSFrames = 0
			FPSTime = 0
			FPSMin = 1000000
			FPSMax = 0
		end
		
		local FPS = 1/dt
		if FPS < FPSMin then
			FPSMin = FPS
		end
		if FPS > FPSMax then
			FPSMax = FPS
		end
	end
	FPSFrames = FPSFrames + 1
	FPSTime = FPSTime + dt

	
	-- END FPS DEBUG CODE --]]
	
	--updateMultipleInputSystemStates(dt)
	
	if keyPressed["Z"] and (not releaseBuild) then
		g_birdDragOnTouchAttributes.enabled = not g_birdDragOnTouchAttributes.enabled 
	end
	
	if oldScreenWidth ~= screenWidth or oldScreenHeight ~= screenHeight then
		local t_minimumScreenWidth = 1024
		--local t_minimumScreenHeight = 768
		--local t_minimumScreenHeight = 720
		local t_minimumScreenHeight = 600
		
		if deviceModel ~= "roku" and (screenWidth < t_minimumScreenWidth or screenHeight < t_minimumScreenHeight) then
			invalidResolutionPage.fromMainMenu = false
			showIngameResolutionChangedPopUp()
		end
		
		prepareMenuPage(g_ingamePausePage)
		
	end
	
	
	--this piece is for dragging the camera, the previous implementation was storing the last 5 mouse coordinates
	--and calculating the drag speed from these values. It wouldnt work if the user has the vsync clipping disabled
	--so I added these lines to increase the drag distance whenever the user is dragging, regardless of how many cycles
	--has passed
	if deviceModel ~= "roku" then
		if keyHold["LBUTTON"] then
		
			g_mouseDragAttributes.dragFromMouse = true
			g_mouseDragAttributes.dragFromTouch = false
			--when dragging the camera, we also change the cursor
			if #birdTutorialPopups == 0 then -- do not show grab icon when showing tutorials
				g_currentCursorName = "CURSOR_HAND_GRAB"
			end
			
			--first touch
			if g_mouseDragAttributes.lastPressedX < 0 then
				g_mouseDragStartX = cursor.x
				g_mouseDragAttributes.mouseDragTime = 0
				g_mouseDragAttributes.cummulativeDragX = 0
				g_mouseDragAttributes.lastPressedX = cursor.x
			else
			--has some previousTouch
				
				--still in the drag time limit
				if g_mouseDragAttributes.mouseDragTime < g_mouseDragAttributes.targetDragTime then
					g_mouseDragAttributes.cummulativeDragX = g_mouseDragAttributes.cummulativeDragX + (cursor.x - g_mouseDragAttributes.lastPressedX)
					g_mouseDragAttributes.mouseDragTime = g_mouseDragAttributes.mouseDragTime + dt
					g_mouseDragAttributes.lastPressedX = cursor.x
				else
				--the drag time has passed the limit, start counting again as if it was starting from zero
					g_mouseDragAttributes.mouseDragTime = g_mouseDragAttributes.mouseDragTime % g_mouseDragAttributes.targetDragTime
					g_mouseDragAttributes.cummulativeDragX = (cursor.x - g_mouseDragAttributes.lastPressedX)
					g_mouseDragAttributes.lastPressedX = cursor.x
				end
			
			end
		
		elseif keyReleased["LBUTTON"] then
			g_mouseDragAttributes.lastPressedX = -1
			g_mouseDragAttributes.dragFromMouse = false
			
			
		end
		
		if (touchcount == 1) and (g_mouseOrTouchStates.doesMouseClickSetsCount == false) and (cameraAnimationSlider > 0.9) and (sweepSpeed == 0) then	
			
			g_mouseDragAttributes.dragFromTouch = true
			g_mouseDragAttributes.dragFromMouse = false
			
			local t_touch = {}
			for k,v in _G.pairs(touches) do
				t_touch.x = v.x
				t_touch.y = v.y
				break
			end
			
			--first touch
			if g_mouseDragAttributes.lastPressedX < 0 then
				g_mouseDragStartX = t_touch.x
				g_mouseDragAttributes.mouseDragTime = 0
				g_mouseDragAttributes.cummulativeDragX = 0
				g_mouseDragAttributes.lastPressedX = t_touch.x
			else
			--has some previousTouch
				
				--still in the drag time limit
				if g_mouseDragAttributes.mouseDragTime < g_mouseDragAttributes.targetDragTime then
					g_mouseDragAttributes.cummulativeDragX = g_mouseDragAttributes.cummulativeDragX + (t_touch.x - g_mouseDragAttributes.lastPressedX)
					g_mouseDragAttributes.mouseDragTime = g_mouseDragAttributes.mouseDragTime + dt
					g_mouseDragAttributes.lastPressedX = t_touch.x
				else
				--the drag time has passed the limit, start counting again as if it was starting from zero
					g_mouseDragAttributes.mouseDragTime = g_mouseDragAttributes.mouseDragTime % g_mouseDragAttributes.targetDragTime
					g_mouseDragAttributes.cummulativeDragX = (t_touch.x - g_mouseDragAttributes.lastPressedX)
					g_mouseDragAttributes.lastPressedX = t_touch.x
				end
			
			end
			
			if not levelCompleted then
				dragStarted = true
			end
		
		elseif touchcount == 0 and g_mouseDragAttributes.dragFromTouch == true then
			g_mouseDragAttributes.dragFromTouch = false
			g_mouseDragAttributes.lastPressedX = -1
			dragStarted = false
		end
	end
	
	local t_hudButtonsLowestTargetScale = 0.6
	local t_hudButtonsLowestTargetWidth = 1024
	local t_hudButtonsHighestTargetWidth = 1920
	local t_hudButtonsTargetScale = (screenWidth - t_hudButtonsLowestTargetWidth) / (t_hudButtonsHighestTargetWidth - t_hudButtonsLowestTargetWidth)
	t_hudButtonsTargetScale = _G.math.max(t_hudButtonsTargetScale, 0)
	t_hudButtonsTargetScale = _G.math.min(t_hudButtonsTargetScale, 1)
	
	local t_hudButtonsScale = t_hudButtonsLowestTargetScale + (1 - t_hudButtonsLowestTargetScale) * t_hudButtonsTargetScale
	
	local t_ingameRestart = getItemByName(g_ingamePausePage.items, "ingameButtonRestart")
	local t_ingamePause = getItemByName(g_ingamePausePage.items, "ingameButtonPause")

	if g_enableMouseOverStates then
		if deviceModel == "roku" then
			if birdTutorialPopups == nil or birdTutorialPopups and #birdTutorialPopups == 0 then
				simulateMouseOverState(t_ingameRestart, keyHold["F5"])
				simulateMouseOverState(t_ingamePause, keyHold["PAUSE"])
				updateItemMouseOverStateIgnoringMouseInput(t_ingameRestart, dt)
				updateItemMouseOverStateIgnoringMouseInput(t_ingamePause, dt)
			end
		else
			updateItemMouseOverState(t_ingameRestart, dt)
			updateItemMouseOverState(t_ingamePause, dt)
		end
	end
	
	-- NOTE: these are only used for the press checks, button hover scaling is done elsewhere
	local t_restartHovered = checkSpriteBoundsWithScaling(t_ingameRestart.sheet, t_ingameRestart.sprite, t_ingameRestart.x,t_ingameRestart.y, t_ingameRestart.xs, t_ingameRestart.ys, cursor.x, cursor.y)
	local t_pauseHovered   = checkSpriteBoundsWithScaling(t_ingamePause.sheet, t_ingamePause.sprite, t_ingamePause.x,t_ingamePause.y, t_ingamePause.xs, t_ingamePause.ys, cursor.x, cursor.y)
	
	local t_restartPressed, t_pausePressed
	if deviceModel == "roku" and currentGameMode == updateGame then
		if birdTutorialPopups == nil or birdTutorialPopups and #birdTutorialPopups == 0 then
			t_restartPressed = keyReleased["F5"]
			t_pausePressed   = keyReleased["PAUSE"]
		end
	else
		t_restartPressed = keyPressed["LBUTTON"] and t_restartHovered
		t_pausePressed   = keyPressed["LBUTTON"] and t_pauseHovered

		if t_restartHovered or t_pauseHovered or birdSpecialtyAvailable then
			g_currentCursorName = "CURSOR_HAND_POINT"
		end
	end

	if t_restartPressed then
		levelRestartedFrom = "keyboard command"
		loading = true
		setGameMode(updateLoading)
		drawGame()
		return
	end
	if t_pausePressed then
		if startedFromEditor then
			returnToEditor()
		else
			goToMenu()
			drawGame()
		end
		return
	end

	if resolutionChanged == true then
		resetCameras()
		if popupPage ~= nil then
			if popupPage == achievementPopUpPage then
				prepareMenuPage(achievementPopUpPage)
			end
		end
		resolutionChanged = nil
	end
	
	if cursor.wheelTriggered and cameraFunction == levelStartCamera then
		allowResetToBirdCamera = true
		cameraTargetObject = nil
		cameraFunction = doItAllCamera
	end
	
	cameraShakeX, cameraShakeY = 0, 0
	if cameraShake ~= nil and cameraShake ~= 0 then
		cameraShakeX = _G.math.floor(_G.math.random(-_G.math.abs(cameraShake), _G.math.abs(cameraShake)))
		cameraShakeY = _G.math.floor(_G.math.random(-_G.math.abs(cameraShake), _G.math.abs(cameraShake)))
	end
	
	if popupPage ~= nil then
		if popupPage == achievementPopUpPage then
			local page = achievementPopUpPage
			if page.animationState == "MOVEUP" then
				page.animationTimer = page.animationTimer - dt
				local bgBox = getItemByName(page.items, "achievementBox")
				bgBox.y = bgBox.y - 190 * dt
				if page.animationTimer < 0 then
					page.animationState = "HOLD"
					page.animationTimer = 2
				end
			elseif page.animationState == "HOLD" then
				page.animationTimer = page.animationTimer - dt
				if page.animationTimer < 0 then
					page.animationState = "MOVEDOWN"
					page.animationTimer = 0.4
				end
			elseif page.animationState == "MOVEDOWN" then
				page.animationTimer = page.animationTimer - dt
				local bgBox = getItemByName(page.items, "achievementBox")
				bgBox.y = bgBox.y + 190 * dt
				if page.animationTimer < 0 then
					popupPage = nil
				end
			end
		else
			updateMenuPage(popupPage, dt)
			drawGame()
			return
		end
	end
	
	if cutScenesReleased ~= true and ((currentLevelNumberInTheme == 1 and currentWorldNumber == 1) or
		(currentLevelNumberInTheme == 1 and currentWorldNumber == 4) or
		(currentLevelNumberInTheme == 1 and currentWorldNumber == 7) or
		(currentLevelNumberInTheme == 1 and currentWorldNumber == 9)) then

		releaseCutScenes()
		cutScenesReleased = true
	end
	
	if currentMenuPage ~= pausePage  then
		setActiveMenuPage(pausePage)
	end
	
	currentFrame = currentFrame + 1
	--updateScale()
	updateAnimations(dt)
	
	-- update cursors
	oldCursorWorld.x = cursorWorld.x
	oldCursorWorld.y = cursorWorld.y
	cursorPhysics.x, cursorPhysics.y = screenToPhysicsTransform(cursor.x, cursor.y)
	cursorWorld.x, cursorWorld.y = screenToWorldTransform(cursor.x, cursor.y)
	
	rightSweep = false
	leftSweep = false
	
	-- update game timers
	quadClickTimer = quadClickTimer - dt
	rokuClickTimer = rokuClickTimer - dt
	
	-- Handle input
	if keyPressed["ESCAPE"] then
		_G.res.stopAudio(musics[currentThemeNumber])
		--setPhysicsEnabled(false)
		if startedFromEditor then
			returnToEditor()
		else
			--g_mouseOrTouchStates.isUsingMouse = true
			--forceInputStateToMouse()
			--captureMouse(false)
			goToMenu()
			drawGame()
		end
		return
	end
	
	
	
	--left and right directional button should move camera only if the mouse is not already on the screen boundaries for camera panning
	if startedFromEditor ~= true then

		if deviceModel ~= "roku" and (keyPressed["F5"] or keyPressed["R"]) then
			levelRestartedFrom = "keyboard command"
			loading = true
			setGameMode(updateLoading)
		end
		
		local t_cursorAtLeftEdge  = (cursor.x >= (1 - g_cameraPanAreaRatio) * screenWidth)
		local t_cursorAtRightEdge = (cursor.x <= (g_cameraPanAreaRatio) * screenWidth)

		-- camera panning when the user is near the screen boundaries...
		if deviceModel ~= "roku" then
			if t_cursorAtLeftEdge and g_mouseOrTouchStates.isUsingMouse then
				panToCastleCamera()
			elseif t_cursorAtRightEdge and g_mouseOrTouchStates.isUsingMouse then
				panToBirdCamera()
			end
		end

		if  (deviceModel == "roku" and not selectedBird) or
			(deviceModel ~= "roku" and not t_cursorAtLeftEdge and not t_cursorAtRightEdge) then
			if keyPressed["LEFT"] then
				panToBirdCamera()
			elseif keyPressed["RIGHT"] then
				panToCastleCamera()
			end
		end

	else
		--local t_restartPressed = keyPressed["LBUTTON"] and checkSpriteBounds("", "BUTTON_RESTART", g_restartButtonPos.x, g_restartButtonPos.y, cursor.x, cursor.y)
		local t_ingameRestart = getItemByName(g_ingamePausePage.items, "ingameButtonRestart")
		
		local t_restartPressed = keyPressed["LBUTTON"] and checkSpriteBoundsWithScaling(t_ingameRestart.sheet, t_ingameRestart.sprite, t_ingameRestart.x,t_ingameRestart.y, t_ingameRestart.xs, t_ingameRestart.ys, cursor.x, cursor.y)
		
		if keyPressed["F5"] or keyPressed["R"] or t_restartPressed then
			levelRestartedFrom = "keyboard command"
			setEditing(false)
			setPhysicsEnabled(false)
			local name = "temp/" .. levelName .. ".temp.playtest"
			checkDirectories()
			loadLevelInternal(levelFolder .. name)
			startedFromEditor = true
			setGameMode(updateGame)
			if startedFromEditor ~= true then
				levelSelectionPageNumber = currentThemeNumber
			end
			currentThemeNumber = currentThemeIndex
		end 
	end
	
	if releaseBuild ~= true then
		if keyPressed["LEFT"] and keyHold["SHIFT"] then
			levelRestartedFrom = "keyboard command"
			setGameMode(loadPreviousLevel)
		elseif keyPressed["RIGHT"] and keyHold["SHIFT"] then
			levelRestartedFrom = "keyboard command"
			setGameMode(loadNextLevel)
		end
	end
	
	if levelStartTimer == 0 then
		levelStartTimer = levelStartTimer + 0.01
		_G.res.playAudio(getAudioName("level_start_military"), 1, false)
		_G.res.stopAudio("title_theme")
		currentBirdIndex = 0
		fillInNextBird = true
	end
	
	local currentMusic = musics[currentThemeNumber]
	if _G.res.isAudioPlaying(currentMusic) == false then
		_G.res.playAudio(currentMusic, 1, true,7)
	end
	
	if #birdTutorialPopups > 0 then
		
		if settings.tutorials["BAIT_SARDINE"] ~= nil and birdTutorialPopups[1] == settings.tutorials["BAIT_SARDINE"].sprite then
			_G.table.remove(birdTutorialPopups, 1)
			if #birdTutorialPopups == 0 then
				setPhysicsEnabled(true)
				if deviceModel == "iphone4" then
					changeResolution = true
					wantedResolution = "FULL"
				end
			end
		else
			if deviceModel == "iphone4" and wantedResolution == "FULL" then
				changeResolution = true
				wantedResolution = "HALF"
				return
			end
			if oldScreenWidth ~= screenWidth or oldScreenHeight ~= screenHeight then
				oldScreenWidth = screenWidth
				oldScreenHeight = screenHeight
				prepareMenuPage(tutorials)
				
				--closes the main menu popuppages
				
				
				
			end
			
			setPhysicsEnabled(false)
			
			local t_okButton = getItemByName(tutorials.items, "okButton")
			if t_okButton.mouseState ~= nil then
				updateItemMouseOverState(t_okButton, dt)
			end
			
			--local t_tutorialOkHovered = checkSpriteBounds("", "TUTORIAL_OK", tutorials.okButtonX, tutorials.okButtonY, cursor.x, cursor.y)
			local t_tutorialOkHovered = checkSpriteBounds("", "TUTORIAL_OK", t_okButton.x, t_okButton.y, cursor.x, cursor.y)
			if deviceModel == "roku" then
				t_tutorialOkHovered = checkSpriteBounds("", "ROKU_TUTORIAL_OK", t_okButton.x, t_okButton.y, cursor.x, cursor.y)
			end

			if isLiteVersion == false and showTutorialGoldenEgg == true and birdTutorialPopups[1] == settings.tutorials["BIRD_GREEN"].sprite then
				if 	deviceModel ~= "roku" and keyPressed["LBUTTON"]  and
					cursor.x >= tutorialGoldenEggPosition.hitBoxMinX and cursor.x < tutorialGoldenEggPosition.hitBoxMaxX  and
					cursor.y >= tutorialGoldenEggPosition.hitBoxMinY and cursor.y < tutorialGoldenEggPosition.hitBoxMaxY  then
					g_releaseGEOnPopupExit = true
					goldenEggAchieved("Level1")
				elseif deviceModel == "roku" and keyPressed["KEY_GAMING_B"] then
					g_releaseGEOnPopupExit = true
					goldenEggAchieved("Level1")
				end
			end

			if keyReleased["LBUTTON"] then
				
				if t_tutorialOkHovered or deviceModel == "roku" then
					_G.table.remove(birdTutorialPopups, 1)
					if #birdTutorialPopups == 0 then
						if deviceModel == "iphone4" then
							changeResolution = true
							wantedResolution = "FULL"
						end
						
						-- make sure that watched tutorials are remembered
						saveLuaFileWrapper("settings.lua", "settings", true)
						setPhysicsEnabled(true)
					else
					--	prepareMenuPage(tutorials)
					end
				end
				
			end
			oldCursor.x = cursor.x
			oldCursor.y = cursor.y
			
			-- Draw game
			drawGame()
			
			-- this isn't probably needed anymore because hidePausePage isn't in updateGame but updateMenu when pause page is closed
			--[[if currentMenuPage == pausePage and elementAnimations["ingamePausePageScroll"].state ~= "HIDDEN" then
				pausePage.offsetX = elementAnimations["ingamePausePageScroll"].percentage / 100 * pauseBGw - pauseBGw
				pausePage.backgroundOverlay.shade = elementAnimations["ingamePausePageScroll"].percentage / 100 * 0.65
				drawMenuPage(pausePage)
			end--]]
			pausePage.backgroundOverlay.shade = 0
			return
		end
	end
	
	if currentWorldNumber == 1 and currentLevelNumberInTheme == 8 and (settings.openGoldenEggLevels["Level6"] == nil) and cameraAnimationSlider > 0.9 then
		treasureChest = objects.world["ExtraTreasureChest_1"]
		if treasureChest ~= nil  then
			if isAnyKeyPressed() then
				if keyPressed[g_treasureChestAttributes.keys[g_treasureChestAttributes.correctKeysCount+1]] then
					
					g_treasureChestAttributes.correctKeysCount = g_treasureChestAttributes.correctKeysCount + 1	

					if g_treasureChestAttributes.correctKeysCount == #g_treasureChestAttributes.keys then
						g_releaseGEOnPopupExit = true
						goldenEggAchieved("Level6")
					end
				else
					g_treasureChestAttributes.correctKeysCount = 0
				end
			end
		end
	end
	
	if g_gesturePausePageEnablingFlags.enablePage == true then
		if keyPressed["KEY_MENU"] or keyPressed["P"] then
			--we dont open the menu if the player is trying to open the chest
			if currentWorldNumber == 1 and currentLevelNumberInTheme == 8 and (settings.openGoldenEggLevels["Level6"] == nil) then
				treasureChest = objects.world["ExtraTreasureChest_1"]
				if treasureChest ~= nil then
					if g_treasureChestAttributes.correctKeysCount == 2 then
						drawGame()
						return 
					end
				end
			end
		
			goToMenu()
			drawGame()
			return
		end
		
		if  touchcount == 3 and g_mouseOrTouchStates.isUsingMouse == false and settings.fullScreen == true then	
			--captureMouse(true)
			--gets the id of the first touch
			if g_gesturePausePage.touchOneID == nil then
				for k,v in _G.pairs(touches) do
					--get the first touch id
					g_gesturePausePage.touchOneID = k
					break
				end

				g_gesturePausePage.currentDragX = touches[g_gesturePausePage.touchOneID].x
				g_gesturePausePage.currentDragY = touches[g_gesturePausePage.touchOneID].y
				
			end
			
			if g_gesturePausePage.touchOneID ~= nil then
				
				if touches[g_gesturePausePage.touchOneID] then
					local t_dragDistance = distance(g_gesturePausePage.currentDragX,g_gesturePausePage.currentDragY, touches[g_gesturePausePage.touchOneID].x, touches[g_gesturePausePage.touchOneID].y)
					
					if t_dragDistance > g_gesturePausePage.targetDragTotal then
						--print("\n here started" )
						
						g_gesturePausePage.currentButtonSelected = nil
						goToGesturePauseMenu()
						drawGame()
						return
					end
				end
				
			end
			
			--goToGesturePauseMenu()
			--drawGame()
			--return
			
			--g_gesturePausePage.waitingForDrag
		else
			--g_gesturePausePage.waitingForDrag = false
			g_gesturePausePage.touchOneID = nil
			g_gesturePausePage.currentButtonSelected = nil
			g_gesturePausePage.currentDragX = 0
			g_gesturePausePage.currentDragY = 0
			
			--captureMouse(false)
		end
	else
		if keyPressed["KEY_MENU"] or keyPressed["P"] or (touchcount == 3 and isInFullScreenMode()) then			
			--we dont open the menu if the player is trying to open the chest
			if currentWorldNumber == 1 and currentLevelNumberInTheme == 8 and (settings.openGoldenEggLevels["Level6"] == nil) then
				treasureChest = objects.world["ExtraTreasureChest_1"]
				if treasureChest ~= nil then				
					if g_treasureChestAttributes.correctKeysCount == 2 then		
						drawGame()
						return 
					end
				end
			end
		
			goToMenu()	
			drawGame()
			return
		end
	end
	
	
	
	

	if keyPressed["MBUTTON"] and (not releaseBuild) then
		setWorldScale(1)
		worldScale = 1
	end
	
	
	
	--[[
	if doubleClick == true then
		if currentWorldNumber == 1 and currentLevelNumberInTheme == 8 then
			treasureChest = objects.world["ExtraTreasureChest_1"]
			if treasureChest ~= nil then
				if distance(cursorPhysics.x, cursorPhysics.y, treasureChest.x, treasureChest.y) < 2.5 then
					goldenEggAchieved("Level6")
				end
			end
		end
	end
	]]
	
	-- if keyPressed["TAB"] then
		-- physicsEnabled = not physicsEnabled
		-- setPhysicsEnabled(physicsEnabled)
	-- end

	if levelStartTimer < 1 or levelStartTimer > 6 then
		levelStartTimer = levelStartTimer + dt
	else
		setPhysicsEnabled(true)
		levelStartTimer = 10
		--print("Level started\n")
		-- set first bird to start position
		--nextBirdTimer = 1
		-- currentBirdName = getNextBird(currentBirdIndex)
	end

	-- check level complete rule
	if levelCompleteTimer > 0 then
		-- level has been completed puff the birds
		if levelCompleted then
			eagleDarkness = nil
			birdBuffTimer = birdBuffTimer - dt
			if birdBuffTimer < 0 then
				local nextBirdName = getNextBird(birdsLeftCounter)
				if nextBirdName ~= nil then
					birdsLeftCounter = birdsLeftCounter + 1
					scoreTable["birds"].score = scoreTable["birds"].score + birdsLeftScoreIncrement
					local nbo = objects.world[nextBirdName]
					-- if nbo == selectedBird then
						-- birdFired = true
					-- end
					_G.res.playAudio(getAudioName("bird_misc"), 1, false, 0)
					_G.table.insert(floatingScores, { x = nbo.x, y = nbo.y, sprite = getObjectDefinition(nextBirdName).spriteScore, score = birdsLeftScoreIncrement, time = 0, lifetime = 0.9, maxScale = 1, xs = 0 } )
					birdBuffTimer = 0.5
					--removeBird(nbo)
				else
					-- show boomerang bird popup just before going to level complete screen
					if showBoomerangBirdPopup == true and (levelCompleteTimer > 0 and levelCompleteTimer - dt <= 0) then
						showBoomerangBirdPopup = false
						loadGoldenEggSprites()
						setActivePopupPage(boomerangBirdAchievedPage)
						_G.res.playAudio("star_collect", 1, false)
						if currentLevelNumberInTheme == 4 and currentWorldNumber == 6 then
							settings.boomerangBirdAchieved = true
						elseif currentLevelNumberInTheme == 5 and currentWorldNumber == 9 then
							settings.boomerangBirdAchieved2 = true
						end
						addToAchievementUnlockQueue("Return to Sender")
						if deviceModel == "iphone4" then
							changeResolution = true
							wantedResolution = "HALF"
						end
					else
						levelCompleteTimer = levelCompleteTimer - dt
					end
				end
				updateScore(dt)
				-- for testing
				if quadClick == true then
					score = starTable[levelName].goldScore
				elseif rokuCheat then
					if rokuClickCounter == 1 then
						score = starTable[levelName].eagleScore
					elseif rokuClickCounter == 2 then
						score = starTable[levelName].silverScore
					elseif rokuClickCounter >= 3 then
						score = starTable[levelName].goldScore
					end
				end
			end
		else
			levelCompleteTimer = levelCompleteTimer - dt
		end
		-- is level going to end
		if levelCompleteTimer <= 0 then
			if startedFromEditor then
				returnToEditor()
				return
			else
				local saveScores = false
				if highscores[levelName] == nil then
					highscores[levelName] = { score = 0 }
				end

				if highscores[levelName].score == nil then
					highscores[levelName] = { score = 0 }
				end
				
				if levelCompleted then
					--logEvent("level_completed", "INGAME", currentWorldNumber, currentLevelNumberInTheme, nil, numberOfAttemptsInLevel, score, birdsShot, birdsCounter)
					levelRestartedFrom = "complete menu"
					if eagleBaitLaunched == true then
						-- percentage from mighty eagle points
						mightyEagleScore = _G.math.min(_G.math.ceil( (score / starTable[levelName].goldScore ) * 100), 100)
						-- mighty eagle score is now always 100%
						mightyEagleScore = 100
						--print("score: " .. score .. ", goldScore: " .. starTable[levelName].goldScore .. ", percentage: " .. mightyEagleScore .. "\n")
						-- if mighty eagle was used for passing the level for the first time, mark eagle used and no score
						if highscores[levelName].score == 0 then
							if levelSelectionPages == levelSelectionPagesBasic then
								settings.eaglesAvailable.basic = settings.eaglesAvailable.basic - 1
							elseif levelSelectionPages == levelSelectionPagesExtra then
								settings.eaglesAvailable.extra = settings.eaglesAvailable.extra - 1
							elseif levelSelectionPages == levelSelectionPagesPack3 then 
								settings.eaglesAvailable.pack3 = settings.eaglesAvailable.pack3 - 1
							elseif levelSelectionPages == levelSelectionPagesPack4 then
								settings.eaglesAvailable.pack4 = settings.eaglesAvailable.pack4 - 1							
							end
							_G.table.insert(settings.eaglesUsedIn, { world = currentWorldNumber, level = currentLevelNumberInTheme } )
						end
						score = 0
						if highscores[levelName].eagleScore == nil or highscores[levelName].eagleScore < mightyEagleScore then
							highscores[levelName].eagleScore = mightyEagleScore
							saveScores = true
						end
						--print("Mighty eagle used in world: " .. currentWorldNumber .. " & level: " .. currentLevelNumberInTheme)
					else 
						-- mighty eagle not used this time, check if it was previously used for this level
						for k, v in _G.pairs(settings.eaglesUsedIn) do
							if v.world == currentWorldNumber and v.level == currentLevelNumberInTheme then
								if levelSelectionPages == levelSelectionPagesBasic then
									settings.eaglesAvailable.basic = settings.eaglesAvailable.basic + 1
								elseif levelSelectionPages == levelSelectionPagesExtra then
									settings.eaglesAvailable.extra = settings.eaglesAvailable.extra + 1
								elseif levelSelectionPages == levelSelectionPagesPack3 then 
									settings.eaglesAvailable.pack3 = settings.eaglesAvailable.pack3 + 1
								elseif levelSelectionPages == levelSelectionPagesPack4 then
									settings.eaglesAvailable.pack4 = settings.eaglesAvailable.pack4 + 1								
								end
								_G.table.remove(settings.eaglesUsedIn, k)
							end
						end
					end
					
					local intel_egg = false
					if customer == "Intel" then
						if currentLevelNumberInTheme > 26 then
							intel_egg = true
						end
					end
					
					local newHighScore = getItemByName(levelComplete.items, "newHighScore")
					newHighScore.visible = false
					if highscores[levelName].score < score then
						highscores[levelName].score = score
						highscores[levelName].birds = birdsShot
						if inExtraWorld ~= true and not intel_egg then
							newHighScore.sprite = "NEW_HIGHSCORE_BG"
							newHighScore.visible = true
						end
						saveScores = true
					end
				
					if inExtraWorld and not intel_egg then
						-- three star limit gives the golden egg star
						if score >= starTable[levelName].goldScore then
							if settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 2 then
								loadGoldenEggStarSprites()
								newHighScore.sprite = "GOLDEN_EGG_STAR_COLLECTED"
							else
								loadGoldenEggStarSprites()
								newHighScore.sprite = "GOLDEN_EGG_STAR"
							end
							
							if currentLevelNumberInTheme == 20 then
								newHighScore.sprite = "ICON_BABY_BLU"
							end
							
							newHighScore.visible = true
							
							if settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 1 then
								settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] = 2
								saveLuaFileWrapper("settings.lua", "settings", true)
								if calculateStarsFromGoldenEggLevels() == 10 then
									addToAchievementUnlockQueue("Egg Cracker")
								end
							end
						end
					end

					if highscores[levelName].lowScore == nil then
						highscores[levelName].lowScore = score
						saveScores = true
					end
					if highscores[levelName].lowScore > score then
						highscores[levelName].lowScore = score
						saveScores = true
					end
					
					if highscores[levelName].completed ~= true then
						highscores[levelName].completed = true
					end

					if saveScores then
						saveLuaFileWrapper("highscores.lua", "highscores", true)
					end
					
					if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
						postTotalHighScores()
						if not isLiteVersion then
							postLevelHighScore(levelName, highscores[levelName].score)
						end
					end
					
					setFont(fontBasic)
					
					getItemByName(levelComplete.items, "scoreNumber").text = _G.string.format("%d", score)
					--getItemByName(levelComplete.items, "highScoreText").text = _G.res.getString("TEXTS_BASIC", "MI_HIGH_SCORE") .. " " .. highscores[levelName].score
					getItemByName(levelComplete.items, "highScoreNumber").text = _G.string.format("%d", highscores[levelName].score)

					if (inExtraWorld and not intel_egg) or (eagleBaitLaunched == true and highscores[levelName].score == 0) then
						-- hide highscore
						getItemByName(levelComplete.items, "highScoreText").visible = false
						getItemByName(levelComplete.items, "highScoreNumber").visible = false
					else
						getItemByName(levelComplete.items, "highScoreText").visible = true
						getItemByName(levelComplete.items, "highScoreNumber").visible = true
					end														
					
					local starsItem = getItemByName(levelComplete.items, "stars")					
					starsItem.sprite = "RESULT_STARS_1"
					if highscores[levelName].score >= starTable[levelName].silverScore then
						starsItem.sprite = "RESULT_STARS_2"
					end
					if highscores[levelName].score >= starTable[levelName].goldScore then
						starsItem.sprite = "RESULT_STARS_3"
					end
					
					local gainedStars = 1

					local starsCurrentItem = getItemByName(levelComplete.items, "starsCurrent")					
					starsCurrentItem.sprite = "STARS_BIG_1"
					if score >= starTable[levelName].silverScore then
						gainedStars = 2
						starsCurrentItem.sprite = "STARS_BIG_2"
					end
					
					-- Check if user got three stars from this level
					local threeStars = false
					if score >= starTable[levelName].goldScore then
						gainedStars = 3
						threeStars = true
						starsCurrentItem.sprite = "STARS_BIG_3"
						-- Check if user got three stars from all levels in the pack
			
						-- Select the right order table
						local orderTable
						if currentWorldNumber >= 1 and currentWorldNumber <= 3 then
							orderTable = levelOrder_packBasic
						elseif currentWorldNumber >= 4 and currentWorldNumber <= 5 then
							orderTable = levelOrder_packOne
						elseif currentWorldNumber >= 6 and currentWorldNumber <= 8 then
							orderTable = levelOrder_packThree
						elseif currentWorldNumber >= 9 and currentWorldNumber <= 11 then
							orderTable = levelOrder_packFour
						elseif currentWorldNumber >= 12 and currentWorldNumber <= 14 then
							orderTable = levelOrder_packFive
						elseif currentWorldNumber >= 15 and currentWorldNumber <= 17 then
							orderTable = levelOrder_packSix
						else
							orderTable = nil
						end
						
						if orderTable ~= nil then
							for k = 1, #orderTable do
								for i = 1, #orderTable[k] do
									if highscores[orderTable[k][i]] == nil then
										threeStars = false
									else
										if starTable[orderTable[k][i]].goldScore > highscores[orderTable[k][i]].score then
											threeStars = false
										end
									end
								end
							end
						end
					end
										
					settings.cumulativeStars = settings.cumulativeStars + gainedStars
					
					if settings.cumulativeStars >= 750 and settings.cumulativeStars < 1500 then
						addToAchievementUnlockQueue("Star Collector", true)
					end
					
					if settings.cumulativeStars >= 1500 then
						addToAchievementUnlockQueue("Star Gatherer", true)
					end
					
					settings.cumulativeScore = _G.string.format("%d", settings.cumulativeScore + score)
					settings.totalLevelsCompleted = settings.totalLevelsCompleted + 1
					
					if inExtraWorld == true then
						--change world number to egg
						--getItemByName(levelComplete.items, "levelNumber").text = "^-" .. currentLevelNumberInTheme
						if currentLevelNumberInTheme == 20 then
							getItemByName(levelComplete.items, "levelNumber").text = "*"
						else
							getItemByName(levelComplete.items, "levelNumber").text = "^-" .. currentLevelNumberInTheme
						end
					else
						getItemByName(levelComplete.items, "levelNumber").text = currentWorldNumber .. "-" .. currentLevelNumberInTheme
					end
					if (inExtraWorld and not intel_egg) or eagleBaitLaunched == true then
						--hide stars
						starsItem.visible = false
						starsCurrentItem.visible = false
					else
						starsItem.visible = true
						starsCurrentItem.visible = true
					end

					local buttonMenu = getItemByName(levelComplete.items, "buttonMenu")					
					local buttonRestart = getItemByName(levelComplete.items, "buttonRestart")					
					local buttonNextLevel = getItemByName(levelComplete.items, "buttonNextLevel")					
					if levelSelectionPages == levelSelectionPagesBasic or levelSelectionPages == levelSelectionPagesExtra or levelSelectionPages == levelSelectionPagesPack3 or levelSelectionPages == levelSelectionPagesPack4 or levelSelectionPages == levelSelectionPagesPack5 or levelSelectionPages == levelSelectionPagesPack6 then
						buttonMenu.page = levelSelectionPages
					else
						buttonMenu.page = levelSelectionPages[currentPageNumber]
					end
					buttonMenu.visible = true
					buttonRestart.visible = true
					if inExtraWorld == true then
						buttonNextLevel.visible = false
					else
						buttonNextLevel.visible = true
					end
					
					for i = 1, 17 do
						getItemByName(levelComplete.items, "buttonCutscene" .. i).visible = false
					end
					
					levelEndMenuPage = levelComplete
					
					if inExtraWorld ~= true then
						if currentWorldNumber == 1 then
							worldCompleted = false

							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene1").visible = true
								if settings.theme1Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme1Completed = true
									if isLiteVersion then
										settings.gameCompleted = true
										addToAchievementUnlockQueue("Ready For More")
									else
										addToAchievementUnlockQueue("Herr Helmet")
									end
								end
							end
						elseif currentWorldNumber == 2 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene2").visible = true
								if settings.theme2Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme2Completed = true
									addToAchievementUnlockQueue("Mr Moustache")
								end
							end
						elseif currentWorldNumber == 3 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene3").visible = true
								if settings.gameCompleted ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.gameCompleted = true
									addToAchievementUnlockQueue("Defeat of The King")
									levelEndMenuPage = gameFinished
									
									if threeStars and settings.threeStars ~= true then
										settings.threeStars = true
										goldenEggAchieved("Level4")
										--getItemByName(gameFinished.items, "buttonYes").page = gameFinishedThreeStars
										levelEndMenuPage = gameFinishedThreeStars
									end
								end
							end
						elseif currentWorldNumber == 4 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene4").visible = true
								if settings.theme4Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme4Completed = true
									addToAchievementUnlockQueue("The Imposter")
								end
							end
						elseif currentWorldNumber == 5 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene5").visible = true
								if settings.theme5Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme5Completed = true
									addToAchievementUnlockQueue("The Mysterious Escape")
									levelEndMenuPage = gameFinishedLP2
									if threeStars and settings.threeStarsLP2 ~= true then
										settings.threeStarsLP2 = true
										goldenEggAchieved("Level7")
										--getItemByName(gameFinishedLP2.items, "buttonYes").page = gameFinishedThreeStarsLP2
										levelEndMenuPage = gameFinishedThreeStarsLP2
									end
								end
							end
						elseif currentWorldNumber == 6 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene6").visible = true
								if settings.theme6Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme6Completed = true
									addToAchievementUnlockQueue("Hovering Helmet")
								end
							end
						elseif currentWorldNumber == 7 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene7").visible = true
								if settings.theme7Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme7Completed = true
									addToAchievementUnlockQueue("Mounting Moustache")
								end
							end
						elseif currentWorldNumber == 8 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene8").visible = true
								if settings.theme8Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme8Completed = true
									addToAchievementUnlockQueue("Green Baron")
									levelEndMenuPage = gameFinishedLP3
									if threeStars and settings.threeStarsLP3 ~= true then
										settings.threeStarsLP3 = true
										goldenEggAchieved("Level12")
										--getItemByName(gameFinishedLP3.items, "buttonYes").page = gameFinishedThreeStarsLP3
										levelEndMenuPage = gameFinishedThreeStarsLP3
										
									end
								end
							end
						elseif currentWorldNumber == 9 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene9").visible = true
								if settings.theme9Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme9Completed = true
									addToAchievementUnlockQueue("Hardhat Hidalgo")
								end
							end
						elseif currentWorldNumber == 10 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene10").visible = true
								if settings.theme10Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme10Completed = true
									addToAchievementUnlockQueue("Mason Moustache")
								end
							end
						elseif currentWorldNumber == 11 then
							worldCompleted = false
							
							if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
								worldCompleted = true
							end
							
							if worldCompleted then
								buttonNextLevel.visible = false
								getItemByName(levelComplete.items, "buttonCutscene11").visible = true
								if settings.theme11Completed ~= true then
									buttonMenu.visible = false
									buttonRestart.visible = false
									settings.theme11Completed = true
									addToAchievementUnlockQueue("Royal Ringleader") 
									levelEndMenuPage = gameFinishedLP4
									if threeStars and settings.threeStarsLP4 ~= true then
										settings.threeStarsLP4 = true
										goldenEggAchieved("Level17") 
										--getItemByName(gameFinishedLP4.items, "buttonYes").page = gameFinishedThreeStarsLP4
										levelEndMenuPage = gameFinishedThreeStarsLP4
									end
								end
							end
						end
						
						-- check if the player completes the "three stars in every level" after (s)he
						-- improves the star ratings of earlier levels
						if threeStars then
							if not settings.threeStars and currentWorldNumber >= 1 and currentWorldNumber <= 3 then
								settings.threeStars = true
								if not isLiteVersion then
									goldenEggAchieved("Level4")
									levelEndMenuPage = gameFinishedThreeStars
								else
									addToAchievementUnlockQueue("Total Destruction Lite")
								end
							elseif not settings.threeStarsLP2 and currentWorldNumber >= 4 and currentWorldNumber <= 5 then
								settings.threeStarsLP2 = true
								goldenEggAchieved("Level7")
								levelEndMenuPage = gameFinishedThreeStarsLP2
							elseif not settings.threeStarsLP3 and currentWorldNumber >= 6 and currentWorldNumber <= 8 then
								settings.threeStarsLP3 = true
								goldenEggAchieved("Level12")
								levelEndMenuPage = gameFinishedThreeStarsLP3
							elseif not settings.threeStarsLP4 and currentWorldNumber >= 9 and currentWorldNumber <= 11 then
								settings.threeStarsLP4 = true
								goldenEggAchieved("Level17")
								levelEndMenuPage = gameFinishedThreeStarsLP4
							elseif not settings.threeStarsLP5 and currentWorldNumber >= 12 and currentWorldNumber <= 14 then
								settings.threeStarsLP5 = true
								goldenEggAchieved("Level21")
								levelEndMenuPage = gameFinishedThreeStarsLP5
							--[[elseif not settings.threeStarsLP6 and currentWorldNumber >= 15 and currentWorldNumber <= 17 then
								settings.threeStarsLP6 = true
								goldenEggAchieved("Level25")
								levelEndMenuPage = gameFinishedThreeStarsLP6]]
							end
						end
						
						if currentWorldNumber >= 1 and currentWorldNumber <= 3 then
							if settings.lastOpenLevel <= currentLevelNumber then
								settings.lastOpenLevel = currentLevelNumber + 1
								saveLuaFileWrapper("settings.lua", "settings", true)
							end
						end
						
						if currentWorldNumber >= 4 and currentWorldNumber <= 5 then
							if settings.lastOpenLevelLP2 <= currentLevelNumber then
								settings.lastOpenLevelLP2 = currentLevelNumber + 1
								saveLuaFileWrapper("settings.lua", "settings", true)
							end
						end
						
						if currentWorldNumber >= 6 and currentWorldNumber <= 8 then
							if settings.lastOpenLevelLP3 <= currentLevelNumber then
								settings.lastOpenLevelLP3 = currentLevelNumber + 1
								saveLuaFileWrapper("settings.lua", "settings", true)
							end
						end
						
						if currentWorldNumber >= 9 and currentWorldNumber <= 11 then
							if settings.lastOpenLevelLP4 <= currentLevelNumber then
								settings.lastOpenLevelLP4 = currentLevelNumber + 1
								saveLuaFileWrapper("settings.lua", "settings", true)
							end
						end
						
						if currentWorldNumber >= 12 and currentWorldNumber <= 14 then
							if settings.lastOpenLevelLP5 <= currentLevelNumber then
								settings.lastOpenLevelLP5 = currentLevelNumber + 1
								saveLuaFileWrapper("settings.lua", "settings", true)
							end
						end
						
						if currentWorldNumber >= 15 and currentWorldNumber <= 17 then
							if settings.lastOpenLevelLP6 <= currentLevelNumber then
								settings.lastOpenLevelLP6 = currentLevelNumber + 1
								settings.lastOpenLevelLP6 = _G.math.min(30, settings.lastOpenLevelLP6)
								saveLuaFileWrapper("settings.lua", "settings", true)
							end
						end
					end
					
					--log flurry event
					if inExtraWorld == true then
						--print("FlurryEventWithParam: Golden egg level completed, param: Level, paramValue: " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
						logFlurryEventWithParam("Golden egg level completed", "Level", "" .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]) 
					else
						levelCompleteFlurryParams = {}
						
						levelCompleteFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
						
						if score >= starTable[levelName].goldScore then
							levelCompleteFlurryParams["Stars"] = "3"
						elseif score >= starTable[levelName].silverScore then
							levelCompleteFlurryParams["Stars"] = "2"
						else
							levelCompleteFlurryParams["Stars"] = "1"
						end
						
						levelCompleteFlurryParams["Attempts"] = "" .. numberOfAttemptsInLevel
						levelCompleteFlurryParams["Birds used"] = "" .. birdsShot
						levelCompleteFlurryParams["Birds available"] = "" .. birdsCounter
						
						logFlurryEventWithParams("Level complete", "levelCompleteFlurryParams")
						--print("FlurryEventWithParams: Level complete \n")
					end				
					numberOfAttemptsInLevel = 0
									
					local episode1TotalScore, episode1Stars, episode1TotalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
					if episode1Stars >= episode1TotalStars then
						addToAchievementUnlockQueue("Episode 1 - Total Destruction")
					end
					
					if episode1TotalScore >= 4000000 then
						addToAchievementUnlockQueue("Episode 1 - Score Addict")
					end

					local episode2TotalScore, episode2Stars, episode2TotalStars = calculateTotalScoreAndStars(levelOrder_packOne)
					if episode2Stars >= episode2TotalStars then
						addToAchievementUnlockQueue("Episode 2 - Total Destruction")
					end
					if episode2TotalScore >= 3300000 then
						addToAchievementUnlockQueue("Episode 2 - Score Addict")
					end
					
					local episode3TotalScore, episode3Stars, episode3TotalStars = calculateTotalScoreAndStars(levelOrder_packThree)
					if episode3Stars >= episode3TotalStars then
						addToAchievementUnlockQueue("Episode 3 - Total Destruction")
					end
					if episode3TotalScore >= 4800000 then
						addToAchievementUnlockQueue("Episode 3 - Score Addict")
					end
					
					local episode4TotalScore, episode4Stars, episode4TotalStars = calculateTotalScoreAndStars(levelOrder_packFour)
					if episode4Stars >= episode4TotalStars then
						addToAchievementUnlockQueue("Episode 4 - Total Destruction")
					end
					if episode4TotalScore >= 4800000 then -- FIX THIS!
						addToAchievementUnlockQueue("Episode 4 - Score Addict")
					end
					
					if eagleBaitLaunched == true then
						getItemByName(levelComplete.items, "eagleFeatherEmpty").visible = true
						getItemByName(levelComplete.items, "eagleFeatherFill").visible = true
						getItemByName(levelComplete.items, "eagleFeatherFull").visible = false
						getItemByName(levelComplete.items, "totalDestruction").visible = false
						getItemByName(levelComplete.items, "starEffect").visible = false
						getItemByName(levelComplete.items, "eagleScoreNumber").visible = true
						getItemByName(levelComplete.items, "eagleScoreNumber").text = "0%"
						getItemByName(levelComplete.items, "levelComplete").visible = false							
						getItemByName(levelComplete.items, "score").visible = false							
						getItemByName(levelComplete.items, "scoreNumber").visible = false							
						getItemByName(levelComplete.items, "highScoreText").visible = false							
						getItemByName(levelComplete.items, "highScoreNumber").visible = false					
						local score = getItemByName(levelComplete.items, "score")
						score.visible = false
						local scoreNumber = getItemByName(levelComplete.items, "scoreNumber")
						scoreNumber.text = mightyEagleScore .. "%"
						scoreNumber.visible = false
					else
						getItemByName(levelComplete.items, "eagleFeatherEmpty").visible = false
						getItemByName(levelComplete.items, "eagleFeatherFill").visible = false
						getItemByName(levelComplete.items, "eagleFeatherFull").visible = false
						getItemByName(levelComplete.items, "totalDestruction").visible = false
						getItemByName(levelComplete.items, "starEffect").visible = false
						getItemByName(levelComplete.items, "eagleScoreNumber").visible = false
						getItemByName(levelComplete.items, "levelComplete").visible = true							
						getItemByName(levelComplete.items, "score").visible = true							
						getItemByName(levelComplete.items, "scoreNumber").visible = true
						local score = getItemByName(levelComplete.items, "score")
						score.visible = true
						local scoreNumber = getItemByName(levelComplete.items, "scoreNumber")
						scoreNumber.visible = true
					end
					_G.res.playAudio("level_complete", 1, false, 7)	

					prepareMenuPage(levelComplete)					
				else

					levelEndMenuPage = levelFailed

					-- flurry fail logging 
					--logEvent("level_failed", "INGAME", currentWorldNumber, currentLevelNumberInTheme, nil, numberOfAttemptsInLevel, score, birdsShot, birdsCounter)
					levelRestartedFrom = "failed menu"
					if inExtraWorld == true then
						logFlurryEventWithParam("Golden egg level failed", "Level", goldenEggLevelMapping["Level" .. currentLevelNumberInTheme])
						--print("FlurryEventWithParam: Golden egg level failed, Level, " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
					else
						levelFailedFlurryParams = {}
						levelFailedFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
						levelFailedFlurryParams["Attempts"] = "" .. numberOfAttemptsInLevel
						levelFailedFlurryParams["Birds used"] = "" .. birdsShot
						levelFailedFlurryParams["Birds available"] = "" .. birdsCounter
						
						logFlurryEventWithParams("Level failed", "levelFailedFlurryParams")
					end
					
					levelFailed.items[5].text = "" .. _G.string.format("%d", highscores[levelName].score)
					
					if levelSelectionPages == levelSelectionPagesBasic or levelSelectionPages == levelSelectionPagesExtra or levelSelectionPages == levelSelectionPagesPack3 or levelSelectionPages == levelSelectionPagesPack4 or levelSelectionPages == levelSelectionPagesPack5 or levelSelectionPages == levelSelectionPagesPack6 then 
						levelFailed.items[6].page = levelSelectionPages
					else
						levelFailed.items[6].page = levelSelectionPages[currentPageNumber]
					end
					
					levelFailed.items[9].visible = true
					--levelFailed.items[9].selectable = true
					levelFailed.items[10].visible = false
					levelFailed.items[11].visible = false
					
					for i = 1, 17 do
						getItemByName(levelFailed.items, "buttonCutscene" .. i).visible = false
					end
				
					print("highscore: " .. highscores[levelName].score .. "\n")
					-- check if mighty eagle is unavailable
					if inExtraWorld == true or (highscores[levelName].score == 0 and 
					   ((levelSelectionPages == levelSelectionPagesBasic and settings.eaglesAvailable.basic < 1) or
						(levelSelectionPages == levelSelectionPagesExtra and settings.eaglesAvailable.extra < 1) or
						(levelSelectionPages == levelSelectionPagesPack3 and settings.eaglesAvailable.pack3 < 1) or
						(levelSelectionPages == levelSelectionPagesPack4 and settings.eaglesAvailable.pack4 < 1))) then
						getItemByName(levelFailed.items, "buttonEagle").visible = false
						getItemByName(levelFailed.items, "buttonEagleLost").visible = true
					end
					local buttonEagleBuy = getItemByName(levelFailed.items, "buttonEagleBuy")
					buttonEagleBuy.visible = false
					if settings.mightyEagleEnabled ~= true then
						getItemByName(levelFailed.items, "buttonEagle").visible = false
						getItemByName(levelFailed.items, "buttonEagleLost").visible = false
						
						if (deviceModel == "s60") and (highscores[levelName] == nil or highscores[levelName].score == 0) then
							buttonEagleBuy.visible = true
						end
					else
						if highscores[levelName] ~= nil and highscores[levelName].score > 0 then
							getItemByName(levelFailed.items, "buttonEagle").visible = false
							getItemByName(levelFailed.items, "buttonEagleLost").visible = false
						end
						buttonEagleBuy.visible = false
					end
					
					levelFailed.items[8].sprite = "RESULT_STARS_0"
					if highscores[levelName].score > 0 then
						levelFailed.items[8].sprite = "RESULT_STARS_1"
						levelFailed.items[11].visible = true
						--levelFailed.items[9].visible = false
						--levelFailed.items[10].visible = true
						
						if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage and inExtraWorld ~= true then
							levelFailed.items[currentWorldNumber + 11].visible = true
							levelFailed.items[11].visible = false
						end	
					end
					if highscores[levelName].score >= starTable[levelName].silverScore then
						levelFailed.items[8].sprite = "RESULT_STARS_2"
						--levelFailed.items[9].visible = false
						--levelFailed.items[10].visible = true
					end
					if highscores[levelName].score >= starTable[levelName].goldScore then
						levelFailed.items[8].sprite = "RESULT_STARS_3"
						--levelFailed.items[9].visible = false
						--levelFailed.items[10].visible = true
					end
					
					if inExtraWorld == true then
						--levelFailed.items[2].text = "^-" .. currentLevelNumberInTheme
						levelFailed.items[11].visible = false
						if currentLevelNumberInTheme == 20 then
							levelFailed.items[2].text = "*"
						else
							levelFailed.items[2].text = "^-" .. currentLevelNumberInTheme
						end
					else
						levelFailed.items[2].text = currentWorldNumber .. "-" .. currentLevelNumberInTheme
					end
					prepareMenuPage(levelFailed)
				end

				_G.res.stopAudio(musics[currentThemeNumber])
				--stop looping rolling sounds
				_G.res.stopAudio("wood_rolling")
				_G.res.stopAudio("rock_rolling")
				_G.res.stopAudio("light_rolling")					
				
				setGameMode(updateMenu)
				setActiveMenuPage(levelEndMenuPage)
				
				
				
				changeResolution = true
				wantedResolution = "HALF"
				
				setPhysicsEnabled(false)
				drawGame()
				
				--forceInputStateToMouse()
				
				return
			end
		end
	else
		if (checkLevelComplete() or keyPressed["C"] or quadClick or rokuCheat or keyPressed["K"]) then
			--g_mouseOrTouchStates.isUsingMouse = true
			rubberBandPos.x = levelStartPosition.x
			rubberBandPos.y = levelStartPosition.y
			rubberBandSpeed = 0
			
			allowResetToBirdCamera = false
			showTapIcon = false
			showTapTimer = 0
			levelCompleted = true
			--setPhysicsEnabled(false)			
			-- count the remaining birds that have not been fired
			birdsLeftCounter = currentBirdIndex

			if currentBirdName == nil or objects.world[currentBirdName].shot == true then
				birdsLeftCounter = birdsLeftCounter + 1
			end

			-- if some birds are left go to launch camera and show the scores
			if getNextBird(birdsLeftCounter) ~= nil then
				birdBuffTimer = 2.5
				if cameraFunction ~= launchCamera then
					birdBuffTimer = 3.5
					castleCameraTimer = 1.0
					cameraFunction = launchCamera
					animationScreen.x = screen.x
					animationScreen.y = screen.y
					animationWorldScale = worldScale					
				end
			end
			
			 if keyPressed["K"] then
				scoreTable.cheat = {score = 10000000}
			 end
			
			_G.res.playAudio(getAudioName("level_clear_military"), 1, false)
			levelCompleteTimer = 1.0
			if eagleBaitLaunched then
				levelCompleteTimer = 2.0
			end
			
			if (currentWorldNumber == 6 and currentLevelNumberInTheme == 4 and settings.boomerangBirdAchieved ~= true) or
			   (currentWorldNumber == 9 and currentLevelNumberInTheme == 5 and settings.boomerangBirdAchieved2 ~= true) then
				showBoomerangBirdPopup = true
			end
		end
		if checkLevelFailed() then 
			-- wait for 1.5 seconds until declare level as failed
			levelFailedTimer = levelFailedTimer + dt
			if levelFailedTimer > 1.5 then
				--setPhysicsEnabled(false)
				levelCompleteTimer = 0.5
				_G.res.playAudio(getAudioName("level_failed_piglets"), 1, false)
			end
		end
	end
	
	-- update timers
	gameTimer = gameTimer + dt
	
	-- update tap timer
	if tapStarted then
		tapTimer = tapTimer + dt
				
		if tapTimer > 0.25 then
			if tapCount == 1 and showTapIcon then
				-- todo: put these to own function, this code is used in three places
				rightSweep = true
				showTapIcon = false
				showTapTimer = 0
				cameraFunction = doItAllCamera
				sweepSpeed = objects.castleCameraData[deviceModel].px - objects.birdCameraData[deviceModel].px
				cameraAnimationSliderTarget = 0
				if cameraAnimationSlider >= 1 then
					cameraAnimationSlider = 1
				end
				allowResetToBirdCamera = false
				cameraTargetObject = nil
				flyingBird = nil
			end
			-- reset camera scale
			if tapCount == 2 then
				if cameraAnimationSliderTarget == 0 then
					currentZoomedScale = objects.birdCameraData[deviceModel].sx
				else
					currentZoomedScale = objects.castleCameraData[deviceModel].sx
				end
			end
		
			tapTimer = 0
			tapCount = 0
			tapStarted = false
		end
	end
	
	-- Handle keypress
	if keyPressed["LBUTTON"] and not levelCompleted then

		draggingStartPosPhysics.x = cursorPhysics.x
		draggingStartPosPhysics.y = cursorPhysics.y
		draggingStartPosScreen.x = cursor.x
		draggingStartPosScreen.y = cursor.y

		oldCursor.x = cursor.x
		oldCursor.y = cursor.y

		if not tapStarted then
			tapPosition.x = cursor.x
			tapPosition.y = cursor.y
			tapStarted = true
			tapTimer = 0
		end
		
		-- try it out - just for fun
		--makeClickExplosion(cursorPhysics.x, cursorPhysics.y, 20000, 10, 200, 5, getAudioName("special_explosion"))

		-- if gamestate is bird flying use special action
		if flyingBird ~= nil and birdSpecialtyAvailable then
			birdSpecialtyAvailable = false
			
			--if the player has pressed the bird specialty but the finger is still in touch, we must wait until the player removes the finger
			--in order to starting dragging the next bird on the slingshot
			if deviceModel ~= "roku" then
				if g_mouseOrTouchStates.isUsingMouse == false and touchcount > 0 then
					g_birdDragOnTouchAttributes.disabledForBirdSpecialty = true
				end
			end
			
			
			local bDef = getObjectDefinition(flyingBird.name)
			birdSpecialty = bDef.specialty
			if birdSpecialty == "BOOST" then
				local force = boostForce * physicsScale * flyingBird.mass
				local x, y = vNormalize(flyingBird.xVel, flyingBird.yVel)
				applyImpulse( flyingBird.name,
							-x * force,
							-y * force,
							flyingBird.x,
							flyingBird.y )
				addParticles(flyingBird.name, blockTable.blocks[flyingBird.definition].particles, 10)
				_G.res.playAudio(getAudioName(blockTable.blocks[flyingBird.definition].specialSound), 1, false)
				objects.world[flyingBird.name].sprite = "BIRD_YELLOW_SPECIAL"
				setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)
				local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
				addPuffToTrajectory(1, lx, ly)
			end
			if birdSpecialty == "BOMB" then
				--birdSpecialtyAvailable = true
				makeExplosion(flyingBird, bDef, getAudioName(blockTable.blocks[flyingBird.definition].specialSound))
				
				removeBird(flyingBird)
			end
			if birdSpecialty == "SOUND" then
				_G.res.playAudio(getAudioName(blockTable.blocks[flyingBird.definition].specialSound), 1, false)
			end
			if birdSpecialty == "CLUSTER_BOMB" then
				
				local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
				addPuffToTrajectory(1, lx, ly)
				
				local x, y = vNormalize(flyingBird.yVel, -flyingBird.xVel)
				local newName = flyingBird.name .. "a"
				createCircle(newName, flyingBird.sprite, flyingBird.x - x, flyingBird.y - y, flyingBird.radius, flyingBird.density, flyingBird.friction, flyingBird.restitution, flyingBird.controllable, flyingBird.z_order)
				objects.world[newName].definition = flyingBird.definition
				objects.world[newName].controllable = flyingBird.controllable
				objects.world[newName].strength = flyingBird.strength
				objects.world[newName].defence = flyingBird.defence
				objects.world[newName].material = flyingBird.material
				objects.world[newName].levelGoal = flyingBird.levelGoal
				objects.world[newName].damageFactors = flyingBird.damageFactors
				objects.world[newName].spritePivotX = flyingBird.spritePivotX
				objects.world[newName].spritePivotY = flyingBird.spritePivotY
				objects.world[newName].damageSprite = flyingBird.damageSprite
				objects.world[newName].useLegacyCollisionPath = flyingBird.useLegacyCollisionPath
				objects.world[newName].shot = true
				objects.world[newName].sleeping = false
				objects.world[newName].hasCollided = false
				objects.world[newName].parentName = flyingBird.name
				objects.world[newName].xVel = flyingBird.xVel - x*7
				objects.world[newName].yVel = flyingBird.yVel - y*7
				setSprite(newName, flyingBird.damageSprite)
				setRotation(newName, flyingBird.angle)
				setVelocity(newName, flyingBird.xVel - x*7, flyingBird.yVel - y*7)
				--_G.table.insert(extraObjects, newName)
				birds[newName] = objects.world[newName]
				
				newName = flyingBird.name .. "b"
				createCircle(newName, flyingBird.sprite, flyingBird.x, flyingBird.y, flyingBird.radius, flyingBird.density, flyingBird.friction, flyingBird.restitution, flyingBird.controllable, flyingBird.z_order)
				objects.world[newName].definition = flyingBird.definition
				objects.world[newName].controllable = flyingBird.controllable
				objects.world[newName].strength = flyingBird.strength
				objects.world[newName].defence = flyingBird.defence
				objects.world[newName].material = flyingBird.material
				objects.world[newName].levelGoal = flyingBird.levelGoal
				objects.world[newName].damageFactors = flyingBird.damageFactors
				objects.world[newName].spritePivotX = flyingBird.spritePivotX
				objects.world[newName].spritePivotY = flyingBird.spritePivotY
				objects.world[newName].damageSprite = flyingBird.damageSprite				
				objects.world[newName].useLegacyCollisionPath = flyingBird.useLegacyCollisionPath
				objects.world[newName].shot = true
				objects.world[newName].sleeping = false
				objects.world[newName].hasCollided = false
				objects.world[newName].parentName = flyingBird.name
				objects.world[newName].xVel = flyingBird.xVel
				objects.world[newName].yVel = flyingBird.yVel
				setSprite(newName, flyingBird.damageSprite)				
				setRotation(newName, flyingBird.angle)
				setVelocity(newName, flyingBird.xVel, flyingBird.yVel)
				--_G.table.insert(extraObjects, newName)
				birds[newName] = objects.world[newName]
				
				newName = flyingBird.name .. "c"
				createCircle(newName, flyingBird.sprite, flyingBird.x + x, flyingBird.y + y, flyingBird.radius, flyingBird.density, flyingBird.friction, flyingBird.restitution, flyingBird.controllable, flyingBird.z_order)
				objects.world[newName].definition = flyingBird.definition
				objects.world[newName].controllable = flyingBird.controllable
				objects.world[newName].strength = flyingBird.strength
				objects.world[newName].defence = flyingBird.defence
				objects.world[newName].material = flyingBird.material
				objects.world[newName].levelGoal = flyingBird.levelGoal
				objects.world[newName].damageFactors = flyingBird.damageFactors
				objects.world[newName].spritePivotX = flyingBird.spritePivotX
				objects.world[newName].spritePivotY = flyingBird.spritePivotY
				objects.world[newName].damageSprite = flyingBird.damageSprite				
				objects.world[newName].useLegacyCollisionPath = flyingBird.useLegacyCollisionPath
				objects.world[newName].shot = true
				objects.world[newName].sleeping = false
				objects.world[newName].hasCollided = false
				objects.world[newName].parentName = flyingBird.name
				objects.world[newName].xVel = flyingBird.xVel + x*7
				objects.world[newName].yVel = flyingBird.yVel + y*7
				setSprite(newName, flyingBird.damageSprite)				
				setRotation(newName, flyingBird.angle)
				setVelocity(newName, flyingBird.xVel + x*7, flyingBird.yVel + y*7)
				birds[newName] = objects.world[newName]
				
				otherBirds = { flyingBird.name .. "a", flyingBird.name .. "b" }
				removeBird(flyingBird)
				--objects.world[flyingBird.name] = nil
				flyingBird = objects.world[newName]
				cameraTargetObject = flyingBird

				_G.res.playAudio(blockTable.blocks[flyingBird.definition].specialSound, 1, false)

			end
			-- drop explosive
			if birdSpecialty == "GRENADE" then
				local x, y = vNormalize(flyingBird.yVel, -flyingBird.xVel)
				local newName = flyingBird.name .. "a"
				objects.world[flyingBird.name].sprite = "BIRD_GREEN_SPECIAL"
				setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)
				
				createCircle(newName, "DROPPABLE_EGG", flyingBird.x, flyingBird.y + flyingBird.radius*2, flyingBird.radius, flyingBird.density, flyingBird.friction, flyingBird.restitution, true, flyingBird.z_order)
				objects.world[newName].definition = "EggGranade"
				objects.world[newName].controllable = true
				objects.world[newName].strength = flyingBird.strength
				objects.world[newName].defence = flyingBird.defence
				objects.world[newName].material = flyingBird.material
				objects.world[newName].damageFactors = blockTable.blocks[objects.world[newName].definition].damageFactors
				objects.world[newName].useLegacyCollisionPath = flyingBird.useLegacyCollisionPath
				objects.world[newName].levelGoal = false
				local xp, yp = _G.res.getSpritePivot("INGAME_BIRDS_1","DROPPABLE_EGG")
				objects.world[newName].spritePivotX = xp
				objects.world[newName].spritePivotY = yp
				objects.world[newName].damageSprite = "DROPPABLE_EGG"
				objects.world[newName].xVel = 0 --flyingBird.xVel * 0.5
				objects.world[newName].yVel = 100 --flyingBird.yVel * 0.5
				setSprite(newName, objects.world[newName].damageSprite)
				setRotation(newName, flyingBird.angle)
				--setVelocity(newName, flyingBird.xVel*0.5, flyingBird.yVel*0.5)
				setVelocity(newName, objects.world[newName].xVel, objects.world[newName].yVel)
				--objects.world[newName].specialty = "BOMB"
				_G.table.insert(flyingGrenades, { name = newName, timer = 5 })
				--_G.table.insert(extraObjects, newName)
				_G.res.playAudio(getAudioName(blockTable.blocks[flyingBird.definition].specialSound), 1, false)
				--_G.res.playAudio(getAudioName("bird_pushing_egg_out"), 1, false)
				cameraTargetObject = objects.world[newName]
				
				applyImpulse( flyingBird.name,
							-0.04*defaultForce * flyingBird.mass,
							0.08*defaultForce * flyingBird.mass,
							flyingBird.x-0.5,
							flyingBird.y )
				local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
				addPuffToTrajectory(1, lx, ly)
			end
			if birdSpecialty == "BOOMERANG" then
				flyingBird.boomerangActive = true
				if flyingBird.xVel ~= 0 then
					yForceCoeff = 2 - _G.math.min(_G.math.abs(flyingBird.yVel / flyingBird.xVel), 2)
				else
					yForceCoeff = 0
				end
				
				flyingBird.boomerangXForce = flyingBird.xVel * physicsScale * flyingBird.mass * blockTable.blocks[flyingBird.definition].boomerangHorizontalForce
				flyingBird.boomerangYForce = yForceCoeff * physicsScale * flyingBird.mass * blockTable.blocks[flyingBird.definition].boomerangVerticalForce
				flyingBird.boomerangMinXVel = -blockTable.blocks[flyingBird.definition].boomerangMaxHorizontalSpeed
				flyingBird.boomerangMaxXVel = blockTable.blocks[flyingBird.definition].boomerangMaxHorizontalSpeed
				
				--flyingBird.angularVelocity = 0
				objects.world[flyingBird.name].sprite = "BIRD_BOOMERANG_SPECIAL"
				setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)
				
				_G.res.playAudio(getAudioName(blockTable.blocks[flyingBird.definition].specialSound), 1, false)
				
				local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
				addPuffToTrajectory(1, lx, ly)
			end
			-- Be Mighty
			--[[if birdSpecialty == "MIGHTY_EAGLE" then
				local x, y = vNormalize(flyingBird.yVel, -flyingBird.xVel)
				local newName = "MightyEagle_a"
				
				local blockDef = blockTable.blocks["MightyEagleBird"]
				
				createCircle(newName, blockDef.sprite, flyingBird.x, flyingBird.y - blockDef.radius*20, blockDef.radius, blockDef.density, blockDef.friction, blockDef.restitution, true, 6)
				objects.world[newName].definition = "MightyEagleBird"
				objects.world[newName].controllable = blockDef.controllable
				objects.world[newName].strength = blockDef.strength
				objects.world[newName].defence = blockDef.defence
				objects.world[newName].material = blockDef.material
				objects.world[newName].damageFactors = blockDef.damageFactors
				objects.world[newName].useLegacyCollisionPath = blockDef.useLegacyCollisionPath
				objects.world[newName].levelGoal = false
				local xp, yp = _G.res.getSpritePivot("INGAME_BIRDS_2",blockDef.sprite)
				objects.world[newName].spritePivotX = xp
				objects.world[newName].spritePivotY = yp
				objects.world[newName].damageSprite = blockDef.sprite
				objects.world[newName].xVel = 0 --flyingBird.xVel * 0.5
				objects.world[newName].yVel = 1000 --flyingBird.yVel * 0.5
				setSprite(newName, objects.world[newName].damageSprite)
				setRotation(newName, flyingBird.angle)
				--setVelocity(newName, flyingBird.xVel*0.5, flyingBird.yVel*0.5)
				setVelocity(newName, objects.world[newName].xVel, objects.world[newName].yVel)
				--objects.world[newName].specialty = "BOMB"
				--_G.table.insert(flyingGrenades, { name = newName, timer = 5 })
				--_G.table.insert(extraObjects, newName)
				_G.res.playAudio(getAudioName(blockTable.blocks[flyingBird.definition].specialSound), 1, false)
				--_G.res.playAudio(getAudioName("bird_pushing_egg_out"), 1, false)
				
				local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
				addPuffToTrajectory(1, lx, ly)
				
				flyingBird.eagleTimer = 0
				flyingBird.eagleMoving = false
			end	--]]
		else
			
			dragStarted = true
			dragCursorTable = {}
			dragCursorIndex = 1
			dragCursorTable[dragCursorIndex] = { dx = 0, dy = 0, dt = dt }
			tapPosWorld.x = cursorWorld.x
			tapPosWorld.y = cursorWorld.y
			
			--on the pc version, the touchcount will be zero if the user is using the mouse solely
			--if touchcount == 1 then
			if currentBirdName ~= nil then
				local obj = objects.world[currentBirdName]
				if deviceModel == "roku" then
					panToBirdCamera()

				else
					local t_slingshotHitAreaRange = 1.2
					local distanceLimit = t_slingshotHitAreaRange/worldScale * screenWidth/480
					if distance(obj.x, obj.y, cursorPhysics.x, cursorPhysics.y) < distanceLimit then
						selectedBird = obj
					end
				end
			end
			--end
		end
	end
	
	
	--the g_birdDragOnTouchAttributes code below is related to having the sligshot bird dragging
	--by touching the trackpad (not clicking), this code has priority over the mouse input
	--so it bypass the forthcoming input handling code
	
	
	--the zoom cooling time is the time the user must wait until he finished a zooming operation to lauch a bird	
	local t_isZoomFinished = true
	if multitouchZoom.zoomCoolingTime > -1 then
		t_isZoomFinished = false
		
		--we only start considering the time if the user has no fingers on the trackpad, otherwise if he would be holding the button
		--the bird would snap to the dragging position when the time reaches the limit
		if (g_mouseOrTouchStates.isUsingMouse == false) and touchcount == 0 then
			multitouchZoom.zoomCoolingTime = multitouchZoom.zoomCoolingTime + dt
		end
		
		if multitouchZoom.zoomCoolingTime > 0.5 then
			multitouchZoom.zoomCoolingTime = -1
			t_isZoomFinished = true
		end
	end
	
	--[[
	if g_birdDragOnTouchAttributes.draggingCancelledBySnap then
		if touchcount == 0 then
			g_birdDragOnTouchAttributes.draggingCancelledBySnap = false
		end
	end
	]]
	
	--if the player has pressed the bird specialty but the finger is still in touch, we must wait until the player removes the finger
	--in order to starting dragging the next bird on the slingshot
	if g_birdDragOnTouchAttributes.disabledForBirdSpecialty == true then
		if touchcount == 0 then
			g_birdDragOnTouchAttributes.disabledForBirdSpecialty = false
		end
	end
	
	if g_birdDragOnTouchAttributes.needsNewTouchToDrag == true then
		if touchcount == 0 then
			g_birdDragOnTouchAttributes.needsNewTouchToDrag = false
		end
	end
	
	if 	g_birdDragOnTouchAttributes.enabled == true and (g_mouseOrTouchStates.isUsingMouse == false and t_isZoomFinished) and not levelCompleted and not g_birdDragOnTouchAttributes.disabledForBirdSpecialty 
		and not birdSpecialtyAvailable and (not g_birdDragOnTouchAttributes.needsNewTouchToDrag) and deviceModel ~= "roku" then
	--if g_birdDragOnTouchAttributes.enabled == true and (g_mouseOrTouchStates.isUsingMouse == false and t_isZoomFinished) and (not g_birdDragOnTouchAttributes.draggingCancelledBySnap) then
		local shootMaxLength = rubberBandMaximumLength()
		if g_birdDragOnTouchAttributes.dragging then
			if touchcount == 1 then
				--still dragging
					
				if selectedBird == nil then
					--for some reason, the bird has already been released (mouse click input for example)
					g_birdDragOnTouchAttributes.dragging = false
				else
				
					g_currentCursorName = "CURSOR_HAND_GRAB"
					
					draggingStartPosPhysics.x = levelStartPosition.x
					draggingStartPosPhysics.y = levelStartPosition.y
					-- for the slingshot
					if birdReady == true then
						local t_cursorPhysics = {}
						
						if touches ~= nil then
							if g_birdDragOnTouchAttributes.touchOneID ~= nil and touches[g_birdDragOnTouchAttributes.touchOneID] ~= nil then
								t_cursorPhysics.x, t_cursorPhysics.y = screenToPhysicsTransform(touches[g_birdDragOnTouchAttributes.touchOneID].x, touches[g_birdDragOnTouchAttributes.touchOneID].y)
							else
								t_cursorPhysics.x, t_cursorPhysics.y = cursorPhysics.x, cursorPhysics.y
							end
						else
							t_cursorPhysics.x, t_cursorPhysics.y = cursorPhysics.x, cursorPhysics.y
						end
						
						
						
						local t_diffX = t_cursorPhysics.x - g_birdDragOnTouchAttributes.dragLastPosPhysics.x
						local t_diffY = t_cursorPhysics.y - g_birdDragOnTouchAttributes.dragLastPosPhysics.y
						
						
						g_birdDragOnTouchAttributes.dragLastPosPhysics.x = t_cursorPhysics.x
						g_birdDragOnTouchAttributes.dragLastPosPhysics.y = t_cursorPhysics.y

						--the rubber band stretching code has been originally written to be based on the cursor. With the touches approach
						--we need to loose the band if the band is already stretched to max but the user input has decreased from the last position
						--The rubber band code has a lot of factors which I dont understand (look for rubberBandAngle >= -1.9 below and similar tweaking values)
						--so I am simulating absolute touches coordinates as if the player has clicked on the level startPosition and the maximum touch coordinate it can 
						--receive is the actual rubber band position retrieved with calculateRubberPosition
						
						local t_rubberPosition = calculateRubberPosition(t_diffX, t_diffY, g_birdDragOnTouchAttributes.dragLastRubberPos.x, g_birdDragOnTouchAttributes.dragLastRubberPos.y)
						
						g_birdDragOnTouchAttributes.dragLastRubberPos.x = t_rubberPosition.x
						g_birdDragOnTouchAttributes.dragLastRubberPos.y = t_rubberPosition.y
						g_birdDragOnTouchAttributes.dragRubberLength = t_rubberPosition.distance
						
						--simulating new touch coordinates (read comment above)
						g_birdDragOnTouchAttributes.dragStartPosPhysics.x = levelStartPosition.x
						g_birdDragOnTouchAttributes.dragStartPosPhysics.y = levelStartPosition.y
						t_cursorPhysics.x = t_rubberPosition.x
						t_cursorPhysics.y = t_rubberPosition.y
						--end of simulating new touch coordinates
						
						local vecToRest = { x = levelStartPosition.x - t_cursorPhysics.x, y = levelStartPosition.y - t_cursorPhysics.y }
						stretchRubberBand(vecToRest)
					end
				end
			end
			
			-- Shoot the bird
			if touchcount == 0 or (touchcount == 1 and keyReleased["LBUTTON"]) then
				local t_cursorPhysics = {}
				t_cursorPhysics.x, t_cursorPhysics.y = g_birdDragOnTouchAttributes.dragLastPosPhysics.x, g_birdDragOnTouchAttributes.dragLastPosPhysics.y

				--the rubber band stretching code has been originally written to be based on the cursor. With the touches approach
				--we need to loose the band if the band is already stretched to max but the user input has decreased from the last position
				--The rubber band code has a lot of factors which I dont understand (look for rubberBandAngle >= -1.9 above and similar tweaking values)
				--so I am simulating absolute touches coordinates as if the player has clicked on the level startPosition and the maximum touch coordinate it can 
				--receive is the actual rubber band position retrieved with calculateRubberPosition

				--simulating new touch coordinates (read comment above)
				t_cursorPhysics.x, t_cursorPhysics.y = g_birdDragOnTouchAttributes.dragLastRubberPos.x, g_birdDragOnTouchAttributes.dragLastRubberPos.y
				local distToRest = g_birdDragOnTouchAttributes.dragRubberLength
				--end of simulating new touch coordinates (read comment above)

				if (shootMaxLength == nil) or (shootMaxLength <= 0) or (rubberBandLength <= 0) or (rubberBandLength == nil) or (distToRest <= 0) then
					selectedBird = nil

				elseif distToRest <= g_birdDragOnTouchAttributes.shootMinLength then
					cancelBirdDrag()

				elseif selectedBird ~= nil then
					local vecToRest = { x = levelStartPosition.x - t_cursorPhysics.x, y = levelStartPosition.y - t_cursorPhysics.y }
					shootSelectedBird(vecToRest)
				end
				
				g_birdDragOnTouchAttributes.dragging = false
				g_birdDragOnTouchAttributes.previousTouchCount = 1
				g_birdDragOnTouchAttributes.lastCursorX = -1
				g_birdDragOnTouchAttributes.lastCursorY = -1
				
				g_birdDragOnTouchAttributes.elapsedTimeAtRest = g_birdDragOnTouchAttributes.targetRestTime + 1
				
				g_birdDragOnTouchAttributes.dragStartPosPhysics.x = nil
				g_birdDragOnTouchAttributes.dragStartPosPhysics.y = nil
				
				g_birdDragOnTouchAttributes.dragLastPosPhysics.x = nil
				g_birdDragOnTouchAttributes.dragLastPosPhysics.y = nil
			end
		else
			local t_newDragAllowed = true
			local t_validTimeLimit = g_birdDragOnTouchAttributes.elapsedTimeAtRest < g_birdDragOnTouchAttributes.targetRestTime
			local t_cursorChanged = g_birdDragOnTouchAttributes.lastCursorX ~= cursorX or g_birdDragOnTouchAttributes.lastCursorY ~= cursorY	
			
			local t_hoveredObject = nil
			
			if currentBirdName ~= nil and (touchcount == 1) then
				local obj = objects.world[currentBirdName]
				t_hoveredObject = obj
			end
			
			if touchcount == 0 then
				if g_birdDragOnTouchAttributes.previousTouchCount == 1 then
					
				else
				
				end
			elseif touchcount == 1 then
				if g_birdDragOnTouchAttributes.previousTouchCount == 0 then		
					--mouse down detected
					
					if t_validTimeLimit then
						
					else
						g_birdDragOnTouchAttributes.elapsedTimeAtRest = 0
						t_newDragAllowed = false;
					end
					
					if t_hoveredObject ~= nil then
						
					else
						g_birdDragOnTouchAttributes.elapsedTimeAtRest = 0
					end
				else
					--dragging around
					--t_newDragAllowed = false;
				end
			end
			
			
			--print("\n NOT DRAGGING")
			--[[
			t_newDragAllowed = 	t_newDragAllowed and (touchcount == 1) and (g_birdDragOnTouchAttributes.previousTouchCount == 0) and
								(not levelCompleted) and (multitouchSweep.isSweepping ~= true) and
								(selectedBird == nil) and
								(not t_cursorChanged)
								]]
			t_newDragAllowed = 	t_newDragAllowed and (touchcount == 1) and
								(not levelCompleted) and (multitouchSweep.isSweepping ~= true) and
								(selectedBird == nil) and
								(not t_cursorChanged)
								
			--t_newDragAllowed = t_newDragAllowed and cameraAnimationSlider < 0.1
			
			
			if t_hoveredObject ~= nil then
				--print("\n object " .. t_hoveredObject.x .. " " .. t_hoveredObject.y)
				local t_x, _ = physicsToScreenTransform(t_hoveredObject.x, t_hoveredObject.y)
				
				if t_x > 0 then
					panToBirdCamera()
					t_newDragAllowed = true
				else
					t_newDragAllowed = false
				end
					
			end
			
			--if cameraAnimationSlider > 0.001 then
			if isTouchDragAllowed() == false then
				g_birdDragOnTouchAttributes.needsNewTouchToDrag = true
				t_newDragAllowed = false
			end

			--on windows, there is a framework issue that a mouse press sets the touchcount to 1, this check avoids trackpad/mouse conflicts
			if keyHold["LBUTTON"] and g_mouseOrTouchStates.doesMouseClickSetsCount == true then
				t_newDragAllowed = false
			end

			if t_newDragAllowed and  t_hoveredObject ~= nil then
				selectedBird = t_hoveredObject
				g_birdDragOnTouchAttributes.dragging = true		
				
				local t_cursorPhysics = {}
	
				
				if touches ~= nil then
					for k,v in _G.pairs(touches) do
						--get the first touch id
						g_birdDragOnTouchAttributes.touchOneID = k
						break
					end
					if g_birdDragOnTouchAttributes.touchOneID ~= nil then
						t_cursorPhysics.x, t_cursorPhysics.y = screenToPhysicsTransform(touches[g_birdDragOnTouchAttributes.touchOneID].x, touches[g_birdDragOnTouchAttributes.touchOneID].y)
					else
						t_cursorPhysics.x, t_cursorPhysics.y = cursorPhysics.x, cursorPhysics.y
					end
				else
					t_cursorPhysics.x, t_cursorPhysics.y = cursorPhysics.x, cursorPhysics.y
				end
						
						
				g_birdDragOnTouchAttributes.dragStartPosPhysics.x = t_cursorPhysics.x
				g_birdDragOnTouchAttributes.dragStartPosPhysics.y = t_cursorPhysics.y
				
				g_birdDragOnTouchAttributes.dragLastPosPhysics.x = t_cursorPhysics.x
				g_birdDragOnTouchAttributes.dragLastPosPhysics.y = t_cursorPhysics.y
				
				g_birdDragOnTouchAttributes.diff = {}
				g_birdDragOnTouchAttributes.dragLastRubberPos = {}
				
				
				g_birdDragOnTouchAttributes.diff.x = 0
				g_birdDragOnTouchAttributes.diff.y = 0
				
				g_birdDragOnTouchAttributes.dragLastRubberPos.x = levelStartPosition.x
				g_birdDragOnTouchAttributes.dragLastRubberPos.y = levelStartPosition.y
				g_birdDragOnTouchAttributes.dragRubberLength = 0
				
				captureMouse(true)
				
				--print("\n starting to drag " .. g_birdDragOnTouchAttributes.dragStartPosPhysics.x .. " " .. g_birdDragOnTouchAttributes.dragStartPosPhysics.y)
			end
			
			
			
			--just to avoid this to pile up
			g_birdDragOnTouchAttributes.elapsedTimeAtRest = _G.math.min(g_birdDragOnTouchAttributes.elapsedTimeAtRest, g_birdDragOnTouchAttributes.targetRestTime + 1)
			
			g_birdDragOnTouchAttributes.lastCursorX = cursorX
			g_birdDragOnTouchAttributes.lastCursorY = cursorY
			g_birdDragOnTouchAttributes.previousTouchCount = touchcount
		end
		
	end
	
	if g_birdDragOnTouchAttributes.dragging and levelCompleted then
		cancelBirdDrag()
	end
	
	local t_touchBirdDragging = (g_birdDragOnTouchAttributes.enabled and g_birdDragOnTouchAttributes.dragging)
	

	if keyHold["LBUTTON"] and not levelCompleted and not multitouchSweep.isSweepping
		and not t_touchBirdDragging and dragStarted then

		dragCursorIndex = dragCursorIndex + 1
		if dragCursorIndex > 5 then
			dragCursorIndex = 1
		end
		dragCursorTable[dragCursorIndex] = { dx = cursor.x - oldCursor.x, dy = cursor.y - oldCursor.y, dt = dt }

		if deviceModel == "roku" then
			rokuDragVector.x = rokuDragVector.x + cursor.dx * g_rokuDragSensitivity
			rokuDragVector.y = rokuDragVector.y + cursor.dy * g_rokuDragSensitivity
		end

		if selectedBird ~= nil then
			--changes the cursor, for dragging the bird
			g_currentCursorName = "CURSOR_HAND_GRAB"
			
			draggingStartPosPhysics.x = levelStartPosition.x
			draggingStartPosPhysics.y = levelStartPosition.y
			
			-- for the slingshot
			if birdReady == true then
				if deviceModel ~= "roku" then
					stretchRubberBand({
						x = draggingStartPosPhysics.x - cursorPhysics.x,
						y = draggingStartPosPhysics.y - cursorPhysics.y })
				else
					-- limit drag vector length
					local t_length = vLength(rokuDragVector.x, rokuDragVector.y)
					local t_maxLength = rubberBandMaximumLength() * physicsToScreenMultiplier()
					if t_length > t_maxLength then
						rokuDragVector.x = rokuDragVector.x * (t_maxLength / t_length)
						rokuDragVector.y = rokuDragVector.y * (t_maxLength / t_length)
					end
					
					local vecToRest = {}
					vecToRest.x, vecToRest.y = screenToPhysicsVectorTransform(-rokuDragVector.x, -rokuDragVector.y)
					stretchRubberBand(vecToRest)
				end
			end
		else
			local dx = (objects.castleCameraData[deviceModel].px - objects.birdCameraData[deviceModel].px)
			if deviceModel == "roku" then
				-- only start dragging a bird when the camera is close to the left edge
				if currentBirdName and (cameraAnimationSlider < 0.05 or dx < 1) then
					rokuDragVector = { x = 0, y = 0 }
					selectedBird = objects.world[currentBirdName]
					if not rokuOnWindows then captureMouse(true) end
				end
			
			-- camera drag panning
			elseif dx > 1 then
				local delta = dragCursorTable[dragCursorIndex].dx / (dx * worldScale)
				sweepSpeed = 0
				cameraAnimationSlider = cameraAnimationSlider - delta
				cameraFunction = doItAllCamera
			end

			if deviceModel == "n900" then
				local angle = _G.math.abs(_G.math.atan2(dragCursorTable[dragCursorIndex].dy, dragCursorTable[dragCursorIndex].dx))
				--print("angle: " .. angle .. "\n")
				if _G.math.pi*0.3333 < angle and angle < _G.math.pi*0.6666 or _G.math.pi*1.3333 < angle and angle < _G.math.pi*1.6666 then
					--local deltay = dragCursorTable[dragCursorIndex].dy * 0.00125 * (((objects.castleCameraData[deviceModel].right - objects.birdCameraData[deviceModel].left)/screenWidth) - worldScale) / worldScale
					local deltay = dragCursorTable[dragCursorIndex].dy * 0.00125
					zoomLevel = zoomLevel + deltay
				end
			end
		end
	end


	if (keyReleased["LBUTTON"] or not keyHold["LBUTTON"]) and not multitouchSweep.isSweepping and not t_touchBirdDragging then
		--checks if the cursor is in the bird selection area, mouse over state 
		if currentBirdName ~= nil then
			local obj = objects.world[currentBirdName]
			if obj ~= nil then
				local t_mouseHitAreaRange = 0.6
				--if distance(obj.x, obj.y, cursorPhysics.x, cursorPhysics.y) < shootRange/worldScale * screenWidth/480 then					
				if distance(obj.x, obj.y, cursorPhysics.x, cursorPhysics.y) < t_mouseHitAreaRange/worldScale * screenWidth/480 then					
					--changes the cursor, for dragging the bird
					g_currentCursorName = "CURSOR_HAND_HOVER"
				end
			end
		end
		
		--not holding LBUTTON
		if dragStarted and keyReleased["LBUTTON"] and selectedBird ~= nil and not levelCompleted then
			settings.birdsShooted = settings.birdsShooted + 1
			if settings.birdsShooted >= 5000 then
				addToAchievementUnlockQueue("Bird Slinger", true)
			end
		end
		
		if dragStarted then
			dragStarted = false

			local vecToRest = {}
			if deviceModel ~= "roku" then
				vecToRest.x, vecToRest.y = draggingStartPosPhysics.x - cursorPhysics.x, draggingStartPosPhysics.y - cursorPhysics.y
			else
				if not rokuOnWindows then captureMouse(false) end
				vecToRest.x, vecToRest.y = screenToPhysicsVectorTransform(-rokuDragVector.x, -rokuDragVector.y)
			end

			local shootMaxLength = rubberBandMaximumLength()
			local distToRest = vLength(vecToRest.x, vecToRest.y)
			if (shootMaxLength == nil) or (shootMaxLength <= 0) or (rubberBandLength <= 0) or (rubberBandLength == nil) or (distToRest <= 0) then
				selectedBird = nil

			elseif distToRest <= g_birdDragOnTouchAttributes.shootMinLength then
				cancelBirdDrag()

			elseif selectedBird ~= nil and not levelCompleted  then
				shootSelectedBird(vecToRest)

			else
				local i = 1
				local dxSum = 0
				local dtSum = 0
				local speed = 0
				while i <= #dragCursorTable do
					if dragCursorTable[i] == nil then
						break
					end
					dtSum = dtSum + dragCursorTable[i].dt
					dxSum = dxSum + dragCursorTable[i].dx
					--print("SEvent: dx:" .. dragCursorTable[i].dx .. " dt:" .. dragCursorTable[i].dt .. "\n")
					i = i + 1
				end
				speed = dxSum / dtSum
				
				
				--this is the new fix, if the game is running on high framerates, the dragCursorTable values would always be 0
				if g_mouseDragAttributes.mouseDragTime > g_mouseDragAttributes.minDragTime then
					speed = g_mouseDragAttributes.cummulativeDragX / g_mouseDragAttributes.mouseDragTime
				else
					speed = 0
				end
				
				-- if #dragCursorTable < 2 then
					-- speed = 0
				-- end
				dragCursorTable = {}
				--fix for issue 578, it wasnt restoring the index, so it would be incremented in the update, possibly crashing on the while loop above
				dragCursorIndex = 0

				if touchcount == 1 and distance(draggingStartPosScreen.x, draggingStartPosScreen.y, cursor.x, cursor.y) > screenWidth * 0.1 or _G.math.abs(speed) > 200 then
					sweepSpeed = speed
					if _G.math.abs(sweepSpeed) > 0 then
						--print("SweepSpeed: " .. sweepSpeed .. "\n")
						if _G.math.abs(draggingStartPosScreen.x - cursor.x) > _G.math.abs(draggingStartPosScreen.y - cursor.y) then
							if draggingStartPosScreen.x - cursor.x > 0 then
								leftSweep = true
							else
								rightSweep = true
							end
						end
						
						if _G.math.abs(sweepSpeed) < 200 then
							--take sign and multiply by 100
							sweepSpeed = sweepSpeed/_G.math.abs(sweepSpeed) * 200
						end
						if _G.math.abs(sweepSpeed) > 5000 then
							sweepSpeed = sweepSpeed/_G.math.abs(sweepSpeed) * 5000
						end
					end

				-- NOTE: this canceled the camera panning on Roku
				elseif deviceModel ~= "roku" then
					sweepSpeed = 0
				end
			end

			if leftSweep == true and sweepSpeed < 0 then
				--print("leftSweep: cameraFunction = doItAllCamera\n")
				cameraFunction = doItAllCamera
				cameraAnimationSliderTarget = 1
				if cameraAnimationSlider < 0 then
					cameraAnimationSlider = 0
				end
				doubleClickTimer = 0
			end
			if rightSweep == true and sweepSpeed > 0 then
				animationScreen.x = screen.x
				animationScreen.y = screen.y
				animationWorldScale = worldScale
				--print("rightSweep: cameraFunction = doItAllCamera\n")	
				cameraFunction = doItAllCamera
				cameraAnimationSliderTarget = 0
				if cameraAnimationSlider > 1 then
					cameraAnimationSlider = 1
				end
				allowResetToBirdCamera = false
				cameraTargetObject = nil
				--print(currentFrame .. " Right sweep: camera target object set to nil\n")
				--flyingBird = nil  -- this was commented as a bugfix to boomerang bird beak not bruising after camera sweep
				doubleClickTimer = 0
				showTapIcon = false
				showTapTimer = 0
			end

			if tapStarted then
				if vLength(cursor.x - tapPosition.x, cursor.y - tapPosition.y) < tapRadius then
					tapCount = tapCount + 1
					tapTimer = 0
				end
			end	
		end
	end

	if releaseBuild ~= true then
		
		
		if deviceModel == "roku" then
			if keyPressed["KEY_GAMING_A"] then
				if rokuClickTimer > 0 then
					rokuClickCounter = rokuClickCounter + 1
					rokuClickTimer = 0.5
				else
					rokuCheat = false
					rokuClickTimer = 0.5
					rokuClickCounter = 1
				end
			end
			
			if rokuClickTimer <= 0 and rokuClickCounter > 0 then
				rokuCheat = true
			end
		end
		
		if keyPressed["LBUTTON"] then
			if quadClickTimer > 0 and cursor.x > screenWidth - 40 and cursor.y < 40 then
				quadClickCounter = quadClickCounter + 1
				quadClickTimer = 0.5
				if quadClickCounter >= 4 then
					quadClick = true
				end
			else
				quadClick = false
				quadClickTimer = 0.5
				quadClickCounter = 1
			end
		end
	end

	-- if allowResetToBirdCamera == true then print("allowResetToBirdCamera: pass")	end
	-- if hasMovingObjects == false then print(" hasMovingObjects: pass") end
	-- if levelCompleted == false then print(" levelCompleted: pass") end
	-- if birdSpecialtyAvailable == false then print(" birdSpecialtyAvailable: pass") end
	-- print("\n")

	-- NOTE: for some reason the variable hasMovingObjectsZeroTolerance is was never being
	--       set to false so the camera is was never resetted to the bird view,
	--       assuming this was intended, a roku specific workaround was implemented
	if allowResetToBirdCamera and not hasMovingObjects and not levelCompleted and not birdSpecialtyAvailable then

		if cameraResetTimer <= 0 then
			cameraResetTimer = 0.5
		end

		cameraResetTimer = cameraResetTimer - dt

		if cameraResetTimer <= 0 then
			--print("Moving to start position. Camera target object set to nil.\n")
			--print(currentFrame .. " Automatic camera reset: camera target object set to nil\n")
			cameraFunction = doItAllCamera
			sweepSpeed = objects.castleCameraData[deviceModel].px - objects.birdCameraData[deviceModel].px
			cameraAnimationSliderTarget = 0
			allowResetToBirdCamera = false
			cameraTargetObject = nil
			flyingBird = nil
			showTapIcon = false
			showTapTimer = 0
		end
	end	

	-- tap icon handling
	-- if allowResetToBirdCamera == true and showTapTimer <= 0 and cameraAnimationSliderTarget == 1 and birdSpecialtyAvailable == false and cameraTargetObject == nil then
		-- showTapTimer = 0.5
	-- end

	if showTapTimer <= 0 and cameraAnimationSliderTarget == 1 and birdSpecialtyAvailable == false and cameraTargetObject == nil then
		showTapTimer = 0.5
	end
	
	if cameraAnimationSliderTarget == 0 then
		showTapTimer = 0
		showTapIcon = false
	end
	
	if showTapTimer > 0 then
		showTapTimer = showTapTimer - dt
		if showTapTimer <= 0 then
			showTapIcon = true
		end
	end	
	
	-- fill the next bird
	animateBirdToSlingShot(dt)
	
	-- trajectory
	local recordTrajectory = false
	if flyingBird ~= nil then
		if flyingBird.recordTrajectory ~= false then
			recordTrajectory = true
			local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
			local bt = birdTrajectory[1] 
			if #bt < 1 or vLength(lx - bt[#bt].x, ly - bt[#bt].y) > 20 then
				-- if getObjectDefinition(flyingBird.name).particlesTrail ~= nil then
					-- addParticles(flyingBird.name, getObjectDefinition(flyingBird.name).particlesTrail, 1)
				-- end
				_G.table.insert(bt, { x = lx, y = ly })
				addToTrajectory(1, lx, ly)
			end
		end
		
		-- space invader achievement (not allowed for the bomb bird)
		if flyingBird.definition ~= "BasicBird2" then
			if previousSpaceInvaderY == nil then
				previousSpaceInvaderY = 0
			end
			if previousSpaceInvaderY > -125 and flyingBird.y <= -125 then
				addToAchievementUnlockQueue("Space Invader", true)
			end
			previousSpaceInvaderY = flyingBird.y
		end
	end
	
	if otherBirds ~= nil then
		for i = 1, 2 do
			local obj = objects.world[otherBirds[i]]
			if obj ~= nil then
				if obj.recordTrajectory ~= false then
					recordTrajectory = true
					local lx, ly = physicsToWorldTransform(obj.x, obj.y)
					local bt = birdTrajectory[i+1] 
					if #bt < 1 or vLength(lx - bt[#bt].x, ly - bt[#bt].y) > 20 then
						-- if getObjectDefinition(obj.name).particlesTrail ~= nil then
							-- addParticles(obj.name, getObjectDefinition(obj.name).particlesTrail, 1)
						-- end
						_G.table.insert(bt, { x = lx, y = ly })
						addToTrajectory(i+1, lx, ly)
					end
				end
			end
		end
	end

	if recordTrajectory == false then
		if allowTrajectoryClearing == true then
			startNewTrajectory()
			allowTrajectoryClearing = false
		end
	end
	
	if birdReady == true then
		--print("Bird is ready!\n")
		if currentBirdName ~= nil then
			--print("Setting position and velocity. " .. currentBirdName .. "\n")
			setPosition(currentBirdName, rubberBandPos.x, rubberBandPos.y)
			setVelocity(currentBirdName, 0, 0)
		end
	end

	-- we have fired a bird from the slingshot
	if birdFired then
	
		local rubberBandDtLeft = dt
		local rubberBandDt
		
		-- Integrate rubber band position multiple times if time step is too large
		while rubberBandDtLeft > 0 do
		
			if rubberBandDtLeft < 0.05 then
				rubberBandDt = rubberBandDtLeft
			else
				rubberBandDt = 0.05
			end
			
			rubberBandDtLeft = rubberBandDtLeft - rubberBandDt
		
			local distToRest = distance(levelStartPosition.x, levelStartPosition.y, rubberBandPos.x, rubberBandPos.y)
			local vecToRest = { x = levelStartPosition.x - rubberBandPos.x, y = levelStartPosition.y - rubberBandPos.y }

			rubberBandAngle = _G.math.atan2(vecToRest.y, vecToRest.x)
			rubberBandLength = distToRest

			rubberBandSpeed = rubberBandSpeed + dampedSpring(springConstant, springDampening, distToRest, rubberBandSpeed) * 0.05 * physicsScale
			if distToRest > 0 then
				rubberBandPos.x = rubberBandPos.x + (vecToRest.x / distToRest) * rubberBandSpeed * rubberBandDt
				rubberBandPos.y = rubberBandPos.y + (vecToRest.y / distToRest) * rubberBandSpeed * rubberBandDt
				rubberBandLength = distance(levelStartPosition.x, levelStartPosition.y, rubberBandPos.x, rubberBandPos.y)
			end
		end
	end
	
	-- explode the granade
	for i = #flyingGrenades, 1, -1 do
		if flyingGrenades[i].explode == true then
			local flyingGrenade = flyingGrenades[i].name
			local grenadeDef = getObjectDefinition(flyingGrenade)
			addParticles(flyingGrenade, grenadeDef.particles, 6)
			makeExplosion(objects.world[flyingGrenade], grenadeDef, getAudioName("special_explosion"))
			addParticles(flyingGrenade, "eggShells", 5)
			if cameraTargetObject ~= nil and cameraTargetObject.name == flyingGrenades[i].name then
				cameraTargetObject = nil
			end
			removeObject(flyingGrenade)
			objects.world[flyingGrenade] = nil
			_G.table.remove(flyingGrenades, i)
		end
	end

	if eagleTimer ~= nil then
		eagleTimer = eagleTimer - dt
	end

	if eagleDarkness ~= nil then
		eagleDarkness = eagleDarkness - dt * 0.4
		eagleDarkness = _G.math.max(_G.math.min(eagleDarkness, 0.5), 0)
	end
	
	-- loop over all objects and do updates if necessary
	for k, v in _G.pairs(objects.world) do
		-- remove birds if criteria is met
		if v.bombTimer ~= nil then
			v.bombTimer = v.bombTimer - dt
			if v.bombTimer < 0 then
				makeExplosion(v, getObjectDefinition(k), getAudioName("special_explosion"))
				removeBird(v)
			elseif v.bombTimer < 1 then
				v.damageSprite = "BIRD_GREY_3"
				setSprite(v.name, v.damageSprite)
			elseif v.bombTimer < 2 then
				v.damageSprite = "BIRD_GREY_2"
				setSprite(v.name, v.damageSprite)
			end
		elseif v.isEagleBait == true and eagleTimer ~= nil then
			if eagleTimer < 6.2 and eagleMoving == true then
				birdSpecialtyAvailable = false
				eagleMoving = false
				createMightyEagle(v.x, v.y)
				--print("Mighty Eagle coming!")
			end
		elseif v.name == "MightyEagle_a" then
			--local eagleHeight = objects.world["ground"].y - v.y
			eagleHeight = levelStartPosition.y - v.y
			if objects.world["ground"].y - v.y < 0 then
				v.lowerThanGround = true
			end
			eagleHeight = _G.math.max(_G.math.min(eagleHeight, 50), 0)
			--print("eagleHeight: " .. eagleHeight .. "\n")
			local speed = 10000
			v.particleTimer = v.particleTimer + dt
			local particleAmount = _G.math.floor(v.particleTimer / v.particleTimerLimit)
			if particleAmount > 0 then
				v.particleTimer = _G.math.fmod(v.particleTimer, v.particleTimerLimit)
				addParticles(v.name, "mightyEagleParticles", particleAmount)
			end	
			if v.hitGround ~= true then -- and v.x < v.targetX then
				--cameraShake = ((50 - eagleHeight) * (50 - eagleHeight) * (50 - eagleHeight) * (50 - eagleHeight)) / 209000
				--v.wantedVelX, v.wantedVelY = vNormalize(v.targetX - v.x, v.targetY - v.y)
				local angle = _G.math.atan2(v.initVelY, v.initVelX)
				setVelocity(v.name, v.initVelX * speed, v.initVelY * speed)
				setRotation(v.name, angle)
			elseif v.hitGround == true then
				setVelocity(v.name, v.initVelX * speed, -v.initVelY * speed)
				setAngularVelocity(v.name, _G.math.pi * 4)
			end
		else
			if v.controllable and v.shot == true then
				
				if v.isReadyForRemoveTimer ~= nil and vLength(v.xVel, v.yVel) < 0.05 then
					v.isReadyForRemoveTimer = v.isReadyForRemoveTimer - dt
				else
					v.isReadyForRemoveTimer = 1.0
				end
				
				if v.isReadyForRemoveTimer < 0 and cameraTargetObject == nil then
					--print(currentFrame .. " Removing stopped bird.\n")
					removeBird(v)
					v = nil
				end
			end
		end
		
		-- remove all frozen objects
		if v ~= nil and v.frozen then
			
			if v.controllable then
				if v.isEagleBait == true then
					eagleX, eagleY = v.x, v.y
					--print("baitSardine frozen!\N")
					if eagleTimer == nil then
						eagleTimer = 8.7
						eagleMoving = true
					end
				end
				if v.boomerangActive ~= true then
					removeBird(v)
				end
				if v.isMightyEagle and v.hitGround ~= true then
					cameraShake = 100
					_G.res.playAudio("mighty_eagle_thump", 1, false)
					for k2, v2 in _G.pairs(objects.world) do
						if v2 ~= nil then
							if v2.strength ~= nil and v2.levelGoal then
								local force = -v2.mass * 15
								applyImpulse( v2.name,
											0,
											force,
											v2.x,
											v2.y )
								v2.strength = 0.00001
								v2.defence = 0
							end
						end
					end
					eagleTimer = 4
				end
			else
				removeObject(k)
				objects.world[k] = nil
				levelGoals[k] = nil
			end
			v = nil
		end
	end
	
	if eagleTimer ~= nil then
		--print("eagleTimer: " .. eagleTimer .. "\n")
		if eagleTimer < 6.2 and eagleMoving == true and eagleX ~= nil and eagleY ~= nil then
			birdSpecialtyAvailable = false
			eagleMoving = false
			--[[local ccd = objects.castleCameraData[deviceModel]
			local wx1, wy1 = worldToPhysicsTransform(ccd.left, ccd.top)
			local wx2, wy2 = worldToPhysicsTransform(ccd.right, ccd.bottom)
			
			createMightyEagle((wx1 + wx2) * 0.5, (wy1 + wy2) * 0.5)--]]
			createMightyEagle(eagleX, eagleY)
		elseif eagleTimer < 7.7 and eagleSoundPlayed ~= true then
			_G.res.playAudio("mighty_eagle_yell", 1, false)
			eagleSoundPlayed = true
		
		end
		if cameraShake ~= nil and cameraShake > 0 then
			--cameraShake = _G.math.max(cameraShake - 200 * dt, 0)
			cameraShake = _G.math.max(cameraShake - cameraShake*dt*2.2, 0)
		end
		if eagleTimer < 0 then
			for k, v in _G.pairs(objects.world) do
				if v.strength ~= nil and v.levelGoal then
					v.strength = 0
				end
			end
		end
	end

	--print("\n slider is " .. cameraAnimationSlider)

	if multitouchSweep.isSweepping == true then
		local t_dx = multitouchSweep.sweepOffsetX
		
		local t_targetsDx = (objects.castleCameraData[deviceModel].px - objects.birdCameraData[deviceModel].px)
		if t_targetsDx > 1 then
			local delta = t_dx / (t_targetsDx * worldScale)			
			cameraAnimationSlider = cameraAnimationSlider - delta				
		end

		sweepSpeed = 0
		cameraFunction = doItAllCamera	

		cameraAnimationSlider = _G.math.max(0, cameraAnimationSlider)
		cameraAnimationSlider = _G.math.min(1, cameraAnimationSlider)

		if cameraAnimationSlider > 0.5 then
			cameraAnimationSliderTarget = 1
		else
			cameraAnimationSliderTarget = 0
		end
		
	elseif multitouchSweep.sweepSpeed ~= 0 and multitouchSweep.sweepSpeed ~= nil then

		local t_absSpeed = _G.math.abs(multitouchSweep.sweepSpeed)
		if t_absSpeed < 200 then
			sweepSpeed = 0
			cameraFunction = doItAllCamera	

			cameraAnimationSlider = _G.math.max(0, cameraAnimationSlider)
			cameraAnimationSlider = _G.math.min(1, cameraAnimationSlider)

			if cameraAnimationSlider > 0.5 then
				cameraAnimationSliderTarget = 1
			else
				cameraAnimationSliderTarget = 0
			end
		else

			sweepSpeed = multitouchSweep.sweepSpeed				
			
			if sweepSpeed < 0 then
				leftSweep = true
			else
				rightSweep = true
			end		
		
			if _G.math.abs(sweepSpeed) < 200 then
				--take sign and multiply by 100
				sweepSpeed = sweepSpeed/_G.math.abs(sweepSpeed) * 200
			end
			if _G.math.abs(sweepSpeed) > 5000 then
				sweepSpeed = sweepSpeed/_G.math.abs(sweepSpeed) * 5000
			end
		
			if leftSweep == true and sweepSpeed < 0 then
				cameraFunction = doItAllCamera
				cameraAnimationSliderTarget = 1
				if cameraAnimationSlider < 0 then
					cameraAnimationSlider = 0
				end
				doubleClickTimer = 0
			end
			if rightSweep == true and sweepSpeed > 0 then
				animationScreen.x = screen.x
				animationScreen.y = screen.y
				animationWorldScale = worldScale
				cameraFunction = doItAllCamera
				cameraAnimationSliderTarget = 0
				if cameraAnimationSlider > 1 then
					cameraAnimationSlider = 1
				end
				allowResetToBirdCamera = false
				cameraTargetObject = nil			
				doubleClickTimer = 0
				showTapIcon = false
				showTapTimer = 0
			end
		end
		
		
		multitouchSweep.sweepSpeed = 0
	end
	
	-- update camera
	if cameraFunction ~= nil then
		cameraFunction(dt)
	end
	
	for k,v in _G.pairs(birds) do
		bird = v
		if bird.shot == true and bird.definition == "BoomerangBird" then
			if v.boomerangActive == true then
				
				if bird.prevAngle ~= nil then
					if bird.prevAngle < -1 and bird.angle >= -1 then
						
						if bird.x < levelLeftEdge then
							vol = _G.math.max( 1 - ((levelLeftEdge - bird.x) / 100.0),  0.0)
						elseif bird.x > levelRightEdge then
							vol = _G.math.max( 1 - ((bird.x - levelRightEdge) / 100.0),  0.0)
						else
							vol = 1.0
						end
						_G.res.playAudio("boomerang_swish", vol, false)
					end
				end
				bird.prevAngle = bird.angle
				
				if bird.xVel >= bird.boomerangMinXVel and bird.xVel <= bird.boomerangMaxXVel then
					applyForce( bird.name,
										bird.boomerangXForce,
										0,
										bird.x,
										bird.y )
				end
				
				if bird.yVel > 5 then
					applyForce( bird.name,
										0,
										bird.boomerangYForce,
										bird.x,
										bird.y )
				end
				
				bird.angularVelocity = bird.angularVelocity + dt * 20
				if bird.angularVelocity > 20 then
					bird.angularVelocity = 20
				end
				
				setAngularVelocity(bird.name, bird.angularVelocity)
			elseif bird == flyingBird and birdSpecialtyAvailable then
				applyForce( bird.name,
									0,
									blockTable.blocks[bird.definition].flyVerticalForce,
									bird.x,
									bird.y )
				--setAngularVelocity(bird.name, 0)
				if bird.angularVelocity == nil then
					bird.angularVelocity = 0
				end
				
				bird.angularVelocity = bird.angularVelocity + dt * 15
				if bird.angularVelocity > 6.28 then
					bird.angularVelocity = 6.28
				end
				
				setAngularVelocity(bird.name, bird.angularVelocity)
			end
		elseif bird.shot == true and bird.definition == "BaitSardine" then
			if bird.angularVelocity == nil then
				bird.angularVelocity = 0
			end
				
			if bird.hasCollided ~= true then
				bird.angularVelocity = bird.angularVelocity + dt * 10
				if bird.angularVelocity > 20 then
					bird.angularVelocity = 20
				end
				setAngularVelocity(bird.name, bird.angularVelocity)
			end
		end
	end
	
	--updateParticles(dt)

	updateCharacterAnimations(dt)
	
	updateFloatingScores(dt)

	updateScore(dt)
	
	-- store current values to old for the next frame
	oldCursor.x = cursor.x
	oldCursor.y = cursor.y
	if cursor.wheelTriggered then
		cursor.wheelTriggered = false
	end
	
	-- Draw game
	drawGame()
	if currentMenuPage == pausePage and elementAnimations["ingamePausePageScroll"].state ~= "HIDDEN" and (birdTutorialPopups == nil or #birdTutorialPopups == 0) then
		pausePage.offsetX = elementAnimations["ingamePausePageScroll"].percentage / 100 * pauseBGw - pauseBGw
		pausePage.backgroundOverlay.shade = elementAnimations["ingamePausePageScroll"].percentage / 100 * 0.65
		drawMenuPage(pausePage)
	end
	
	if currentMenuPage == g_gesturePausePage and (birdTutorialPopups == nil or #birdTutorialPopups == 0) then
		--g_gesturePausePage.offsetX = 0
		--g_gesturePausePage.backgroundOverlay.shade = 0.65
		g_gesturePausePage.backgroundOverlay.shade = elementAnimations["ingameGesturePausePageScroll"].percentage / 100 * 0.65
		drawMenuPage(g_gesturePausePage)
	end
	
	
	
end

function closeMightyEaglePurchasePage()
	setGameMode(updateMenu)
	popupPage = nil
	setActiveMenuPage(levelFailed)
	setPhysicsEnabled(false)
	drawGame()
end

function closeBetaDisclaimerPage()
	setGameMode(updateMenu)
	popupPage = nil
	setActiveMenuPage(mainMenu)
	drawMenu()
end

function openExitPage()
	setActivePopupPage(areYouSurePage)
end

function closeResolutionWarningPage()
	
	if invalidResolutionPage.fromMainMenu == false then		
		setPhysicsEnabled(true)
		popupPage = nil
		setAnimationState("ingamePausePageScroll", "EXITING")
		setAnimationState("ingameGesturePausePageScroll", "EXITING")
		setGameMode(updateGame)				
	else		
		setPhysicsEnabled(false)
		popupPage = nil
	end
	
	invalidResolutionPage.fromMainMenu = nil
	
	-- the enablePhysicsWhenDone approach is not possible on this screen, because the prepare menu page can be called several times
	-- while resizing the screen, and it will set the enablePhysicsWhenDone variable to false if preparemenupage gets called more than once, which
	-- will happen when resizing the window
	--if invalidResolutionPage.enablePhysicsWhenDone == true then
	--	setPhysicsEnabled(true)
	--end
	
end


function enableMightyEagleFeature()
	settings.mightyEagleEnabled = true
	
	local mightyEagleButton = getItemByName(levelFailed.items, "buttonEagle")
	local mightyEagleButtonPM = getItemByName(pausePage.items, "buttonEagle")
	local mightyEagleButtonBuy = getItemByName(levelFailed.items, "buttonEagleBuy")
	
	mightyEagleButton.visible = true
	mightyEagleButtonPM.visible = true
	mightyEagleButtonBuy.visible = false	
end

function resetMightyEagleFeature()
	settings.mightyEagleEnabled = false
	settings.tutorials.BAIT_SARDINE = nil
	settings.eaglesUsedIn = {}
	settings.eaglesAvailable = {}
	settings.eaglesAvailable.basic = 1
	settings.eaglesAvailable.extra = 1
	settings.eaglesAvailable.pack3 = 1
	settings.eaglesAvailable.pack4 = 1
	
	local buttonEagle = getItemByName(pausePage.items, "buttonEagle")
	buttonEagle.visible = false
	
	setActiveMenuPage(mainMenu)
	setGameMode(updateMenu)
	drawMenu()
	
	--[[setAnimationState("ingamePausePageScroll", "EXITING")
	setActiveMenuPage(pausePage, false)
	setGameMode(updateGame)
	setPhysicsEnabled(true)
	drawMenu()--]]
end

function unlockLevels()
	releaseBuild = false
	settings.lastOpenLevel = 200
	settings.lastOpenLevelLP2 = 200
	settings.lastOpenLevelLP3 = 200
	settings.lastOpenLevelLP4 = 200
	settings.theme1Completed = true
	settings.theme2Completed = true
	settings.gameCompleted = true
	settings.theme4Completed = true
	settings.theme5Completed = true
	settings.theme6Completed = true
	settings.theme7Completed = true
	settings.theme8Completed = true
	settings.theme9Completed = true
	settings.theme10Completed = true
	settings.theme11Completed = true
	
	--prepareMenuPage(mainMenu)
	prepareMenuPage(episodeSelectionPage)
	prepareMenuPage(levelSelectionPagesBasic)
	prepareMenuPage(levelSelectionPagesExtra)
	prepareMenuPage(levelSelectionPagesGoldenEggs[1])
	prepareMenuPage(levelSelectionPagesPack3)
	prepareMenuPage(levelSelectionPagesPack4)
	prepareMenuPage(levelSelectionPagesPack5)
	prepareMenuPage(levelSelectionPagesPack6)
	
	setActiveMenuPage(mainMenu, true)
	setGameMode(updateMenu)
	drawMenu()
	print("Levels unlocked.\n")
end

function lockLevels()
	releaseBuild = true
	settings.lastOpenLevel = 200
	settings.lastOpenLevelLP2 = 1
	settings.lastOpenLevelLP3 = 1
	settings.lastOpenLevelLP4 = 1
	settings.theme1Completed = nil
	settings.theme2Completed = nil
	settings.gameCompleted = nil
	settings.theme4Completed = nil
	settings.theme5Completed = nil
	settings.theme6Completed = nil
	settings.theme7Completed = nil
	settings.theme8Completed = nil
	settings.theme9Completed = nil
	settings.theme10Completed = nil
	settings.theme11Completed = nil
	settings.threeStars = nil
	settings.threeStarsLP2 = nil
	settings.threeStarsLP3 = nil
	settings.threeStarsLP4 = nil
	settings.threeStarsLP5 = nil
	for i = #settings.eaglesUsedIn , 1, -1 do
		local v = settings.eaglesUsedIn[i]
		if v.world >= 4 then
			_G.table.remove(settings.eaglesUsedIn, i)
		end
	end
	if settings.eaglesAvailable == nil then
		settings.eaglesAvailable = {}
		settings.eaglesAvailable.basic = 1
	end
	settings.eaglesAvailable.extra = 1
	settings.eaglesAvailable.pack3 = 1
	settings.eaglesAvailable.pack4 = 1

	for levelPack = 1, #levelOrder.packs do
		--print("  levelPack: " .. levelOrder.packs[levelPack] .. "\n")
		for level = 1, #levelOrder[levelOrder.packs[levelPack]] do
			--print("    level: " .. levelOrder[levelOrder.packs[levelPack]][level] .. "\n")
			highscores[levelOrder[levelOrder.packs[levelPack]][level]] = nil
		end
	end
	
	settings.openGoldenEggLevels = {}
	for _, filename in _G.pairs(goldenEggLevelMapping) do
		highscores[filename] = nil
	end

	saveLuaFileWrapper("settings.lua", "settings", true)
	saveLuaFileWrapper("highscores.lua", "highscores", true)
	
	--prepareMenuPage(mainMenu, true)
	prepareMenuPage(episodeSelectionPage)
	--prepareMenuPage(levelSelectionPagesBasic)
	prepareMenuPage(levelSelectionPagesExtra)
	prepareMenuPage(levelSelectionPagesGoldenEggs[1])
	prepareMenuPage(levelSelectionPagesPack3)
	prepareMenuPage(levelSelectionPagesPack4)
	prepareMenuPage(levelSelectionPagesPack5)
	prepareMenuPage(levelSelectionPagesPack6)
	
	setActiveMenuPage(mainMenu)
	setGameMode(updateMenu)
	drawMenu()
	print("Levels locked.\n")
end

function createMightyEagle(meX, meY)
	levelCompleteTimer = 0
	levelFailedTimer = -200
	eagleX, eagleY = nil, nil
	--print("createMightyEagle: " .. meX .. ", " .. meY)
			
	local newName = "MightyEagle_a"
	local blockDef = blockTable.blocks["MightyEagleBird"]
	--print("eagleX: " .. levelLimitMinX .. ", eagleY: " .. meY - (meX - levelLimitMinX) / 2  .. "\n")
	createCircle(newName, blockDef.sprite, levelLimitMinX + 1, meY - (meX - levelLimitMinX+1) / 2, blockDef.radius, blockDef.density, blockDef.friction, blockDef.restitution, true, blockDef.z_order)
	objects.world[newName].targetX = meX
	objects.world[newName].targetY = meY
	-- eagle init velocity
	objects.world[newName].initVelX, objects.world[newName].initVelY = vNormalize(objects.world[newName].targetX - objects.world[newName].x, objects.world[newName].targetY - objects.world[newName].y)
	objects.world[newName].definition = "MightyEagleBird"
	objects.world[newName].controllable = blockDef.controllable
	objects.world[newName].strength = blockDef.strength
	objects.world[newName].defence = blockDef.defence
	objects.world[newName].material = blockDef.material
	objects.world[newName].damageFactors = blockDef.damageFactors
	objects.world[newName].useLegacyCollisionPath = blockDef.useLegacyCollisionPath
	objects.world[newName].levelGoal = false
	local xp, yp = _G.res.getSpritePivot("INGAME_BIRDS_2",blockDef.sprite)
	objects.world[newName].spritePivotX = xp
	objects.world[newName].spritePivotY = yp
	objects.world[newName].damageSprite = blockDef.sprite
	objects.world[newName].xVel = 0
	objects.world[newName].yVel = 0
	setSprite(newName, objects.world[newName].damageSprite)
	setRotation(newName, 0)
	setVelocity(newName, objects.world[newName].xVel, objects.world[newName].yVel)
	objects.world[newName].animTimer = 9999
	objects.world[newName].jumpTimer = 9999
	objects.world[newName].animOn = false
	--objects.world[newName].impulseX = 0
	--objects.world[newName].impulseY = 0
	objects.world[newName].isMightyEagle = true
	objects.world[newName].shot = true
	objects.world[newName].particleTimer = 0 
	objects.world[newName].particleTimerLimit = 0.025
	objects.world[newName].recordTrajectory = false
	birds[newName] = objects.world[newName]
	_G.res.playAudio(getAudioName(blockTable.blocks[objects.world[newName].definition].specialSound), 1, false)
	--cameraTargetObject = nil
	birdsCounter = birdsCounter + 1
	cameraFunction = gotoCastleCamera
	flyingBird = objects.world[newName]
	setMaxTranslation(5)
	_G.particles.setHardLimit(250)
	_G.particles.setSoftLimit(0, 0.2)
end

function removeBlocks()
	if objects.world == nil then
		return
	end

	-- remove objects if their strength is 0
	for k, v in _G.pairs(objects.world) do
		if v ~= nil and v.strength ~= nil then
			if v.strength <= 0 then
				local bDef = getObjectDefinition(k)
				local scoreToAdd = blockDestroyedScoreIncrement
				
				if blockTable.blocks[v.definition].destroyedScoreInc ~= nil then
					scoreToAdd = blockTable.blocks[v.definition].destroyedScoreInc
				end
				
				if v.levelGoal then
					scoreToAdd = pigletteDestroyedScoreIncrement
					_G.res.playAudio(getAudioName("piglette_damage"), 1, false)
					_G.table.insert(floatingScores, { x = v.x, y = v.y, sprite = "5K_GREEN", score = scoreToAdd, time = 0, lifetime = 0.9, maxScale = 1, xs = 0  } )
					-- check if only one piglette is still alive and play level complete sound if so
					-- local anyPiglettesAlive = 0
					-- for k, v in _G.pairs(levelGoals) do
						-- if v.levelGoal then
							-- anyPiglettesAlive = anyPiglettesAlive + 1
						-- end
					-- end
					-- if anyPiglettesAlive == 1 then
						-- _G.res.playAudio(getAudioName("level_clear_military"), 1, false)
					-- end
				else
					_G.table.insert(floatingScores, { x = v.x, y = v.y, text = "" .. scoreToAdd, score = scoreToAdd, time = 0, lifetime = 0.6, maxScale = 0.25 + scoreToAdd / 3000, xs = 0 } )
				end
				scoreTable["blocks"].score = scoreTable["blocks"].score + scoreToAdd

				local bDef = getObjectDefinition(k)
				local particle = bDef.particles
				if particle == nil then
					particle = blockTable.materials[v.material].particles
				end

				local destroySound = blockTable.materials[v.material].destroyedSound
				local particleAmount = 12
				if particle == "smokeBuff" then
					particleAmount = 1
				end
				if bDef.specialty == "BOMB" then
					makeExplosion(objects.world[k], bDef, getAudioName("tnt_explodes"))
				end

				if destroySound ~= nil then
					_G.res.playAudio(getAudioName(destroySound), 0.7, false, 3)
				end
				
				if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
					if v.material ~= nil then
						if v.material == "wood" then
							if settings.woodBlocksDestroyed == nil then
								settings.woodBlocksDestroyed = 0
							end
							settings.woodBlocksDestroyed = settings.woodBlocksDestroyed + 1
							if settings.woodBlocksDestroyed == 5000 then
								addToAchievementUnlockQueue("Woodpecker", true)
							end
							if settings.woodBlocksDestroyed == 100 then
								addToAchievementUnlockQueue("Woodpecker Lite", true)
							end
						elseif v.material == "light" then
							if settings.iceBlocksDestroyed == nil then
								settings.iceBlocksDestroyed = 0
							end
							settings.iceBlocksDestroyed = settings.iceBlocksDestroyed + 1
							if settings.iceBlocksDestroyed == 5000 then
								addToAchievementUnlockQueue("Icepicker", true)
							end
							if settings.iceBlocksDestroyed == 100 then
								addToAchievementUnlockQueue("Icepicker Lite", true)
							end
						elseif v.material == "rock" then
							if settings.rockBlocksDestroyed == nil then
								settings.rockBlocksDestroyed = 0
							end
							settings.rockBlocksDestroyed = settings.rockBlocksDestroyed + 1
							if settings.rockBlocksDestroyed == 5000 then
								addToAchievementUnlockQueue("Stonecutter", true)
							end
						elseif v.material == "piglette" then
							if settings.pigsDestroyed == nil then
								settings.pigsDestroyed = 0
							end
							if eagleBaitLaunched ~= true then
								settings.pigsDestroyed = settings.pigsDestroyed + 1
							end
							if settings.pigsDestroyed == 1000 then
								addToAchievementUnlockQueue("Pig Popper", true)
							end
						end
						
						totalBlocks = 0
						if settings.woodBlocksDestroyed ~= nil then
							totalBlocks = totalBlocks + settings.woodBlocksDestroyed
						end
						if settings.iceBlocksDestroyed ~= nil then
							totalBlocks = totalBlocks + settings.iceBlocksDestroyed
						end
						if settings.rockBlocksDestroyed ~= nil then
							totalBlocks = totalBlocks + settings.rockBlocksDestroyed
						end
						
						if totalBlocks == 50000 then
							addToAchievementUnlockQueue("Block Smasher", true)
						end
						if totalBlocks == 500000 then
							addToAchievementUnlockQueue("Smash Maniac", true)
						end
						if totalBlocks == 500 then
							addToAchievementUnlockQueue("Block Smasher Lite", true)
						end
					end
				end
				
				if eagleBaitLaunched ~= true then
					if currentLevelNumberInTheme == 2 and currentWorldNumber == 2 then
						if v.name == "ExtraBeachBall_1" then
							g_releaseGEOnPopupExit = true
							goldenEggAchieved("Level3")
						end
					end
					
					if currentLevelNumberInTheme == 14 and currentWorldNumber == 6 then
						if v.name == "StaticBalloon03_2" then
							g_releaseGEOnPopupExit = true
							goldenEggAchieved("Level10")
						end
					end
					
					if currentLevelNumberInTheme == 7 and currentWorldNumber == 4 then
						if v.name == "ExtraGoldenEgg_1" then
							g_releaseGEOnPopupExit = true
							goldenEggAchieved("Level9")
						end
					end
					
					if currentLevelNumberInTheme == 19 and currentWorldNumber == 5 then
						if v.name == "ExtraGoldenEgg_1" then
							g_releaseGEOnPopupExit = true
							goldenEggAchieved("Level2")
						end
					end
					
					if currentLevelNumberInTheme == 15 and currentWorldNumber == 8 then
						if v.name == "ExtraGoldenEgg_1" then
							g_releaseGEOnPopupExit = true
							goldenEggAchieved("Level13")
						end
					end
					
					if currentLevelNumberInTheme == 14 and currentWorldNumber == 9 then
						if v.name == "ExtraGoldenEgg_1" then
							g_releaseGEOnPopupExit = true
							goldenEggAchieved("Level14")
						end
					end
					
					if currentLevelNumberInTheme == 3 and currentWorldNumber == 10 then
						if v.name == "ExtraRubberDuck_1" then
							g_releaseGEOnPopupExit = true
							goldenEggAchieved("Level15")
						end
					end
					
					if currentLevelNumberInTheme == 15 and currentWorldNumber == 11 then
						if v.name == "ExtraGoldenEgg_1" then
							g_releaseGEOnPopupExit = true
							goldenEggAchieved("Level16")
						end
					end
					
				end
				
				addParticles(k, particle, particleAmount)
				removeObject(k)
				levelGoals[k] = nil				
				objects.world[k] = nil
			end
		end
	end
end



function updateScore(dt)
	score = 0
	for k, v in _G.pairs(scoreTable) do
		score = score + v.score
	end
end


function initPictureLevel()
	if currentPictureLevel == "PIGGY" then
		piggyPage = PiggyPage:new()
	elseif currentPictureLevel == "MIGHTY_EAGLE" then
		eaglePage = EaglePage:new()
	end
	
end


------------
--Page-class
------------
Page = {}
    
function Page:new(o)
	o = o or {}
	o.items = {}
	o.order = {}
	_G.setmetatable(o, self)
	self.__index = self
	o:init()
	return o
end

function Page:init()
-- Overridden in classes that inherit this but needs to be declared here.
end

function Page:insertItem(key, item, pushback)
	
	self:setItemDefaults(item)
	
	if not pushback then
		_G.table.insert(self.order, key)
		self.items[key] = item
	else
		local index = self:getIndexOfItem(pushback)
		if index then
			_G.table.insert(self.order, index, key)
			self.items[key] = item
		end
	end	
end

function Page:removeItem(key)
	local index = self:getIndexOfItem(key)
	if index then
		_G.table.remove(self.order, index)
		for i, v in _G.ipairs(self.items) do
			if v == self.items.key then
				_G.table.remove(self.items, i)
				return
			end
		end
	end
end

function Page:setItemDefaults(item)
	
	item.x, item.y = item.x or 0, item.y or 0
	
	if item.sprite then
		item.sheet = item.sheet or self.sheet
	elseif item.text then
		item.font = item.font or self.font or defaultMenuFont
	end
	
	if item.renderState then
		item.xs = item.xs or 1
		item.ys = item.ys or 1
		item.angle = item.angle or 0
		if item.useSpritePivot and item.sprite then
			item.pivotX, item.pivotY = _G.res.getSpritePivot(item.sheet, item.sprite)
		else
			item.pivotX, item.pivotY = item.pivotX or 0, item.pivotY or 0
		end
	end
end

function Page:getIndexOfItem(name)
	for i = 1, #self.order do
		if self.order[i] == name then
			return i
		end
	end
	return false
end

function Page:getActivatedItems()
	local activatedItems = {}
	local activatedItemsTouchData = {}
	for k, v in _G.pairs(touches) do
		for key, value in _G.pairs(self.items) do
			if value.visible ~= false and value.selectable ~= false 
			  and value:checkBounds(v.x, v.y) then
				if #activatedItems == 0 or #activatedItems >= 1 and activatedItems[1] ~= key then
					_G.table.insert(activatedItems, key)
					activatedItemsTouchData[key] = k
				end
			end
		end
	end
	if #activatedItems >= 1 then
		return activatedItems, activatedItemsTouchData
	else
		return false
	end
end

function Page:getHoveredItemKey()
	-- TODO: selectionCandidate functionality for overlapping sprites, texts and/or touch areas.
	-- Needs to take pivot and anchor into account.

	for k, v in _G.pairs(self.items) do
		if v.visible ~= false and v.selectable ~= false 
		 and v:checkBounds(cursor.x, cursor.y) then 
			return {k}
		end
	end
	return false
end

function Page:getClickedItem()
	-- TODO: selectionCandidate functionality for overlapping sprites, texts and/or touch areas.
	-- Needs to take pivot and anchor into account.

	for k, v in _G.pairs(self.items) do
		if v.visible ~= false and v.selectable ~= false 
		 and (v.activateOnRelease ~= true and keyPressed["LBUTTON"] or v.activateOnRelease and keyReleased["LBUTTON"])
		 and v:checkBounds(cursor.x, cursor.y) then 
			return v
		end
	end
	return false
end

function Page:draw()
	for i = 1, #self.order do
		local item = self.items[self.order[i]]
		if item.visible ~= false then
			item:draw()
		end
	end
end

------------
--Item-class
------------
Item = {}
    
function Item:new(o)
	o = o or {}
	o.x, o.y = o.x or 0, o.y or 0
	_G.setmetatable(o, self)
	self.__index = self
	return o
end

function Item:checkBounds(xCoord, yCoord)
	if self.h == nil or self.w == nil then
		return false -- Height and width for click area must be set.
	else
		return yCoord >= self.y and yCoord <= self.y + self.h and
			xCoord >= self.x and xCoord <= self.x + self.h
	end
end



----------------------------------
--SpriteItem-class, inherits Item
----------------------------------

SpriteItem = Item:new()

function SpriteItem:checkBounds(xCoord, yCoord)

	if self.clickArea ~= nil then	   
		return xCoord >= self.clickArea.xLeft and xCoord <= self.clickArea.xRight and
			   yCoord >= self.clickArea.yTop and yCoord <= self.clickArea.yBot
	end
	self.sheet = self.sheet or ""
	local width, height = _G.res.getSpriteBounds(self.sheet, self.sprite)
	local pivotX, pivotY = _G.res.getSpritePivot(self.sheet, self.sprite)
	
	if self.renderState then
		local scaleCorrectionX, scaleCorrectionY = 0, 0
		local xs, ys = self.xs or 1, self.ys or 1
		if self.scale ~= nil then
			xs, ys = self.scale, self.scale
		end
		if xs ~= 1 then
			scaleCorrectionX = ((width * xs) - width) / 2
		end
		if ys ~= 1 then
			scaleCorrectionY = ((height * ys) - height) / 2
		end

		return yCoord >= (self.y - pivotY - scaleCorrectionY) and yCoord <= (self.y - pivotY + height + scaleCorrectionY)
			and xCoord >= (self.x - pivotX - scaleCorrectionX) and xCoord <= (self.x - pivotX + width + scaleCorrectionX)
	end
	
	return yCoord >= (self.y - pivotY) and yCoord <= (self.y - pivotY + height) and
		xCoord >= (self.x - pivotX) and xCoord <= (self.x - pivotX + width)
end

function SpriteItem:draw()
	if(self.mouseState ~= nil) then
		drawMouseScalingItem(self.sheet, self, self.x, self.y)
		
	elseif self.renderState then

		local xCoord, yCoord = self.x, self.y
		local xs, ys = self.xs or 1, self.ys or 1
		local angle = self.angle or 0
		local px, py = self.pivotX or 0, self.pivotY or 0
		if xs ~= 1 then
			xCoord =  xCoord / xs
		end
		if ys ~= 1 then
			yCoord = yCoord / ys
		end
		setRenderState(0, 0, xs, ys, angle, px, py)
		if self.drawToScreenSize then
			--local hAnchor = self.hAnchor or "HCENTER"
			--local vAnchor = self.vAnchor or "TOP"
			local sw, sh = _G.res.getSpriteBounds(self.sheet, self.sprite)
			local aspect = sw / sh
			local width = screenHeight * aspect
			local px, py = _G.res.getSpritePivot(self.sheet, self.sprite)
			
			if screenHeight <= sh and screenWidth <= sw then			
				_G.res.drawSprite("", self.sprite, xCoord, yCoord)				
			elseif screenHeight > sh and screenWidth <= sw then
				_G.res.drawSprite("", self.sprite, (sw - width) / 2, 0, "LEFT", "TOP", width, screenHeight)
			else
				_G.res.drawSprite("", self.sprite, 0, 0, "LEFT", "TOP", screenWidth, screenHeight)
			end
			
			
			--_G.res.drawSprite("", self.sprite, _G.math.floor(xCoord), _G.math.floor(yCoord) - screenHeight / 2, hAnchor, vAnchor, sw * screenHeight / sh, screenHeight)
		else
			_G.res.drawSprite("", self.sprite, _G.math.floor(xCoord), _G.math.floor(yCoord))
		end
		setRenderState(0, 0, 1, 1, 0, 0, 0)
	
	else
		_G.res.drawSprite("", self.sprite, self.x, self.y)
	end
end

-------------------------------
--TextItem-class, inherits Item
-------------------------------

TextItem = Item:new({text = "", group = "TEXTS_BASIC", textBoxSize = screenWidth, hanchor = "HCENTER", vanchor = "VCENTER"})

function TextItem:draw()
	_G.res.drawString(self.group, self.text, self.x, self.y, self.hanchor, self.vanchor )
end

--------------------------------
--EaglePage-class, inherits Page
--------------------------------

EaglePage = Page:new()

function EaglePage:init()
	_G.res.stopAudio("title_theme")
	
	self.name = "eaglePage"
	self.beakUpperDragStartCursorY = 0
	self.beakUpperDragTouchId = -1
	self.beakLowerDragStartCursorY = 0
	self.beakLowerDragTouchId = -1
	self.beakTwitch = false
	self.beakTwitchTimer = 0
	self.beakMovable = true
	self.drawStarEffect = false
	self.sheet = ""
		
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", x = screenWidth / 2, y = screenHeight / 2, renderState = true, drawToScreenSize = true  } ))
	self:insertItem("eagleBirds1", SpriteItem:new( { sprite = "CONCEPT_EAGLE_BIRDS_1", x = screenWidth/ 2, y = screenHeight / 2 } ))
	self:insertItem("eagleTongue", SpriteItem:new( { sprite = "CONCEPT_EAGLE_TONGUE", x = screenWidth, y = screenHeight / 2 } ))
	self:insertItem("beakLower", SpriteItem:new({ sprite = "CONCEPT_EAGLE_BEAK_LOWER", x = screenWidth, y = 0 }))
	self:insertItem("beakUpper", SpriteItem:new({ sprite = "CONCEPT_EAGLE_BEAK_UPPER", x = screenWidth, y = 0 }))
	self:insertItem("back", SpriteItem:new( { sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight } ))
		
	local starX, starY, effectOffset
	self.x = screenWidth
	
	self.beakUpperRestY = 0.61 * screenHeight
	self.beakLowerRestY = 0.6 * screenHeight
	self.beakHitBoxes = { x = screenWidth / 2, beakUpperTopY = self.beakUpperRestY - 0.009 * screenHeight, 
								beakUpperBotY = self.beakUpperRestY - 0.28 * screenHeight,
								beakLowerTopY = self.beakLowerRestY + 0.19 * screenHeight,
								beakLowerBotY = self.beakLowerRestY + 0.009 * screenHeight }
	self.twitchTopY = 0.78 * screenHeight
	self.twitchBotY = 0.33 * screenHeight
	self.botLimit = 0.34 * screenHeight
	self.topLimit = 0.72 * screenHeight	
	starX, starY, effectOffset = 0.75 * screenWidth, 0.55 * screenHeight, 0.008 * screenWidth
				


	self.starCollected = settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 2
	if self.starCollected then
		self:insertItem("starCollected", SpriteItem:new( {sprite = "GOLDEN_EGG_STAR_COLLECTED", x = starX, y = starY} ), "beakLower")
	else
		self:insertItem("star", SpriteItem:new( {sprite = "GOLDEN_EGG_STAR", x = starX, y = starY} ), "beakLower")
		self:insertItem("starEffect", SpriteItem:new( { sprite = "GOLDEN_EGG_STAR_EFFECT", x = starX - effectOffset, y = starY - effectOffset, angle = 0,
		renderState = true, useSpritePivot = true, visible = false} ), "star")	
	end
		
	self.beakUpperY = self.beakUpperRestY
	self.beakLowerY = self.beakLowerRestY
	self.beakUpperDragStartY = self.beakUpperRestY
	self.beakLowerDragStartY = self.beakLowerRestY
	self.items.beakLower.x = self.x
	self.items.beakUpper.x = self.x
	
	--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level5"] .. "\n")
	logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level5"]) 
end

function EaglePage:update(dt)

	if self.drawStarEffect == true then
		self.items.starEffect.angle = self.items.starEffect.angle + 0.6 * dt
		self.items.starEffect.visible = true
	end
				
	if self.beakMovable == true then
					
		if touchcount == 2 or (deviceModel == "n900" and touchcount == 1) then
			
			for k, v in _G.pairs(touches) do

				if v.x > self.beakHitBoxes.x and v.y > self.beakHitBoxes.beakUpperBotY
				   and v.y < self.beakHitBoxes.beakUpperTopY then
					self.beakUpperDragStartCursorY = v.y
					self.beakUpperDragStartY = self.beakUpperY
					self.beakUpperDragTouchId = k
				elseif v.x > self.beakHitBoxes.x and v.y >= self.beakHitBoxes.beakLowerBotY
					and v.y < self.beakHitBoxes.beakLowerTopY then
					self.beakLowerDragStartCursorY = v.y
					self.beakLowerDragStartY = self.beakLowerY
					self.beakLowerDragTouchId = k
				end
				
			end
				
			if self.beakUpperDragTouchId ~= -1 and touches[self.beakUpperDragTouchId] ~= nil 
			  and self.beakLowerDragTouchId ~= -1 and touches[self.beakLowerDragTouchId] ~= nil
			  and deviceModel ~= "n900" then
				self.beakUpperY = _G.math.min(self.beakUpperRestY, self.beakUpperDragStartY - (self.beakUpperDragStartCursorY - touches[self.beakUpperDragTouchId].y))
				self.beakLowerY = _G.math.max(self.beakLowerRestY, self.beakLowerDragStartY - (self.beakLowerDragStartCursorY - touches[self.beakLowerDragTouchId].y))
			elseif deviceModel == "n900" and self.beakUpperDragTouchId ~= -1 and touches[self.beakUpperDragTouchId] ~= nil then
				self.beakUpperY = _G.math.min(self.beakUpperRestY, self.beakUpperDragStartY - (self.beakUpperDragStartCursorY - touches[self.beakUpperDragTouchId].y))
			elseif deviceModel == "n900" and self.beakLowerDragTouchId ~= -1 and touches[self.beakLowerDragTouchId] ~= nil then
				self.beakLowerY = _G.math.max(self.beakLowerRestY, self.beakLowerDragStartY - (self.beakLowerDragStartCursorY - touches[self.beakLowerDragTouchId].y))
			end
						
			if deviceModel == "n900" and keyPressed["LBUTTON"] then
				if self.beakTwitch == false and cursor.x > self.beakHitBoxes.x 
				   and cursor.y > self.twitchBotY and cursor.y < self.twitchTopY then
					self.beakTwitch = true
					self.beakTwitchTimer = 0
				end
			end
			
		elseif keyPressed["C"] and (not releaseBuild) then
			self.beakUpperY = self.botLimit - 1
			self.beakLowerY = self.topLimit + 1
		elseif keyPressed["LBUTTON"] then
			if self.beakTwitch == false and cursor.x > self.beakHitBoxes.x 
			   and cursor.y > self.twitchBotY and cursor.y < self.twitchTopY then
				self.beakTwitch = true
				self.beakTwitchTimer = 0
			end
		else
			self.beakUpperDragTouchId = -1
			self.beakLowerDragTouchId = -1
		end
	end
		
	if self.beakTwitch == true then
		self.beakTwitchTimer = self.beakTwitchTimer + dt
		if self.beakTwitchTimer < 0.08 then
			self.beakUpperY = self.beakUpperY - 60 * dt
		elseif self.beakTwitchTimer < 0.16 then
			self.beakUpperY = _G.math.min(self.beakUpperRestY, self.beakUpperY + 30 * dt)
		else
			self.beakTwitch = false
			self.beakTwitchTimer = 0
		end
	end
		
	if deviceModel == "n900" then
		if self.beakUpperY < self.botLimit then
			self.beakUpperY = self.botLimit
			self.beakUpperRestY = self.botLimit
		elseif self.beakLowerY > self.topLimit then
			self.beakLowerY = self.topLimit
			self.beakLowerRestY = self.topLimit
		end
	else
		if self.beakUpperY < self.botLimit then
			self.beakUpperY = self.botLimit
		elseif self.beakLowerY > self.topLimit then
			self.beakLowerY = self.topLimit
		end
	end
		
	if self.beakUpperY <= self.botLimit and self.beakLowerY >= self.topLimit then
		self.beakUpperY = self.botLimit
		self.beakLowerY = self.topLimit
		self.beakUpperRestY = self.botLimit
		self.beakLowerRestY = self.topLimit
		self.beakMovable = false
		
		if not self.starCollected then
			self.drawStarEffect = true
		end
			
		if settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 1 then
			settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] = 2
			highscores[goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]] = {completed = true, birds = 0, score = 0, lowScore = 0}
			saveLuaFileWrapper("highscores.lua", "highscores", true)
			saveLuaFileWrapper("settings.lua", "settings", true)
			_G.res.playAudio("star_collect", 1, false)
		end
		
		if self.flurryLogged ~= true then
			--print("FlurryEventWithParam: Golden egg level completed, param: Level, paramValue: " .. goldenEggLevelMapping["Level5"] .. "\n")
			logFlurryEventWithParam("Golden egg level completed", "Level", "" .. goldenEggLevelMapping["Level5"]) 
			self.flurryLogged = true
		end
	end
		
	if self.beakTwitch == false and self.beakMovable == true then 
		if self.beakUpperDragTouchId == -1 and self.beakUpperY < self.beakUpperRestY then
			self.beakUpperY = _G.math.min(self.beakUpperY + 200 * dt, self.beakUpperRestY)
		end
		if self.beakLowerDragTouchId == -1 and self.beakLowerY > self.beakLowerRestY then
			self.beakLowerY = _G.math.max(self.beakLowerY - 200 * dt, self.beakLowerRestY)
		end
	end
				
	self.items.beakLower.y = self.beakLowerY
	self.items.beakUpper.y = self.beakUpperY
	
	if keyPressed["LBUTTON"] then
		local width, height = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "LS_BACK_BUTTON")
		if cursor.y > (screenHeight - height) and cursor.x < width then
			setGameMode(gotoLevelSelectionGoldenEggs)
		end
	end
	
end

--------------------------------
--PiggyPage-class, inherits Page
--------------------------------

PiggyPage = Page:new()

function PiggyPage:init()
	_G.res.stopAudio("title_theme")
	
	self.name = "piggyPage"
	self.starCollected = settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 2
	self.drawStarEffect = false
	self.starAnimationTimer = 0
	self.starSoundPlayed = false
	self.nosey = screenHeight / 2
	self.nosevel = 0
	self.noseTwitch = false
	self.noseTwitchTimer = 0
	self.sheet = ""
	local _, tempHeight = _G.res.getSpriteBounds("", "CONCEPT_PIG_NOSE")
	self.noseSpriteHeight = tempHeight
		
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", x = screenWidth/2, y = screenHeight/2,renderState = true, drawToScreenSize = true } ))
	self:insertItem("pigBody", SpriteItem:new( { sprite = "CONCEPT_PIG_BODY", x = screenWidth/2, y = screenHeight/2 } ))
	self:insertItem("pigBird", SpriteItem:new( { sprite = "CONCEPT_PIG_BIRD", x = screenWidth/2, y = screenHeight/2 } ))
	self:insertItem("pigEyesOpen", SpriteItem:new( {sprite = "CONCEPT_PIG_EYES_OPEN", visible = false, x = screenWidth/2, y = screenHeight/2} ))
	self:insertItem("pigNose", SpriteItem:new( {name = "pig_nose", sprite = "CONCEPT_PIG_NOSE", x = screenWidth/2, y = screenHeight/2 } ))
	self:insertItem("back", SpriteItem:new( { sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight } ))
			
	local starX, starY
	local px, py = _G.res.getSpritePivot("", "CONCEPT_PIG_NOSE")
	local pw, ph = _G.res.getSpriteBounds("", "CONCEPT_PIG_NOSE")
	local pigNoseLeft = -px + self.items.pigNose.x
	local pigNoseTop = -py + self.items.pigNose.y
	
	self.leftNostrilX, self.leftNostrilY = -0.004 * screenWidth, 0.05 * screenHeight
	self.rightNostrilX, self.rightNostrilY = 0.14 * screenWidth, 0.05* screenHeight
	self.hitboxX, self.hitboxY = 0.06 * screenWidth, 0.05* screenHeight
	self.nostrilRadius = 0.1 * screenWidth
	self.noseRadius = 0.19 * screenWidth
		
	starX, starY = pigNoseLeft + pw / 2, pigNoseTop	+ ph / 2

	
	if self.starCollected then
		self:insertItem("starCollected", SpriteItem:new( { sprite = "GOLDEN_EGG_STAR_COLLECTED", x = starX, y = starY }), "pigEyesOpen" )
	else
		self:insertItem("star", SpriteItem:new( { sprite = "GOLDEN_EGG_STAR", x = starX, y = starY }), "pigEyesOpen" )
		self:insertItem("starEffect", SpriteItem:new( { sprite = "GOLDEN_EGG_STAR_EFFECT", x = starX, y = starY, angle = 0 , renderState = true, useSpritePivot = true, visible = false }), "star" )
	end
	
	--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level6"] .. "\n")
	logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level6"]) 
end

function PiggyPage:update(dt)
		
	if touchcount == 2 or (deviceModel == "n900" and touchcount == 1) then
		local leftNostril = false
		local rightNostril = false
		for k,v in _G.pairs(touches) do
		
			if distance(v.x, v.y, self.leftNostrilX + screenWidth / 2, self.leftNostrilY + screenHeight / 2) < self.nostrilRadius then
				leftNostril = true
				if deviceModel == "n900" then
					self.leftHit = true
				end
			elseif distance(v.x, v.y, self.rightNostrilX + screenWidth / 2, self.rightNostrilY + screenHeight / 2) < self.nostrilRadius then
				rightNostril = true
				if deviceModel == "n900" then
					self.rightHit = true
				end
			elseif deviceModel == "n900" then
				self.leftHit, self.rightHit = false, false
			end	
		end
			
		if deviceModel == "n900" and keyPressed["LBUTTON"] then
			if self.noseTwitch == false and distance(cursor.x, cursor.y, self.hitboxX + screenWidth / 2, self.hitboxY + screenHeight / 2) < self.noseRadius then
				self.noseTwitch = true
				self.noseTwitchTimer = 0
			end
		end	
		
		if leftNostril == true and rightNostril == true or (deviceModel == "n900" and self.leftHit and self.rightHit) then
			self.drawStarEffect = true
			if not self.starCollected then
				self.items.starEffect.visible = true
			end
		end
	elseif keyPressed["C"] and (not relaseBuild) then
		self.drawStarEffect = true
		if not self.starCollected then
			self.items.starEffect.visible = true
		end
	elseif keyPressed["LBUTTON"] then
		if self.noseTwitch == false and distance(cursor.x, cursor.y, self.hitboxX + screenWidth / 2, self.hitboxY + screenHeight / 2) < self.noseRadius then
			self.noseTwitch = true
			self.noseTwitchTimer = 0
		end
	end
	
	if self.noseTwitch == true then
		self.noseTwitchTimer = self.noseTwitchTimer + dt
		if self.noseTwitchTimer < 0.08 then
			self.nosey = self.nosey - 60 * dt
		elseif self.noseTwitchTimer < 0.16 then
			self.nosey = self.nosey + 30 * dt
			if self.drawStarEffect == false and self.nosey > screenHeight / 2 then
				self.nosey = screenHeight / 2
			end
		else
			if self.drawStarEffect == false then
				self.nosey = screenHeight / 2
			end
			self.noseTwitch = false
			self.noseTwitchTimer = 0
		end
		
		self.items.pigNose.y = self.nosey
		
	end
	
	if self.drawStarEffect == true then
	
		self.starAnimationTimer = self.starAnimationTimer + dt
		
		if not self.starCollected then	
			self.items.starEffect.angle = self.items.starEffect.angle + 0.6 * dt
			-- sound
			if self.starAnimationTimer > 2.3 and self.starSoundPlayed == false then
				self.starSoundPlayed = true
				if settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 1 then
					settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] = 2
					highscores[goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]] = {completed = true, birds = 0, score = 0, lowScore = 0}
					saveLuaFileWrapper("highscores.lua", "highscores", true)
					saveLuaFileWrapper("settings.lua", "settings", true)
					_G.res.playAudio("star_collect", 1, false)
				end
			end
		
		end
		
		-- nose
		if self.starAnimationTimer >= 1.5 and self.nosey < screenHeight + self.noseSpriteHeight then
			self.nosevel = self.nosevel + 800 * dt
			self.nosey = self.nosey + dt * self.nosevel
		end
		
		if (self.starAnimationTimer < 0.25 or (self.starAnimationTimer > 0.4 and self.starAnimationTimer < 0.8)
		    or self.starAnimationTimer > 0.9) then
			self.items.pigEyesOpen.visible = true
		else
			self.items.pigEyesOpen.visible = false
		end
		
		self.items.pigNose.y = self.nosey
							
		if self.complete ~= true then
			logFlurryEventWithParam("Golden egg level completed", "Level", "" .. goldenEggLevelMapping["Level6"]) 
			self.complete = true
		end
	end
	
	if keyPressed["LBUTTON"] then
		local width, height = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "LS_BACK_BUTTON")
		if cursor.y > (screenHeight - height) and cursor.x < width then
			setGameMode(gotoLevelSelectionGoldenEggs)
		end
	end
	
end

--helper functions for soundboards

function gotoGoldenEggs()
	_G.res.stopAllAudio()
	if deviceModel == "roku" then
		releaseImages({ "INGAME", "THEMES"})
		loadImages({"LEVELSELECTION", "GOLDEN_EGGS"})
	end
	setGameOn(false) -- enable screen saver
	setGameMode(gotoLevelSelectionGoldenEggs)
	g_SoundBoardLayouted = nil
end

function toggleSoundBoardSFXButtons()
	if currentSoundboard == "KEYBOARD" then	
		local t_sfxOffButton = keyboardPage.items["buttonSFXOff"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible
	elseif currentSoundboard == "SEQUENCER" then	
		local t_sfxOffButton = sequencerPage.items["buttonSFXOff"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible
	elseif currentSoundboard == "SOUNDBOARD1" then	
		local t_sfxOffButton = soundPage["sfxOffButton"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible	
	elseif currentSoundboard == "ACCORDION" then	
		local t_sfxOffButton = accordionPage.items["buttonSFXOff"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible
	elseif currentSoundboard == "RADIO" then	
		local t_sfxOffButton = soundPage["sfxOffButton"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible		
		
		if settings.audioEnabled == true and soundPage.musicPlaying and soundPage.musicStartedWhenMuted == true and currentGameMode == updateSoundboard then
			_G.res.playAudio(soundPage.upcomingTune, 0.8, true)
			soundPage.musicStartedWhenMuted = false
		end
	end	
	
end

function toggleSoundBoardSFX()
	
	if popupPage == nil then		
		changeAudio()
		if settings.audioEnabled == false then
			if currentSoundboard ~= "RADIO" then
				_G.res.stopAllAudio()
			end
		elseif currentSoundboard == "RADIO" and soundPage.musicPlaying and soundPage.musicStartedWhenMuted == true then
			_G.res.playAudio(soundPage.upcomingTune, 0.8, true)
			soundPage.musicStartedWhenMuted = false
		end
		
	end
	
	if currentSoundboard == "KEYBOARD" then	
		local t_sfxOffButton = keyboardPage.items["buttonSFXOff"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible
	elseif currentSoundboard == "SEQUENCER" then	
		local t_sfxOffButton = sequencerPage.items["buttonSFXOff"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible
	elseif currentSoundboard == "SOUNDBOARD1" then	
		local t_sfxOffButton = soundPage["sfxOffButton"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible	
	elseif currentSoundboard == "ACCORDION" then	
		local t_sfxOffButton = accordionPage.items["buttonSFXOff"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible
	elseif currentSoundboard == "RADIO" then	
		local t_sfxOffButton = soundPage["sfxOffButton"]
		t_sfxOffButton.visible = not t_sfxOffButton.visible
		
	end
end

function addSoundBoardMenuButtons(page)
	
	page:insertItem("back", SpriteItem:new( {sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight, selectable = true, activateOnRelease = true } ))
	page:insertItem("buttonSFX", SpriteItem:new( {sheet = "", sprite = "BUTTON_SFX", y = screenHeight, selectable = true, activateOnRelease = true } ))
	page:insertItem("buttonSFXOff", SpriteItem:new( {sheet = "", sprite = "BUTTON_OFF_SMALL", y = screenHeight, selectable = true, activateOnRelease = true } ))
	
	local t_backButton = page.items["back"]
	local t_spriteWidth, t_spriteHeight = _G.res.getSpriteBounds("", "LS_BACK_BUTTON")
	local t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_BACK_BUTTON")
	local t_offsetX, t_offsetY = t_pivotX, -(t_spriteHeight-t_pivotY)
	t_backButton.x = t_offsetX
	t_backButton.y = screenHeight + t_offsetY
	t_backButton.activateOnRelease = true
	
	if deviceModel == "roku" then
		t_backButton.x = t_backButton.x + screenWidth * 0.05 - 5
		t_backButton.y = t_backButton.y - screenHeight * 0.05 + 21
	end
	
	local t_sfxButton = page.items["buttonSFX"]	
	t_offsetX, t_offsetY = 50, 50
	t_sfxButton.x, t_sfxButton.y = t_offsetX, t_offsetY
	t_sfxButton.activateOnRelease = true
	
	
	local t_sfxOffButton = page.items["buttonSFXOff"]	
	t_offsetX, t_offsetY = 50, 50
	t_sfxOffButton.x, t_sfxOffButton.y = t_offsetX, t_offsetY
	t_sfxOffButton.activateOnRelease = true
	t_sfxOffButton.visible = not settings.audioEnabled
	
	prepareItemForMouseScalingStates(t_backButton)
	prepareItemForMouseScalingStates(t_sfxButton)
	prepareItemForMouseScalingStates(t_sfxOffButton, t_sfxButton)
	
end

function addSoundBoardMenuButtonsToTable(target)
	
	target.backButton = { sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight, selectable = true, activateOnRelease = true, } 
	target.sfxButton=  { sheet = "", sprite = "BUTTON_SFX", y = screenHeight, selectable = true, activateOnRelease = true }
	target.sfxOffButton=  { sheet = "", sprite = "BUTTON_OFF_SMALL", y = screenHeight, selectable = true, activateOnRelease = true }
	
	local t_backButton = target["backButton"]
	local t_spriteWidth, t_spriteHeight = _G.res.getSpriteBounds("", "LS_BACK_BUTTON")
	local t_pivotX, t_pivotY = _G.res.getSpritePivot("", "LS_BACK_BUTTON")
	local t_offsetX, t_offsetY = t_pivotX, -(t_spriteHeight-t_pivotY)
	t_backButton.x = t_offsetX
	t_backButton.y = screenHeight + t_offsetY
	t_backButton.activateOnRelease = true
	
	if deviceModel == "roku" then
		t_backButton.x = t_backButton.x + screenWidth * 0.05 - 5
		t_backButton.y = t_backButton.y - screenHeight * 0.05 + 21
	end
	
	local t_sfxButton = target["sfxButton"]	
	t_offsetX, t_offsetY = 50, 50
	t_sfxButton.x, t_sfxButton.y = t_offsetX, t_offsetY
	t_sfxButton.activateOnRelease = true
	t_sfxButton.visible = true
	
	
	local t_sfxOffButton = target["sfxOffButton"]	
	t_offsetX, t_offsetY = 50, 50
	t_sfxOffButton.x, t_sfxOffButton.y = t_offsetX, t_offsetY
	t_sfxOffButton.activateOnRelease = true
	t_sfxOffButton.visible = not settings.audioEnabled
	
	
	prepareItemForMouseScalingStates(t_backButton)
	prepareItemForMouseScalingStates(t_sfxButton)
	prepareItemForMouseScalingStates(t_sfxOffButton, t_sfxButton)
	
end

function drawSoundBoardButtonsFromTable(target)
	local t_backButton = target["backButton"]	
	local t_sfxButton = target["sfxButton"]	
	local t_sfxOffButton = target["sfxOffButton"]	
	
	drawMouseScalingItem("",t_backButton, t_backButton.x, t_backButton.y)
	drawMouseScalingItem("",t_sfxButton, t_sfxButton.x, t_sfxButton.y)
	
	if t_sfxOffButton.visible == true then
		drawMouseScalingItem("",t_sfxOffButton, t_sfxOffButton.x, t_sfxOffButton.y)
	end
	
end

function updateSoundBoardButtonsFromTable(target, dt)
	local t_backButton = target["backButton"]
	local t_sfxButton = target["sfxButton"]
	local t_sfxOffButton = target["sfxOffButton"]
	
	if(keyReleased["LBUTTON"] and t_backButton.mouseState ~= "up") then
		gotoGoldenEggs()
	elseif(keyReleased["LBUTTON"] and t_sfxButton.mouseState ~= "up") then
		toggleSoundBoardSFX()
	elseif(keyReleased["LBUTTON"] and t_sfxOffButton.mouseState ~= "up") then
		toggleSoundBoardSFX()
	end
	
	updateItemMouseOverState(t_backButton, dt)		
	updateItemMouseOverState(t_sfxButton, dt)		
	updateItemMouseOverState(t_sfxOffButton, dt)
	
	
end

function updateSoundBoardMenuButtons(page, dt)
	
	local t_backButton = page.items["back"]
	updateItemMouseOverState(t_backButton, dt)
	
	local t_sfxButton = page.items["buttonSFX"]
	updateItemMouseOverState(t_sfxButton, dt)
	
	local t_sfxOffButton = page.items["buttonSFXOff"]
	updateItemMouseOverState(t_sfxOffButton, dt)
	
	if page:getClickedItem() == t_backButton then
		gotoGoldenEggs()
	elseif page:getClickedItem() == t_sfxButton or page:getClickedItem() == t_sfxOffButton then
		toggleSoundBoardSFX()
	end
end

--------------------------------
--SequencerPage-class, inherits Page
--------------------------------

SequencerPage = Page:new()

function SequencerPage:init()
	self.name = "SequencerPage"
	self.sheet = ""
	self.currentPosition = 0
	self.isPlaying = false
	self.timerTempo = 0
	self.currentTempo = 0.25
	self.timerPlayAnim = 0
	self.soundPlayed = false
	self.birdAnimationClockwise = true
	self.activatedItems = {}
	self.dragging = false
	self.birdStartDraggingX = 0
	self.maxTempo = false
	
	self.barWidth, self.barHeight = _G.res.getSpriteBounds("", "SOUNDBOARD_4_BG")
	self.bfpw, bfph =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_FOOTPRINT")
	
	local sw, sh = _G.res.getSpriteBounds("INGAME_BIRDS_1", "BIRD_BIG_BROTHER")

	local phw1, phh1 =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_PIG_1")
	local phw2, phh2 =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_PIG_1")
	local phw3, phh3 =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_PIG_1")
	self.shw, self.shh =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_HIGHLIGHT")
	
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", selectable = false, x = screenWidth/2, y = screenHeight/2, renderState = true, drawToScreenSize = true } ))
	self:insertItem("sequencerBG", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_BG", x = 0, y = screenHeight * 0.15, xs = screenWidth, selectable = false, renderState = true}))
	
	self:insertItem("sequencerHighlight", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_HIGHLIGHT", x = ((66 * screenWidth) / 960) + (((66 * screenWidth) / 960) * 1.82 * self.currentPosition)  , y = screenHeight * 0.15, xs = 1.0, selectable = false, renderState = true}))
	
	
	local grassW, grassH = _G.res.getSpriteBounds("", "SOUNDBOARD_4_GRASS_TOP")
	local grassAmount = 0
	if grassW ~= 0 then
		grassAmount = _G.math.floor(screenWidth / grassW)
	end
	
	for i = 0, grassAmount do
		self:insertItem("grassTop"..i, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_GRASS_TOP", x = i * grassW, y = screenHeight * 0.15, selectable = false}))
		self:insertItem("grassBottom"..i, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_GRASS_BOTTOM", x = i * grassW, y = screenHeight * 0.15 + ((166 * self.barHeight) / 166), selectable = false}))
	end
	
	for i = 0, 7 do
		self:insertItem("pigLineOne_"..i+1, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_PIG_1", spriteOn = "PIGLETTE_BIG_01", 
		spriteDefault = "SOUNDBOARD_4_PIG_1", spriteActive = "PIGLETTE_BIG_01_SMILE", spriteSleep = "PIGLETTE_BIG_01_BLINK", x = (i * screenWidth / 8) + ((23 * screenWidth) / 480) + ((10 * screenWidth) / 480), 
		y = (screenHeight * 0.15) + ((30 * self.barHeight) / 166) , selectable = true, renderState = true, xOns = 0.45 * phw1 / 42, yOns = 0.45 * phh1 / 44, xs = 1.0, ys = 1.0}))
		self:insertItem("pigLineTwo_"..i+1, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_PIG_2", spriteOn = "PIGLETTE_HELMET_01", 
		spriteDefault = "SOUNDBOARD_4_PIG_2", spriteActive = "PIGLETTE_HELMET_01_SMILE", spriteSleep = "PIGLETTE_HELMET_01_BLINK", x = (i * screenWidth / 8) + ((23 * screenWidth) / 480) + ((10 * screenWidth) / 480), 
		y = (screenHeight * 0.15) + (((30 * self.barHeight) / 166) + ((50 * self.barHeight) / 166)) , selectable = true, renderState = true, xOns = 0.5 * phw2 / 46, yOns = 0.5 * phh2 / 44, xs = 1.0, ys = 1.0}))
		self:insertItem("pigLineThree_"..i+1, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_PIG_3", spriteOn = "PIGLETTE_GRANDPA_01", 
		spriteDefault = "SOUNDBOARD_4_PIG_3", spriteActive = "PIGLETTE_GRANDPA_04_SMILE", spriteSleep = "PIGLETTE_GRANDPA_01_BLINK", x = (i * screenWidth / 8) + ((23 * screenWidth) / 480) + ((10 * screenWidth) / 480), 
		y = (screenHeight * 0.15) + (((30 * self.barHeight) / 166) + ((100 * self.barHeight) / 166)) , selectable = true, renderState = true, xOns = 0.45 * phw3 / 49, yOns = 0.45 * phh3 / 46, xs = 1.0, ys = 1.0}))
		
		local t_pig1Button = self.items["pigLineOne_"..i+1]
		prepareItemForMouseScalingStates(t_pig1Button)
		
		local t_pig2Button = self.items["pigLineTwo_"..i+1]
		prepareItemForMouseScalingStates(t_pig2Button)
		
		local t_pig3Button = self.items["pigLineThree_"..i+1]
		prepareItemForMouseScalingStates(t_pig3Button)
	end
	
	self:insertItem("birdFootprints", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_FOOTPRINT", x = screenWidth / 2, y = screenHeight - (screenHeight * 0.16) + sh / 2.5, selectable = false}))
	self:insertItem("birdShadow", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_SHADOW", x = screenWidth / 2, y = screenHeight - (screenHeight * 0.16) + sh / 2.5, selectable = false}))
	
	local birdScale = 1
	
	if screenWidth > 480 then
		birdScale = 1.5
	end
	
	self:insertItem("birdPlay", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_BIG_BROTHER_BLINK", spritePlay = "BIRD_BIG_BROTHER", 
	spritePressed = "BIRD_BIG_BROTHER_YELL", spriteDefault = "BIRD_BIG_BROTHER_BLINK", x = screenWidth / 2, y = screenHeight - (screenHeight * 0.16), renderState = true, 
	alwaysRender = true, angle = 0, pivotX = sw / 2, pivotY = sh, xs = birdScale, ys = birdScale} ))
	
	addSoundBoardMenuButtons(self)
	
	local t_birdPlayButton = self.items["birdPlay"]
	prepareItemForMouseScalingStates(t_birdPlayButton)
	
	
end

function SequencerPage:update(dt)	
	
	local t_backButton = self.items["back"]
	updateItemMouseOverState(t_backButton, dt)
	
	local t_sfxButton = self.items["buttonSFX"]
	updateItemMouseOverState(t_sfxButton, dt)
	
	local t_sfxOffButton = self.items["buttonSFXOff"]
	updateItemMouseOverState(t_sfxOffButton, dt)
	
	if self:getClickedItem() == t_backButton then
		gotoGoldenEggs()
		return
	elseif self:getClickedItem() == t_sfxButton or self:getClickedItem() == t_sfxOffButton then
		--t_sfxOffButton.visible = not t_sfxOffButton.visible
		toggleSoundBoardSFX()
		return
	end
	
	if keyPressed["ESCAPE"] or deviceModel == "roku" and keyReleased["KEY_BACK"] then
		gotoGoldenEggs()
		return
	end
	
	local t_birdPlayButton = self.items["birdPlay"]
	updateItemMouseOverState(t_birdPlayButton, dt)
	
	for i = 0, 7 do
		
		local t_pig1Button = self.items["pigLineOne_"..i+1]
		updateItemMouseOverState(t_pig1Button, dt)
		
		local t_pig2Button = self.items["pigLineTwo_"..i+1]
		updateItemMouseOverState(t_pig2Button, dt)
		
		local t_pig3Button = self.items["pigLineThree_"..i+1]
		updateItemMouseOverState(t_pig3Button, dt)
	end
	
	
	if keyHold["LBUTTON"] then
		--self.activatedItems = self:getActivatedItems()
		self.activatedItems = self:getHoveredItemKey()
		if self.activatedItems then
			for k, v in _G.pairs(self.activatedItems) do
				if v == "birdPlay" then
					local birdX = cursor.x
					if ( _G.math.abs(self.birdStartDraggingX - cursor.x) > 10) then
						if birdX < (self.items.birdFootprints.x - self.bfpw / 2) then
							birdX = self.items.birdFootprints.x - self.bfpw / 2
						elseif birdX > (self.items.birdFootprints.x + self.bfpw / 2) then
							birdX = self.items.birdFootprints.x + self.bfpw / 2
							self.maxTempo = true
						else
							self.maxTempo = false
						end
						self.items.birdShadow.x = birdX
						self.dragging = true
						self.items["birdPlay"].x = birdX
						self.currentTempo = 0.0007 * (self.items.birdFootprints.x + self.bfpw -  birdX ) 
					else
						self.dragging = false
					end
				end
			end
		end
	end
	
	if keyPressed["LBUTTON"]  then
		self.birdStartDraggingX = cursor.x
		self.activatedItems = self:getActivatedItems()
		self.dragging = false
	end
	
	if keyReleased["LBUTTON"] and not(self.dragging)  then		
		if self.activatedItems then
			for k, v in _G.pairs(self.activatedItems) do
				if v == "birdPlay" then
					self.isPlaying = not(self.isPlaying)
					if self.isPlaying then
					-- Wait 1 second to play the bird animation
						self.items["birdPlay"].sprite = self.items["birdPlay"].spritePressed
						_G.res.playAudio(getAudioName("big_brother_special_1"), 1.0, false, 0)
					else
						--_G.res.playAudio(getAudioName("big_brother_flying"), 1.0, false, 0)
						self.items["birdPlay"].sprite = self.items["birdPlay"].spriteDefault
						self.items["birdPlay"].angle = 0
						self.timerTempo = 0
						self.timerPlayAnim = 0
						self.currentPosition = 0
						self.items["sequencerHighlight"].x = ((66 * screenWidth) / 960) + (((66 * screenWidth) / 960) * 1.82 * self.currentPosition)
						for i = 1, 8 do
							if(self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteOn) or (self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteActive) then
								self.items["pigLineOne_"..i].sprite = self.items["pigLineOne_"..i].spriteSleep
							end
							if(self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteOn) or (self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteActive) then
								self.items["pigLineTwo_"..i].sprite = self.items["pigLineTwo_"..i].spriteSleep
							end
							if(self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteOn) or (self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteActive) then
								self.items["pigLineThree_"..i].sprite = self.items["pigLineThree_"..i].spriteSleep
							end
						end
					end
				else
					if (self.items[v].sprite == self.items[v].spriteDefault) and self.isPlaying then
						self.items[v].xs = self.items[v].xOns
						self.items[v].ys = self.items[v].yOns
						self.items[v].sprite = self.items[v].spriteOn				
					elseif (self.items[v].sprite == self.items[v].spriteDefault) and not(self.isPlaying) then
						self.items[v].xs = self.items[v].xOns
						self.items[v].ys = self.items[v].yOns
						self.items[v].sprite = self.items[v].spriteSleep
					else
						self.items[v].xs = 1.0
						self.items[v].ys = 1.0
						self.items[v].sprite = self.items[v].spriteDefault
					end
				end
			end
		end
	
	end
	if self.isPlaying then
		for i = 1, 8 do
			if(self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteSleep) then
				self.items["pigLineOne_"..i].sprite = self.items["pigLineOne_"..i].spriteOn
			end
			if(self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteSleep) then
				self.items["pigLineTwo_"..i].sprite = self.items["pigLineTwo_"..i].spriteOn
			end
			if(self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteSleep) then
				self.items["pigLineThree_"..i].sprite = self.items["pigLineThree_"..i].spriteOn
			end
		end
		self.timerPlayAnim = self.timerPlayAnim + dt
		if self.timerPlayAnim < 2.0 then
			self.timerPlayAnim = self.timerPlayAnim + dt
			return
		end
		self.items["birdPlay"].sprite = self.items["birdPlay"].spritePlay
		self:play(dt)
		self:playBirdAnimation(dt)
		self:checkComplete()
	end
end

function SequencerPage:checkComplete()
	local levelComplete = true
	
	for i = 1, 8 do
		levelComplete = levelComplete and (self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteOn)
		levelComplete = levelComplete and (self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteOn)
		levelComplete = levelComplete and (self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteOn)
	end
	
	if levelComplete and settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] ~= 2 and self.maxTempo then
		self.isPlaying = false
		self.items["birdPlay"].sprite = self.items["birdPlay"].spriteDefault
		self.items["birdPlay"].angle = 0
		self.timerTempo = 0
		self.timerPlayAnim = 0
		self.currentPosition = 0
		self.items["sequencerHighlight"].x = ((66 * screenWidth) / 960) + (((66 * screenWidth) / 960) * 1.82 * self.currentPosition)
		for i = 1, 8 do
			if(self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteOn) or (self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteActive) then
				self.items["pigLineOne_"..i].sprite = self.items["pigLineOne_"..i].spriteSleep
			end
			if(self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteOn) or (self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteActive) then
				self.items["pigLineTwo_"..i].sprite = self.items["pigLineTwo_"..i].spriteSleep
			end
			if(self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteOn) or (self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteActive) then
				self.items["pigLineThree_"..i].sprite = self.items["pigLineThree_"..i].spriteSleep
			end
		end
		goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
	end
end

function SequencerPage:playBirdAnimation(dt)
	
	if self.birdAnimationClockwise then
		if self.items["birdPlay"].angle < 0.1 then
			self.items["birdPlay"].angle = self.items["birdPlay"].angle + dt / (self.currentTempo * 6 )
		else
			self.birdAnimationClockwise = false
		end
	else
		if self.items["birdPlay"].angle > -0.1 then
			self.items["birdPlay"].angle = self.items["birdPlay"].angle - dt / (self.currentTempo * 6)
		else
			self.birdAnimationClockwise = true
		end
	end
end

function SequencerPage:play(dt)
	self.soundPlayed = false
	-- Start the sequencer
	if not(self.soundPlayed) then
		if(self.items["pigLineOne_"..self.currentPosition+1].sprite == "PIGLETTE_BIG_01") then
			_G.res.playAudio(getAudioName("pig_hi-hat_"..((self.currentPosition+1) % 2)+1), 1.0, false, 0)
			self.items["pigLineOne_"..self.currentPosition+1].sprite = self.items["pigLineOne_"..self.currentPosition+1].spriteActive
			self.items["pigLineOne_"..self.currentPosition+1].xs = self.items["pigLineOne_"..self.currentPosition+1].xOns
		end
		if(self.items["pigLineTwo_"..self.currentPosition+1].sprite == "PIGLETTE_HELMET_01") then
			_G.res.playAudio(getAudioName("pig_snare_"..((self.currentPosition+1) % 4)+1), 1.0, false, 0)
			self.items["pigLineTwo_"..self.currentPosition+1].sprite = self.items["pigLineTwo_"..self.currentPosition+1].spriteActive
			self.items["pigLineTwo_"..self.currentPosition+1].xs = self.items["pigLineTwo_"..self.currentPosition+1].xOns
		end
		if(self.items["pigLineThree_"..self.currentPosition+1].sprite == "PIGLETTE_GRANDPA_01") then
			_G.res.playAudio(getAudioName("pig_bd"), 1.0, false, 0)			
			self.items["pigLineThree_"..self.currentPosition+1].sprite = self.items["pigLineThree_"..self.currentPosition+1].spriteActive
			self.items["pigLineThree_"..self.currentPosition+1].xs = self.items["pigLineThree_"..self.currentPosition+1].xOns
		end
		self.soundPlayed = true
	end
	
	self.timerTempo = self.timerTempo + dt
	if self.timerTempo >= self.currentTempo then
		self.timerTempo = 0
		self.soundPlayed = false
		
		if(self.items["pigLineOne_"..self.currentPosition+1].sprite == self.items["pigLineOne_"..self.currentPosition+1].spriteActive) then
			self.items["pigLineOne_"..self.currentPosition+1].sprite = self.items["pigLineOne_"..self.currentPosition+1].spriteOn
		end
		if(self.items["pigLineTwo_"..self.currentPosition+1].sprite == self.items["pigLineTwo_"..self.currentPosition+1].spriteActive) then
			self.items["pigLineTwo_"..self.currentPosition+1].sprite = self.items["pigLineTwo_"..self.currentPosition+1].spriteOn
		end
		if(self.items["pigLineThree_"..self.currentPosition+1].sprite == self.items["pigLineThree_"..self.currentPosition+1].spriteActive) then
			self.items["pigLineThree_"..self.currentPosition+1].sprite = self.items["pigLineThree_"..self.currentPosition+1].spriteOn
		end
		
		self.currentPosition = self.currentPosition + 1
		
		if self.currentPosition > 7 then
			self.currentPosition = 0
		end
		self.items["sequencerHighlight"].x = ((66 * screenWidth) / 960) + (((66 * screenWidth) / 960) * 1.82 * self.currentPosition)
	end
end

	
--------------------------------
--KeyboardPage-class, inherits Page
--------------------------------

KeyboardPage = Page:new()

function KeyboardPage:init()
	self.name = "Keyboardpage"
	self.sheet = "GOLDEN_EGGS_SHEET_1"
	self.notesPlayed = ""
	self.notes = { C = {}, Cis = {}, D = {}, dis = {}, E = {}, F = {}, Fis = {}, G = {} }
	for k, v in _G.pairs(self.notes) do
		v.pressed = false
		v.playIDs = {nil, nil, nil}
		v.playCounter = 0
	end
	
	self.rightMelody = "CDdisCG"
	self.wholeMelody = "CDdCGGGFddDC"
	self.melodyPauses = { 0.5, 0.1875, 0.1875, 0.375, 0.375, 0.6, 0.375, 0.15, 0.225, 0.375, 0.15, 0.225 }
	self.melodyIndex = 1
	self.currentSound = "noteG"
	self.starCollected = settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 2
	self.sessionStarCollected = false
	self.playMelody = false
	
	local boundingBoxWidth = screenWidth
	local boundingBoxHeight = screenHeight
	
	if boundingBoxWidth > 640 then
		boundingBoxWidth = 640
	end
	
	if boundingBoxHeight > 480 then
		boundingBoxHeight = 480
	end

	
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", selectable = false, x = screenWidth/2, y = screenHeight/2, renderState = true, drawToScreenSize = true } ))
	self:insertItem("shadow1", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 72 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 157 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), selectable = false} ))
	self:insertItem("shadow2", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 168 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 157 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), selectable = false } ))
	self:insertItem("shadow3", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 390 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 159 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), selectable = false } ))
	self:insertItem("shadow4", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 41 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 232 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), selectable = false, renderState = true, xs = 0.5, ys = 0.5 } ))
	self:insertItem("shadow5", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 122 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 232 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), selectable = false, renderState = true, xs = 0.65, ys = 0.65 } ))
	self:insertItem("shadow6", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 212 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 234 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), selectable = false, renderState = true, xs = 0.9, ys = 0.9 } ))
	self:insertItem("shadow7", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 315 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 245 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), selectable = false } ))
	self:insertItem("shadow8", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 420 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 249 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), selectable = false, renderState = true, xs = 0.85, ys = 0.85 } ))
	self:insertItem("C", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_BLUE", sprite2 = "BIRD_BLUE_YELL", defaultSprite = "BIRD_BLUE", x = 39 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 221 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), defaultY = 221 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)} ))
	self:insertItem("Cis", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_GREY", sprite2 = "BIRD_GREY_YELL", defaultSprite = "BIRD_GREY", x = 72 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 132 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), defaultY = 132 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)} ))
	self:insertItem("D", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_RED", sprite2 = "BIRD_RED_YELL", defaultSprite = "BIRD_RED", x = 123 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 218 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), defaultY = 218 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)}))
	self:insertItem("dis", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_GREY_BLINK", sprite2 = "BIRD_GREY_YELL", defaultSprite = "BIRD_GREY_BLINK", x = 168 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 132 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), defaultY = 132 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)} ))
	self:insertItem("E", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_YELLOW", sprite2 = "BIRD_YELLOW_YELL", defaultSprite = "BIRD_YELLOW", x = 212 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 218 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), defaultY = 218 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)} ))
	self:insertItem("F", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_GREEN", sprite2 = "BIRD_GREEN_YELL", defaultSprite = "BIRD_GREEN", x = 315 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 215 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), defaultY = 215 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)} ))
	self:insertItem("Fis", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_GREY_FLYING", sprite2 = "BIRD_GREY_YELL", defaultSprite = "BIRD_GREY_FLYING", x = 392 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 134 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), defaultY = 134 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)} ))
	self:insertItem("G", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_BOOMERANG", sprite2 = "BIRD_BOOMERANG_YELL", defaultSprite = "BIRD_BOOMERANG", x = 434 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = 222 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), defaultY = 222 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)} ))
	
	self.items.C.clickArea = {xLeft = 10 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), xRight = 70 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), yBot = 241 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), yTop = 185 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)}
	self.items.D.clickArea = {xLeft = 77 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), xRight = 160 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), yBot = 250 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), yTop = 175 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)}

	--repositioning shadows
	local t_shadowOffsetsY = {-10, -10, -10, -10, -10, -8, -13, -13}
	local t_shadowOffsetsX = {0, 0, 0, -8, 0, 0, -3, 0}
	for i=1, 8, 1 do
		local t_shadow = self.items["shadow" .. i]	
		local t_ys = t_shadow.ys or 1
		local t_xs = t_shadow.xs or 1
		t_shadow.y = t_shadow.y + (t_shadowOffsetsY[i] * t_ys)
		t_shadow.x = t_shadow.x + (t_shadowOffsetsX[i] * t_xs)
	end
	
	
	local t_cButton = self.items["C"]			
	local t_cisButton = self.items["Cis"]		
	local t_dButton = self.items["D"]	
	local t_disButton = self.items["dis"]	
	local t_eButton = self.items["E"]	
	local t_fButton = self.items["F"]
	local t_fisButton = self.items["Fis"]
	local t_gButton = self.items["G"]
	prepareItemForMouseScalingStates(t_cButton)
	prepareItemForMouseScalingStates(t_cisButton)
	prepareItemForMouseScalingStates(t_dButton)
	prepareItemForMouseScalingStates(t_disButton)
	prepareItemForMouseScalingStates(t_eButton)
	prepareItemForMouseScalingStates(t_fButton)
	prepareItemForMouseScalingStates(t_fisButton)
	prepareItemForMouseScalingStates(t_gButton)
	
	
	addSoundBoardMenuButtons(self)
	
end


function KeyboardPage:update(dt)
	
	if keyPressed["ESCAPE"] or deviceModel == "roku" and keyReleased["KEY_BACK"] then
		gotoGoldenEggs()
		return
	end
	
	updateSoundBoardMenuButtons(self, dt)
	
		
	local t_cButton = self.items["C"]			
	local t_cisButton = self.items["Cis"]		
	local t_dButton = self.items["D"]	
	local t_disButton = self.items["dis"]	
	local t_eButton = self.items["E"]	
	local t_fButton = self.items["F"]
	local t_fisButton = self.items["Fis"]
	local t_gButton = self.items["G"]
	
	updateItemMouseOverState(t_cButton, dt)
	updateItemMouseOverState(t_cButton, dt)
	updateItemMouseOverState(t_cisButton, dt)
	updateItemMouseOverState(t_dButton, dt)
	updateItemMouseOverState(t_disButton, dt)
	updateItemMouseOverState(t_eButton, dt)
	updateItemMouseOverState(t_fButton, dt)
	updateItemMouseOverState(t_fisButton, dt)
	updateItemMouseOverState(t_gButton, dt)
	
	if self.playMelody then
		return self:play(dt)
	end
	
	if popupPage then
		return
	end
	
	if not settings.audioEnabled then
		_G.res.stopAllAudio()
	end
	
	for k, v in _G.pairs(self.notes) do
		for i = 1, 3 do
			if self.notes[k].playIDs[i] ~= nil and not _G.res.isAudioPlaying(self.notes[k].playIDs[i]) then
				self.notes[k].playIDs[i] = nil
				self.notes[k].playCounter = self.notes[k].playCounter - 1
			end
		end
	end
	
	local restore = false
	--if touchcount >= 1 then
	if keyHold["LBUTTON"] then
		-- Touches need to be checked with default bird sprites or sound might loop with
		-- certain cursor positions.
		local keysWithYellSprite = {}
		local tmpYs
		for k, v in _G.pairs(self.items) do
			if v.defaultSprite and v.sprite ~= v.defaultSprite then
				_G.table.insert(keysWithYellSprite, {key = k, y = v.y})
				v.sprite, v.sprite2 = v.sprite2, v.sprite
				v.y = v.defaultY
				if v.alwaysRender then
					tmpYs = v.ys
					v.ys = v.defaultYs
				end
			end
		end
		--local activatedItems = self:getActivatedItems()
		local activatedItems = self:getHoveredItemKey()
		-- Restore yell sprites.
		for k, v in _G.pairs(keysWithYellSprite) do
			local _, h = _G.res.getSpriteBounds(self.items[v.key].sheet, self.items[v.key].sprite)
			self.items[v.key].sprite, self.items[v.key].sprite2 = self.items[v.key].sprite2, self.items[v.key].sprite
			self.items[v.key].y = v.y
			if self.items[v.key].alwaysRender then
				self.items[v.key].ys = tmpYs	
			end
		end
	
		if activatedItems then
			for k, v in _G.pairs(activatedItems) do
				if self.notes[v] ~= nil then
					self.notes[v].activated = true
				end
			end
			
			for key, value in _G.pairs(self.notes) do	
				if value.pressed and not value.activated then
					self:restoreKey(key)
				end
				local sound = "note" .. key
				if not value.pressed and value.activated then 
					if self.notes[key].playCounter <= 3 then
						self:pressKey(key)
						local c = _G.res.playAudio(sound, 1.0, false, 0)
						for i = 1, 3 do
							if self.notes[key].playIDs[i] == nil then
								self.notes[key].playIDs[i] = c
								self.notes[key].playCounter = self.notes[key].playCounter + 1
								break
							end
						end
						if not self.sessionStarCollected then
							self.notesPlayed = self.notesPlayed .. key	
						end	
					end
				end
				value.activated = false 
			end
		else
			restore = true
		end
	else
		restore = true
	end

	if restore then
		for k, v in _G.pairs(self.notes) do
			self:restoreKey(k)
		end
	end

	if _G.string.sub(self.rightMelody, 1, #self.notesPlayed) ~= self.notesPlayed then
		-- Check if new correct melody was started.
		if _G.string.sub(self.notesPlayed, #self.notesPlayed) == "C" then
			self.notesPlayed = "C"
		elseif _G.string.sub(self.notesPlayed, #self.notesPlayed - 1, #self.notesPlayed) == "CD" then
			self.notesPlayed = "CD"
		else
			self.notesPlayed = ""
		end
	elseif self.notesPlayed == self.rightMelody then
		self.notesPlayed = ""
		self.playMelody = true
	end
	
end

function KeyboardPage:play(dt)
	self.melodyPauses[self.melodyIndex] = self.melodyPauses[self.melodyIndex] - dt
	if self.melodyPauses[self.melodyIndex] > 0 then
		return
	else
		self:restoreKey(_G.string.sub(self.currentSound, 5, #self.currentSound))
		local key = _G.string.sub(self.wholeMelody, self.melodyIndex, self.melodyIndex)
		if key == "d" then
			key = key .. "is"
		end	
		self:pressKey(key)
		self.currentSound = "note" .. key
		_G.res.playAudio(self.currentSound, 1.0, false, 0)
		self.melodyIndex = self.melodyIndex + 1
		
		if self.melodyIndex > #self.wholeMelody then
			self.playMelody = false
			goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
			self.sessionStarCollected = true
		end
	end
end

function KeyboardPage:restoreKey(k)
	if self.notes[k].pressed then
		self.items[k].ys = self.items[k].defaultYs or 1
		self.items[k].y = self.items[k].defaultY
		if not self.items[k].alwaysRender then
			self.items[k].renderState = false
		end
		if self.items[k].sprite ~= self.items[k].defaultSprite then
			self.items[k].sprite, self.items[k].sprite2 = self.items[k].sprite2, self.items[k].sprite
		end
		self.notes[k].pressed = false
	end
end

function KeyboardPage:pressKey(key)
	self.notes[key].pressed = true
	local item = self.items[key] 
	item.renderState = true
	local _, h = _G.res.getSpriteBounds(item.sheet, item.sprite)
	if item.alwaysRender and item.defaultYs then
		item.ys = item.ys * 0.85
		item.y = _G.math.floor(item.y + ((h * item.defaultYs - (h * item.ys)) / 2))
	else
		item.ys = 0.85
		item.y = _G.math.floor(item.y + ((h - (h * 0.85)) / 2))
	end
	self.items[key].sprite, self.items[key].sprite2 = self.items[key].sprite2, self.items[key].sprite
end


--------------------------------
--AccordionPage-class, inherits Page
--------------------------------

AccordionPage = Page:new()

function AccordionPage:init()
	self.name = "AccordionPage"
	self.sheet = ""
	
	self.bellowsW, self.bellowsH = _G.res.getSpriteBounds("","ACCO_MID")
	self.bellowsPX, self.bellowsPY = _G.res.getSpritePivot("","ACCO_MID")
	self.grandpaW, self.grandpaH = _G.res.getSpriteBounds("","PIGLETTE_GRANDPA_01")
	
	self.rightHandleW, self.rightHandleH = _G.res.getSpriteBounds("","ACCO_RIGHT")
	self.cursorData = { x = 0, y = 0, speedX = 0, speedY = 0}
	self.handleCursorData = {x = 1, y = 1}
	self.cursorReleased = true
	self.activeButton = nil
	
	self.ripCount = 0
	self.levelComplete = false
	self.resetRipStatus = false
	self.ripTimer = 0
	
	self.currentVolumeLeft = 0
	self.currentVolumeRight = 0
	self.isPlaying = false
	self.direction = "left"
	self.timerVolume = 0
	self.currentTrack = 5
	
	self.grandpaTimer = 0
	self.grandpaIsActive = true
	
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", selectable = false, x = screenWidth/2, y = screenHeight/2, renderState = true, drawToScreenSize = true } ))
	
	-- Accordion
	self:insertItem("accordionBellowsBroken", SpriteItem:new( { sheet = "", sprite = "ACCO_MID_BROKEN", visible = false, selectable = false, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2 } ))
	self:insertItem("accordionBellows", SpriteItem:new( { sheet = "", sprite = "ACCO_MID", selectable = false, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, renderState = true, xs = (self.bellowsW / 2 + self.bellowsW / 4) / (self.bellowsW - self.bellowsPX) , ys = 1 } ))
	self:insertItem("accordionLHandle", SpriteItem:new( { sheet = "", sprite = "ACCO_LEFT", selectable = false, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2 } ))
	self:insertItem("accordionRHandle", SpriteItem:new( { sheet = "", sprite = "ACCO_RIGHT", selectable = true, x = screenWidth/2 + self.bellowsW / 4, y = screenHeight/2 } ))
	
	-- Buttons
	self:insertItem("accButton1", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_1", spriteOn = "ACCO_BTN_DOWN_1", spriteOff = "ACCO_BTN_UP_1", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "cminor" } ))
	self:insertItem("accButton2", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_2", spriteOn = "ACCO_BTN_DOWN_2", spriteOff = "ACCO_BTN_UP_2", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "dismajor" } ))
	self:insertItem("accButton3", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_3", spriteOn = "ACCO_BTN_DOWN_3", spriteOff = "ACCO_BTN_UP_3", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "fmajor" } ))
	self:insertItem("accButton4", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_4", spriteOn = "ACCO_BTN_DOWN_4", spriteOff = "ACCO_BTN_UP_4", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "gminor" } ))
	self:insertItem("accButton5", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_5", spriteOn = "ACCO_BTN_DOWN_5", spriteOff = "ACCO_BTN_UP_5", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "bmajor" } ))
	
	-- Grandpa
	local grandpaScale = 0.75 * screenWidth / 480
	if grandpaScale > 1.5 then
		grandpaScale = 1.5
	end
	self:insertItem("birdShadow", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_SHADOW", x = screenWidth - self.grandpaW * grandpaScale / 1.75, y = screenHeight - self.grandpaH * grandpaScale / 7, selectable = false}))
	self:insertItem("grandpa", SpriteItem:new( { sheet = "", sprite = "PIGLETTE_GRANDPA_01", selectable = true, x = screenWidth - self.grandpaW * grandpaScale / 1.75, y = screenHeight - self.grandpaH * grandpaScale / 1.75, xs = grandpaScale, ys = grandpaScale, renderState = true } ))
	
	if deviceModel == "roku" then
		self.items.birdShadow.x, self.items.birdShadow.y = screenWidth - self.grandpaW * grandpaScale / 0.9, screenHeight - (self.grandpaH * grandpaScale / 1.5) 
		self.items.grandpa.x, self.items.grandpa.y = screenWidth - self.grandpaW * grandpaScale / 0.9, screenHeight - self.grandpaH * grandpaScale / 0.9
	end
	
	-- Back Button
	-- self:insertItem("back", SpriteItem:new( {sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight, selectable = false } ))
	
	addSoundBoardMenuButtons(self)
end

function AccordionPage:update(dt)
	local t_backButton = self.items["back"]
	updateItemMouseOverState(t_backButton, dt)
	
	local t_sfxButton = self.items["buttonSFX"]
	updateItemMouseOverState(t_sfxButton, dt)
	
	local t_sfxOffButton = self.items["buttonSFXOff"]
	updateItemMouseOverState(t_sfxOffButton, dt)
	
	if self:getClickedItem() == t_backButton then
		gotoGoldenEggs()
		return
	elseif self:getClickedItem() == t_sfxButton or self:getClickedItem() == t_sfxOffButton then
		--t_sfxOffButton.visible = not t_sfxOffButton.visible
		toggleSoundBoardSFX()
		return
	end
	
	if keyPressed["ESCAPE"] or deviceModel == "roku" and keyReleased["KEY_BACK"] then
		gotoGoldenEggs()
		return
	end
	
	_G.res.setTrackVolume(0, 7)
	if cursor.x > (self.items["accordionLHandle"].x + self.bellowsW * 1.2) and self.accordionIsActive == true and touchcount >= 1 then
		self.accordionIsActive = true
		self:play(-dt, self.direction, self.activeButton, dt)
		
	else
		self.accordionIsActive = false
	end
	
	if self.levelCompleted ~= true then
		if touchcount >= 1 then
			--print("touches: ".. touchcount .."\n")
			self.activatedItems, self.activatedItemsTouchData = self:getActivatedItems()
			
			if self.activatedItems then
				for k, v in _G.pairs(self.activatedItems) do
					
					if v == "accordionRHandle" and self.cursorData.x ~= 0 and self.cursorData.y ~= 0 then
						
						if self.handleCursorData.x ~= touches[self.activatedItemsTouchData[v]].x then
							self.handleCursorData = touches[self.activatedItemsTouchData[v]]						
							self:updateBellows(self.handleCursorData.x)
							local currentDirection = self.direction
						
							if self.handleCursorData.x - self.cursorData.x > 2 then
								currentDirection = "right"
							elseif self.handleCursorData.x - self.cursorData.x < -2 then
								currentDirection = "left"
							end
							
							if self.direction ~= currentDirection then
								if currentDirection == "right" then
									self.currentTrack = 6
									self.currentVolumeRight = self.currentVolumeLeft
									self.currentVolumeLeft = 0
									_G.res.setTrackVolume(self.currentVolumeRight, 6)
									_G.res.setTrackVolume(0, 5)
								else
									self.currentTrack = 5
									self.currentVolumeLeft = self.currentVolumeRight
									self.currentVolumeRight = 0
									_G.res.setTrackVolume(0, 6)
									_G.res.setTrackVolume(self.currentVolumeLeft, 5)
								end
								--print("changing direction")
								if self.grandpaIsActive == true then
									if self.items["grandpa"].sprite == "PIGLETTE_GRANDPA_01" then
										self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_04_SMILE"
									else
										self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_01"
									end
									_G.res.playAudio(getAudioName("pig_accordion"), 0.7, false, 0)
								end
								--self.isPlaying = false
								self.direction = currentDirection
							end
							
							self:play(_G.tonumber(_G.string.format("%.1f", self.cursorData.speedX)), self.direction, self.activeButton, dt)
							--self:updateGrandpa(dt)
						else
							self:play(-dt, self.direction, self.activeButton, dt)
						end

						self.accordionIsActive = true
					elseif v == "grandpa" and keyPressed["LBUTTON"] then
						self.grandpaIsActive = not self.grandpaIsActive
						if self.grandpaIsActive == false then
							self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_01_BLINK"
						else
							self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_01"
						end
					elseif _G.string.sub(v, 1, _G.string.len(v) - 1) == "accButton" and touchcount <= 2 then
						self:activateButton(self.items[v])
					end
				end
			self.cursorReleased = false
			end
			
			-- if (self.handleCursorData.x > self.cursorData.x) and self.cursorData.speedX > 0.9 and self.handleCursorData.x > (self.items["accordionLHandle"].x + self.bellowsW * 0.5) and self.resetRipStatus ~= true then
				-- print("self.ripCount: "..self.ripCount)
				-- self.ripCount = self.ripCount + 1
				-- self.resetRipStatus = true
			-- end
			
			if self.items["accordionRHandle"].x >= (screenWidth/2 + self.bellowsW / 2.1) then
				self.ripTimer = self.ripTimer + dt
			else
				self.ripTimer = 0
			end
			
			if self.accordionIsActive == true and self.handleCursorData.x < (self.items["accordionLHandle"].x + self.bellowsW * 0.5) then
				self.resetRipStatus = false
			end
			self.cursorData.x = self.handleCursorData.x
			self.cursorData.y = self.handleCursorData.y
		else
			self.ripCount = 0
			self.ripTimer = 0
			self.cursorData.speedX = 0
			self.cursorReleased = true
		end
		
		if self.accordionIsActive ~= true then
			self:restoreBellows(dt)
		end
		
		-- if self.ripCount >= 7 * screenWidth / 480 then
			-- _G.res.stopAllAudio()
			-- self.ripCount = 0
			-- self.levelCompleted = true
			-- self.items["accordionBellowsBroken"].visible = true
			-- self.items["accordionBellows"].xs = 1
			-- self.items["accordionRHandle"].x = screenWidth / 2 + self.bellowsW / 2
			-- self:ripBellows()
		-- end
		
		if self.ripTimer >= 3 then
			_G.res.stopAllAudio()
			self.ripTimer = 0
			self.levelCompleted = true
			self.items["accordionBellowsBroken"].visible = true
			self.items["accordionBellows"].xs = 1
			self.items["accordionRHandle"].x = screenWidth / 2 + self.bellowsW / 2.5
			self:ripBellows()
		end
	else
		self:playRipAnimation(dt)
	end
	
end

function AccordionPage:playRipAnimation(dt)
	if self.items["accordionRHandle"].x <= (screenWidth * 2) then
		self.items["accordionRHandle"].x = self.items["accordionRHandle"].x + self.items["accordionRHandle"].x * 2*dt
		self.items["accordionBellows"].x = self.items["accordionBellows"].x + self.items["accordionRHandle"].x * 2*dt
	end
end

function AccordionPage:ripBellows()
	_G.res.playAudio(getAudioName("accordion_break"), 0.7, false, 0)
	goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
end

function AccordionPage:updateBellows(posX)
	if posX > (self.items["accordionLHandle"].x + self.rightHandleW / 2 + self.bellowsPX) and posX <= (screenWidth/2 + self.bellowsW / 2 + self.rightHandleW / 2) then
								
		self.cursorData.speedX = (_G.math.abs((self.items["accordionRHandle"].x - (posX - self.rightHandleW / 2))) / (self.bellowsW / 20))
		if self.cursorData.speedX > 1 then
			self.cursorData.speedX = 1
		end
		
		self.items["accordionRHandle"].x = posX - self.rightHandleW / 2
		self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
	end
	if self.items["accordionRHandle"].x > (screenWidth/2 + self.bellowsW / 2) then
		self.items["accordionRHandle"].x = screenWidth/2 + self.bellowsW / 2
		self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
	end		
end

function AccordionPage:restoreBellows(dt)
	if self.items["accordionRHandle"].x < (screenWidth/2 + self.bellowsW / 4 ) then
		if self.isPlaying == true and self.direction ~= "right" then
			self.currentTrack = 6
			self.currentVolumeRight = self.currentVolumeLeft
			self.currentVolumeLeft = 0
			self.direction = "right"
			_G.res.setTrackVolume(self.currentVolumeRight, 6)
			_G.res.setTrackVolume(0, 5)
		end
		self.items["accordionRHandle"].x = self.items["accordionRHandle"].x + self.items["accordionRHandle"].x * dt
		
		if self.items["accordionRHandle"].x > (screenWidth/2 + self.bellowsW / 4) then
			self.items["accordionRHandle"].x = (screenWidth/2 + self.bellowsW / 4)
		end
		
		self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
			
		self:play(-dt, self.direction, self.activeButton, dt)
	-- end
	elseif self.items["accordionRHandle"].x > (screenWidth/2 + self.bellowsW / 4 ) then
		if self.isPlaying == true and self.direction ~= "left" then
			self.currentTrack = 5
			self.currentVolumeLeft = self.currentVolumeRight
			self.currentVolumeRight = 0
			self.direction = "left"
			_G.res.setTrackVolume(self.currentVolumeLeft, 5)
			_G.res.setTrackVolume(0, 6)
		end
		self.items["accordionRHandle"].x = self.items["accordionRHandle"].x - self.items["accordionRHandle"].x * dt
		
		if self.items["accordionRHandle"].x < (screenWidth/2 + self.bellowsW / 4 ) then
			self.items["accordionRHandle"].x = (screenWidth/2 + self.bellowsW / 4 )
		end
		
		self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
		
		self:play(-dt, self.direction, self.activeButton, dt)
	else
		self:play(-dt, self.direction, self.activeButton, dt)
		if self.grandpaIsActive == true then
			self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_01"
		end
	end
	-- if self.items["accordionRHandle"].x >= (screenWidth/2 + self.bellowsW / 4) then
		-- self:play(-dt, self.direction, self.activeButton, dt)
		-- self.items["accordionRHandle"].x = screenWidth/2 + self.bellowsW / 4
		-- self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
	-- end
end

function AccordionPage:activateButton(button)
	if button ~= self.activeButton  then
		_G.res.stopAllAudio()
		self.isPlaying = false
		self.activeButton = button
		for i = 1, 5 do
			if self.items["accButton"..i] == button then
				if self.items["accButton"..i].sprite == self.items["accButton"..i].spriteOff then
					self.items["accButton"..i].sprite = self.items["accButton"..i].spriteOn
				end
			else
				self.items["accButton"..i].sprite = self.items["accButton"..i].spriteOff
			end
		end
	end
end

function AccordionPage:play(volume, direction, activeButton, dt)
	if audioRampVolume then
		--_G.res.stopAllAudio()
		self.currentVolumeRight = 0
		self.currentVolumeLeft = 0
		self.isPlaying = false
		return
	end
	
	--volume = 0.5
	self.timerVolume = self.timerVolume + dt
	
	if self.timerVolume >= 0.03 then
		self.timerVolume = 0
		if self.currentTrack == 6 then
			if volume < 0 then
				if self.currentVolumeRight >= 0 then
					self.currentVolumeRight = self.currentVolumeRight + volume
				end
			else
				if (volume - self.currentVolumeRight) > 0.1 then
					self.currentVolumeRight = self.currentVolumeRight + 0.1
				elseif (volume - self.currentVolumeRight) < -0.1 then
					self.currentVolumeRight = self.currentVolumeRight - 0.1
				else
					self.currentVolumeRight = volume
				end
			end
			_G.res.setTrackVolume(self.currentVolumeRight, self.currentTrack)
		else
			if volume < 0 then
				if self.currentVolumeLeft >= 0 then
					self.currentVolumeLeft = self.currentVolumeLeft + volume
				end
			else
				if (volume - self.currentVolumeLeft) > 0.1 then
					self.currentVolumeLeft = self.currentVolumeLeft + 0.1
				elseif (volume - self.currentVolumeLeft) < -0.1 then
					self.currentVolumeLeft = self.currentVolumeLeft - 0.1
				else
					self.currentVolumeLeft = volume
				end
			end
			_G.res.setTrackVolume(self.currentVolumeLeft, self.currentTrack)
		end
		
		
	end
	
	--if _G.res.isAudioPlaying(activeButton.sound.."_"..direction) == false then
		
		if self.isPlaying ~= true then
			_G.res.setTrackVolume(0, 5)
			_G.res.setTrackVolume(0, 6)
			--print(""..activeButton.sound.."_"..direction.." volumeRight: "..self.currentVolumeRight.." volumeLeft: "..self.currentVolumeLeft)
			if activeButton ~= nil then
				_G.res.playAudio(activeButton.sound.."_right", 1, true, 6)
				_G.res.playAudio(activeButton.sound.."_left", 1, true, 5)
			else
				_G.res.playAudio("empty_accordion_right", 1, true, 6)
				_G.res.playAudio("empty_accordion_left", 1, true, 5)
			end
			self.isPlaying = true
		end
end


----------------

function getItemByName(items, name)
	
	for i = 1, #items do
		if items[i].name == name then
			return items[i], i
		elseif items[i].children ~= nil then
			for j = 1, #items[i].children do
				if items[i].children[j].name == name then
					return items[i].children[j], i, j
				end
			end
		end
	end
	
end

function updatePictureLevel(dt)
	
	if currentPictureLevel == "PIGGY" then
		piggyPage:update(dt)
		piggyPage:draw()
	elseif currentPictureLevel == "MIGHTY_EAGLE" then
		eaglePage:update(dt)
		eaglePage:draw()
	end
	
end


function drawPictureLevel(page)
	
	for i, v in _G.ipairs(page.items) do
		
		local xCoord = v.x or 0
		local yCoord = v.y or 0
		local sheet = v.sheet or page.defaultSheet or ""
	
		if 	v.name == "wheel" or v.name == "preset1" or  
			v.name == "preset2" or v.name == "preset3" or
			v.name == "preset4" or v.name == "presetUp1" or
			v.name == "presetUp2" or v.name == "presetUp3" or
			v.name == "presetUp4" then
			--[[
			local w, h = _G.res.getSpriteBounds(sheet, v.sprite)
			setRenderState(0, 0, 1, 1, v.angle, w / 2, h / 2)
			_G.res.drawSprite("", v.sprite, xCoord, yCoord)
			setRenderState(0, 0, 1, 1, 0)
			]]
			
			if v.visible ~= false then
				drawMouseScalingItem(sheet, v, v.x, v.y)			
			end
			setRenderState(0, 0, 1, 1, 0)
		elseif v.name == "bird" then
			local tmpWidth, tmpHeight = _G.res.getSpriteBounds(sheet, v.sprite)
			setRenderState(0, 0, 1, 1, v.angle, tmpWidth / 2, tmpHeight)
			_G.res.drawSprite("", v.sprite, xCoord, yCoord)
			setRenderState(0, 0, 1, 1, 0)
		else
			if i == 1 then -- background
				_G.res.drawSprite("", v.sprite, xCoord - screenWidth / 2, yCoord - screenHeight / 2, "TOP", "LEFT", screenWidth, screenHeight)
			else
				_G.res.drawSprite("", v.sprite, xCoord, yCoord)
			end
		end
	end
	--_G.res.drawSprite("", "LS_BACK_BUTTON", 0, screenHeight)

end


function initSoundboard()
	print("\n initing soundboard")
	_G.res.stopAudio("title_theme")
	
	if currentSoundboard == "KEYBOARD" then
		keyboardPage = KeyboardPage:new()
		--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level12"] .. "\n")
		logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level12"]) 
	elseif currentSoundboard == "SEQUENCER" then
		sequencerPage = SequencerPage:new()	
		setGameOn(true) -- disable screen saver
	elseif currentSoundboard == "ACCORDION" then
		accordionPage = AccordionPage:new()	
		setGameOn(true) -- disable screen saver
	elseif currentSoundboard == "SOUNDBOARD1" then
		soundPage = { starEffect = false, 
				  starTimer = 0,
				  starAngle = 0,
				  items = {}
				}
		soundPage.state = 0
		soundPage.currentBird = 0
		soundPage.starState = 0
		soundPage.buttonPressTimes = {}
		soundPage.sessionStarCollected = false
		
		
		for i = 1, 16 do
			soundPage.buttonPressTimes[i] = 0
		end
		
		local boundingBox = { maxWidth = 1024, maxHeight = 768, left = 0, top = 0, width = screenWidth, height = screenHeight }
		
		if screenWidth > boundingBox.maxWidth then
			boundingBox.left = (screenWidth / 2) - (boundingBox.maxWidth / 2)
			boundingBox.width = boundingBox.maxWidth
		end
		
		if screenHeight > boundingBox.maxHeight then
			boundingBox.top = (screenHeight / 2) - (boundingBox.maxHeight / 2)
			boundingBox.height = boundingBox.maxHeight
		end
		
		
		_G.table.insert(soundPage.items, { sheet = "", sprite = "GOLDEN_EGG_BG_2", x = screenWidth / 2, y = screenHeight / 2})
		soundPage.defaultSheet = ""
		
		--[[
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_BLOCK_ICE", x = boundingBox.left + boundingBox.width * 0.89, y = boundingBox.top + boundingBox.height * 0.50625})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_BLOCK_WOOD", x = boundingBox.left + boundingBox.width * 0.78, y = boundingBox.top + boundingBox.height * 0.5075})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_BLOCK_STONE", x = boundingBox.left + boundingBox.width * 0.67, y = boundingBox.top + boundingBox.height * 0.5049})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_TNT", x = boundingBox.left + boundingBox.width * 0.52, y = boundingBox.top + boundingBox.height * 0.5})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_SLINGSHOT", x = boundingBox.left + boundingBox.width * 0.34, y = boundingBox.top + boundingBox.height * 0.5})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_PIG_KING", x = boundingBox.left + boundingBox.width * 0.89, y = boundingBox.top + boundingBox.height * 0.82})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_PIG_OLD", x = boundingBox.left + boundingBox.width * 0.68, y = boundingBox.top + boundingBox.height * 0.82})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_PIG_HELMET", x = boundingBox.left + boundingBox.width * 0.48, y = boundingBox.top + boundingBox.height * 0.85})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_PIG_SMALL", x = boundingBox.left + boundingBox.width * 0.305, y = boundingBox.top + boundingBox.height * 0.88})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_LEVEL_FAIL", x = boundingBox.left + boundingBox.width * 0.17, y = boundingBox.top + boundingBox.height * 0.6460})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_LEVEL_START", x = boundingBox.left + boundingBox.width * 0.15, y = boundingBox.top + boundingBox.height * 0.34})
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_WHITE", x = boundingBox.left + boundingBox.width * 0.89, y = boundingBox.top + boundingBox.height * 0.1837 })
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_BLACK", x = boundingBox.left + boundingBox.width * 0.7, y = boundingBox.top + boundingBox.height * 0.1807 })
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_YELLOW", x = boundingBox.left + boundingBox.width * 0.52, y = boundingBox.top + boundingBox.height * 0.16107 })
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_RED", x = boundingBox.left + boundingBox.width * 0.36, y = boundingBox.top + boundingBox.height * 0.1415 })
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_BLUE", x = boundingBox.left + boundingBox.width * 0.23, y = boundingBox.top + boundingBox.height * 0.13 })
		]]--
		
		soundPage.items["blockIce"] = {sprite = "SOUNDBOARD_1_BLOCK_ICE", x = boundingBox.left + boundingBox.width * 0.89, y = boundingBox.top + boundingBox.height * 0.50625}
		soundPage.items["blockWood"] = {sprite = "SOUNDBOARD_1_BLOCK_WOOD", x = boundingBox.left + boundingBox.width * 0.78, y = boundingBox.top + boundingBox.height * 0.5075}
		soundPage.items["blockStone"] = {sprite = "SOUNDBOARD_1_BLOCK_STONE", x = boundingBox.left + boundingBox.width * 0.67, y = boundingBox.top + boundingBox.height * 0.5049}
		soundPage.items["blockTNT"] = {sprite = "SOUNDBOARD_1_TNT", x = boundingBox.left + boundingBox.width * 0.52, y = boundingBox.top + boundingBox.height * 0.5}
		soundPage.items["blockSlingshot"] = {sprite = "SOUNDBOARD_1_SLINGSHOT", x = boundingBox.left + boundingBox.width * 0.34, y = boundingBox.top + boundingBox.height * 0.5}
		soundPage.items["blockPigKing"] = {sprite = "SOUNDBOARD_1_PIG_KING", x = boundingBox.left + boundingBox.width * 0.89, y = boundingBox.top + boundingBox.height * 0.82}
		soundPage.items["blockPigOld"] = {sprite = "SOUNDBOARD_1_PIG_OLD", x = boundingBox.left + boundingBox.width * 0.68, y = boundingBox.top + boundingBox.height * 0.82}
		soundPage.items["blockPigHelmet"] = {sprite = "SOUNDBOARD_1_PIG_HELMET", x = boundingBox.left + boundingBox.width * 0.48, y = boundingBox.top + boundingBox.height * 0.85}
		soundPage.items["blockPigSmall"] = {sprite = "SOUNDBOARD_1_PIG_SMALL", x = boundingBox.left + boundingBox.width * 0.305, y = boundingBox.top + boundingBox.height * 0.88}
		soundPage.items["blockLevelFail"] = {sprite = "SOUNDBOARD_1_LEVEL_FAIL", x = boundingBox.left + boundingBox.width * 0.17, y = boundingBox.top + boundingBox.height * 0.6460}
		soundPage.items["blockLevelStart"] = {sprite = "SOUNDBOARD_1_LEVEL_START", x = boundingBox.left + boundingBox.width * 0.15, y = boundingBox.top + boundingBox.height * 0.34}
		soundPage.items["blockBirdWhite"] = { sprite = "SOUNDBOARD_1_BIRD_WHITE", x = boundingBox.left + boundingBox.width * 0.89, y = boundingBox.top + boundingBox.height * 0.1837 }
		soundPage.items["blockBirdBlack"] = { sprite = "SOUNDBOARD_1_BIRD_BLACK", x = boundingBox.left + boundingBox.width * 0.7, y = boundingBox.top + boundingBox.height * 0.1807 }
		soundPage.items["blockBirdYellow"] = { sprite = "SOUNDBOARD_1_BIRD_YELLOW", x = boundingBox.left + boundingBox.width * 0.52, y = boundingBox.top + boundingBox.height * 0.16107 }
		soundPage.items["blockBirdRed"] = { sprite = "SOUNDBOARD_1_BIRD_RED", x = boundingBox.left + boundingBox.width * 0.36, y = boundingBox.top + boundingBox.height * 0.1415 }
		soundPage.items["blockBirdBlue"] = { sprite = "SOUNDBOARD_1_BIRD_BLUE", x = boundingBox.left + boundingBox.width * 0.23, y = boundingBox.top + boundingBox.height * 0.13 }
		
		
		prepareItemForMouseScalingStates(soundPage.items["blockIce"])
		prepareItemForMouseScalingStates(soundPage.items["blockWood"])
		prepareItemForMouseScalingStates(soundPage.items["blockStone"])
		prepareItemForMouseScalingStates(soundPage.items["blockTNT"])
		prepareItemForMouseScalingStates(soundPage.items["blockSlingshot"])
		prepareItemForMouseScalingStates(soundPage.items["blockPigKing"])
		prepareItemForMouseScalingStates(soundPage.items["blockPigOld"])
		prepareItemForMouseScalingStates(soundPage.items["blockPigHelmet"])
		prepareItemForMouseScalingStates(soundPage.items["blockPigSmall"])
		prepareItemForMouseScalingStates(soundPage.items["blockLevelFail"])
		prepareItemForMouseScalingStates(soundPage.items["blockLevelStart"])
		prepareItemForMouseScalingStates(soundPage.items["blockBirdWhite"])
		prepareItemForMouseScalingStates(soundPage.items["blockBirdBlack"])
		prepareItemForMouseScalingStates(soundPage.items["blockBirdYellow"])
		prepareItemForMouseScalingStates(soundPage.items["blockBirdRed"])
		prepareItemForMouseScalingStates(soundPage.items["blockBirdBlue"])
	
		addSoundBoardMenuButtonsToTable(soundPage)
		
		
		--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level4"] .. "\n")
		logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level4"]) 
				
	elseif currentSoundboard == "RADIO" then
		soundPage = { starEffect = false, 
				  starTimer = 0,
				  starAngle = 0,
				  items = {}
				}
		
		soundPage.dragStartCursorX = 0
		soundPage.dragTouchId = -1
		soundPage.dragging = false
		soundPage.animating = false
		soundPage.animatingTo = 0
		soundPage.delayedButtonSound = false
		soundPage.birdDanceY = 0
		soundPage.dragAngle = 0
		soundPage.musicPlaying = false
		soundPage.musicStartedWhenMuted = false
		soundPage.sessionStarCollected = false
		soundPage.buttonPressed = false
		soundPage.oldSwitches = {}
		soundPage.radioSwitches = {0, 0, 0, 0}
		--the up and down switches are needed for the new mouse over system, the logic for the old
		--one is still there, but the new switches are the ones to be  drawn
		soundPage.radioUpSwitches = {}
		soundPage.radioDownSwitches = {}
		
		soundPage.wheelDivider = 23 * (screenHeight / 320)
	
		soundPage.defaultSheet = ""
		_G.table.insert(soundPage.items, {sheet = "", sprite = "GOLDEN_EGG_BG_1", x = screenWidth / 2, y = screenHeight / 2})
		_G.table.insert(soundPage.items, {name = "radio", sprite = "SOUNDBOARD_2_RADIO", x = screenWidth / 2, y = screenHeight / 2})
		
		local rx, ry = _G.res.getSpritePivot("", "SOUNDBOARD_2_RADIO")
		local sw, sh = _G.res.getSpriteBounds("", "SOUNDBOARD_2_RADIO")
		local radioLeft = -rx + getItemByName(soundPage.items, "radio").x
		local radioTop = -ry + getItemByName(soundPage.items, "radio").y
		
		_G.table.insert(soundPage.items, {name = "birdShadow", sprite = "SOUNDBOARD_2_BIRD_SHADOW", x = screenWidth / 2, y = screenHeight / 2})
		_G.table.insert(soundPage.items, {name = "wheel", sprite = "SOUNDBOARD_2_WHEEL", x = screenWidth / 2, y = screenHeight / 2, angle = 0})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_2_LCD", x = screenWidth / 2, y = screenHeight / 2})
		_G.table.insert(soundPage.items, {name = "indicator", sprite = "SOUNDBOARD_2_INDICATOR", x = radioLeft + (sw * 0.383), y = radioTop + (sh * 0.42)})	
		
		--wheel
		prepareItemForHoveringStates(		soundPage.items[4], nil, {sheet="", sprite="SOUNDBOARD_2_WHEEL"},
											{sheet="", sprite="SOUNDBOARD_2_WHEEL_HOVER"}, 
											{sheet="", sprite="SOUNDBOARD_2_WHEEL_HOVER"})
		local t_w, t_h = _G.res.getSpriteBounds("", soundPage.items[4].sprite)
		soundPage.items[4].pivotX, soundPage.items[4].pivotY = t_w / 2, t_h / 2
		
		
		for i = 1, 4 do
			_G.table.insert(soundPage.items, {name = "preset" .. i, sprite = "SOUNDBOARD_2_BUTTON_DOWN_" .. i, x = screenWidth / 2, y = screenHeight / 2})
			
			prepareItemForHoveringStates(	soundPage.items[6+i], nil, {sheet="", sprite="SOUNDBOARD_2_BUTTON_DOWN_" .. i},
											{sheet="", sprite="SOUNDBOARD_2_BUTTON_DOWN_HOVER_" .. i}, 
											{sheet="", sprite="SOUNDBOARD_2_BUTTON_DOWN_HOVER_" .. i})
			soundPage.items[6+i].visible = false	


		soundPage.radioDownSwitches[i] = soundPage.items[6+i]		
			
		end
		
		for i = 1, 4 do
			_G.table.insert(soundPage.items, {name = "presetUp" .. i, sprite = "SOUNDBOARD_2_BUTTON_DOWN_" .. i, x = screenWidth / 2, y = screenHeight / 2})
			
			prepareItemForHoveringStates(	soundPage.items[10+i], nil, {sheet="", sprite="SOUNDBOARD_2_BUTTON_UP_" .. i},
											{sheet="", sprite="SOUNDBOARD_2_BUTTON_UP_HOVER_" .. i}, 
											{sheet="", sprite="SOUNDBOARD_2_BUTTON_UP_HOVER_" .. i})
											
			soundPage.radioUpSwitches[i] = soundPage.items[10+i]	
		end
		
		
		_G.table.insert(soundPage.items, {name = "bird", sprite = "SOUNDBOARD_2_BIRD",  angle = 0})
		local bird = getItemByName(soundPage.items, "bird")
		local birdShadow = getItemByName(soundPage.items, "birdShadow")
		local bw, bh = _G.res.getSpriteBounds("", bird.sprite)
		local bsw, bsh = _G.res.getSpriteBounds("", birdShadow.sprite)
		bird.x = radioLeft + sw - bw / 2.5
		bird.y = radioTop + sh - bh / 2.5
		
		
		birdShadow.x = radioLeft + sw - bw / 2.5
		birdShadow.y = radioTop + sh + bsh / 2
		
		soundPage.indicatorX, soundPage.indicatorY = getItemByName(soundPage.items, "indicator").x, getItemByName(soundPage.items, "indicator").y
		soundPage.birdOriginalY = getItemByName(soundPage.items, "bird").y
		soundPage.presetCoords = { radioLeft + (sw * 0.383), radioLeft + (sw * 0.522), radioLeft + (sw * 0.667), radioLeft + (sw * 0.806), radioLeft + (sw * 0.736) }
		soundPage.defaultMultiplier = 300 * (sw / 599)	
		--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level7"] .. "\n")
		
		addSoundBoardMenuButtonsToTable(soundPage)
		logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level7"]) 
	
		setGameOn(true) -- disable screen saver
	end

end

function cursorOnSoundboardSprite(item)
	local px,py = _G.res.getSpritePivot("", item.sprite)
	local w, h = _G.res.getSpriteBounds("", item.sprite)
		
	return cursor.x > item.x - px and cursor.x < item.x - px + w and cursor.y > item.y - py and cursor.y < item.y - py + h	
end

function touchOnSoundboardSprite(sheet, sprite, touchid, x, y)
	local px,py = _G.res.getSpritePivot(sheet, sprite)
	local w, h = _G.res.getSpriteBounds(sheet, sprite)
	
	return touches[touchid].y >= ((screenHeight / 2) - py) and touches[touchid].y <= ((screenHeight / 2) - py + h)
		and touches[touchid].x >= ((screenWidth / 2) - px) and touches[touchid].x <= ((screenWidth / 2) - px + w)
	

	--return touches[touchid].x > -px and touches[touchid].x < -px + w and touches[touchid].y > -py and touches[touchid].y < -py + h
	
end

function drawSoundboardButton(sheet, sprite, pressed, x, y)
	
	local scale = 1
	if pressed == true then
		scale = 1.1
		setRenderState(0, 0, scale, scale, 0)
		local w, h = _G.res.getSpriteBounds(sheet, sprite)
		local px, py = _G.res.getSpritePivot(sheet, sprite)
		x = (x / scale) + (px - (w / 2)) * (1 - (1 / scale))
		y = (y / scale) + (py - (h / 2)) * (1 - (1 / scale))
	end
	
	_G.res.drawSprite("", sprite, x, y)
	if pressed == true then
		setRenderState(0, 0, 1, 1, 0)
	end
end

function updateSoundboard(dt)
	-- fixes issue2466, ideally would be only on the draw methods, but the soundboards were created with update and draw in the same place
	_G.res.setClipRect(0, 0, screenWidth, screenHeight)
	
	if deviceModel == "roku" and g_SoundBoardLayouted ~= true or oldScreenWidth ~= screenWidth or oldScreenHeight ~= screenHeight then
		oldScreenWidth = screenWidth
		oldScreenHeight = screenHeight
		initSoundboard()
		g_SoundBoardLayouted = true
	end
	
	if popupPage ~= nil then
		updateMenuPage(popupPage, dt)
	end
	
	if currentSoundboard == "KEYBOARD" then
		keyboardPage:update(dt)
		keyboardPage:draw()
	elseif currentSoundboard == "SEQUENCER" then
		sequencerPage:update(dt)
		sequencerPage:draw()
	elseif currentSoundboard == "ACCORDION" then
		accordionPage:update(dt)
		accordionPage:draw()
	elseif currentSoundboard == "SOUNDBOARD1" then
		if keyPressed["ESCAPE"] or deviceModel == "roku" and keyReleased["KEY_BACK"] then
			gotoGoldenEggs()
			return
		end
		updateSoundBoardButtonsFromTable(soundPage, dt)
		
		updateItemMouseOverState(soundPage.items["blockIce"], dt)
		updateItemMouseOverState(soundPage.items["blockWood"], dt)
		updateItemMouseOverState(soundPage.items["blockStone"], dt)
		updateItemMouseOverState(soundPage.items["blockTNT"], dt)
		updateItemMouseOverState(soundPage.items["blockSlingshot"], dt)
		updateItemMouseOverState(soundPage.items["blockPigKing"], dt)
		updateItemMouseOverState(soundPage.items["blockPigOld"], dt)
		updateItemMouseOverState(soundPage.items["blockPigHelmet"], dt)
		updateItemMouseOverState(soundPage.items["blockPigSmall"], dt)
		updateItemMouseOverState(soundPage.items["blockLevelFail"], dt)
		updateItemMouseOverState(soundPage.items["blockLevelStart"], dt)
		updateItemMouseOverState(soundPage.items["blockBirdWhite"], dt)
		updateItemMouseOverState(soundPage.items["blockBirdBlack"], dt)
		updateItemMouseOverState(soundPage.items["blockBirdYellow"], dt)
		updateItemMouseOverState(soundPage.items["blockBirdRed"], dt)
		updateItemMouseOverState(soundPage.items["blockBirdBlue"], dt)
		
		if keyPressed["LBUTTON"] and soundPage.starEffect == false and popupPage == nil then
			
			-- ice block
			--if cursorOnSoundboardSprite(soundPage.items[2]) then
			if cursorOnSoundboardSprite(soundPage.items["blockIce"]) then
				soundPage.buttonPressTimes[1] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("light_destroyed"), 1.0, false, 0)
				else
					_G.res.playAudio(getAudioName("light_collision"), 1.0, false, 0)
					soundPage.starState = 0
					soundPage.state = 0
				end
			
			-- wood block
			--elseif cursorOnSoundboardSprite(soundPage.items[3]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockWood"]) then
				soundPage.buttonPressTimes[2] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("wood_destroyed"), 1.0, false, 0)
				else
					_G.res.playAudio(getAudioName("wood_collision"), 1.0, false, 0)
					soundPage.starState = 0
					soundPage.state = 0
				end
			
			-- stone block
			--elseif cursorOnSoundboardSprite(soundPage.items[4]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockStone"]) then
				soundPage.buttonPressTimes[3] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("rock_destroyed"), 1.0, false, 0)
				else
					_G.res.playAudio(getAudioName("rock_collision"), 1.0, false, 0)
					soundPage.starState = 0
					soundPage.state = 0
				end
			
			-- tnt box
			--elseif cursorOnSoundboardSprite(soundPage.items[5]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockTNT"]) then
				soundPage.buttonPressTimes[4] = time
				_G.res.playAudio(getAudioName("tnt_explodes"), 1.0, false, 0)
			
			-- slingshot
			--elseif cursorOnSoundboardSprite(soundPage.items[6]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockSlingshot"]) then
				soundPage.buttonPressTimes[5] = time
				soundPage.state = 1
				_G.res.playAudio(getAudioName("slingshot_stretched"), 1.0, false, 0)
				if soundPage.starState == 1 then
					soundPage.starState = 2
				else
					soundPage.starState = 0
				end
			
			-- king pig
			--elseif cursorOnSoundboardSprite(soundPage.items[7]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockPigKing"]) then
				soundPage.buttonPressTimes[6] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("piglette_destroyed"), 1.0, false, 0)
					if soundPage.starState == 3 then
						soundPage.starState = 4
						soundPage.state = 0
					else
						soundPage.starState = 0
					end
				else
					_G.res.playAudio(getAudioName("piglette"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
				end
				
			-- old pig
			--elseif cursorOnSoundboardSprite(soundPage.items[8]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockPigOld"]) then
				soundPage.buttonPressTimes[7] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("piglette_destroyed"), 1.0, false, 0)
					if soundPage.starState == 3 then
						soundPage.starState = 4
						soundPage.state = 0
					else
						soundPage.starState = 0
					end
				else
					_G.res.playAudio(getAudioName("piglette"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
				end
			
			-- helmet pig
			--elseif cursorOnSoundboardSprite(soundPage.items[9]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockPigHelmet"]) then
				soundPage.buttonPressTimes[8] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("piglette_destroyed"), 1.0, false, 0)
					if soundPage.starState == 3 then
						soundPage.starState = 4
						soundPage.state = 0
					else
						soundPage.starState = 0
					end
				else
					_G.res.playAudio(getAudioName("piglette"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
				end
			
			-- small pig
			--elseif cursorOnSoundboardSprite(soundPage.items[10]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockPigSmall"]) then
				soundPage.buttonPressTimes[9] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("piglette_destroyed"), 1.0, false, 0)
					if soundPage.starState == 3 then
						soundPage.starState = 4
						soundPage.state = 0
					else
						soundPage.starState = 0
					end
				else
					_G.res.playAudio(getAudioName("piglette"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
				end
			
			-- level fail
			--elseif cursorOnSoundboardSprite(soundPage.items[11]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockLevelFail"]) then
				soundPage.buttonPressTimes[10] = time
				for i = 1, #audioGroups["level_failed_piglets"] do
					if _G.res.isAudioPlaying(audioGroups["level_failed_piglets"][i]) then
						_G.res.stopAudio(audioGroups["level_failed_piglets"][i])
					end
				end				 
				_G.res.playAudio(getAudioName("level_failed_piglets"), 1.0, false, 0)
				soundPage.state = 0
				soundPage.starState = 0
			
			-- level start
			--elseif cursorOnSoundboardSprite(soundPage.items[12]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockLevelStart"]) then
				soundPage.buttonPressTimes[11] = time
				for i = 1, #audioGroups["level_start_military"] do
					if _G.res.isAudioPlaying(audioGroups["level_start_military"][i]) then
						_G.res.stopAudio(audioGroups["level_start_military"][i])
					end
				end
				_G.res.playAudio(getAudioName("level_start_military"), 1.0, false, 0)
				soundPage.state = 0
				soundPage.starState = 1
			
			-- white bird
			--elseif cursorOnSoundboardSprite(soundPage.items[13]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockBirdWhite"]) then
				soundPage.buttonPressTimes[12] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_05_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 1
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 1 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("special_egg"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_05_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			
			-- black bird
			--elseif cursorOnSoundboardSprite(soundPage.items[14]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockBirdBlack"]) then
				soundPage.buttonPressTimes[13] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_04_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 2
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 2 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("special_explosion"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_04_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			
			-- yellow bird
			--elseif cursorOnSoundboardSprite(soundPage.items[15]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockBirdYellow"]) then
				soundPage.buttonPressTimes[14] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_03_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 3
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 3 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("special_boost"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_03_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			
			-- red bird
			--elseif cursorOnSoundboardSprite(soundPage.items[16]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockBirdRed"]) then
				soundPage.buttonPressTimes[15] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_01_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 4
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 4 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("red_special"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_01_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			
			-- blue bird
			--elseif cursorOnSoundboardSprite(soundPage.items[17]) then
			elseif cursorOnSoundboardSprite(soundPage.items["blockBirdBlue"]) then
				soundPage.buttonPressTimes[16] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_02_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 5
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 5 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("special_group"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_02_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			end
			
			if soundPage.starState == 4 then
				soundPage.state = 0
				soundPage.starState = 0
				soundPage.currentBird = 0
				if not soundPage.sessionStarCollected then
					goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
					soundPage.sessionStarCollected = true
				end
			end
		end
		
		
		--[[
		for i = 1, #soundPage.items do
			local sheet = soundPage.items[i].sheet or soundPage.defaultSheet
			if i >= 2 then
				drawSoundboardButton(sheet, soundPage.items[i].sprite, time - soundPage.buttonPressTimes[i - 1] < 0.2, soundPage.items[i].x, soundPage.items[i].y)
			else
				_G.res.drawSprite("", soundPage.items[i].sprite, soundPage.items[i].x - screenWidth / 2, soundPage.items[i].y - screenHeight / 2,  "LEFT", "TOP", screenWidth, screenHeight)
			end
		end
		]]
		
		
		local t_sheet = soundPage.items[1].sheet or soundPage.defaultSheet
		_G.res.drawSprite("", soundPage.items[1].sprite, soundPage.items[1].x - screenWidth / 2, soundPage.items[1].y - screenHeight / 2,  "LEFT", "TOP", screenWidth, screenHeight)
		
		local t_block = soundPage.items["blockIce"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockWood"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockStone"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockTNT"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockSlingshot"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockPigKing"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockPigOld"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockPigHelmet"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockPigSmall"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockLevelFail"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockLevelStart"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockBirdWhite"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockBirdBlack"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockBirdYellow"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockBirdRed"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		t_block = soundPage.items["blockBirdBlue"]
		drawMouseScalingItem(t_block.sheet or soundPage.defaultSheet, t_block, t_block.x, t_block.y)
		
		
		--_G.res.drawSprite("", "LS_BACK_BUTTON", 0, screenHeight)

		drawSoundBoardButtonsFromTable(soundPage)
		
	elseif currentSoundboard == "RADIO" then
		if keyPressed["ESCAPE"] or deviceModel == "roku" and keyReleased["KEY_BACK"] then
			gotoGoldenEggs()
			return
		end
		updateSoundBoardButtonsFromTable(soundPage, dt)
		
		--mousewheel
		updateItemMouseOverState(soundPage.items[4], dt)
		
		--down buttons
		for i = 1, 4 do			
			updateItemMouseOverState(soundPage.items[6+i], dt)	
			updateItemMouseOverState(soundPage.items[10+i], dt)					
		end
	
		
		local tmpDeltaAngle = 0			
		if popupPage == nil then
			
			if keyPressed["LBUTTON"] then

				for i = 1, 4 do
					local itm = getItemByName(soundPage.items, "preset" .. i)
					itm.sprite = "SOUNDBOARD_2_BUTTON_UP_" .. i
					if soundPage.radioSwitches[i] == 0 and cursorOnSoundboardSprite(itm) then
						soundPage.radioSwitches = {0, 0, 0, 0}
						soundPage.radioSwitches[i] = 1	
						_G.res.stopAllAudio()
						_G.res.playAudio("button_radio", 1, false)
						soundPage.delayedButtonSound = false
						prepareRadioAnimation(soundPage.presetCoords[i], i)
						soundPage.buttonPressed = false
						
					end
					
					soundPage.radioDownSwitches[i].visible = soundPage.radioSwitches[i] == 1
					soundPage.radioUpSwitches[i].visible = soundPage.radioSwitches[i] == 0
				end	

				for i = 1, 4 do					
					soundPage.radioDownSwitches[i].visible = soundPage.radioSwitches[i] == 1
					soundPage.radioUpSwitches[i].visible = soundPage.radioSwitches[i] == 0
				end		
				
				local px, py = _G.res.getSpritePivot(soundPage.defaultSheet, getItemByName(soundPage.items, "wheel").sprite)
				local w, h = _G.res.getSpriteBounds(soundPage.defaultSheet, getItemByName(soundPage.items, "wheel").sprite)
				local tmpDist = distance(-px + getItemByName(soundPage.items, "wheel").x - (w / 2), -py + getItemByName(soundPage.items, "wheel").y - (h / 2), cursor.x, cursor.y)
				
				if tmpDist < w * 2 then
					soundPage.dragAngle = _G.math.atan2((-py + getItemByName(soundPage.items, "wheel").y - (h / 2)- cursor.y), (-px + getItemByName(soundPage.items, "wheel").x - (w / 2) - cursor.x))
					soundPage.dragging = true
					soundPage.buttonPressed = false
				end
						
			elseif soundPage.dragging and keyHold["LBUTTON"] then
				local px, py = _G.res.getSpritePivot(soundPage.defaultSheet, getItemByName(soundPage.items, "wheel").sprite)			
				local w, h = _G.res.getSpriteBounds(soundPage.defaultSheet, getItemByName(soundPage.items, "wheel").sprite)
				local tmpDist = distance(-px + getItemByName(soundPage.items, "wheel").x - (w / 2), -py + getItemByName(soundPage.items, "wheel").y - (h / 2), cursor.x, cursor.y)
				
				
				if tmpDist > w / 2 then 
					
					local tmpAngle = _G.math.atan2((-py + getItemByName(soundPage.items, "wheel").y  - (h / 2) - cursor.y), (-px + getItemByName(soundPage.items, "wheel").x - (w / 2) - cursor.x))
					if soundPage.dragAngle ~= nil then
						tmpDeltaAngle = tmpAngle - soundPage.dragAngle
						if tmpDeltaAngle >= _G.math.pi * 3/2 then
							tmpDeltaAngle = tmpDeltaAngle - _G.math.pi * 2
						elseif tmpDeltaAngle <= -_G.math.pi * 3/2 then
							tmpDeltaAngle = tmpDeltaAngle + _G.math.pi * 2
						end
						if _G.math.abs(tmpDeltaAngle) > 0 and soundPage.musicPlaying then
							_G.res.stopAllAudio()
							soundPage.musicPlaying = false
						end
						if _G.math.abs(tmpDeltaAngle) < _G.math.pi / 2 then
							soundPage.indicatorX = soundPage.indicatorX + tmpDeltaAngle * 12
							if soundPage.indicatorX < soundPage.presetCoords[1] then
								tmpDeltaAngle = 0
								soundPage.indicatorX = soundPage.presetCoords[1]
							elseif soundPage.indicatorX > soundPage.presetCoords[4] then
								tmpDeltaAngle = 0
								soundPage.indicatorX = soundPage.presetCoords[4]
							end
							getItemByName(soundPage.items, "wheel").angle = getItemByName(soundPage.items, "wheel").angle + tmpDeltaAngle
						end
					end
					soundPage.dragAngle = tmpAngle
				elseif tmpDist <= w / 2 then
					soundPage.dragAngle = nil
				end
		
			elseif keyReleased["LBUTTON"] and soundPage.dragging then	
				local shortDist, shortDistIndex = screenWidth, 0
				for i = 1, #soundPage.presetCoords do
					local tmpDist = _G.math.abs(soundPage.indicatorX - soundPage.presetCoords[i])
					if tmpDist < shortDist then
						shortDist = tmpDist
						shortDistIndex = i
					end
				end
							
				for i = 0, #soundPage.radioSwitches do
					soundPage.radioSwitches[i] = 0
				end
				soundPage.radioSwitches[shortDistIndex] = 1
				
				if shortDistIndex == 5 then 
					prepareRadioAnimation(soundPage.presetCoords[shortDistIndex], 0) -- funky station
					soundPage.radioSwitches = {1, 0, 1, 0}
				else
					prepareRadioAnimation(soundPage.presetCoords[shortDistIndex], shortDistIndex)
				end
				
				for i = 1, 4 do					
					soundPage.radioDownSwitches[i].visible = soundPage.radioSwitches[i] == 1
					soundPage.radioUpSwitches[i].visible = soundPage.radioSwitches[i] == 0
				end		
				
				soundPage.dragging = false
				soundPage.delayedButtonSound = true
				
			elseif soundPage.animating then		
				updateSoundPageAnimation(dt)
			end
		end
		
		if soundPage.upcomingTune == "funky_theme" then
			soundPage.birdDanceY = (soundPage.birdDanceY + dt * 5) % _G.math.pi
			getItemByName(soundPage.items, "bird").angle = _G.math.sin(soundPage.birdDanceY) / 4
		elseif soundPage.birdDanceY > 0 then
			soundPage.birdDanceY = (soundPage.birdDanceY + dt * 5) 
			if soundPage.birdDanceY > _G.math.pi then
				soundPage.birdDanceY = 0
			end
			getItemByName(soundPage.items, "bird").angle = _G.math.sin(soundPage.birdDanceY) / 4
		end
	
		if soundPage.dragging ~= true then
			getItemByName(soundPage.items, "wheel").angle = (soundPage.indicatorX - soundPage.presetCoords[1]) / soundPage.wheelDivider
		end
		getItemByName(soundPage.items, "indicator").x = soundPage.indicatorX
		getItemByName(soundPage.items, "indicator").y = soundPage.indicatorY
		
		local _, birdHeight = _G.res.getSpriteBounds(soundPage.defaultSheet, getItemByName(soundPage.items, "bird").sprite)
		getItemByName(soundPage.items, "bird").y = soundPage.birdOriginalY - _G.math.sin(soundPage.birdDanceY) * birdHeight / 3
		
		for i = 1, 4 do
			local spriteName
			if soundPage.radioSwitches[i] == 1 then
				spriteName = "SOUNDBOARD_2_BUTTON_DOWN_" .. i
			else
				spriteName = "SOUNDBOARD_2_BUTTON_UP_" .. i
			end
			getItemByName(soundPage.items, "preset" .. i).sprite = spriteName
		end
		
		drawPictureLevel(soundPage)
		drawSoundBoardButtonsFromTable(soundPage)
	end
	
	
	
	
	--since the pivot points of the sound button are not aligned as the pause button, we need to get the pivot position from the pause so that they 
	-- have the same spacing
	local t_pauseButtonPivotX, t_pauseButtonPivotY = _G.res.getSpritePivot("", "MENU_BUTTON")
	if deviceModel == "roku" then
		t_pauseButtonPivotX, t_pauseButtonPivotY = _G.res.getSpritePivot("", "ROKU_MENU_BUTTON")
	end
	local t_soundButtonPivotX, t_soundButtonPivotY = _G.res.getSpritePivot("", "MENU_SFX")
	
	--[[
	_G.res.drawSprite("", "MENU_SFX", t_soundButtonPivotX -t_pauseButtonPivotX, t_soundButtonPivotY -t_pauseButtonPivotY)
	if settings.audioEnabled == false then	
		_G.res.drawSprite("", "BUTTON_OFF", t_soundButtonPivotX -t_pauseButtonPivotX, t_soundButtonPivotY -t_pauseButtonPivotY)
	end
	if keyPressed["LBUTTON"] and popupPage == nil then
		local width, height = _G.res.getSpriteBounds("", "MENU_SFX")
		if cursor.x < width and cursor.y < height then
			changeAudio()
			if settings.audioEnabled == false then
				if currentSoundboard ~= "RADIO" then
					_G.res.stopAllAudio()
				end
			elseif currentSoundboard == "RADIO" and soundPage.musicPlaying and soundPage.musicStartedWhenMuted then
				_G.res.playAudio(soundPage.upcomingTune, 0.8, true)
			end
		end
	end
	
	]]--
	
	-- if audioRampVolume then
		-- audioRampVolume = audioRampVolume + (dt / audioRampLength)
		
		-- if audioRampVolume <= 0 then
			-- _G.res.stopAudioOutput()
			-- audioRampVolume = nil
		-- else
			--Use squared volume because it gives more linear response
			-- setMusicVolume( audioRampVolume * audioRampVolume )
			-- setEffectsVolume( audioRampVolume * audioRampVolume )
		-- end
	-- end
	
	--[[
	if keyPressed["LBUTTON"] and popupPage == nil then
		local width, height = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "LS_BACK_BUTTON")
		if cursor.y > (screenHeight - height) and cursor.x < width then
			_G.res.stopAllAudio()
			setGameOn(false) -- enable screen saver
			setGameMode(gotoLevelSelectionGoldenEggs)
		end
	end
	]]--
	
	if popupPage ~= nil then
		drawMenuPage(popupPage)
		return
	end
end

function prepareRadioAnimation(target, index)
	
	soundPage.animatingTo = target
	soundPage.animating = true
	
	if soundPage.animatingTo < soundPage.indicatorX then
		soundPage.animationMultiplier = -soundPage.defaultMultiplier
	else
		soundPage.animationMultiplier = soundPage.defaultMultiplier
	end
	
	if index == 0 then
		soundPage.upcomingTune = "funky_theme"
	elseif index == 1 then
		soundPage.upcomingTune = "title_theme"
	else
		local tmpIndex = index - 1
		soundPage.upcomingTune = "ambient_theme" .. tmpIndex
	end

end

function updateSoundPageAnimation(dt)
	
	soundPage.indicatorX = soundPage.indicatorX + dt * soundPage.animationMultiplier
				
	if (soundPage.indicatorX >= soundPage.animatingTo and soundPage.animationMultiplier > 0)
		or (soundPage.indicatorX <= soundPage.animatingTo and soundPage.animationMultiplier < 0) then
		
		if soundPage.delayedButtonSound then
			soundPage.delayedButtonSound = false
			_G.res.stopAllAudio()
			_G.res.playAudio("button_radio", 1, false)
		end
					
		soundPage.animating = false
		soundPage.indicatorX = soundPage.animatingTo
		if soundPage.upcomingTune == "funky_theme" then
			if not soundPage.sessionStarCollected then
				goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
				soundPage.sessionStarCollected = true
			end
		end
					
		_G.res.playAudio(soundPage.upcomingTune, 0.8, true)
		soundPage.musicPlaying = true
		
		soundPage.musicStartedWhenMuted = settings.audioEnabled == false
		
	end

end


function animateBirdToSlingShot(dt)
	local testIndex = currentBirdIndex + 1
	if nextBirdTimer > 0 then
		nextBirdTimer = nextBirdTimer - dt
		if nextBirdTimer <= 0 then
			if getNextBird(testIndex) ~= nil then
				if birdFired then
					birdFired = false
					fillInNextBird = true
					selectedBird = nil
				end
			else
				allowResetToBirdCamera = false
				--print("Can't reset to bird camera\n")
			end
		end
	end
	
	if fillInNextBird == true then		
		if birdToSlingshotBirdName == nil then
			birdToSlingshotAnimationTimer = 0
			birdToSlingshotBirdName = getNextBird(testIndex)
			
			
			
			objects.world[birdToSlingshotBirdName].jumpTimer = 10000
			if objects.world[birdToSlingshotBirdName].jumpOn == true then
				birdToSlingshotAnimationStartY = objects.world[birdToSlingshotBirdName].oldY
				objects.world[birdToSlingshotBirdName].y = objects.world[birdToSlingshotBirdName].oldY
				objects.world[birdToSlingshotBirdName].jumpOn = false
				--print("levelStartPosition.y: " .. levelStartPosition.y .. "\n")
				--print("objects.world[birdToSlingshotBirdName].y: " .. objects.world[birdToSlingshotBirdName].y .. "\n")
				--print("birdToSlingshotAnimationHeight: " .. birdToSlingshotAnimationHeight .. "\n")
			end
			birdToSlingshotAnimationStartX = objects.world[birdToSlingshotBirdName].x
			birdToSlingshotAnimationStartY = objects.world[birdToSlingshotBirdName].y
			birdToSlingshotAnimationHeight = (levelStartPosition.y - objects.world[birdToSlingshotBirdName].y) * 1.33
		end
	
		--print("Bird to slingshot animation\n")
		birdToSlingshotAnimationTimer = birdToSlingshotAnimationTimer + dt
		
		local obj = objects.world[birdToSlingshotBirdName]
		
		if obj == nil then
			return 
		end
		
		--print("newPos: " .. obj.y + _G.math.sin(birdToSlingshotAnimationAngle*birdToSlingshotAnimationTimer) * birdToSlingshotAnimationHeight .. "\n")
		setPosition(obj.name, 
			birdToSlingshotAnimationStartX * (1 - birdToSlingshotAnimationTimer) + levelStartPosition.x * birdToSlingshotAnimationTimer, 
			birdToSlingshotAnimationStartY + _G.math.sin(birdToSlingshotAnimationAngle*birdToSlingshotAnimationTimer) * birdToSlingshotAnimationHeight)
		setRotation(obj.name, obj.angle + _G.math.pi*2*dt)
		
		-- get next bird ready for action
		if birdToSlingshotAnimationTimer >= 1 then
			birdToSlingshotBirdName = nil
			birdToSlingshotAnimationTimer = 0
			fillInNextBird = false
			birdReady = true
			currentBirdIndex = currentBirdIndex + 1
			currentBirdName = getNextBird(currentBirdIndex)
			setPosition(currentBirdName, levelStartPosition.x - 0.1, levelStartPosition.y - 0.1)
			rubberBandPos.x, rubberBandPos.y = levelStartPosition.x - 0.1, levelStartPosition.y - 0.1
			rubberBandAngle = _G.math.atan2(-0.1, 0.1)
			
			local castleToBirdCamDist = _G.math.abs(distance(objects.birdCameraData[deviceModel].px, objects.birdCameraData[deviceModel].py,
				objects.castleCameraData[deviceModel].px, objects.castleCameraData[deviceModel].py))
			local camToBirdCamDist = _G.math.abs(distance(screen.x, screen.y, objects.birdCameraData[deviceModel].px, 
				objects.birdCameraData[deviceModel].py))
			local volume = _G.math.min(1, _G.math.max(0.25, 1 - (camToBirdCamDist / castleToBirdCamDist)))
			
			_G.res.playAudio(getAudioName("bird_next_military"), volume, false)
			setObjectParameter(currentBirdName, 2, 1)
			setRotation(currentBirdName, 0)
		end
	end
end

function updateCharacterAnimations(dt)
	
	-- make piglets laugh when there are no birds left
	if checkLevelFailed() then
		--piglette smiles
		for k, v in _G.pairs(levelGoals) do
			setSprite(v.name, v.smileSprite)
		end
	else
		--piglette blinks
		for k, v in _G.pairs(levelGoals) do
			v.blinkTimer = v.blinkTimer - dt
			if v.blinkTimer < 0 then
				if v.blinkOn == true then
					v.blinkTimer = _G.math.random(1,30) / 10
					setSprite(v.name, v.damageSprite)
					v.blinkOn = false
				else
					v.blinkTimer = _G.math.random(1,4) / 10
					setSprite(v.name, v.blinkSprite)
					v.blinkOn = true
				end
			end
		end		
	end	
	
	--piglette oinks
	for k, v in _G.pairs(levelGoals) do
		v.oinkTimer = v.oinkTimer - dt
		if v.oinkTimer < 0 then
			v.oinkTimer = _G.math.random(10,60) / 10
			local lsx, lsy = physicsToWorldTransform(v.x, v.y)
			local dist = vLength(screen.x - lsx, screen.y - lsy)
			local volume = 1 - dist / 1000
			if volume > 0 then 
				_G.res.playAudio(getAudioName("piglette"), volume, false, 0) 
			end
		end
	end	

	
	-- bird animations
	for k, v in _G.pairs(birds) do
		if v.shot ~= true then
			v.animTimer = v.animTimer - dt
			-- blink and yell
			if v.animTimer < 0 then
				if v.animOn == true then
					v.animTimer = _G.math.random(10,150) / 100
					setSprite(v.name, v.damageSprite)
					v.animOn = false
				else
					v.animTimer = _G.math.random(10,20) / 100
					local animType = _G.math.random(1,4)
					local sprite = nil
					if animType == 1 then
						sprite = blockTable.blocks[v.definition].spriteYell
						--if sprite ~= nil then
						local lsx, lsy = physicsToWorldTransform(levelStartPosition.x, levelStartPosition.y )
						local dist = vLength(screen.x - lsx, screen.y - lsy)
						local volume = 1 - dist / 1000
						if volume > 0 then 
							_G.res.playAudio(getAudioName("bird_misc"), volume, false, 0) 
						end
						--end
					else
						sprite = blockTable.blocks[v.definition].spriteBlink				
					end
					if sprite ~= nil then
						setSprite(v.name, sprite)
					end
					v.animOn = true
				end			
			end
			
			-- jump
			if currentBirdName ~= v.name then
				if v.jumpOn ~= true then
					v.jumpTimer = v.jumpTimer - dt			
				end

				if v.jumpTimer < 0 then
					v.jumpTimer = _G.math.random(0,35) / 10
					v.jumpHeight = _G.math.random(5,15) / 10
					v.jumpSpeed = 7 / v.jumpHeight * 1.2
					if levelCompleted then
						v.jumpTimer = 0
						v.jumpHeight = _G.math.random(25,35) / 10
						v.jumpSpeed = 7 / v.jumpHeight * 1.6
					end
					v.jumpAngle = 0
					v.jumpOn = true
					v.jumpRebound = false
					v.jumpRoll = 0
					if blockTable.blocks[v.definition].allowRoll == true and v.jumpHeight > 0.9 then
						v.jumpRoll = _G.math.random(0,4) - 1
					end
					v.oldY = v.y
					v.oldAngle = v.angle
				end
				
				if v.jumpOn == true then
					v.jumpAngle = v.jumpAngle + dt * v.jumpSpeed
					setPosition(v.name, v.x, v.oldY - _G.math.sin(v.jumpAngle) * v.jumpHeight)
					if (v.jumpRoll == -1 or v.jumpRoll == 1) and v.jumpRebound ~= true then
						setRotation(v.name, v.jumpAngle * 2 * v.jumpRoll)
					end
					-- if jump complete
					if v.jumpAngle > _G.math.pi then
						if v.jumpRebound == true then
							v.jumpOn = false
							v.y = v.oldY
							v.angle = v.oldAngle
							setPosition(v.name, v.x, v.y)
							setRotation(v.name, v.angle)
						else
							v.jumpRebound = true
							v.jumpAngle = 0
							v.jumpHeight = v.jumpHeight * 0.3
							v.jumpSpeed = v.jumpSpeed * 2
						end
					end
				end
			end
		end
	end	
end

-- XXX: ADD TO OTHERS
function drawCircle(x,y,radius, angle,r,g,b,a,w)
	local points = {}
					
	for i = 0,_G.math.pi * 2,0.5 do
			local px = _G.math.cos(i) * physicsToWorldTransform(radius,0)
			local py = _G.math.sin(i) * physicsToWorldTransform(radius,0)
			local point = {x + px, y +py}						
			_G.table.insert(points,point)							
	end
	
	drawPolygon(points,w, true,r,g,b,a,angle,0.5,0.5)	
end
-- XXX: ADD TO OTHERS
function drawPolygon(points,lineW,inWorld,r,g,b,a,angle,pivotX,pivotY)
	local wScale = worldScale
	
	if tempWorldScale ~= nil then
		wScale = tempWorldScale
	end
	
	-- Add the last one again to complete polygon.	
	_G.table.insert(points, points[1])

	pivotX = pivotX or 0.5
	pivotY = pivotY or 0.5
	
	local temp = 99999999
	local w = 0
	local h = 0
	local minX = temp
	local maxX = -temp
	local minY = temp
	local maxY = -temp
	
	-- find bounds
	for k,v in _G.pairs(points) do

		minX = _G.math.min(minX, points[k][1])
		minY = _G.math.min(minY, points[k][2])
			
		maxX = _G.math.max(maxX, points[k][1])
		maxY = _G.math.max(maxY, points[k][2])			
	end
	
	local w = (maxX - minX) 
	local h = (maxY - minY) 

	local px = pivotX * w
	local py = pivotY * h
	
	-- draw polygon
	for k,v in _G.pairs(points) do
		if(k > 1) then
			
			local x1 = points[k-1][1]
			local y1 = points[k-1][2]
			
			local x2 = points[k][1]
			local y2 = points[k][2]
			
			-- calculate rotation pivot
			local rotatePivotX = (minX + px) - x1   
			local rotatePivotY = (minY + py) - y1 			
			
			setRenderState(-screen.left, -screen.top, wScale, wScale, angle, rotatePivotX, rotatePivotY)
			drawLine(r,g,b,a,x1,y1,x2,y2,inWorld,lineW)		
		end
	end	
end

-- XXX: ADD TO OTHERS
function drawWireFrameRect(x1,y1,x2,y2,lineW, inWorld,r,g,b,a,angle,pivotX, pivotY)
	local points = {{x1,y1}, {x2,y1}, {x2,y2},{x1,y2}}
	drawPolygon(points,lineW, inWorld,r,g,b,a,angle,pivotX,pivotY)
end

-- XXX: ADD TO OTHERS
function drawDummyCollisionBox(object)
	
	if showSleepingObjects == true then
		local objectName = object.name
			
		if(objectName ~= nil and adjustedBlockDef ~= nil and adjustedBlockDef.objectNames[objectName] ~= nil) then
			local selected = objects.world[objectName]
			local blockDef = adjustedBlockDef.objectNames[objectName]
			
			local x, y = physicsToWorldTransform(selected.x, selected.y)
			--local w, h = _G.res.getSpriteBounds("", v.sprite)
			local w, h = _G.res.getSpriteBounds("", selected.sprite)

			
			
			local radius = adjustedBlockDef.objectNames[objectName].radius 
			local width = adjustedBlockDef.objectNames[objectName].width 
			local height = adjustedBlockDef.objectNames[objectName].height 
			local vertices = adjustedBlockDef.objectNames[objectName].vertices 
					
			if(radius ~= nil) then
				drawCircle(x,y,radius, selected.angle,255,0,255,255,2)
				drawString(""..radius, 0.5, x,y, nil,nil, true)
			elseif(width ~= nil and height ~= nil) then
					local ww, hh = physicsToWorldTransform(width, height) 
					local x1, y1 = x - ww / 2, y - hh / 2
					local x2, y2 = x + ww / 2, y + hh / 2					
					local pivX = object.spritePivotX / (w ) 
					local pivY = object.spritePivotY / (h )
					drawWireFrameRect(x1,y1,x2,y2,1,true,255,0,255,255,selected.angle,pivX, pivY)					
					drawString("w="..width .." h="..height, 0.5, x,y, nil,nil, true)
			
			elseif(vertices ~= nil) then
				local points = {}
					
				for kk,vv in _G.pairs(blockDef.vertices) do
					local wx,wy = w * vv.x, h  * vv.y 
					local point = {x + (wx) - w / 2, y + (wy) - h / 2}
					_G.table.insert(points,point)
				end					
				drawPolygon(points,2, true,255,0,255,255,object.angle,0.5,0.5)					

				for kk,vv in _G.pairs(blockDef.vertices) do
					local wx,wy = w * vv.x, h  * vv.y 
					local xString = _G.string.format("%.2f", (vv.x))
					local yString = _G.string.format("%.2f", (vv.y))
					drawString("("..xString.."/"..yString..")", 0.1, x + wx - w / 2,y + wy - h / 2, nil,nil, true)
				end					
			end				
		end
	end
end	


-- XXX: ADD TO OTHERS
function checkCollide(object1, object2, dir) 
    local left1 = object1.x1
    local left2 = object2.x1
    local right1 = object1.x2
    local right2 = object2.x2
    local top1 = object1.y1
    local top2 = object2.y1
    local bottom1 = object1.y2
    local bottom2 = object2.y2
	
	if(dir == 1) then
		if (bottom1 < top2) then return nil end;
		if (top1 > bottom2) then return nil end;	
	end
  
	if(dir == 0) then
		if (right1 < left2) then return nil end;
		if (left1 > right2) then return nil end;	
	end

	return true

end
-- XXX: ADD TO OTHERS
function getBoundingBox(object)
	local w,h = _G.res.getSpriteBounds(object.sprite)
	w,h = worldToPhysicsTransform(w,h)
	local x1 = object.x - w / 2
	local y1 = object.y - h / 2

	local x2 = object.x + w / 2
	local y2 = object.y - h / 2

	local x3 = object.x + w / 2
	local y3 = object.y + h / 2

	local x4 = object.x - w / 2
	local y4 = object.y + h / 2

	local _x1 = object.x - x1
	local _y1 = object.y - y1
	local _x2 = object.x - x2
	local _y2 = object.y - y2
	local _x3 = object.x - x3
	local _y3 = object.y - y3
	local _x4 = object.x - x4 
	local _y4 = object.y - y4	
	
	local an = object.angle
	local cosinus = _G.math.cos(an)
	local sinus = _G.math.sin(an)
	
	local __x1 = _x1 * cosinus - _y1 * sinus + object.x
	local __y1 = _x1 * sinus + _y1 * cosinus + object.y
	local __x2 = _x2 * cosinus - _y2 * sinus + object.x
	local __y2 = _x2 * sinus + _y2 * cosinus + object.y
	local __x3 = _x3 * cosinus - _y3 * sinus + object.x
	local __y3 = _x3 * sinus + _y3 * cosinus + object.y
	local __x4 = _x4 * cosinus - _y4 * sinus + object.x
	local __y4 = _x4 * sinus + _y4 * cosinus + object.y

	local minx = _G.math.min(_G.math.min(__x1,__x2), _G.math.min(__x3,__x4))
	local maxx = _G.math.max(_G.math.max(__x1,__x2), _G.math.max(__x3,__x4))
	
	local miny = _G.math.min(_G.math.min(__y1,__y2), _G.math.min(__y3,__y4))
	local maxy = _G.math.max(_G.math.max(__y1,__y2), _G.math.max(__y3,__y4))
	
	return {x1 = minx, y1 = miny, x2 = maxx, y2 = maxy}	
end
-- XXX: ADD TO OTHERS
function alignObjects(dir)
	
	local xDir = 0
	local yDir = 0
	
	if(dir == "DOWN") then
		yDir = -1		
	elseif(dir == "UP") then
		yDir = 1
	elseif(dir == "LEFT") then
		xDir = -1
	elseif(dir == "RIGHT") then
		xDir = 1
	end
	
	
	if(selectedObjects ~= nil and #selectedObjects > 1) then
		-- sort selected objects according to direction
		if(dir == "DOWN") then _G.table.sort( selectedObjects, function(a,b) return a.y > b.y end )	end	
		if(dir == "UP") then _G.table.sort( selectedObjects, function(a,b) return a.y < b.y end )	end	
		if(dir == "LEFT") then _G.table.sort( selectedObjects, function(a,b) return a.x < b.x end )	end	
		if(dir == "RIGHT") then _G.table.sort( selectedObjects, function(a,b) return a.x > b.x end )	end	
		
		
		for i = 1, #selectedObjects do
			local sel = selectedObjects[i]
			cBox1 = getBoundingBox(sel)			
			local w = cBox1.x2 - cBox1.x1
			local h = cBox1.y2 - cBox1.y1
			
			-- insert to initial position
			if(yDir == 1) then
				setPosition(sel.name, sel.x,  selectedObjectsAreaCoords.y1 +  h / 2)									
			elseif(yDir == -1) then
				setPosition(sel.name, sel.x,  selectedObjectsAreaCoords.y2 - h / 2)									
			elseif(xDir == 1) then 
				setPosition(sel.name, selectedObjectsAreaCoords.x2 - w / 2,  sel.y)									
			elseif(xDir == -1) then 
				setPosition(sel.name, selectedObjectsAreaCoords.x1 + w / 2 ,  sel.y)									
			end
			
			local val = 99999999999999
			local mincX = val
			local maxcX = -val
			local mincY = val
			local maxcY = -val
			local collided = false
			-- collision checks					
			for j = 1, i do
				-- for boxes that won't move anymore
				local sel2 = selectedObjects[j]							
				cBox2 = getBoundingBox(sel2)
				
				if(sel2 ~= sel) then
					local collideArea = nil
					if(xDir ~= 0) then
						collideArea = checkCollide(cBox1,cBox2,1)					
					else
						collideArea = checkCollide(cBox1,cBox2,0)					
					end
					if(collideArea ~= nil) then 				
						mincX = _G.math.min(cBox2.x1, mincX)
						maxcX = _G.math.max(cBox2.x2, maxcX)
						mincY = _G.math.min(cBox2.y1, mincY)
						maxcY = _G.math.max(cBox2.y2, maxcY)
						collided = true
					end		
				end					
			end
			
			if(collided == true) then
				local ww,hh = worldToPhysicsTransform(1,1)
				if(xDir ~=0) then
					local w = cBox1.x2 - cBox1.x1
					local xp = 0
					if(xDir == -1) then
						xp = maxcX
					else
						xp = mincX
					end
					setPosition(sel.name, xp + (ww + w / 2) * -xDir, sel.y)														
				else
					local h = cBox1.y2 - cBox1.y1
					local yp = 0
					if(yDir == 1) then
						yp = maxcY
					else
						yp = mincY
					end
					setPosition(sel.name, sel.x, yp + (hh + h / 2) * yDir)														
				end
			end
		end			
	end	
end
-- XXX: ADD TO OTHERS
selectedObjectsAreaCoords = nil
function drawSelectedObjectsArea()
	-- draw box of selected items
	if(selectedObjects ~= nil and #selectedObjects > 1) then
		
		local val = 9999999999
		local minX = val local minY = val local maxX = -val local maxY = -val		

		
		for k,v in _G.pairs(selectedObjects) do
			
			local points = getBoundingBox(v)
			
			local w = points.x2 - points.x1
			local h = points.y2 - points.y1
			
			
			minX = _G.math.min(minX, v.x - w / 2)
			minY = _G.math.min(minY, v.y - h / 2)

			maxX = _G.math.max(maxX, v.x + w / 2)
			maxY = _G.math.max(maxY, v.y + h / 2)
			
		end		

		if(selectedObjectsAreaCoords == nil or keyHold["LBUTTON"]) then
			selectedObjectsAreaCoords = {}
			selectedObjectsAreaCoords.x1 = minX
			selectedObjectsAreaCoords.y1 = minY
			selectedObjectsAreaCoords.x2 = maxX
			selectedObjectsAreaCoords.y2 = maxY				
		end
		
		local worldMinX, worldMinY = physicsToWorldTransform(selectedObjectsAreaCoords.x1, selectedObjectsAreaCoords.y1)
		local worldMaxX, worldMaxY = physicsToWorldTransform(selectedObjectsAreaCoords.x2, selectedObjectsAreaCoords.y2)
		drawWireFrameRect(worldMinX,worldMinY,worldMaxX,worldMaxY,3,true,255,0,255,255,0,0.5,0.5)
		
	else
		selectedObjectsAreaCoords = nil
	end	
end

-- XXX: ADD TO OTHERS
function drawLine(r,g,b,a,x1,y1,x2,y2,inWorld, lineSize)
	local lz = lineSize or 1
	
	if(inWorld == false) then
		setRenderState(0,0,1,1)
	end
	
		drawLine2D(x1,y1,x2,y2,lz,r,g,b,a)
end

--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- This function only draws the game without any logic

function drawGame()

	local c = blockTable.themes[objects.theme].color
	setBGColor(c.r, c.g, c.b)
	
	--print("draw game\n")
	setFont(fontBasic)
	-- Draw background image
	if showBG and not g_gfxLowQuality then
		drawBackgroundNative()
	end
	
	----slingshot rubber band
	local rbx, rby = physicsToWorldTransform(rubberBandPos.x, rubberBandPos.y )
	local lsx, lsy = physicsToWorldTransform(levelStartPosition.x, levelStartPosition.y )
	
	local rbx1, rby1 = rbx, rby
	
	--there is a weird flickering of this line when the blue bird is resting t the slingshot
	--so we disable the drawing if there is no bird selected. BUG 172
	local t_skipDrawing = selectedBird == nil and birdReady == true
	
	--bug 173
	--if currentBirdName ~= nil and flyingBird == nil then
	if currentBirdName ~= nil and (not t_skipDrawing) then
		local radius = objects.world[currentBirdName].radius
		if radius == nil then
			radius = objects.world[currentBirdName].width * 0.5
		end
		rbx1 = rbx - (radius + 0.05 ) * physicsToWorld * _G.math.cos(rubberBandAngle)
		rby1 = rby - (radius + 0.05 ) * physicsToWorld * _G.math.sin(rubberBandAngle)
	end
	
	local rbw = 50 / rubberBandLength
	if rbw > 25 then
		rbw = 25
	end

	if rbw < 10 then
		rbw = 10
	end
	
	local wScale = worldScale
	
	--if currentGameMode == updateGame then
	setRenderState(-screen.left - cameraShakeX, -screen.top - cameraShakeY, worldScale, worldScale, 0)
	_G.res.drawSprite("", "SLING_SHOT_01_BACK", lsx, lsy)
	local lsx1, lsy1 = lsx + 20, lsy
	
	
	local lsx2, lsy2 = lsx - 21, lsy - 3
	
	if selectedBird == nil then
		--_G.res.drawSprite("", "SLING_HOLDER", rbx1, rby1)
		
		drawLine2D(lsx1, lsy1, lsx2, lsy2, rbw, 48, 23, 8, 255)
	else
		drawLine2D(lsx1, lsy1, rbx1, rby1, rbw, 48, 23, 8, 255)
	end
	--end
	drawGameNative()
	
	if showBG then
		drawForegroundNative()
	end
	
	setRenderState(-screen.left - cameraShakeX, -screen.top - cameraShakeY, worldScale, worldScale, 0, 0, 0)
			
	-- local bcd = objects.birdCameraData[deviceModel]			
	-- _G.res.drawSprite("", "SLING_HOLDER", bcd.px, bcd.py)
	-- _G.res.drawSprite("", "HUD_ARROW_UP", 0, 0)
	
	
	
	--
	
	if not t_skipDrawing then	
		drawLine2D(lsx2, lsy2, rbx1, rby1, rbw, 48, 23, 8, 255)
	end
	
	if selectedBird ~= nil and not t_skipDrawing then
		setRenderState(-screen.left - cameraShakeX, -screen.top - cameraShakeY, worldScale, worldScale, rubberBandAngle, _G.res.getSpritePivot("INGAME_BIRDS_1", "SLING_HOLDER"))
		_G.res.drawSprite("", "SLING_HOLDER", rbx1, rby1)
	end
	setRenderState(-screen.left - cameraShakeX, -screen.top - cameraShakeY, worldScale, worldScale, 0, 0, 0)
	_G.res.drawSprite("", "SLING_SHOT_01_FRONT", lsx, lsy)
	
	if useLevelLimits then
		if cameraTargetObject ~= nil then
			local ct = cameraTargetObject
			if ct.y*physicsToWorld < screen.top then
				setRenderState(-screen.left, -screen.top, worldScale, worldScale, 0, ct.spritePivotX, ct.spritePivotY)
				_G.res.drawSprite("", "HUD_ARROW_UP", _G.math.floor(ct.x*physicsToWorld), _G.math.floor(screen.top))
			end
		end
	end	
	
	if currentGameMode ~= updateEditor then

		setRenderState(0, 0, 1, 1, 0)
		
		local drawHud = true
		if currentGameMode == updateMenu and (currentMenuPage == levelComplete or currentMenuPage == levelFailed or currentMenuPage == gameFinished or currentMenuPage == gameFinishedThreeStars or currentMenuPage == gameFinishedLP2 or currentMenuPage == gameFinishedThreeStarsLP2) then
			drawHud = false
		end
		
			
		if drawHud then
			if eagleBaitLaunched ~= true then
				setFont("FONT_SCORE")
				local yAdd = 0
				local scoreString = _G.string.format("%d", score)
				local scoreLen = _G.res.getStringWidth(scoreString)
				if deviceModel == "iphone4" and ((changeResolution ~= true and wantedResolution == "FULL") or (changeResolution == true and wantedResolution == "HALF")) then
					setRenderState(-screenWidth * 0.5, 0, 2, 2, 0)
				else
					setRenderState(0, 0, 1, 1, 0)
				end
				scoreLen = _G.math.max( scoreLen, oldScoreLen)
				oldScoreLen = scoreLen
				
				
				
				setFont("FONT_SCORE")
				
				
				
				local t_targetLowestResolutionHighScoreScaleFactor = 0.6
				local t_targetHighScoreLowestResolutionWidth = 1024
				local t_targetHighScoreHighestResolutionWidth = 1920				
				
				local t_resolutionBasedScaleFactorHighScore = (screenWidth - t_targetHighScoreLowestResolutionWidth) / (t_targetHighScoreHighestResolutionWidth - t_targetHighScoreLowestResolutionWidth)
				t_resolutionBasedScaleFactorHighScore = _G.math.max(t_resolutionBasedScaleFactorHighScore, 0)
				t_resolutionBasedScaleFactorHighScore = _G.math.min(t_resolutionBasedScaleFactorHighScore, 1)
				
				t_resolutionBasedScaleFactorHighScore = t_targetLowestResolutionHighScoreScaleFactor + ((1 - t_targetLowestResolutionHighScoreScaleFactor) * t_resolutionBasedScaleFactorHighScore)
				
				
				
				
				local t_fontRightSpacing = 18
				local t_fontTopSpacing = 15
				
				if deviceModel == "roku" then
					t_fontRightSpacing = screenWidth * 0.03
					t_fontTopSpacing   = t_fontRightSpacing
				end
				
				setRenderState(0, 0, t_resolutionBasedScaleFactorHighScore, t_resolutionBasedScaleFactorHighScore, 0)
					
				local t_maxScoreLen = 	_G.res.getStringWidth("" .. 999999)
				local t_modifiedMaxScoreLen = t_maxScoreLen * t_resolutionBasedScaleFactorHighScore
					
				if highscores[levelName] ~= nil and highscores[levelName].score > 0 then
					local highScoreLen = _G.res.getStringWidth("" .. highscores[levelName].score)
					
					--highScoreLen = highScoreLen * t_resolutionBasedScaleFactorHighScore
					yAdd = _G.res.getFontHeight()
					if scoreLen < highScoreLen then
						scoreLen = highScoreLen
					end
					
					
					
					--local t_modifiedScoreLen = scoreLen * t_resolutionBasedScaleFactorHighScore
					
					--scoreLen = scoreLen * t_resolutionBasedScaleFactorHighScore
					
					
					
					local highscoreStr = _G.res.getString("TEXTS_BASIC", "MI_HIGH_SCORE")
					--local t_x = (screenWidth - t_fontRightSpacing - t_modifiedScoreLen) / t_resolutionBasedScaleFactorHighScore
					local t_x = (screenWidth - t_fontRightSpacing - t_modifiedMaxScoreLen) / t_resolutionBasedScaleFactorHighScore
					_G.res.drawString("TEXTS_BASIC", highscoreStr .. " ", t_x, t_fontTopSpacing, "TOP", "RIGHT")
					t_x = (screenWidth - t_fontRightSpacing) / t_resolutionBasedScaleFactorHighScore
					_G.res.drawString("TEXTS_BASIC", _G.string.format("%d", highscores[levelName].score), t_x, t_fontTopSpacing, "TOP", "RIGHT")
					--_G.res.drawString("TEXTS_BASIC", _G.string.format("%d", highscores[levelName].score), (screenWidth - t_scoreLen - t_fontRightSpacing) / t_resolutionBasedScaleFactorHighScore , t_fontTopSpacing , "TOP", "LEFT")
					
				end
				
				local t_modifiedScoreLen = scoreLen * t_resolutionBasedScaleFactorHighScore

				local scoreStr = _G.res.getString("TEXTS_BASIC", "MI_SCORE")
				--local t_x = (screenWidth - t_fontRightSpacing - t_modifiedScoreLen) / t_resolutionBasedScaleFactorHighScore
				local t_x = (screenWidth - t_fontRightSpacing - t_modifiedMaxScoreLen) / t_resolutionBasedScaleFactorHighScore
				_G.res.drawString("TEXTS_BASIC", scoreStr .. " ", t_x, t_fontTopSpacing + yAdd, "TOP", "RIGHT")
				t_x = (screenWidth - t_fontRightSpacing) / t_resolutionBasedScaleFactorHighScore
				_G.res.drawString("TEXTS_BASIC", scoreString, t_x, t_fontTopSpacing + yAdd, "TOP", "RIGHT")
				
				
				
				setRenderState(0, 0, 1, 1, 0)
				--setFont("FONT_SCORE")
				setFont("FONT_INGAME_SCORE")
				--setFont(fontBasic)
				
				local t_textScaleMultiplier = 2.5
				local t_spriteScaleMultiplier = 2
				
				local t_targetLowestResolutionScaleFactor = 0.7
				local t_targetHighestScaleFactor = 1
				local t_targetLowestResolutionWidth = 1024
				local t_targetHighestResolutionWidth = 1920
				
				
				local t_resolutionBasedScaleFactor = (screenWidth - t_targetLowestResolutionWidth) / (t_targetHighestResolutionWidth - t_targetLowestResolutionWidth)
				t_resolutionBasedScaleFactor = _G.math.max(t_resolutionBasedScaleFactor, 0)
				t_resolutionBasedScaleFactor = _G.math.min(t_resolutionBasedScaleFactor, t_targetHighestScaleFactor)
				
				local t_resolutionBasedScaleFactor = t_targetLowestResolutionScaleFactor + ((t_targetHighestScaleFactor - t_targetLowestResolutionScaleFactor) * t_resolutionBasedScaleFactor)
				
				t_textScaleMultiplier = t_textScaleMultiplier * t_resolutionBasedScaleFactor
				t_spriteScaleMultiplier = t_spriteScaleMultiplier * t_resolutionBasedScaleFactor
				
				for i = 1, #floatingScores do
					local fs = floatingScores[i]
					local fx, fy =  physicsToScreenTransform(fs.x, fs.y)
					local xs = fs.xs * t_textScaleMultiplier
					
					
					--setRenderState(0, 0, xs, xs)
					if fs.text ~= nil then
						setRenderState(0, 0, xs, xs)
						_G.res.drawString("TEXTS_BASIC", fs.text, fx/xs, fy/xs, "BOTTOM", "HCENTER")
					end
					if fs.sprite ~= nil then 
						xs = fs.xs * t_spriteScaleMultiplier
						setRenderState(0, 0, xs, xs)
						_G.res.drawSprite("", fs.sprite, _G.math.floor(fx/xs), _G.math.floor(fy/xs), "BOTTOM", "HCENTER")
					end
				end
			end
			setFont(fontBasic)

			if deviceModel == "iphone4" and ((changeResolution ~= true and wantedResolution == "FULL") or (changeResolution == true and wantedResolution == "HALF")) then
				setRenderState(0, 0, 2, 2)
			else
				setRenderState(0, 0, 1, 1)
			end
			-- if hasMovingObjects then
				-- _G.res.drawString("", "HasMovingObjects", 0, screenHeight, "BOTTOM", "LEFT")
			-- end
			
			local t_hudButtonsLowestTargetScale = 0.6
			local t_hudButtonsLowestTargetWidth = 1024
			local t_hudButtonsHighestTargetWidth = 1920
			local t_hudButtonsTargetScale = (screenWidth - t_hudButtonsLowestTargetWidth) / (t_hudButtonsHighestTargetWidth - t_hudButtonsLowestTargetWidth)
			t_hudButtonsTargetScale = _G.math.max(t_hudButtonsTargetScale, 0)
			t_hudButtonsTargetScale = _G.math.min(t_hudButtonsTargetScale, 1)
			
			local t_hudButtonsScale = t_hudButtonsLowestTargetScale + (1 - t_hudButtonsLowestTargetScale) * t_hudButtonsTargetScale
			
			local t_ingamePause = getItemByName(g_ingamePausePage.items, "ingameButtonPause")
			local t_ingameRestart = getItemByName(g_ingamePausePage.items, "ingameButtonRestart")				
				
			if g_enableMouseOverStates then
				
				setRenderState(0, 0, 1, 1)
				drawMouseScalingItem(t_ingamePause.sheet, t_ingamePause, t_ingamePause.x, t_ingamePause.y)
				drawMouseScalingItem(t_ingameRestart.sheet, t_ingameRestart, t_ingameRestart.x, t_ingameRestart.y)
			else
			--[[
				setRenderState(0, 0, t_hudButtonsScale, t_hudButtonsScale)
				_G.res.drawSprite("", "MENU_BUTTON", 0, 0)
				
				_G.res.drawSprite("", "BUTTON_INGAME_RESTART", 0, 0 )
				
				setRenderState(0, 0, 1, 1)
				]]--
				setRenderState(t_ingamePause.x / t_ingamePause.xs, t_ingamePause.y / t_ingamePause.ys, t_ingamePause.xs, t_ingamePause.ys)
				_G.res.drawSprite("", t_ingamePause.sprite, 0, 0)
				
				setRenderState(t_ingameRestart.x / t_ingameRestart.xs, t_ingameRestart.y / t_ingameRestart.ys, t_ingameRestart.xs, t_ingameRestart.ys)
				_G.res.drawSprite("", t_ingameRestart.sprite, 0, 0)
			end
			
			
			
		end
		
		if #birdTutorialPopups > 0 then
	
			drawRect( 0, 0, 0, 0.5, 0, 0, screenWidth, screenHeight, false)
			local tutorial = getItemByName(tutorials.items, birdTutorialPopups[1])
			local t_isTrackPadTutorial = (tutorial.trackpadTutorial == true)
			local box = tutorials.backgroundBox
			
			if t_isTrackPadTutorial then
				drawBox(box.sprites, "", box.x, box.y, tutorial.boxWidth, tutorial.boxHeight, box.hanchor, box.vanchor)
			else
				drawBox(box.sprites, "", box.x, box.y, box.width, box.height, box.hanchor, box.vanchor)
			end
			
			_G.res.drawCompoSprite("", tutorial.sprite, tutorial.x, tutorial.y)
			
			if showTutorialGoldenEgg == true and birdTutorialPopups[1] == settings.tutorials["BIRD_GREEN"].sprite and settings.openGoldenEggLevels["Level1"] == nil then
				setRenderState(0, 0, 0.65, 0.65)
				_G.res.drawSprite("GOLDEN_EGG_1", tutorialGoldenEggPosition.x, tutorialGoldenEggPosition.y)
				setRenderState(0, 0, 1, 1, 0)
			end
			
			local t_okButton = getItemByName(tutorials.items, "okButton")
			
			t_okButton.x, t_okButton.y = tutorial.okButtonX, tutorial.okButtonY
			
			if t_okButton.mouseState ~= nil then
				drawMouseScalingItem(t_okButton.sheet, t_okButton, t_okButton.x, t_okButton.y)
			else
				if deviceModel == "roku" then
					_G.res.drawSprite("ROKU_TUTORIAL_OK", _G.math.floor(tutorials.okButtonX), _G.math.floor(tutorials.okButtonY))
				else
					_G.res.drawSprite("TUTORIAL_OK", _G.math.floor(tutorials.okButtonX), _G.math.floor(tutorials.okButtonY))
				end
			end
			
			
			--_G.res.drawSprite("TUTORIAL_OK", _G.math.floor(tutorials.okButtonX), _G.math.floor(tutorials.okButtonY))
			
			if deviceModel == "android" and isBetaVersion then
				_G.res.drawSprite("BETA_BOTTOM_RIGHT", screenWidth, screenHeight)
			end
			
		end
	end

	
	if showSleepingObjects then
		for k, v in _G.pairs(objects.world) do
			if v.sleeping == true and v.sprite ~= "" then
				local w, h = _G.res.getSpriteBounds("", v.sprite)
				w, h = w*0.5, h*0.5
				local x, y = physicsToWorldTransform(v.x, v.y)
				local x1, y1 = x - w, y - h
				local x2, y2 = x + w, y + h
				setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, v.spritePivotX, v.spritePivotY)
				drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
			end

			
			
			-- XXX: ADD TO OTHERS
			if(v.definition and v.sprite ~= "") then
				local blockDef = blockTable.blocks[v.definition]
		
				local w, h = _G.res.getSpriteBounds("", v.sprite)

				w, h = w*0.5, h*0.5
				local x, y = physicsToWorldTransform(v.x, v.y)
				local x1, y1 = x - w, y - h
				local x2, y2 = x + w, y + h
				
				
				
				if(blockDef.type == "circle") then
					local radius = blockDef.radius or _G.math.max(worldToPhysicsTransform(w,0),worldToPhysicsTransform(h,0))
					drawCircle(x,y,radius, v.angle,255,255,255,255,4)
					
				elseif (blockDef.type == "box" and blockDef.width ~= nil) then
					local ww, hh = physicsToWorldTransform(blockDef.width, blockDef.height) 
					local x1, y1 = x - ww / 2, y - hh / 2
					local x2, y2 = x + ww / 2, y + hh / 2
					
					local pivX = v.spritePivotX / (w * 2) 
					local pivY = v.spritePivotY / (h * 2)
					
					drawWireFrameRect(x1,y1,x2,y2,3,true,0,255,255,190,v.angle,pivX,pivY)
				
				elseif(blockDef.type == "box" and blockDef.width == nil) then
					local w, h = _G.res.getSpriteBounds("", v.sprite)
					w, h = w * 0.5, h * 0.5
					local x, y = physicsToWorldTransform(v.x, v.y)
					local x1, y1 = x - w, y - h
					local x2, y2 = x + w, y + h
					--setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, v.spritePivotX, v.spritePivotY)
					--drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
					drawWireFrameRect(x1,y1,x2,y2,3,true,0,255,255,190,v.angle,pivX,pivY)
				
				elseif (blockDef.type == "polygon" and blockDef.vertices) then
					local points = {}

					for kk,vv in _G.pairs(blockDef.vertices) do
						local wx,wy = w * 2 * vv.x, h * 2 * vv.y 
						local point = {x + wx - w, y + wy - h}
						_G.table.insert(points,point)
					end					
					drawPolygon(points,3, true,255,255,255,255,v.angle,0.5,0.5)
				end				
			end

			-- XXX: ADD TO OTHERS
			if v.strength ~= nil and v.sprite ~= nil and v.strength ~= blockTable.blocks[v.definition].strength and v.sprite ~= "" then
				local w, h = _G.res.getSpriteBounds("", v.sprite)
				w ,h = w * 0.50, h * 0.50
				local x, y = physicsToWorldTransform(v.x, v.y)
				local x1, y1 = x - w, y - h
				local x2, y2 = x + w, y + h 
				
				setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, v.spritePivotX, v.spritePivotY)
				
				drawLine(0,0,255,155,x1,y1,x2,y1,true,4)
				drawLine(0,0,255,155,x1,y1,x1,y2,true,4)
				setRenderState(-screen.left , -screen.top , wScale, wScale, v.angle, v.spritePivotX, -v.spritePivotY)
				drawLine(0,0,255,155,x1,y2,x2,y2,true,4)
				setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, -v.spritePivotX , v.spritePivotY )
				drawLine(0,0,255,155,x2,y1,x2,y2,true,4)
			end
			
			-- XXX: ADD TO OTHERS
			if(selectedObjects ~= nil and #selectedObjects == 1 and selectedObjects[1] == v) then			
				drawDummyCollisionBox(v)
			end
		end
	end	

	setRenderState(0, 0, 1, 1, 0)

	-- setRenderState(-screen.left, -screen.top, worldScale, worldScale, 0, 0, 0)
	-- drawRect( 1, 0, 0, 1, tapPosWorld.x - 3, tapPosWorld.y - 3, tapPosWorld.x + 3, tapPosWorld.y + 3, true)
	
	if currentGameMode == updateEditor then
		setRenderState(0, 0, 1, 1, 0)
		_G.res.drawString("TEXTS_BASIC", levelName, 0, 0, "TOP", "LEFT")

		if selectionRectActive then
			local x1, y1 = draggingStartPosWorld.x, draggingStartPosWorld.y
			local x2, y2 = cursorWorld.x, cursorWorld.y
			if x1 > x2 then	x1, x2 = x2, x1	end
			if y1 > y2 then	y1, y2 = y2, y1	end
			setRenderState(-screen.left, -screen.top, worldScale, worldScale, 0)
			drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
		end		

		setRenderState(0, 0, 1, 1, 0)
		for k, v in _G.pairs(objects.joints) do
			drawJoint(v, "EDITOR_JOINT")
		end

		if selectedObjects[1] ~= nil then
			if selectedObjects[1].controllable then
				if selectedObjects[1].startNumber ~= nil then
					_G.res.drawString("TEXTS_BASIC", "Start: " .. selectedObjects[1].startNumber, 0, 35, "TOP", "LEFT")
				end
			end
		end

		for k, v in _G.pairs(selectedObjects) do
			if v.sprite ~= nil and v.sprite ~= "" then
				local w, h = _G.res.getSpriteBounds("", v.sprite)
				w, h = w*0.5, h*0.5
				local x, y = physicsToWorldTransform(v.x, v.y)
				local x1, y1 = x - w, y - h
				local x2, y2 = x + w, y + h
				setRenderState(-screen.left, -screen.top, worldScale, worldScale, v.angle, v.spritePivotX, v.spritePivotY)
				drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
			end
		end
		
		--debug camera
		if g_cameraToDraw ~= nil then			
				
			setRenderState(0,0,1,1,0)
			--birds camera 
			local t_worldX, t_worldY  = objects.birdCameraData[g_cameraToDraw].px, objects.birdCameraData[g_cameraToDraw].py
			local t_screenX, t_screenY = worldToScreenTransform(t_worldX, t_worldY)					
			
			local t_screenHalfWidth = objects.birdCameraData[g_cameraToDraw].screenWidth / 2 / objects.birdCameraData[g_cameraToDraw].sx
			local t_screenHalfHeight = objects.birdCameraData[g_cameraToDraw].screenHeight / 2 / objects.birdCameraData[g_cameraToDraw].sy
			
			local t_right = t_screenX + (t_screenHalfWidth * worldScale)
			local t_left = t_screenX - (t_screenHalfWidth * worldScale)
			local t_bottom = t_screenY + (t_screenHalfHeight * worldScale)
			local t_top = t_screenY - (t_screenHalfHeight * worldScale)
			
			drawRect(1,0,0,0.5, t_left, t_top, t_right, t_bottom, true)
			
			drawLine2D(t_left, t_top, t_right, t_top, 3, 0, 0, 0, 255)
			drawLine2D(t_right, t_top, t_right, t_bottom, 3, 0, 0, 0, 255)
			drawLine2D(t_right, t_bottom, t_left, t_bottom, 3, 0, 0, 0, 255)
			drawLine2D(t_left, t_bottom, t_left, t_top, 3, 0, 0, 0, 255)
			
			_G.res.drawString("TEXTS_BASIC", g_cameraToDraw, t_left, t_top, "BOTTOM", "LEFT")
			
			--castle camera
			t_worldX, t_worldY  = objects.castleCameraData[g_cameraToDraw].px, objects.castleCameraData[g_cameraToDraw].py
			t_screenX, t_screenY = worldToScreenTransform(t_worldX, t_worldY)					
			
			t_screenHalfWidth = objects.castleCameraData[g_cameraToDraw].screenWidth / 2 / objects.castleCameraData[g_cameraToDraw].sx
			t_screenHalfHeight = objects.castleCameraData[g_cameraToDraw].screenHeight / 2 / objects.castleCameraData[g_cameraToDraw].sy
			
			t_right = t_screenX + (t_screenHalfWidth * worldScale)
			t_left = t_screenX - (t_screenHalfWidth * worldScale)
			t_bottom = t_screenY + (t_screenHalfHeight * worldScale)
			t_top = t_screenY - (t_screenHalfHeight * worldScale)
			
			drawRect(0,1,0,0.5, t_left, t_top, t_right, t_bottom, true)
			
			drawLine2D(t_left, t_top, t_right, t_top, 3, 0, 0, 0, 255)
			drawLine2D(t_right, t_top, t_right, t_bottom, 3, 0, 0, 0, 255)
			drawLine2D(t_right, t_bottom, t_left, t_bottom, 3, 0, 0, 0, 255)
			drawLine2D(t_left, t_bottom, t_left, t_top, 3, 0, 0, 0, 255)
			
			_G.res.drawString("TEXTS_BASIC", g_cameraToDraw, t_left, t_top, "BOTTOM", "LEFT")
			
				
		end
		
		if g_debugCameras then
			for i = 1, #g_camerasList, 1 do
				local t_initialX = 20
				local t_initialY = 150
				
				local t_offsetY = 50
				
				_G.res.drawString("TEXTS_BASIC", g_camerasList[i], t_initialX, t_initialY + (t_offsetY * (i-1)), "BOTTOM", "LEFT")
			end
		end
		
		
		if physicsEnabled then
			for k, v in _G.pairs(objects.world) do
				if v.sleeping == true and v.sprite ~= "" then
					local w, h = _G.res.getSpriteBounds("", v.sprite)
					w, h = w*0.5, h*0.5
					local x, y = physicsToWorldTransform(v.x, v.y)
					local x1, y1 = x - w, y - h
					local x2, y2 = x + w, y + h
					setRenderState(-screen.left, -screen.top, worldScale, worldScale, v.angle, v.spritePivotX, v.spritePivotY)
					drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
				end
			end
		end
		
		-- Draw small rect to indicate origin
		if keyHold["O"] then
			setRenderState(-screen.left*worldScale, -screen.top*worldScale, 1, 1, 0, 0, 0)
		else
			setRenderState(-screen.left, -screen.top, worldScale, worldScale, 0, 0, 0)
		end
		_G.res.drawSprite("", "ORIGO", 0, 0)
		setRenderState(0, 0, 1, 1, 0)

		if objectToAdd ~= nil then
			local sprite = blockTable.blocks[objectToAdd].sprite
			setRenderState(-screen.left, -screen.top, worldScale, worldScale, objectToAddAngle, _G.res.getSpritePivot("", sprite))
			_G.res.drawSprite("", sprite, _G.math.floor(cursorWorld.x), _G.math.floor(cursorWorld.y))
			setRenderState(0, 0, 1, 1, 0)
		end

		if copiedObjects ~= nil then
			for k, v in _G.pairs(copiedObjects) do
				local sprite = objects.world[v.name].sprite
				setRenderState(-screen.left, -screen.top, worldScale, worldScale, v.angle, _G.res.getSpritePivot("", sprite))
				local x, y = physicsToWorldTransform(v.x + cursorPhysics.x, v.y + cursorPhysics.y)
				_G.res.drawSprite("", sprite, _G.math.floor(x), _G.math.floor(y))
			end
			setRenderState(0, 0, 1, 1, 0)
		end
		
		if levelSaved then
			_G.res.drawSprite("", "EDITOR_SAVED", screenWidth, 0)
		else
			_G.res.drawSprite("", "EDITOR_NOT_SAVED", screenWidth, 0)
		end

		if physicsEnabled then
			_G.res.drawSprite("", "EDITOR_PHYSICS_ON", screenWidth, 0)
		else
			_G.res.drawSprite("", "EDITOR_PHYSICS_OFF", screenWidth, 0)
		end

		if objects.castleCameraData and objects.castleCameraData[deviceModel] then
			_G.res.drawSprite("", "EDITOR_C_CAMERA_ON", screenWidth, 0)
		else
			_G.res.drawSprite("", "EDITOR_C_CAMERA_OFF", screenWidth, 0)
		end

		if objects.birdCameraData and objects.birdCameraData[deviceModel] then
			_G.res.drawSprite("", "EDITOR_B_CAMERA_ON", screenWidth, 0)
		else
			_G.res.drawSprite("", "EDITOR_B_CAMERA_OFF", screenWidth, 0)
		end
		
		if objects.doNotWaitForMovingObjects ~= nil then
			_G.res.drawString("", "QUICK END", screenWidth, screenHeight, "BOTTOM", "RIGHT")
		end
	end

	--_G.res.drawString("TEXTS_BASIC", "cp.x: " .. cursorPhysics.x .. " - cp.y: " .. cursorPhysics.y, cursor.x, cursor.y, "BOTTOM", "HCENTER")
	--_G.res.drawString("TEXTS_BASIC", "cw.x: " .. cursorWorld.x .. " - cw.y: " .. cursorWorld.y, cursor.x, cursor.y+20, "BOTTOM", "HCENTER")
	-- if cameraTargetObject ~= nil then
		-- wx, wy = physicsToWorldTransform(cameraTargetObject.x, cameraTargetObject.y)
		-- sx = wx
		-- sy = wy
		-- tlx = sx - screenWidth * 0.5
		-- tly = sy - screenHeight * 0.5
		-- tx = screen.left
		-- ty = screen.top
		-- _G.res.drawString("TEXTS_BASIC", "s: (" .. sx .. " - " .. sy .. ")", 0, 30, "TOP", "LEFT")
		-- _G.res.drawString("TEXTS_BASIC", "target: (" .. tlx .. " - " .. tly .. ")", 0, 50, "TOP", "LEFT")
		-- _G.res.drawString("TEXTS_BASIC", "topleft: (" .. tx .. " - " .. ty .. ")", 0, 70, "TOP", "LEFT")
	-- end
	setRenderState(0, 0, 1, 1, 0)
	
	oldZoomLevel = zoomLevel
	
	if deviceModel == "android" and isBetaVersion and currentGameMode == updateGame and #birdTutorialPopups == 0 then
		_G.res.drawSprite("", "BETA_BOTTOM_RIGHT", screenWidth, screenHeight)
	end
	
	if objects.world["MightyEagle_a"] ~= nil then
		local eagle = objects.world["MightyEagle_a"]
		if eagle.targetX > eagle.x then
			eagleDarkness = (100 - _G.math.min(_G.math.max(_G.math.abs(eagle.targetX - eagle.x), 0), 100)) / 200
		end
	end	
	if eagleDarkness ~= nil then
		drawRect( 0, 0, 0, eagleDarkness, 0, 0, screenWidth, screenHeight, false)
	end

	if popupPage ~= nil then
		drawMenuPage(popupPage)
	end
	
	--[[ BEGIN FPS DEBUG CODE -- 
	if drawFPSStatistics then
		local FPSMinStr = String
		_G.res.drawString("", _G.string.format("FPSMin: %.1f", FPSMin), 0, screenHeight-60, "BOTTOM", "LEFT")
		_G.res.drawString("", _G.string.format("FPSAvg: %.1f", FPSFrames/FPSTime), 0, screenHeight-30, "BOTTOM", "LEFT")
		_G.res.drawString("", _G.string.format("FPSMax: %.1f", FPSMax), 0, screenHeight, "BOTTOM", "LEFT")
	end
	-- END FPS DEBUG CODE --]]
	
	--[[
	local t_halfWidth = 5
	if auei ~= nil then
		local t_auei = {}
		t_auei.x, t_auei.y = physicsToScreenTransform(auei.x, auei.y)
		drawRect(1,0,0,1, t_auei.x - t_halfWidth, t_auei.y - t_halfWidth, t_auei.x + t_halfWidth, t_auei.y + t_halfWidth,false)
	end
	]]
						
end



function drawJoint(joint, sprite)
	if joint.x1 == nil then
		return
	end
	
	local jointWorldX1 = joint.x1
	local jointWorldY1 = joint.y1
	local jointWorldX2 = joint.x2
	local jointWorldY2 = joint.y2
	
	if joint.coordType == 2 then
		jointWorldX1, jointWorldY1 = getWorldPoint(joint.end1, jointWorldX1, jointWorldY1);
		jointWorldX2, jointWorldY2 = getWorldPoint(joint.end2, jointWorldX2, jointWorldY2);
	end
	
	local xdif = jointWorldX2 - jointWorldX1
	local ydif = jointWorldY2 - jointWorldY1
	local tlen = vLength(xdif, ydif)
	local x = 0
	local y = 0

	--print(k .. " " .. tlen .. " " .. vLength(x, y) .."\n")
	if tlen == 0 then
		return
	end

	local vlen = 0
	while vlen <= tlen do
		sx, sy = physicsToScreenTransform(jointWorldX1 + x, jointWorldY1 + y )
		_G.res.drawSprite("", sprite, sx, sy)
		x = x + xdif * 0.13
		y = y + ydif * 0.13
		vlen = vLength(x, y)
		--print("vlen: " .. vlen .. " tlen: " .. tlen .. "\n")
	end
end

-------------------------------------------------------------------------------
-- Cameras 

function defaultCamera(dt)
	screen.left = screen.x - screenWidth * 0.5 / worldScale
	screen.top = screen.y - screenHeight * 0.5 / worldScale
	screen.right = screen.x + screenWidth * 0.5 / worldScale
	screen.bottom = screen.y + screenHeight * 0.5 / worldScale
	
	--print("left : " .. screen.left .. ", top: " .. screen.top .. "\n")
	--print("right: " .. screen.right .. ", bottom: " .. screen.bottom .. "\n")
	--print("Scale: " .. worldScale .. "\n")
	
	setTopLeft(screen.left + cameraShakeX, screen.top + cameraShakeY)
end


--kamera
--stay on the current target
--if target changes move to the new target using given speed
--keep the defined objects visible if possible by current restraints

function getTempBirdCamera()
	local tempCamera = {}
	
	local bcd = objects.birdCameraData[deviceModel]
	local ccd = objects.castleCameraData[deviceModel]
	
	--tempCamera.sx = bcd.sx + zoomLevel
	tempCamera.sx = currentZoomedScale
	if tempCamera.sx > bcd.sx then
		tempCamera.sx = bcd.sx
	end
	if tempCamera.sx < minWorldScale then
		tempCamera.sx = minWorldScale
	end
	
	tempCamera.py = bcd.py	
	local alpha = (tempCamera.sx - minWorldScale) / (bcd.sx - minWorldScale)
	--print("alpha: " .. alpha .. "\n")
	tempCamera.py = bcd.py * alpha + ccd.py * (1 - alpha)

	local groundPos = tempCamera.py + screenHeight * 0.5 / tempCamera.sx 
	if groundPos > groundLimit then
		tempCamera.py = tempCamera.py + (groundLimit - groundPos)
	end
	
	local leftPos = bcd.px - screenWidth * 0.5 / tempCamera.sx 
	tempCamera.px = bcd.px
	if leftPos < leftLimit then
		tempCamera.px = bcd.px + (leftLimit - leftPos)
	end	
	
	return tempCamera
end


function getTempCastleCamera()
	local tempCamera = {}
	local ccd = objects.castleCameraData[deviceModel]
		
	tempCamera.sx = currentZoomedScale
	if tempCamera.sx > ccd.sx then
		tempCamera.sx = ccd.sx
	end
	if tempCamera.sx < minWorldScale then
		tempCamera.sx = minWorldScale
	end
	
	local groundPos = ccd.py + screenHeight * 0.5 / tempCamera.sx
	tempCamera.py = ccd.py
	if groundPos > groundLimit then
		tempCamera.py = ccd.py + (groundLimit - groundPos)
	end
		
	local rightPos = ccd.px + screenWidth * 0.5 / tempCamera.sx 
	tempCamera.px = ccd.px
	if rightPos > rightLimit then
		tempCamera.px = ccd.px + (rightLimit - rightPos)
	end
	
	return tempCamera
end

function panToBirdCamera()
	cameraFunction = doItAllCamera
	local speedScalingFactor = _G.math.min(1, worldScale / objects.birdCameraData[deviceModel].sx)
	local speedFactor = 1.3 * speedScalingFactor
	sweepSpeed = (objects.castleCameraData[deviceModel].px - objects.birdCameraData[deviceModel].px) * speedFactor

	cameraAnimationSliderTarget = 0
	cameraAnimationSlider = _G.math.min(cameraAnimationSlider, 1)
end

function panToCastleCamera()
	cameraFunction = doItAllCamera
	local speedScalingFactor = _G.math.min(1, worldScale / objects.castleCameraData[deviceModel].sx)
	local speedFactor = 1.3 * speedScalingFactor
	sweepSpeed = (objects.birdCameraData[deviceModel].px - objects.castleCameraData[deviceModel].px) * speedFactor

	cameraAnimationSliderTarget = 1
	cameraAnimationSlider = _G.math.max(cameraAnimationSlider, 0)
end

useLevelLimits = true
function doItAllCamera(dt)
	--print(currentFrame .. " doItAllCamera camera\n")

	local ccd = objects.castleCameraData[deviceModel]
	local bcd = objects.birdCameraData[deviceModel]
	
	-- do not allow to zoom beyond level limits
	-- if zoomLevel + bcd.sx < minWorldScale and zoomLevel + ccd.sx < minWorldScale then
		-- zoomLevel = oldZoomLevel
	-- end
	
	-- Zoom level has changed
	if oldZoomLevel ~= zoomLevel then
		currentZoomedScale = currentZoomedScale + zoomLevel - oldZoomLevel
		-- if current zoomed scale is bigger than the current target camera set the scale to the camera scale
		if cameraAnimationSliderTarget == 0 then
			if currentZoomedScale > bcd.sx then
				currentZoomedScale = bcd.sx
			end
		else
			if currentZoomedScale > ccd.sx then
				currentZoomedScale = ccd.sx
			end
		end
		if currentZoomedScale < minWorldScale then
			currentZoomedScale = minWorldScale
		end
		oldZoomLevel = zoomLevel
		animationWorldScale = currentZoomedScale
	end	
	
	local bcdt = getTempBirdCamera()
	local ccdt = getTempCastleCamera()
	
	if ccd ~= nil and bcd ~= nil then
		local springFactor = dt * 3.5
		local scaleFactor = screenWidth / ccd.screenWidth
		local screenTemp = { x = 0, y = 0 }
		local dx = ccdt.px - bcdt.px
		
		if dx < 1 then dx = 1 end
		
		animateScale = true
		if cameraAnimationSlider < 0 then
			cameraAnimationSlider = cameraAnimationSlider - cameraAnimationSlider * 0.3
			if cameraAnimationSlider < -0.01 then
				animateScale = false
			end
			forceSprings = true
			sweepSpeed = 0
		end

		if cameraAnimationSlider > 1 then
			cameraAnimationSlider = cameraAnimationSlider + (1-cameraAnimationSlider) * 0.3
			if cameraAnimationSlider > 1.01 then
				animateScale = false
			end
			forceSprings = true
			sweepSpeed = 0
		end
		
		if cameraAnimationSlider >= 0 and cameraAnimationSlider <= 1 and sweepSpeed == 0 then
			forceSprings = false
			if cameraAnimationSlider < 0.5 then
				cameraAnimationSliderTarget = 0
			else
				cameraAnimationSliderTarget = 1
			end
		end
		
		if cameraTargetObject == nil then
			--print(currentFrame .. " Camera target object is nil\n")
			if not keyHold["LBUTTON"] and sweepSpeed == 0 and (multitouchSweep.isSweepping ~= true) then
				cameraAnimationSlider = cameraAnimationSlider + (cameraAnimationSliderTarget-cameraAnimationSlider) * 0.3
				--print("LButton and sweepSpeed\n")
			else
				if forceSprings ~= true then
					springFactor = 1
				end
			end
		
			--print("before cameraAnimationSlider: " .. cameraAnimationSlider .. " sweepSpeed: " .. sweepSpeed .. " cameraAnimationSliderTarget: " .. cameraAnimationSliderTarget .. " dt: " .. dt .. " dx: " .. dx .. "\n")
			--print("Before animationWorldScale: " .. animationWorldScale .. " animationScreen.x: " .. animationScreen.x .. " animationScreen.y: " .. animationScreen.y .. "\n")
			cameraAnimationSlider = cameraAnimationSlider - dt * sweepSpeed / (dx * bcd.sx) -- * worldScale)
			local tsx = bcdt.sx + (ccdt.sx - bcdt.sx) * cameraAnimationSlider
			local tpx = bcdt.px + (ccdt.px - bcdt.px) * cameraAnimationSlider
			local tpy = bcdt.py + (ccdt.py - bcdt.py) * cameraAnimationSlider			
			animationScreen.x = animationScreen.x - (animationScreen.x - tpx) * springFactor
			animationScreen.y = animationScreen.y - (animationScreen.y - tpy) * springFactor
			if animateScale == true then
				animationWorldScale = animationWorldScale - (animationWorldScale - tsx) * springFactor
			end
			--print("After animationWorldScale: " .. animationWorldScale .. " animationScreen.x: " .. animationScreen.x .. " animationScreen.y: " .. animationScreen.y .. "\n")
			
			--print("after cameraAnimationSlider: " .. cameraAnimationSlider .. " sweepSpeed: " .. sweepSpeed .. " cameraAnimationSliderTarget: " .. cameraAnimationSliderTarget .. " dt: " .. dt .. " dx: " .. dx .. "\n")			
			--print("castle camera phase2 cas: " .. cameraAnimationSlider .. "\n")
			
			-- set the current values
			screen.x = animationScreen.x
			screen.y = animationScreen.y
			
			worldScale = animationWorldScale
			setWorldScale(worldScale)
			repositionScreen()
		end
	
		----[[
		if cameraTargetObject ~= nil then
			--print(currentFrame .. " Camera target object is " .. cameraTargetObject.name .. "\n")
			-- camera target x, y
			--print("castle camera phase1 cas: " .. cameraAnimationSlider .. "\n")	
			local ctx, cty = physicsToWorldTransform(cameraTargetObject.x, cameraTargetObject.y)
			if cameraTargetObject.xVel > 0 then
				cameraAnimationSlider = cameraAnimationSlider + cameraTargetObject.xVel * physicsToWorld * dt * 10 / dx
			end
			if cameraAnimationSlider > 1 then
				cameraAnimationSlider = 1
			end
			
			--print("cameraAnimationSlider: " .. cameraAnimationSlider .. "\n")
			
			-- current animation targets based on the bird velocity
			local tsx = bcdt.sx + (ccdt.sx - bcdt.sx) * cameraAnimationSlider
			local tpx = bcdt.px + (ccdt.px - bcdt.px) * cameraAnimationSlider
			local tpy = bcdt.py + (ccdt.py - bcdt.py) * cameraAnimationSlider
			
			animationWorldScale = animationWorldScale - (animationWorldScale - tsx) * springFactor
			animationScreen.x = animationScreen.x - (animationScreen.x - tpx) * springFactor
			animationScreen.y = animationScreen.y - (animationScreen.y - tpy) * springFactor		

			-- camera x, y
			local cleft = animationScreen.x - screenWidth * 0.5 / animationWorldScale
			local ctop = animationScreen.y - screenHeight * 0.5 / animationWorldScale
			local cright = animationScreen.x + screenWidth * 0.5 / animationWorldScale
			local cbottom = animationScreen.y + screenHeight * 0.5 / animationWorldScale

			local minx = _G.math.min(cleft, ctx - 50)
			local miny = _G.math.min(ctop, cty - 50)
			local maxx = _G.math.max(cright, ctx + 50)
			local maxy = _G.math.max(cbottom, cty + 50)
			
			if useLevelLimits then
				minx = _G.math.max(leftLimit, minx)
				maxx = _G.math.min(rightLimit, maxx)
			end
			
			--print("animation xy: " .. animationScreen.x .. ", " .. animationScreen.y .. "\n")
			--print("camera tl: " .. cleft .. ", " .. ctop .. "\n")
			--print("camera br: " .. cright .. ", " .. cbottom .. "\n")
			--print("ct: " .. ctx .. ", " .. cty .. "\n")
			--print("min: " .. minx .. ", " .. miny .. "\n")
			--print("max: " .. maxx .. ", " .. maxy .. "\n")

			local xScale = _G.math.abs(screenWidth/(maxx-minx))
			local yScale = _G.math.abs(screenHeight/(maxy-miny))
			
			local worldScaleTemp = _G.math.min(xScale, yScale) * scaleFactor
			--print("worldScaleTemp: " .. worldScaleTemp .. " animws: " .. animationWorldScale .. "\n")

			-- scale is never closer than the animation to castle camera's scale
			if worldScaleTemp > animationWorldScale then
				worldScaleTemp = animationWorldScale
				--print("worldScaleTemp = animationWorldScale.\n")
			end
			--print("worldScaleTemp: " .. worldScaleTemp .. "\n")
			
			screenTemp.x = (maxx + minx) * 0.5
			screenTemp.y = (maxy + miny) * 0.5

			if useLevelLimits then								
				-- if y scale is smaller we need to check that x coordinates stay inside the boundaries
				local limitsReached = false
				if (screenTemp.x + screenWidth * 0.5 / worldScaleTemp) > rightLimit then
					maxx = rightLimit
					minx = maxx - screenWidth / worldScaleTemp
					limitsReached = true
					if minx < leftLimit then
						minx = leftLimit
					end
					--print("Limits reached 1\n")
				end
				if (screenTemp.x - screenWidth * 0.5 / worldScaleTemp) < leftLimit then
					minx = leftLimit
					maxx = minx + screenWidth / worldScaleTemp
					limitsReached = true
					if maxx > rightLimit then
						maxx = rightLimit
					end
					--print("Limits reached 1\n")
				end
				if limitsReached then
					screenTemp.x = (maxx + minx) * 0.5
					worldScaleTemp = _G.math.abs(screenWidth/(maxx-minx)) * scaleFactor 
					--print("new worldScaleTemp: " .. worldScaleTemp .. "\n")
					--print("screenWidth: " .. screenWidth .. "\n")
					--print("min: " .. minx .. ", " .. miny .. "\n")
					--print("max: " .. maxx .. ", " .. maxy .. "\n")
				end
			end
			
			screen.x = screen.x - (screen.x - screenTemp.x) * springFactor
			animationWorldScale2 = animationWorldScale2 - (animationWorldScale2 - worldScaleTemp) * springFactor
			worldScale = animationWorldScale2
			--print("worldScale: " .. worldScale .. " worldScaleTemp: " .. worldScaleTemp .. "\n")
			
			-- if useLevelLimits then								
				-- maxy = groundLimit
				-- miny = maxy - screenHeight / worldScale
				-- screenTemp.y = (maxy + miny) * 0.5				
			-- end
			
			screen.y = screen.y - (screen.y - screenTemp.y) * springFactor
			
			forceSprings = true
			
			if ctx >= rightLimit or ctx <= leftLimit then
				animationWorldScale = worldScale
				animationScreen.x = screen.x
				animationScreen.y = screen.y
				-- print("animationWorldScale: " .. animationWorldScale .. " animationScreen.x: " .. animationScreen.x .. " animationScreen.y: " .. animationScreen.y .. "\n")
				--print("Camera target object outside level limits\n")
				cameraTargetObject = nil
			end
			
			-- flyCameraData.px = screen.x
			-- flyCameraData.py = screen.y
			-- flyCameraData.sx = worldScale
			-- flyCameraData.sy = worldScale
			-- flyCameraData.left = screen.x - screenWidth * 0.5 / worldScale
			-- flyCameraData.right = screen.x + screenWidth * 0.5 / worldScale
			-- flyCameraData.top = screen.y - screenHeight * 0.5 / worldScale
			-- flyCameraData.bottom = screen.y + screenHeight * 0.5 / worldScale
			
			--print("min: " .. minx .. ", " .. miny .. "\n")
			--print("max: " .. maxx .. ", " .. maxy .. "\n")
			
			setWorldScale(worldScale)
			repositionScreen()			
		end
		--]]		
	end
	defaultCamera(dt)
end

function isTouchDragAllowed()
	local ccd = objects.castleCameraData[deviceModel]
	local bcd = objects.birdCameraData[deviceModel]		
	
	local bcdt = getTempBirdCamera()
	local ccdt = getTempCastleCamera()
	
	if ccd ~= nil and bcd ~= nil then
		

		local tsx = bcdt.sx 
		local tpx = bcdt.px
		local tpy = bcdt.py	
		
		
		local t_diff = _G.math.abs(animationScreen.x - tpx)		
		return (t_diff < 100)
	end
	
	return true
	
end


function repositionScreen()
	local ccd = objects.castleCameraData[deviceModel]
	local bcd = objects.birdCameraData[deviceModel]
		
	-- scale is too big, limit the scale
	if worldScale < minWorldScale then
		worldScale = minWorldScale
		setWorldScale(worldScale)
		--print("Forced scale to minWorldScale.\n")
	end
	
	local groundPos = screen.y + screenHeight * 0.5 / worldScale 
	if groundPos > groundLimit then
		screen.y = screen.y + (groundLimit - groundPos)
	end
		
	local rightPos = screen.x + screenWidth * 0.5 / worldScale 
	if rightPos > rightLimit then
		screen.x = screen.x + (rightLimit - rightPos)
	end	

	local leftPos = screen.x - screenWidth * 0.5 / worldScale 
	if leftPos < leftLimit then
		screen.x = screen.x + (leftLimit - leftPos)
	end
end

function levelStartCamera(dt)
	--print("Level start camera\n")
	local ccd = objects.castleCameraData[deviceModel]
	local bcd = objects.birdCameraData[deviceModel]

	if castleCameraTimer < 2 then
		local wx, wy = ccd.px, ccd.py
		if levelRestartedFrom == nil or startedFromEditor then
			worldScale = ccd.sx
		else
			worldScale  = getTempCastleCamera().sx
		end
		setWorldScale(worldScale)
		screen.x = wx
		screen.y = wy
		castleCameraTimer = castleCameraTimer + dt
		animationWorldScale = worldScale
		animationScreen.x = screen.x
		animationScreen.y = screen.y		
		
		if levelRestartedFrom ~= nil or startedFromEditor ~= true then
			repositionScreen()
		end
		
		defaultCamera(dt)
		return
	end

	castleCameraTimer = 0
	cameraAnimationSlider = 1
	cameraAnimationSliderTarget = 0
	sweepSpeed = ccd.px - bcd.px
	showTapIcon = false
	--print("levelStartCamera: cameraFunction = doItAllCamera\n")	
	cameraFunction = doItAllCamera
	animationScreen.x = screen.x
	animationScreen.y = screen.y
	animationWorldScale = worldScale	
	defaultCamera(dt)
end

function gotoCastleCamera(dt)
	if objects.birdCameraData[deviceModel] ~= nil then
		local ccd = objects.castleCameraData[deviceModel]
		local wx, wy = ccd.px, ccd.py
		local springFactor = dt * 4

		animationWorldScale = animationWorldScale - (animationWorldScale - ccd.sx) * springFactor
		animationScreen.x = animationScreen.x - (animationScreen.x - wx) * springFactor
		animationScreen.y = animationScreen.y - (animationScreen.y - wy) * springFactor
		
		cameraAnimationSliderTarget = 1
		cameraAnimationSlider = 1
		screen.x = animationScreen.x
		screen.y = animationScreen.y
		worldScale = animationWorldScale
		setWorldScale(worldScale)		
		
		--[[if _G.math.abs(worldScale - ccd.sx) < 0.05 and
			_G.math.abs(screen.x - wx) < 5 and
			_G.math.abs(screen.y - wy) < 5 then
			worldScale = ccd.sx
			setWorldScale(worldScale)
			screen.x = wx
			screen.y = wy
			--cameraFunction = defaultCamera
			--castleCameraTimer = 0
			--cameraAnimationSlider = 0
		end--]]
	end
	--doItAllCamera(dt)
	
	defaultCamera(dt)
end

function launchCamera(dt)
	--print("launch camera\n")

	if castleCameraTimer < 3 then
		castleCameraTimer = castleCameraTimer + dt
		defaultCamera(dt)
		return
	end
	
	if objects.birdCameraData and objects.birdCameraData[deviceModel] ~= nil then
		local ccd = objects.castleCameraData[deviceModel]
		local bcd = objects.birdCameraData[deviceModel]
		local wx, wy = bcd.px, bcd.py
		local springFactor = dt * 4

		animationWorldScale = animationWorldScale - (animationWorldScale - bcd.sx) * springFactor
		animationScreen.x = animationScreen.x - (animationScreen.x - wx) * springFactor
		animationScreen.y = animationScreen.y - (animationScreen.y - wy) * springFactor
		
		cameraAnimationSlider = (bcd.px - animationScreen.x)/(bcd.px - ccd.px)
		--print("bird camera cas: " .. cameraAnimationSlider .. "\n")		
		screen.x = animationScreen.x
		screen.y = animationScreen.y
		worldScale = animationWorldScale
		setWorldScale(worldScale)		

		-- worldScale = bcd.sx + (ccd.sx - bcd.sx) * cameraAnimationSlider
		-- screen.x = bcd.px + (ccd.px - bcd.px) * cameraAnimationSlider
		-- screen.y = bcd.py + (ccd.py - bcd.py) * cameraAnimationSlider
		-- setWorldScale(worldScale)

		if _G.math.abs(worldScale - ccd.sx) < 0.05 and
			_G.math.abs(screen.x - wx) < 5 and
			_G.math.abs(screen.y - wy) < 5 then
			worldScale = bcd.sx
			setWorldScale(worldScale)
			screen.x = wx
			screen.y = wy
			cameraFunction = defaultCamera
			castleCameraTimer = 0
			cameraAnimationSlider = 0
			--print("Launch camera in place!\n")
		end
	end
	defaultCamera(dt)
end


-------------------------------------------------------------------------------
-- The Others

function setPositions(xadd, yadd)
	for k, v in _G.pairs(selectedObjects) do
		setPosition(v.name, v.x + xadd*physicsScale, v.y + yadd*physicsScale)
		setSleeping(v.name, false)
	end
	levelSaved = false
end

-- scale update, when animated or user controlled
function updateScale()
	if oldScale ~= worldScale then
		local wx = cursor.x / oldScale + screen.left
		local wy = cursor.y / oldScale + screen.top
		local newx = (wx * worldScale - cursor.x) / worldScale
		local newy = (wy * worldScale - cursor.y) / worldScale

		screen.x = newx + screenWidth * 0.5 / worldScale
		screen.y = newy + screenHeight * 0.5 / worldScale
	end
	oldScale = worldScale
end


function birdCollision(object1, object2, force, damage)
	local obj1 = objects.world[object1]
	local obj2 = objects.world[object2]
	
	-- update score
	if obj1.controllable and damage > 0 then
		local bird = obj1
		
		local resultDamage = damage * 10
		_G.table.insert(floatingScores, { x = bird.x, y = bird.y, text = "" .. resultDamage, score = resultDamage, time = 0, lifetime = 0.6, maxScale = floatingScoreScaling * (0.25 + resultDamage / 3000), xs = 0 } )

		if scoreTable[object1] == nil then
			scoreTable[object1] = {}
			scoreTable[object1].score = 0
			--scoreTable[object1].blockDestroyedScore = blockDestroyedScoreIncrement
		end

		scoreTable[object1].score = scoreTable[object1].score + resultDamage
	end
	-- bird has been launched
	
	-- Willhelm Tell and Bull's Eye achievement check
	-- if both are birds..
	if obj1.shot and obj2.shot then
		-- ..and none of them has collided and are not eagle baits
		if not(obj1.hasCollided) and not(obj2.hasCollided) and not(settings.wilhelmTell) and not(obj1.isEagleBait) and not(obj2.isEagleBait) then
			if (obj1.parentName == nil or obj2.parentName == nil) or (obj1.parentName ~= obj2.parentName) then
				--print("Wilhelm Tell achieved! bird "..obj1.name.." has collided with target bird "..obj2.name )
				obj1.hasCollided, obj2.hasCollided = true, true
				if eagleBaitLaunched ~= true then
					settings.wilhelmTell = true
					addToAchievementUnlockQueue("Wilhelm Tell")
				end
			end
		-- if mighty eagle collides eagle bait, remove bait by frozing it
		elseif obj1.isMightyEagle and obj2.isEagleBait then
			obj2.frozen = true
		elseif obj2.isMightyEagle and obj1.isEagleBait then
			obj1.frozen = true
		end
	-- else if one is a bird and the other is a pig
	elseif obj1.shot and obj2.levelGoal and not(settings.bullsEye) then
		if not(obj1.hasCollided) and (obj2.x - levelStartPosition.x) > 75 then
			--print("Bull's eye achieved! bird "..obj1.name.." has collided with target pig "..obj2.name)
			obj1.hasCollided = true
			if eagleBaitLaunched ~= true then
				addToAchievementUnlockQueue("Bull's Eye")
				settings.bullsEye = true
			end
		end
	elseif obj2.shot and obj1.levelGoal and not(settings.bullsEye) then
		if not(obj2.hasCollided) and (obj1.x - levelStartPosition.x) > 75 then
			--print("Bull's eye achieved! bird "..obj2.name.." has collided with target pig "..obj1.name)
			obj2.hasCollided = true
			if eagleBaitLaunched ~= true then
				addToAchievementUnlockQueue("Bull's Eye")
				settings.bullsEye = true
			end
		end
	-- else just ignore it and set hasCollided to true
	elseif obj1.shot then
		obj1.hasCollided = true
	elseif obj2.shot then
		obj2.hasCollided = true
	end
	
	-- bird has been launched
	if flyingBird ~= nil and (flyingBird.name == object1 or flyingBird.name == object2) then			
		
		-- if birds collide camera target object is not reset nor is collision timer set
		if obj1.controllable ~= true or obj2.controllable ~= true then
			if cameraTargetObject ~= nil then
				if cameraTargetObject == obj1 or cameraTargetObject == obj2 then
					--print("Setting camera target object to nil in bird collision.\n")
					cameraTargetObject = nil
					animationScreen.x = screen.x
					animationScreen.y = screen.y
					animationWorldScale = worldScale
				end
			end
		end
		
		local bDef = getObjectDefinition(flyingBird.name)
		local birdSpecialty = bDef.specialty
		if birdSpecialty ~= "BOMB" then
			if bDef.spriteCollision ~= nil then
				if birdSpecialty == "GRENADE" then
					if birdSpecialtyAvailable then
						objects.world[flyingBird.name].sprite = bDef.spriteCollision
						setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)						
					end
				else
					objects.world[flyingBird.name].sprite = bDef.spriteCollision
					setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)				
				end
			end
			birdSpecialtyAvailable = false
			if birdSpecialty == "SUMMON_MIGHTY_EAGLE" then
				if flyingBird.collision ~= true and eagleTimer == nil then
					eagleTimer = 8.7
					eagleMoving = true
					--birdSpecialtyAvailable = true
					--print("Summon mighty eagle.\n")
				end
			end
		else
			if flyingBird.collision ~= true then
				objects.world[flyingBird.name].bombTimer = 1.5			
				objects.world[flyingBird.name].damageSprite = "BIRD_GREY_1"
				objects.world[flyingBird.name].sprite = objects.world[flyingBird.name].damageSprite
				setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)
				birdSpecialtyAvailable = true
			end
		end
		-- set collision flag to true
		flyingBird.collision = true
		
	end
	
	if obj1.controllable then
		local bird = obj1
		local bDef = getObjectDefinition(bird.name)
		local birdSpecialty = bDef.specialty
		if birdSpecialty == "BOOMERANG" then
			bird.boomerangActive = false
		end
	end
	
	if obj2.controllable then
		local bird = obj2
		local bDef = getObjectDefinition(bird.name)
		local birdSpecialty = bDef.specialty
		if birdSpecialty == "BOOMERANG" then
			bird.boomerangActive = false
		end
	end
	
	--set collision flags
	if obj1.shot and obj1.controllable then
		obj1.collision = true
		-- bird to bird collision does not stop trajectory recording
		if obj2.controllable ~= true then
			obj1.recordTrajectory = false
		end
	end
	if obj2.shot and obj2.controllable then
		obj2.collision = true
		-- bird to bird collision does not stop trajectory recording
		if obj1.controllable ~= true then
			obj2.recordTrajectory = false
		end
	end	
	
	-- mark the granade to explode
	for i = #flyingGrenades, 1, -1 do
		local flyingGrenade = flyingGrenades[i].name
		if flyingGrenade == object1 and obj2.controllable ~= true or
			flyingGrenade == object2 and obj1.controllable ~= true then
			flyingGrenades[i].explode = true
			if object1 == flyingGrenade then
				object1 = nil
			end
		end
		
		if object1 == flyingGrenade and obj2.controllable == true then
			return
		end
		if object2 == flyingGrenade and obj1.controllable == true then
			return
		end
	end
	
	--local particleAmount = _G.math.random(12,20)
	
	if object1 ~= nil then
		if objects.world[object1].definition == "MightyEagleBird" and objects.world[object2].definition == "BaitSardine" then
			objects.world[object2].strength = 0
		elseif objects.world[object1].lowerThanGround or (objects.world[object1].definition == "MightyEagleBird" and object2 == "ground")  then
			objects.world[object1].hitGround = true
			cameraShake = 100
			local bDef = getObjectDefinition(objects.world[object1].name)
			bDef.spriteCollision = "BIRD_MIGHTY_EAGLE_RADIAL"
			objects.world[object1].sprite = bDef.spriteCollision
			setSprite(object1, objects.world[object1].sprite)						
			_G.res.playAudio("mighty_eagle_thump", 1, false)
			for k, v in _G.pairs(objects.world) do
				if v.strength ~= nil and v.levelGoal then
					local force = -v.mass * 15
					applyImpulse( v.name,
								0,
								force,
								v.x,
								v.y )
					v.strength = 0.0001
					v.defence = 0
				elseif v.isEagleBait then
					v.strength = 0
				end
			end
			-- delete all joints later in updateGame
			destroyJoints = true
			eagleTimer = 4
		end
	
		local birdie = birds[object1]
		local birdieStartForce = 0
		if object2 ~= nil and (getObjectDefinition(object2).material == "immovable" or getObjectDefinition(object2).material == "staticGround") then
			if birdie ~= nil and birdie.xVel ~= nil and birdie.yVel ~= nil then
				birdieStartForce = (vLength(birdie.xVel, birdie.yVel) * birdie.mass) / 10.0
			end
		end
		if force > collisionParticleForceThreshold or birdieStartForce > collisionParticleForceThreshold then
		 
			--print("Material: " .. getObjectDefinition(object2).material .. "\n")
			-- play either collision or damage sound
			local mat = blockTable.materials[getObjectDefinition(object2).material]
			if mat ~= nil then
				local sound = mat.collisionSound
				if damage > 10 then
					sound = mat.damageSound or sound
				end
				if sound ~= nil then
					_G.res.playAudio(getAudioName(sound), 0.7, false, 2)
				end
			end
			--print("Object: " .. object1 .. "\n")
			local particle = getObjectDefinition(object1).particles
			--print("particles: " .. particle .. "\n")
			local particleAmount = _G.math.random(12, 20)
			if getObjectDefinition(object1).particlesAmountLimits ~= nil then
				particleAmount = _G.math.random(getObjectDefinition(object1).particlesAmountLimits[1], getObjectDefinition(object1).particlesAmountLimits[2])
			end
			addParticles(object1, particle, particleAmount, false)
			
			-- scale volume with collision force
			local volume = 0.7
			if birdie ~= nil then
				local maxForce = ((60.0 * birdie.mass) / 10.0)
				local dmgFactor = blockTable.damageFactors[birdie.damageFactors].damageMultiplier[getObjectDefinition(object2).material]
				if dmgFactor ~= nil and dmgFactor > 1 then
					maxForce = maxForce * dmgFactor
				end
				volume = _G.math.min(_G.math.max(_G.math.max(force, birdieStartForce) / maxForce, 0.20), 1.0)
			end
					
			-- bird sound
			if getObjectDefinition(object1).collisionSound ~= nil then
				_G.res.playAudio(getAudioName(getObjectDefinition(object1).collisionSound), volume, false, 2)
			end
		end
	end
	
	if obj2.controllable ~= true then
		local sprites = getDamageSprite(obj2, blockTable.blocks)
		obj2.damageSprite = sprites.sprite
		obj2.blinkSprite = sprites.blink
		obj2.smileSprite = sprites.smile
	end
end

function blockCollision(object1, object2, force, wasDamageDone)
	--[[
	if(force > 0 and startedFromEditor) then
		local obj1 = objects.world[object1]
		local obj2 = objects.world[object2]
		obj2.debugDamageAmount = force;
		obj1.debugDamageAmount = force;
	end]]
	
	if wasDamageDone then
		local obj1 = objects.world[object1]
		local sprites = getDamageSprite(obj1, blockTable.blocks)
		local dmgSprite = sprites.sprite
		if dmgSprite ~= obj1.damageSprite then
			obj1.damageSprite = dmgSprite
			obj1.blinkSprite = sprites.blink
			obj1.smileSprite = sprites.smile			
			if getObjectDefinition(object1).damageSound ~= nil then
				_G.res.playAudio(getAudioName(getObjectDefinition(object1).damageSound), 0.5, false, 2)
			end
		end
		
		local obj2 = objects.world[object2]
		local sprites = getDamageSprite(obj2, blockTable.blocks)
		local dmgSprite = sprites.sprite		
		if dmgSprite ~= obj2.damageSprite then
			obj2.damageSprite = dmgSprite
			obj2.blinkSprite = sprites.blink		
			obj2.smileSprite = sprites.smile
			if getObjectDefinition(object2).damageSound ~= nil then
				_G.res.playAudio(getAudioName(getObjectDefinition(object2).damageSound), 0.5, false, 2)
			end
		end
	end

	if force > collisionSoundForceThreshold then
		--print("Material: " .. getObjectDefinition(object1).material .. "\n")
		local material1 = blockTable.materials[getObjectDefinition(object1).material]
		local material2 = blockTable.materials[getObjectDefinition(object2).material]
		if material1 ~= nil then
			_G.res.playAudio(getAudioName(blockTable.materials[getObjectDefinition(object1).material].collisionSound), 0.5, false, 2)
		end

		--print("Material: " .. getObjectDefinition(object2).material .. "\n")
		if material2 ~= nil and material2 ~= material1 then
			_G.res.playAudio(getAudioName(blockTable.materials[getObjectDefinition(object2).material].collisionSound), 0.5, false, 2)
		end
	end
end

-- Stretches the rubber band of the sling shot
-- @param displacement vector of the sling shot rubber band in physics units
function stretchRubberBand(displacement)
	_G.assert(displacement.x ~= nil and displacement.y ~= nil,
		"displacement vector missing x/y members")

	local distToRest = vLength(displacement.x, displacement.y)

	local shootMaxLength = rubberBandMaximumLength()
	rubberBandAngle = _G.math.atan2(displacement.y, displacement.x)

	-- Limit the maximum stretch displacement of the rubber band
	if distToRest < shootMaxLength then
		rubberBandPos.x, rubberBandPos.y = levelStartPosition.x - displacement.x , levelStartPosition.y - displacement.y
		rubberBandLength = distToRest

		if _G.math.abs(rubberBandLength - oldRubberBandLength) > 0.1 and not _G.res.isAudioPlaying("slingshot_stretched") then
			_G.res.playAudio("slingshot_stretched", 1, false)
		end

		oldRubberBandLength = rubberBandLength
	else
		rubberBandPos.x = levelStartPosition.x - displacement.x * (shootMaxLength / distToRest)
		rubberBandPos.y = levelStartPosition.y - displacement.y * (shootMaxLength / distToRest)
		rubberBandLength = shootMaxLength
		rubberBandSpeed = 0

		if not birdSelected then
			_G.res.playAudio("slingshot_stretched", 1, false)
		end
	end

	if not birdSelected then
		_G.res.playAudio(getObjectDefinition(selectedBird.name).selectionSound, 1, false)
		birdSelected = true
	end

	-- limit the rubber band stretching in certain angles (collision with sling shot fork)
	local factor = 1
	if rubberBandAngle >= -1.9 and rubberBandAngle < -1.75 then
		factor = -(rubberBandAngle + 1.75) / 0.15
	end
	if rubberBandAngle >= -1.75 and rubberBandAngle < -1.5 then
		factor = 0.25
	end
	if rubberBandAngle >= -1.5 and rubberBandAngle < -1.35 then
		factor = (1.5 + rubberBandAngle) / 0.15
	end

	if rubberBandLength > factor * shootMaxLength then 
		rubberBandPos.y = levelStartPosition.y - displacement.y * (shootMaxLength * factor / distToRest)
		rubberBandLength = vLength(displacement.x, levelStartPosition.y - rubberBandPos.y)
	end
end

-- Fires the bird that is stored in the 'selectedBird' global variable
-- @param displacement vector of the sling shot rubber band
function shootSelectedBird(displacement)
	_G.assert(selectedBird ~= nil, "No bird currently selected")
	_G.assert(displacement.x ~= nil and displacement.y ~= nil,
		"displacement vector missing x/y members")

	local distToRest = vLength(displacement.x, displacement.y)
	local distFactor = rubberBandLength / rubberBandMaximumLength()
	if distFactor < 0 then distFactor = 0 end
	if distFactor > 1 then distFactor = 1 end

	local force = -defaultForce * physicsScale * selectedBird.mass
	setPosition(selectedBird.name, rubberBandPos.x, rubberBandPos.y)
	setVelocity(selectedBird.name, 0, 0)
	applyImpulse(selectedBird.name,
				displacement.x / distToRest * force * distFactor,
				displacement.y / distToRest * force * distFactor,
				selectedBird.x,
				selectedBird.y)
	cameraTargetObject = selectedBird
	flyingBird = selectedBird
	cameraFunction = doItAllCamera
	
	-- set target camera based on shooting direction
	if displacement.x > 0 then
		cameraAnimationSliderTarget = 1
	else
		cameraAnimationSliderTarget = 0
	end

	animationScreen.x = screen.x
	animationScreen.y = screen.y
	animationWorldScale = worldScale
	animationWorldScale2 = worldScale

	selectedBird.shot = true
	selectedBird.hasCollided = false
	birdSpecialtyAvailable = true
	allowResetToBirdCamera = true
	allowTrajectoryClearing = true
	hasMovingObjectsZeroTolerance = true
	birdSelected = false
	birdReady = false
	birdFired = true
	showTapIcon = false
	birdsShot = birdsShot + 1
	cameraResetTimer = 0
	showTapTimer = 0
	nextBirdTimer = 1
	currentBirdName = nil

	otherBirds = {}
	birdTrajectory =  { {}, {}, {} }

	flyingBird.sprite = getObjectDefinition(flyingBird.name).spriteFlying
	setSprite(flyingBird.name, flyingBird.sprite)

	-- Play audio
	if getObjectDefinition(selectedBird.name).launchSound ~= nil then
		_G.res.playAudio(getAudioName("bird_shot"), 1, false)
		_G.res.playAudio(getObjectDefinition(selectedBird.name).launchSound, 1, false)
	end

	selectedBird = nil

	-- Check "shooting birds backwards" achievement
	if displacement.x < 0 then
		if settings.backwardsBirdCount == nil then
			settings.backwardsBirdCount = 0
		end

		settings.backwardsBirdCount = settings.backwardsBirdCount + 1

		if settings.backwardsBirdCount == 10 then
			addToAchievementUnlockQueue("Backward Compatibility", true)
		end
	end
end

function addParticles(object, particle, amount)
	local obj = objects.world[object]
	if obj == nil then
		return
	end

	local x, y = physicsToWorldTransform(obj.x, obj.y)
	local w, h = 1, 1

	if obj.radius == nil then
		w, h = physicsToWorldTransform(obj.width, obj.height)
	else
		w, h = physicsToWorldTransform(obj.radius*2, obj.radius*2)
	end

	newParticles(particle, amount, x, y, w, h, getAngle(obj.name))
end

function addParticlesToPosition(px, py, particle, amount)
	local x, y = physicsToWorldTransform(px, py)
	local w, h = 1, 1

	newParticles(particle, amount, x, y, w, h, getAngle(obj.name))
end

function removeBird(object)
	local k = object.name
	
	addParticles(k, getObjectDefinition(k).particles , 10)

	if cameraTargetObject == object then
		--print("Remove bird: setting camera target object to nil\n")
		cameraTargetObject = nil
	end
	
	if currentBirdName == k then
		currentBirdName = nil
	end
	if flyingBird == object then
		flyingBird = nil
		birdSpecialtyAvailable = false
	end
	
	removeObject(k)
	objects.world[k] = nil
	birds[k] = nil
	otherBirds[k] = nil

	_G.res.playAudio(getAudioName("bird_destroyed"), 1, false)
end

-- This function finds the definition of the given level object based on its name
function getObjectDefinition(name)
	return blockTable.blocks[objects.world[name].definition]
end

-- returns the next bird name or nil if bird not found
function getNextBird(index)
	--print("Getting next bird: " .. index .. "\n")
	for k, v in _G.pairs(birds) do
		if v.controllable then
			if v.startNumber == index then
				return k
			end
		end
	end

	return nil
end

-- TODO: parse piglettes to own table
function checkLevelComplete()
	if hasMovingObjects and objects.doNotWaitForMovingObjects ~= true then
		return false
	end
	for k, v in _G.pairs(levelGoals) do
		if v.levelGoal then
			return false
		end
	end	
	return true
end

function checkLevelFailed()
	if hasMovingObjects and objects.doNotWaitForMovingObjects ~= true then
		return false
	end
	
	for k, v in _G.pairs(birds) do
		if v.controllable then
			return false
		end
	end
	return true
end

function getDamageSprite(object, definitions)
	local sprites = {}
	sprites.sprite = object.sprite
	sprites.blink = object.sprite
	sprites.smile = object.sprite
	
	if object.definition == nil or object.definition == "" then
		return sprites
	end

	if definitions[object.definition] == nil then
		return sprites
	end

	if definitions[object.definition].damageSprites == nil then
		return sprites
	end

	if object.strength == nil then
		return sprites
	end

	local percentage = (object.strength / definitions[object.definition].strength) * 100
	for k, v in _G.pairs(definitions[object.definition].damageSprites) do
		if v.min < percentage and v.max >= percentage then
			setSprite(object.name, v.sprite)
			sprites.sprite = v.sprite
			sprites.blink = v.sprite
			sprites.smile = v.sprite
			if v.blinkSprite ~= nil then
				sprites.blink = v.blinkSprite
			end
			if v.smileSprite ~= nil then
				sprites.smile = v.smileSprite
			end
			return sprites
		end
	end

	-- fail safe
	return sprites
end


function makeExplosion(object, definition, sound)
	if definition.explosionForce ~= nil then
		if sound ~= nil then
			_G.res.playAudio(sound, 0.7, false, 1)
		end
		addParticles(object.name, "explosion", 1)
		addParticles(object.name, "explosionBuff", 1)

		for k, v in _G.pairs(objects.world) do
			if v.controllable or object == v then
				--do nothing
			else
				local dist = vLength(v.x - object.x, v.y - object.y)
				local x, y = vNormalize(v.x - object.x, v.y - object.y)
				if dist < definition.explosionRadius then
					local force = physicsScale * definition.explosionForce / dist
					applyImpulse( k,
								x * force,
								y * force,
								v.x,
								v.y )
				end
				if dist < definition.explosionDamageRadius then
					if v.defence < definition.explosionDamage/dist then
						v.strength = v.strength - definition.explosionDamage/dist
						local sprites = getDamageSprite(v, blockTable.blocks)
						v.damageSprite = sprites.sprite
						v.blinkSprite = sprites.blink
						v.smileSprite = sprites.smile
						--print("st: " .. v.strength .. "\n")
					end
				end
			end
		end
	end
end

function makeClickExplosion(objectX, objectY, explosionForce, explosionRadius, explosionDamage, explosionDamageRadius, sound)
	if sound ~= nil then
		_G.res.playAudio(sound, 0.7, false, 1)
	end

	local wx, wy = physicsToWorldTransform(objectX, objectY)
	newParticles("explosion", 1, wx, wy, 4, 4, 0)
	newParticles("explosionBuff", 1, wx, wy, 4, 4, 0)

	for k, v in _G.pairs(objects.world) do
		local dist = vLength(v.x - objectX, v.y - objectY)
		local x, y = vNormalize(v.x - objectX, v.y - objectY)
		if dist < explosionRadius then
			local force = physicsScale * explosionForce / dist
			applyImpulse( k,
						x * force,
						y * force,
						v.x,
						v.y )
		end
		if dist < explosionDamageRadius then
			if v.defence ~= nil and v.defence < explosionDamage/dist then
				v.strength = v.strength - explosionDamage/dist
				local sprites = getDamageSprite(v, blockTable.blocks)
				v.damageSprite = sprites.sprite
				v.blinkSprite = sprites.blink
				v.smileSprite = sprites.smile
				--print("st: " .. v.strength .. "\n")
			end
		end
	end
end


-------------------------------------------------------------------------------
-- Miscellaneous stuff

function rubberBandMaximumLength()
	return shootRange + 3.2
end

function screenToPhysicsMultiplier()
	return physicsScale / worldScale
end

function physicsToScreenMultiplier()
	return worldScale / physicsScale
end

function screenToPhysicsVectorTransform(x, y)
	local multiplier = screenToPhysicsMultiplier()
	return x * multiplier, y * multiplier
end

function physicsToScreenVectorTransform(x, y)
	local multiplier = physicsToScreenMultiplier()
	return x * multiplier, y * multiplier
end

function worldToPhysicsTransform(x, y)
	local px = x * physicsScale
	local py = y * physicsScale
	return px, py
end

function worldToScreenTransform(x, y)
	local sx = (x - screen.left) * worldScale
	local sy = (y - screen.top) * worldScale
	return sx, sy
end

function screenToWorldTransform(x, y)
	local wx = x / worldScale + screen.left
	local wy = y / worldScale + screen.top
	return wx, wy
end

function physicsToWorldTransform(x, y)
	local wx = x * physicsToWorld
	local wy = y * physicsToWorld
	return wx, wy
end

function physicsToScreenTransform(x, y)
	local wx, wy = physicsToWorldTransform(x, y)
	local sx, sy = worldToScreenTransform(wx, wy)
	return sx, sy
end

function screenToPhysicsTransform(x, y)
	local wx, wy = screenToWorldTransform(x, y)
	local px, py = worldToPhysicsTransform(wx, wy)
	return px, py
end

function distance(x1,y1,x2,y2)
	local dx = x2-x1
	local dy = y2-y1
	return _G.math.sqrt(dx*dx+dy*dy)
end

function squaredDistance(x1,y1,x2,y2)
	local dx = x2-x1
	local dy = y2-y1
	return (dx*dx+dy*dy)
end


function checkObjectBounds(x, y, width, height, angle, cursorX, cursorY)	 
	local cx = cursorX - x
	local cy = cursorY - y
	
	local tcx = cx * _G.math.cos(angle) + cy * _G.math.sin(angle)
	local tcy = -cx * _G.math.sin(angle) + cy * _G.math.cos(angle)

	local halfWidth = width * 0.5
	local halfHeight = height * 0.5
	
	local left = -halfWidth
	local top = -halfHeight
	local right = halfWidth
	local bottom = halfHeight
	
	if tcx >= left and tcx < right then
		if tcy >= top and tcy < bottom then
			return true
		end
	end
	return false
end


function checkPolygonObjectBounds(x, y, width, height, angle, vertices, cursorX, cursorY)	 
	local cx = cursorX - x
	local cy = cursorY - y
	
	local tcx = cx * _G.math.cos(angle) + cy * _G.math.sin(angle)
	local tcy = -cx * _G.math.sin(angle) + cy * _G.math.cos(angle)
	
	local tVerts = {}
	
	for i = 1, #vertices do
		tVerts[i] = {}
		tVerts[i].x = vertices[i].x * width - 0.5*width
		tVerts[i].y = vertices[i].y * height - 0.5*height
	end
	
	return testPointInPolygon(tcx, tcy, tVerts)
end


function checkBounds(left, top, w, h, cursorX, cursorY, angle, hanchor, vanchor)
	--[[
	print("Checking bounds: ")
	print(" x:" .. x)
	print(" y:" .. y)
	print(" w:" .. w)
	print(" h:" .. h)
	print(" cx:" .. cursorX)
	print(" cy:" .. cursorY)
	print("\n")
	--]]
	if hanchor and vanchor then
		if hanchor == "HCENTER" then
			left = left - w * 0.5
		elseif hanchor == "LEFT" then
			left = left + w
		elseif hanchor == "RIGHT" then
			left = left - w
		end
		if vanchor == "VCENTER" then
			top = top - h * 0.5
		elseif vanchor == "TOP" then
			top = top + h
		elseif vanchor == "BOTTOM" then
			top = top - h
		end
	end
	
	
	if cursorX >= left and cursorX < left + w then
		if cursorY >= top and cursorY < top + h then
			return true
		end
	end
	return false
	
end

function checkTextBounds(textGroup, text, hanchor, vanchor, x, y, cursorX, cursorY)
	local w = _G.res.getStringWidth(_G.res.getString(textGroup, text))
	local h = _G.res.getFontLeading()
	--print("String width " .. text .. " " .. w .. "\n")
	--print("Font leading " .. h .. "\n")
	if hanchor == nil then
		x = x - w * 0.5
	elseif hanchor == "RIGHT" then
		x = x - w
	elseif hanchor == "HCENTER" then
		x = x - w * 0.5
	end

	if vanchor == nil then
		y = y - h * 0.5
	elseif vanchor == "BOTTOM" then
		y = y - h
	elseif vanchor == "VCENTER" then
		y = y - h * 0.5
	end

	return checkBounds(x, y, w, h, cursorX, cursorY)
end

function checkSpriteBounds(sheet, sprite, x, y, cursorX, cursorY)
	local w, h = _G.res.getSpriteBounds(sheet, sprite)
	local px, py = _G.res.getSpritePivot(sheet, sprite)

	return checkBounds(x - px, y - py, w, h, cursorX, cursorY)
end

function checkSpriteBoundsWithScaling(sheet, sprite, x, y, xs, ys, cursorX, cursorY)
	local w, h = _G.res.getSpriteBounds(sheet, sprite)
	local px, py = _G.res.getSpritePivot(sheet, sprite)
	
	w = w * xs
	h = h * ys
	
	px = px * xs
	py = py * ys
	
	return checkBounds(x - px, y - py, w, h, cursorX, cursorY)
end

function hitTest(pivotX, pivotY, width, height, x, y, cursorX, cursorY)	
	return checkBounds(x - pivotX, y - pivotY, width, height, cursorX, cursorY)
end

function getObjectsInsideRect(x1, y1, x2, y2)
	if x1 > x2 then
		x1, x2 = x2, x1
	end
	if y1 > y2 then
		y1, y2 = y2, y1
	end

	local t = {}

	for k, v in _G.pairs(objects.world) do
		x, y = physicsToWorldTransform(v.x, v.y)
		if x > x1 and x <= x2 then
			if y > y1 and y <= y2 then
				if v.name ~= "ground" then
					_G.table.insert(t, v)
				end
			end
		end
	end

	return t
end

function testPointInPolygon(x, y, vertices)
	local s = #vertices
	local e = 1
	local counter = 0
	
	while e <= #vertices do
		-- check that the line is not below this point
		if y > _G.math.min(vertices[s].y, vertices[e].y) then
			-- check that the line is not above this point
			if y <= _G.math.max(vertices[s].y, vertices[e].y) then
				-- check that the line is to the right from this point
				if x <= _G.math.max(vertices[s].x, vertices[e].x) then
					-- horizontal lines are ignored
					if vertices[s].y ~= vertices[e].y then
						local crossPointX = (y - vertices[s].y) * (vertices[e].x - vertices[s].x) / (vertices[e].y - vertices[s].y) + vertices[s].x
						if vertices[s].x == vertices[e].x or x < crossPointX then
							counter = counter + 1
						end
					end
				end
			end
		end
		
		s = e
		e = e + 1
	end
	
	if counter % 2 == 0 then
		return false
	end
	
	return true
end

--[[
ks Spring constant.
kd Spring damping constant.
r Distance to rest length.
v Spring velocity

Usage: springspeed += dampedSpring(0.8,0.5,distancetorest,springspeed) * dt
springlength += springspeed * dt
]]
function dampedSpring(ks, kd, r, v)
	return (ks * r) - (kd * v)
end

--[[
Calculates 2 times the signed triangle area. <br>

Algorithm from "Real time collision detection" by Christer Ericson, page 152.

@param aX Point A x-component
@param aY Point A y-component
@param bX Point B x-component
@param bY Point B y-component
@param cX Point C x-component
@param cY Point C y-component
The result is positive if abc is ccw, negative if abc is cw, zero if abc is degenerate.
]]
function signed2DTriArea(aX, aY, bX, bY, cX, cY)
	return (aX - cX) * (bY - cY) - (aY - cY) * (bX - cX)
end

--[[
Test if segments ab and cd overlap. If they do, compute intersection value t along ab and
intersection position p. <br>

Algorithm from "Real time collision detection" by Christer Ericson, page 152-153.
]]
function test2DSegmentSegment(aX, aY, bX, bY, cX, cY, dX, dY, findPoint)

	local instersectionValue, intersectionPoint = nil, nil

	-- Compute winding of abd (+ or -)
	local a1 = signed2DTriArea(aX, aY, bX, bY, dX, dY)
	-- To intersect, must have sign opposite of a1
	local a2 = signed2DTriArea(aX, aY, bX, bY, cX, cY)

	-- If c and d are on different sides of ab, areas have different signs
	if a1 ~= 0 and a2 ~= 0 and a1 * a2 < 0 then
		-- Compute signs for a and b with respect to segment cd
		local a3 = signed2DTriArea(cX, cY, dX, dY, aX, aY) -- Compute winding of cda (+ or -)
		-- Since area is constant a1 - a2 = a3 - a4, or a4 = a3 + a2 - a1
		local a4 = a3 + a2 - a1
		-- Points a and b on different sides of cd if areas have different signs
		if(a3 ~= 0 and a4 ~= 0 and a3 * a4 < 0) then
			if(findPoint == true) then -- Test if we want to get also intersection value and point
				-- Segments intersect. Find intersection point along L(t) = a + t * (b - a).
				-- Given height h1 of an over cd and height h2 of b over cd,
				-- t = h1 / (h1 - h2) = (b*h1/2 - b*h2/2) = a3 / (a3 - a4),
				-- where b ( the base of the triangles cda and adb, i.e., the length
				-- of cd) cancels out.
				intersectionValue = a3 / (a3 - a4)
				intersectionPoint = { x = aX + intersectionValue * (bX - aX), y = aY + intersectionValue * (bY - aY) }
			end
			return true, instersectionValue, intersectionPoint
		end
	end
	return false -- Segments do not intersect (or collinear)
end

function vLength(x, y)
	local len = _G.math.sqrt(x * x + y * y)
	return len
end

function vNormalize(x, y)
	local len = _G.math.sqrt(x * x + y * y)
	return x/len, y/len
end

-------------------------------------------------------------------------------
-- Floating scores

function updateFloatingScores(dt)
	-- update floating scores
	local i = 1
	while i <= #floatingScores do
		local fs = floatingScores[i]
		fs.time = fs.time + dt

		if fs.time < 0.25 then
			fs.xs = fs.maxScale * fs.time / 0.25
		else
			if fs.time < fs.lifetime - 0.25 then
				fs.xs = fs.maxScale
			else
				fs.xs = fs.maxScale * (fs.lifetime - fs.time) / 0.25
			end
		end

		if floatingScores[i].time > floatingScores[i].lifetime then
			_G.table.remove(floatingScores, i)
		else
			i = i + 1
		end
	end
end

-------------------------------------------------------------------------------
-- Animations

function newAnimation(name, state, page, speedIn, speedOut)
	local v = {}
	v.page = page
	v.state = state
	v.percentage = 0
	v.speedIn = speedIn
	v.speedOut = speedOut
	v.name = name
	elementAnimations[name] = v
end

function updateAnimations(dt)
	for k, v in _G.pairs(elementAnimations) do
		if v.state == "ENTERING" then
			v.percentage = v.percentage + v.speedIn * dt
			if v.percentage > 100 then
				v.percentage = 100
				v.state = "VISIBLE"
				v.page.state = "READY"
			end
		elseif v.state == "VISIBLE" then
		elseif v.state == "EXITING" then
			v.percentage = v.percentage - v.speedOut * dt
			if v.percentage < 0 then
				v.percentage = 0
				v.state = "HIDDEN"
				v.page.state = "DISABLED"
				if k == "ingamePausePageScroll" or k == "ingameGesturePausePageScroll" then
					--onExitPage(pausePage)
					
					-- continue game after pause menu has scrolled out
					if deviceModel == "iphone4" and (birdTutorialPopups == nil or #birdTutorialPopups == 0) then
						changeResolution = true
						wantedResolution = "FULL"
						resolutionChanged = true
					end
					setGameMode(updateGame)
					setPhysicsEnabled(true)
				end
			end
		end
	end
end

function setAnimationState(animation, state)
	local v = elementAnimations[animation]
	if state == "ENTERING" then
		if v.state == "HIDDEN" then
			v.state = state
			v.percentage = 0
			v.page.state = "DISABLED"
		elseif v.state == "EXITING" then
			v.state = state
		end
	elseif state == "VISIBLE" then
		if v.state == "ENTERING" or v.state == "HIDDEN" or v.state == "EXITING" then
			v.state = state
			v.percentage = 100
			v.page.state = "READY"			
		end
	elseif state == "EXITING" then
		if v.state == "VISIBLE" then
			v.state = state
			v.percentage = 100
			v.page.state = "READY"			
		elseif v.state == "ENTERING" then
			v.state = state
		end
	elseif state == "HIDDEN" then
		if v.state == "ENTERING" or v.state == "VISIBLE" or v.state == "EXITING" then
			v.state = state
			v.percentage = 0
			v.page.state = "DISABLED"
		end
	end
end

-------------------------------------------------------------------------------
-- Particle engine

function newParticles(type, amount, x, y, w, h, angle)
	local pt = particleTable.particles[type]
	if pt == nil then
		return
	end
	
	_G.particles.addParticles(type, amount, x, y, w, h, angle)

--[[	
	if softLimitSimultaneousParticles < particleAmount + amount then
		amount = amount * 0.5
	end
	
	for i = 1, amount, 1 do
		if particleAmount < hardLimitSimultaneousParticles then
			particleAmount = particleAmount + 1
			local p = { }
			p.x = x + (_G.math.random(0, w) - 0.5*w ) -- * cos(angle)
			p.y = y + (_G.math.random(0, h) - 0.5*h ) -- * sin(angle)
			p.xVel = _G.math.random(pt.minVel, pt.maxVel)
			p.yVel = _G.math.random(pt.minVel, pt.maxVel)
			p.angle = _G.math.random(1, 3.14)
			p.angleVel = _G.math.random(pt.minAngleVel, pt.maxAngleVel)
			p.scaleBegin = _G.math.random(pt.minScaleBegin, pt.maxScaleBegin)
			p.scaleEnd = _G.math.random(pt.minScaleEnd, pt.maxScaleEnd)
			p.scale = p.scaleBegin
			p.type = type
			p.sprite = pt.sprites[_G.math.random(1, #pt.sprites)]
			p.sheet = pt.sheet
			p.time = 0
			p.lifeTime = pt.lifeTime
			p.lifeTimeAnimation = pt.animation == "lifeTime"

			if p.lifeTimeAnimation then
				p.sprite = pt.sprites[1]
			end
			p.oldSprite = p.sprite
			p.spritePivotX, p.spritePivotY = _G.res.getSpritePivot(p.sheet, p.sprite)

			_G.table.insert(particles, p)
		end
	end
--]]
end

function updateParticles(dt)
	for k, v in _G.pairs(particles) do
		local p = v
		p.time = p.time + dt
		if p.time > p.lifeTime then
			_G.table.remove(particles, k)
			particleAmount = particleAmount - 1
		else
			pt = particleTable.particles[p.type]
			p.xVel = p.xVel + pt.gravityX * dt
			p.yVel = p.yVel + pt.gravityY * dt
			p.x = p.x + p.xVel * dt
			p.y = p.y + p.yVel * dt
			p.angle = p.angle + p.angleVel * dt
			p.scale = p.scaleBegin + (p.scaleEnd - p.scaleBegin) * (p.time / p.lifeTime)
			
			if p.lifeTimeAnimation then
				index = _G.math.ceil(#pt.sprites * (p.time / p.lifeTime))
				if index < 1 then index = 1 end
				if index > #pt.sprites then index = #pt.sprites end
				p.sprite = pt.sprites[index]
				if p.oldSprite ~= p.sprite then
					p.spritePivotX, p.spritePivotY = _G.res.getSpritePivot(p.sheet, p.sprite)
					p.oldSprite = p.sprite
				end
			end
		end
	end
end


function drawParticles()
	--local counter = 0
	for k, v in _G.pairs(particles) do
		--counter = counter + 1
		local p = v
		setRenderState(-screen.left/p.scale, -screen.top/p.scale, worldScale*p.scale, worldScale*p.scale, p.angle, p.spritePivotX, p.spritePivotY)
		_G.res.drawSprite("", p.sprite, p.x/p.scale, p.y/p.scale)
	end
	--print("Particles: " .. particleAmount .. "\n")
end

-------------------------------

function getCutsceneBackgroundWidth(sprites)
	local bgWidth = 0
	for k, v in _G.pairs(sprites) do
		if v.isBackground then
			local tsw, _ = _G.res.getSpriteBounds("", v.sprite)
			bgWidth = bgWidth + tsw
		end
	end
	return bgWidth
end

function logEvent(eventType, triggeredFrom, worldNumber, levelNumber, timePlayed, numberOfTries, currentScore, numberOfBirdsUsed, numberOfBirdsAvailable)
	--[[if eventType == "level_started" then
		print("LOG: Level " .. worldNumber .. "-" .. levelNumber .. " started.\n")
	elseif eventType == "level_restarted" then
		print("LOG: Level " .. worldNumber .. "-" .. levelNumber .. " restarted " .. numberOfTries .. " times, birds used: " .. numberOfBirdsUsed .. "/" .. numberOfBirdsAvailable .. "\n")
	elseif eventType == "level_completed" then
		print("LOG: Level " .. worldNumber .. "-" .. levelNumber .. " completed with " .. numberOfTries .. " attempts, score: " .. currentScore .. ", birds used: " .. numberOfBirdsUsed .. "/" .. numberOfBirdsAvailable .. "\n")
	elseif eventType == "level_failed" then
		print("LOG: Level " .. worldNumber .. "-" .. levelNumber .. " failed, attempts: " .. numberOfTries .. ", birds used: " .. numberOfBirdsUsed .. "/" .. numberOfBirdsAvailable .. "\n")
	elseif eventType == "level_exited" then
		print("LOG: Level " .. worldNumber .. "-" .. levelNumber .. " exited, attempts: " .. numberOfTries .. "\n")
	end--]]
	--[[
	if eventType == "level_started" then
		print("LOG: START," .. triggeredFrom .. "," .. worldNumber .. "," .. levelNumber .. "," .. numberOfTries .. "," .. currentScore .. "," .. numberOfBirdsUsed .. "," .. numberOfBirdsAvailable .. "\n")
	elseif eventType == "level_restarted" then
		print("LOG: RESTART," .. triggeredFrom .. ",".. worldNumber .. "," .. levelNumber .. "," .. numberOfTries .. "," .. currentScore .. "," .. numberOfBirdsUsed .. "," .. numberOfBirdsAvailable .. "\n")
	elseif eventType == "level_completed" then
		print("LOG: COMPLETED," .. triggeredFrom .. ",".. worldNumber .. "," .. levelNumber .. "," .. numberOfTries .. "," .. currentScore .. "," .. numberOfBirdsUsed .. "," .. numberOfBirdsAvailable .. "\n")
	elseif eventType == "level_failed" then
		print("LOG: FAILED," .. triggeredFrom .. ",".. worldNumber .. "," .. levelNumber .. "," .. numberOfTries .. "," .. currentScore .. "," .. numberOfBirdsUsed .. "," .. numberOfBirdsAvailable .. "\n")
	elseif eventType == "level_exited" then
		print("LOG: EXIT," .. triggeredFrom .. ",".. worldNumber .. "," .. levelNumber .. "," .. numberOfTries .. "," .. currentScore .. "," .. numberOfBirdsUsed .. "," .. numberOfBirdsAvailable .. "\n")
	end--]]
end

function drawBoxWithTiledBorders( borderSprites, sheet, x1, y1, width, height, hAnchor, vAnchor, color)
	
	local r, g, b, a = 1.0, 1.0, 1.0, 1.0
	if color ~= nil then
		if color.red ~= nil then
			r = color.red
		end
		if color.green ~= nil then
			g = color.green
		end
		if color.blue ~= nil then
			b = color.blue
		end
		if color.alpha ~= nil then
			a = color.alpha
		end
	end
	
	local x2 = x1 + width
	local y2 = y1 + height
	
	-- top (& bottom) part
	local pxTopLeft,   pyTopLeft   = 0, 0
	local pxTopMiddle, pyTopMiddle = 0, 0
	local pxTopRight,  pyTopRight  = 0, 0
	local twTopLeft,   thTopLeft   = 0, 0
	local twTopMiddle, thTopMiddle = 0, 0
	local twTopRight,  thTopRight  = 0, 0
	
	-- left (& right) part
	local pxMiddleLeft, pyMiddleLeft = 0, 0
	local pxBottomLeft, pyBottomLeft = 0, 0
	local twMiddleLeft, thMiddleLeft = 0, 0
	local twBottomLeft, thBottomLeft = 0, 0
		
	-- top (& bottom) part
	if borderSprites.topLeft ~= nil then
		pxTopLeft, pyTopLeft = _G.res.getSpritePivot(sheet, borderSprites.topLeft)
		twTopLeft, thTopLeft = _G.res.getSpriteBounds(sheet, borderSprites.topLeft)
	elseif borderSprites.bottomLeft ~= nil then
		pxTopLeft, pyTopLeft = _G.res.getSpritePivot(sheet, borderSprites.bottomLeft)
		twTopLeft, thTopLeft = _G.res.getSpriteBounds(sheet, borderSprites.bottomLeft)
		borderSprites.topLeft = ""
	else
		borderSprites.topLeft = ""
	end
	if borderSprites.topMiddle ~= nil then
		pxTopMiddle, pyTopMiddle = _G.res.getSpritePivot(sheet, borderSprites.topMiddle)
		twTopMiddle, thTopMiddle = _G.res.getSpriteBounds(sheet, borderSprites.topMiddle)
	elseif borderSprites.bottomMiddle ~= nil then
		pxTopMiddle, pyTopMiddle = _G.res.getSpritePivot(sheet, borderSprites.bottomMiddle)
		twTopMiddle, thTopMiddle = _G.res.getSpriteBounds(sheet, borderSprites.bottomMiddle)
		borderSprites.topMiddle = ""
	else
		borderSprites.topMiddle = ""
	end
	if borderSprites.topRight ~= nil then
		pxTopRight,  pyTopRight  = _G.res.getSpritePivot(sheet, borderSprites.topRight)
		twTopRight,  thTopRight  = _G.res.getSpriteBounds(sheet, borderSprites.topRight)
	elseif borderSprites.bottomRight ~= nil then
		pxTopRight,  pyTopRight  = _G.res.getSpritePivot(sheet, borderSprites.bottomRight)
		twTopRight,  thTopRight  = _G.res.getSpriteBounds(sheet, borderSprites.bottomRight)
		borderSprites.topRight = ""
	else
		borderSprites.topRight = ""
	end
					
	local startXTopMiddle = x1 + twTopLeft - pxTopLeft + pxTopMiddle
	local stopXTopMiddle = x2 - pxTopRight - (twTopMiddle - pxTopMiddle)
	if stopXTopMiddle < startXTopMiddle then
		stopXTopMiddle = startXTopMiddle + 1
	end
	
	-- left (& right) part
	if borderSprites.topLeft ~= nil then
		pxTopLeft, pyTopLeft = _G.res.getSpritePivot(sheet, borderSprites.topLeft)
		twTopLeft, thTopLeft = _G.res.getSpriteBounds(sheet, borderSprites.topLeft)
	elseif borderSprites.topRight ~= nil then 
		pxTopLeft, pyTopLeft = _G.res.getSpritePivot(sheet, borderSprites.topRight)
		twTopLeft, thTopLeft = _G.res.getSpriteBounds(sheet, borderSprites.topRight)
		borderSprites.topLeft = ""
	else
		borderSprites.topLeft = ""
	end
	if borderSprites.left ~= nil then
		pxMiddleLeft, pyMiddleLeft = _G.res.getSpritePivot(sheet, borderSprites.left)
		twMiddleLeft, thMiddleLeft = _G.res.getSpriteBounds(sheet, borderSprites.left)
	elseif borderSprites.right ~= nil then 
		pxMiddleLeft, pyMiddleLeft = _G.res.getSpritePivot(sheet, borderSprites.right)
		twMiddleLeft, thMiddleLeft = _G.res.getSpriteBounds(sheet, borderSprites.right)
		borderSprites.left = ""
	else
		borderSprites.left = ""
	end
	if borderSprites.bottomLeft ~= nil then
		pxBottomLeft, pyBottomLeft  = _G.res.getSpritePivot(sheet, borderSprites.bottomLeft)
		twBottomLeft, thBottomLeft  = _G.res.getSpriteBounds(sheet, borderSprites.bottomLeft)
	elseif borderSprites.bottomRight ~= nil then
		pxBottomLeft, pyBottomLeft  = _G.res.getSpritePivot(sheet, borderSprites.bottomRight)
		twBottomLeft, thBottomLeft  = _G.res.getSpriteBounds(sheet, borderSprites.bottomRight)
		borderSprites.bottomLeft = ""
	else
		borderSprites.bottomLeft = ""
	end
	
	if borderSprites.right == nil then
		borderSprites.right = ""
	end
	if borderSprites.bottomMiddle == nil then
		borderSprites.bottomMiddle = ""
	end
	if borderSprites.bottomRight == nil then
		borderSprites.bottomRight = ""
	end
	if borderSprites.center == nil then
		borderSprites.center = ""
	end
	
	local startYMiddleLeft = y1 + thTopLeft - pyTopLeft + pyMiddleLeft 
	local stopYMiddleLeft = y2 - pyBottomLeft - ( thMiddleLeft - pyMiddleLeft)
	if stopYMiddleLeft < startYMiddleLeft then
		stopYMiddleLeft = startYMiddleLeft + 1
	end
	
	local correctedX1, correctedX2, xPivot, yPivot, horBorderOffset, verBorderOffset = 0, 0, 0, 0, 0, 0
	
	-- top (& bottom) middle sprite is drawn as many times as necessary to fill the gap between corners so the width of the box might increase
	local horDrawCount = _G.math.ceil(width / twTopMiddle)
	local offsetX = 0
	if horDrawCount ~= 0 and twTopMiddle ~= 0 then
		offsetX = (horDrawCount * twTopMiddle) - width
	end
	if hAnchor == "HCENTER" then
		correctedX1 = x1 - offsetX /2
		correctedX2 = x2 + offsetX / 2
		xPivot = -width / 2
		horBorderOffset = -offsetX / 2
	elseif hAnchor == "RIGHT" then
		correctedX1 = x1 - offsetX
		correctedX2 = x2 
		xPivot = -width
		horBorderOffset = -offsetX
	else -- left
		correctedX1 = x1
		correctedX2 = x2 + offsetX 
		xPivot = 0
	end
	
	-- left (& right) middle sprite is drawn as many times as necessary to fill the gap between corners so the height of the box might increase
	local verDrawCount = _G.math.ceil((y2 - y1) / thMiddleLeft)
	local offsetY = 0
	if verDrawCount ~= 0 and thMiddleLeft ~= 0 then
		offsetY = (verDrawCount * thMiddleLeft) - height
	end
	if vAnchor == "VCENTER" then
		correctedY1 = y1 - offsetY / 2
		correctedY2 = y2 + offsetY / 2
		yPivot = -height / 2
		verBorderOffset = -offsetY / 2
	elseif vAnchor == "BOTTOM" then
		correctedY1 = y1 - offsetY
		correctedY2 = y2 
		yPivot = -height
		verBorderOffset = -offsetY
	else -- top
		correctedY1 = y1
		correctedY2 = y2 + offsetY 
		yPivot = 0
	end
	for i = 0, (horDrawCount-1) * twTopMiddle, twTopMiddle do
		_G.res.drawSprite("", borderSprites.topMiddle, _G.math.floor(startXTopMiddle + i + horBorderOffset + xPivot), _G.math.floor(correctedY1 + yPivot))
		_G.res.drawSprite("", borderSprites.bottomMiddle, _G.math.floor(startXTopMiddle + i + horBorderOffset + xPivot) , _G.math.floor(correctedY2 + yPivot + 1))
	end
	for i = 0, (verDrawCount-1) * thMiddleLeft, thMiddleLeft do
		_G.res.drawSprite("", borderSprites.left, _G.math.floor(correctedX1 + xPivot), _G.math.floor(startYMiddleLeft + i + verBorderOffset + yPivot))
		_G.res.drawSprite("", borderSprites.right, _G.math.floor(correctedX2 + xPivot + 1), _G.math.floor(startYMiddleLeft + i + verBorderOffset + yPivot))
	end
	
	-- draw corners
	_G.res.drawSprite("", borderSprites.topLeft, _G.math.floor(correctedX1 + xPivot), _G.math.floor(correctedY1 + yPivot))
	_G.res.drawSprite("", borderSprites.topRight, _G.math.floor(correctedX2 + xPivot + 1), _G.math.floor(correctedY1 + yPivot))
	_G.res.drawSprite("", borderSprites.bottomLeft, _G.math.floor(correctedX1 + xPivot), _G.math.floor(correctedY2 + yPivot + 1))
	_G.res.drawSprite("", borderSprites.bottomRight, _G.math.floor(correctedX2 + xPivot + 1), _G.math.floor(correctedY2 + yPivot + 1))
	
	-- if color isn't defined then fill with center sprite
	if color ~= nil then
		drawRect(r, g, b, a, _G.math.floor(correctedX1 + xPivot), _G.math.floor(correctedY1 + yPivot), _G.math.floor(correctedX2 + xPivot), _G.math.floor(correctedY2 + yPivot), false)
	else
		_G.res.drawSprite("", borderSprites.center, _G.math.floor(correctedX1 + xPivot), _G.math.floor(correctedY1 + yPivot), "TOP", "LEFT", _G.math.floor(correctedX2 - correctedX1 + 1), _G.math.floor(correctedY2 - correctedY1 + 1))
	end
	
	local correctedWidth = correctedX2 - correctedX1 + 1
	local correctedHeight = correctedY2 - correctedY1 + 1
	return _G.math.floor(correctedX1), _G.math.floor(correctedY1), _G.math.floor(correctedWidth), _G.math.floor(correctedHeight)
end

function drawBox( borderSprites, sheet, x1, y1, width, height, hAnchor, vAnchor, color)
	
	local boxSprites = borderSprites
	local r, g, b, a = 1.0, 1.0, 1.0, 1.0
	if color ~= nil then
		if color.red ~= nil then
			r = color.red
		end
		if color.green ~= nil then
			g = color.green
		end
		if color.blue ~= nil then
			b = color.blue
		end
		if color.alpha ~= nil then
			a = color.alpha
		end
	end

	local x2 = x1 + width - 1
	local y2 = y1 + height - 1
	
	local pxTopLeft,   pyTopLeft   = 0, 0
	local pxTopMiddle, pyTopMiddle = 0, 0
	local pxTopRight,  pyTopRight  = 0, 0
	local twTopLeft,   thTopLeft   = 0, 0
	local twTopMiddle, thTopMiddle = 0, 0
	local twTopRight,  thTopRight  = 0, 0
	
	local pxMiddleLeft,  pyMiddleLeft = 0, 0
	local pxMiddleRight, pyMiddleRight = 0, 0
	local twMiddleLeft,  thMiddleLeft = 0, 0
	local twMiddleRight, thMiddleRight = 0, 0
	
	local pxBottomLeft,   pyBottomLeft = 0, 0
	local pxBottomMiddle, pyBottomMiddle = 0, 0
	local pxBottomRight,  pyBottomRight = 0, 0
	local twBottomLeft,   thBottomLeft = 0, 0
	local twBottomMiddle, thBottomMiddle = 0, 0
	local twBottomRight,  thBottomRight = 0, 0
		
	if boxSprites.topLeft ~= nil then
		pxTopLeft, pyTopLeft = _G.res.getSpritePivot(sheet, boxSprites.topLeft)
		twTopLeft, thTopLeft = _G.res.getSpriteBounds(sheet, boxSprites.topLeft)
	else
		boxSprites.topLeft = ""
	end
	
	if boxSprites.topMiddle ~= nil then
		pxTopMiddle, pyTopMiddle = _G.res.getSpritePivot(sheet, boxSprites.topMiddle)
		twTopMiddle, thTopMiddle = _G.res.getSpriteBounds(sheet, boxSprites.topMiddle)
	else
		boxSprites.topMiddle = ""
	end
	
	if boxSprites.topRight ~= nil then
		pxTopRight,  pyTopRight  = _G.res.getSpritePivot(sheet, boxSprites.topRight)
		twTopRight,  thTopRight  = _G.res.getSpriteBounds(sheet, boxSprites.topRight)
	else
		boxSprites.topRight = ""
	end
	
	if boxSprites.left ~= nil then
		pxMiddleLeft, pyMiddleLeft = _G.res.getSpritePivot(sheet, boxSprites.left)
		twMiddleLeft, thMiddleLeft = _G.res.getSpriteBounds(sheet, boxSprites.left)
	else
		boxSprites.left = ""
	end
	
	if boxSprites.right ~= nil then 
		pxMiddleRight, pyMiddleRight = _G.res.getSpritePivot(sheet, boxSprites.right)
		twMiddleRight, thMiddleRight = _G.res.getSpriteBounds(sheet, boxSprites.right)
	else
		boxSprites.right = ""
	end
	
	if boxSprites.bottomLeft ~= nil then
		pxBottomLeft, pyBottomLeft  = _G.res.getSpritePivot(sheet, boxSprites.bottomLeft)
		twBottomLeft, thBottomLeft  = _G.res.getSpriteBounds(sheet, boxSprites.bottomLeft)
	else
		boxSprites.bottomLeft = ""
	end
	
	if boxSprites.bottomMiddle ~= nil then
		pxBottomMiddle, pyBottomMiddle = _G.res.getSpritePivot(sheet, boxSprites.bottomMiddle)
		twBottomMiddle, thBottomMiddle = _G.res.getSpriteBounds(sheet, boxSprites.bottomMiddle)
	else
		boxSprites.bottomMiddle = ""
	end
	
	if boxSprites.bottomRight ~= nil then
		pxBottomRight,  pyBottomRight  = _G.res.getSpritePivot(sheet, boxSprites.bottomRight)
		twBottomRight,  thBottomRight  = _G.res.getSpriteBounds(sheet, boxSprites.bottomRight)
	else
		boxSprites.bottomRight = ""
	end

	if boxSprites.center == nil then
		boxSprites.center = ""
	end
	
	local startXTopMiddle = x1 + twTopLeft - pxTopLeft
	local stopXTopMiddle = x2 - pxTopRight
	local y1Top = y1 - pyTopMiddle
	if stopXTopMiddle < startXTopMiddle then
		stopXTopMiddle = startXTopMiddle 
	end
	
	local startXBottomMiddle = x1 + twBottomLeft - pxBottomLeft
	local stopXBottomMiddle = x2 - pxBottomRight
	local y1Bottom = y2 - pyBottomMiddle
	if stopXBottomMiddle < startXBottomMiddle then
		stopXBottomMiddle = startXBottomMiddle 
	end
	
	local startYMiddleLeft = y1 + thTopLeft - pyTopLeft
	local stopYMiddleLeft = y2 - pyBottomLeft
	local x1Left = x1 - pxMiddleLeft
	if stopYMiddleLeft < startYMiddleLeft then
		stopYMiddleLeft = startYMiddleLeft 
	end
	
	local startYMiddleRight = y1 + thTopRight - pyTopRight
	local stopYMiddleRight = y2 - pyBottomRight
	local x1Right = x2 - pxMiddleRight
	if stopYMiddleRight < startYMiddleRight then
		stopYMiddleRight = startYMiddleRight 
	end
	
	local xPivot, yPivot = 0, 0
	
	if hAnchor == "HCENTER" then
		xPivot = -width / 2
	elseif hAnchor == "RIGHT" then
		xPivot = -width
	else -- left
		xPivot = 0
	end
	if vAnchor == "VCENTER" then
		yPivot = -height / 2
	elseif vAnchor == "BOTTOM" then
		yPivot = -height
	else -- top
		yPivot = 0
	end
		
	-- draw borders
	_G.res.drawSprite("", boxSprites.topMiddle, _G.math.floor(startXTopMiddle + xPivot) , _G.math.floor(y1Top + yPivot) , "TOP", "LEFT", _G.math.floor(stopXTopMiddle - startXTopMiddle), _G.math.floor(thTopMiddle))
	_G.res.drawSprite("", boxSprites.bottomMiddle, _G.math.floor(startXBottomMiddle + xPivot) , _G.math.floor(y1Bottom + yPivot), "TOP", "LEFT", _G.math.floor(stopXBottomMiddle - startXBottomMiddle), _G.math.floor(thBottomMiddle))
	_G.res.drawSprite("", boxSprites.left, _G.math.floor(x1Left + xPivot) , _G.math.floor(startYMiddleLeft + yPivot) , "TOP", "LEFT", _G.math.floor(twMiddleLeft), _G.math.floor(stopYMiddleLeft - startYMiddleLeft))
	_G.res.drawSprite("", boxSprites.right, _G.math.floor(x1Right + xPivot), _G.math.floor(startYMiddleRight + yPivot) , "TOP", "LEFT", _G.math.floor(twMiddleRight), _G.math.floor(stopYMiddleRight - startYMiddleRight))
	
	-- draw corners
	_G.res.drawSprite("", boxSprites.topLeft, _G.math.floor(x1 + xPivot), _G.math.floor(y1 + yPivot))
	_G.res.drawSprite("", boxSprites.topRight, _G.math.floor(x2 + xPivot), _G.math.floor(y1 + yPivot))
	_G.res.drawSprite("", boxSprites.bottomLeft, _G.math.floor(x1 + xPivot), _G.math.floor(y2 + yPivot))
	_G.res.drawSprite("", boxSprites.bottomRight, _G.math.floor(x2 + xPivot), _G.math.floor(y2 + yPivot))
	
	-- if color isn't defined then fill with center sprite
	if color ~= nil then
		drawRect(r, g, b, a, _G.math.floor(x1 + xPivot), _G.math.floor(y1 + yPivot), _G.math.floor(x2 + xPivot), _G.math.floor(y2 + yPivot), false)
	else
		_G.res.drawSprite("", boxSprites.center, _G.math.floor(x1 + xPivot), _G.math.floor(y1 + yPivot), "TOP", "LEFT", _G.math.floor(width), _G.math.floor(height))
	end
end

function createPopupBoxSpriteTables()

	popupBoxSprites = { topLeft = "POPUP_TOP_LEFT", topMiddle = "POPUP_TOP_MIDDLE", topRight = "POPUP_TOP_RIGHT",
						left = "POPUP_LEFT", center = "POPUP_CENTER", right = "POPUP_RIGHT", 
     				    bottomLeft = "POPUP_BOTTOM_LEFT", bottomMiddle = "POPUP_BOTTOM_MIDDLE", bottomRight = "POPUP_BOTTOM_RIGHT" }
	completeBoxSprites = { topLeft = "COMPLETE_TOP_LEFT", topMiddle = "COMPLETE_TOP_MIDDLE", topRight = "COMPLETE_TOP_RIGHT",
						   left = "COMPLETE_LEFT", center = "COMPLETE_CENTER", right = "COMPLETE_RIGHT", 
							}
	whiteBoxSprites = { topLeft = "WHITE_TOP_LEFT", topMiddle = "WHITE_TOP_MIDDLE", topRight = "WHITE_TOP_RIGHT",
						   left = "WHITE_LEFT", center = "WHITE_CENTER", right = "WHITE_RIGHT", 
						   bottomLeft = "WHITE_BOTTOM_LEFT", bottomMiddle = "WHITE_BOTTOM_MIDDLE", bottomRight = "WHITE_BOTTOM_RIGHT",
						}
	tutorialBoxSprites = { topLeft = "TUTORIAL_TOP_LEFT", topMiddle = "TUTORIAL_TOP_MIDDLE", topRight = "TUTORIAL_TOP_RIGHT",
						   left = "TUTORIAL_LEFT", center = "TUTORIAL_CENTER", right = "TUTORIAL_RIGHT", 
						   bottomLeft = "TUTORIAL_BOTTOM_LEFT", bottomMiddle = "TUTORIAL_BOTTOM_MIDDLE", bottomRight = "TUTORIAL_BOTTOM_RIGHT",
						}
	achievementBoxSprites = {left = "ACHIEVEMENT_BG_LEFT", center = "ACHIEVEMENT_BG_MIDDLE", right = "ACHIEVEMENT_BG_RIGHT"}
end				

function calculatePlaytime()
	--playtimeCounter = playtimeCounter or 0
	if playtimeCounter == nil then
		playtimeCounter = 0
	end
	--print("playtimeCounter: " .. playtimeCounter .. "\n")
	
	if settings.playtime == nil then
		settings.playtime = playtimeCounter
	else
		settings.playtime = _G.string.format("%d", settings.playtime + playtimeCounter)
	end
	playtimeCounter = 0
end
		
function resetCameras()
-- resets camera for current screen resolution from original castle camera

	local ccd = objects.castleCameraData[deviceModel]
	if ccd.screenWidth == nil then
		ccd.screenWidth = 1680
	end
	if ccd.screenHeight == nil then
		ccd.screenHeight = 1050
	end

	local cameraAspectRation = ccd.screenWidth / ccd.screenHeight
	local currentAspectRation = screenWidth / screenHeight
	local tempCcd = {}
	if currentAspectRation >= cameraAspectRation then
		-- Current aspect ratio is wider than the one used to make the level, expand horizontally
		tempCcd.sx = originalCcd.sx * screenHeight / ccd.screenHeight
	else
		-- Current aspect ratio is narrower than the one used to make the level, expand vertically
		tempCcd.sx = originalCcd.sx * screenWidth / ccd.screenWidth
	end
	--worldScale = worldScale * (tempCcd.sx / ccd.sx)
	worldScale = animationWorldScale * (tempCcd.sx / ccd.sx)
	setWorldScale(worldScale)
	--print("resetCameras! worldScale: " .. worldScale .. ", screenWidth: " .. screenWidth .. "\n")
end

function roundNumber(number, decimalDigits) 	
	local t_shift = 10 ^ decimalDigits
	
	return (_G.math.floor( number*t_shift + 0.5 ) / t_shift)
end

function resolutionChanged(width, height)
	if currentGameMode == updateGame or currentGameMode == updateMenu and currentMenuPage == pausePage then
		local cameraFunctionTemp = cameraFunction
		local cameraAnimationSliderTemp = cameraAnimationSlider
		local cameraAnimationSliderTargetTemp = cameraAnimationSliderTarget
		local screenWidthTemp = screenWidth
		local screenHeightTemp = screenHeight
		
		local worldScaleTemp = worldScale
		local animationWorldScaleTemp = animationWorldScale
		worldScale = worldScaleTemp
		animationWorldScale = animationWorldScaleTemp
		setWorldScale(worldScale)
		
		screenWidth = width
		screenHeight = height
		
		-- Revert the scales back to original before doing update
		objects.castleCameraData[deviceModel].px = originalCcd.px
		objects.castleCameraData[deviceModel].py = originalCcd.py
		objects.castleCameraData[deviceModel].sx = originalCcd.sx
		objects.castleCameraData[deviceModel].sy = originalCcd.sy
		objects.castleCameraData[deviceModel].screenWidth = originalCcd.screenWidth
		objects.castleCameraData[deviceModel].screenHeight = originalCcd.screenHeight
			
		-- Revert the scales back to original before doing update
		objects.birdCameraData[deviceModel].px = originalBcd.px
		objects.birdCameraData[deviceModel].py = originalBcd.py
		objects.birdCameraData[deviceModel].sx = originalBcd.sx
		objects.birdCameraData[deviceModel].sy = originalBcd.sy
		objects.birdCameraData[deviceModel].screenWidth = originalBcd.screenWidth
		objects.birdCameraData[deviceModel].screenHeight = originalBcd.screenHeight	

		
		
		initCameras()
		cameraFunction = cameraFunctionTemp
		cameraAnimationSlider = cameraAnimationSliderTemp
		cameraAnimationSliderTarget = cameraAnimationSliderTargetTemp
		
		worldScale = worldScaleTemp
		animationWorldScale = animationWorldScaleTemp
		setWorldScale(worldScale)
		
		cameraFunction(0)
		
		screenWidth = screenWidthTemp
		screenHeight = screenHeightTemp	
	end
end

originalCcd = {}
originalBcd = {}

-- iphone4 needs to init cameras again after the level is loaded when the screen resolution is changed 
function initCameras()
	cameraFunction = levelStartCamera
		
	if objects.castleCameraData ~= nil then
		local cameraSelected = false
		
		-- Try loading cameras in priority order
		for i=1,#g_cameraProfileList do
			local cameraProfile = g_cameraProfileList[i]
			if objects.castleCameraData[cameraProfile] ~= nil then
				cameraSelected = true
				if cameraProfile ~= deviceModel then
					objects.castleCameraData[deviceModel] = {}
					objects.castleCameraData[deviceModel].px = objects.castleCameraData[cameraProfile].px
					objects.castleCameraData[deviceModel].py = objects.castleCameraData[cameraProfile].py
					objects.castleCameraData[deviceModel].sx = objects.castleCameraData[cameraProfile].sx
					objects.castleCameraData[deviceModel].sy = objects.castleCameraData[cameraProfile].sy
					objects.castleCameraData[deviceModel].screenWidth = objects.castleCameraData[cameraProfile].screenWidth
					objects.castleCameraData[deviceModel].screenHeight = objects.castleCameraData[cameraProfile].screenHeight
				end
				break
			end
		end
		
		if cameraSelected == false then
			if objects.castleCameraData.px ~= nil then
				-- If no camera data is found for any profile, use generic data
				objects.castleCameraData[deviceModel] = {}
				objects.castleCameraData[deviceModel].px = objects.castleCameraData.px
				objects.castleCameraData[deviceModel].py = objects.castleCameraData.py
				objects.castleCameraData[deviceModel].sx = objects.castleCameraData.sx
				objects.castleCameraData[deviceModel].sy = objects.castleCameraData.sy
				objects.castleCameraData[deviceModel].screenWidth = objects.castleCameraData.screenWidth
				objects.castleCameraData[deviceModel].screenHeight = objects.castleCameraData.screenHeight
			else
				-- If no generic data found, assume very old format
				objects.castleCameraData[deviceModel] = {}
				objects.castleCameraData[deviceModel].px = screen.x
				objects.castleCameraData[deviceModel].py = screen.y
				objects.castleCameraData[deviceModel].sx = 1
				objects.castleCameraData[deviceModel].sy = 1
				objects.castleCameraData[deviceModel].screenWidth = screenWidth
				objects.castleCameraData[deviceModel].screenHeight = screenHeight
			end
		end
		
		local ccd = objects.castleCameraData[deviceModel]
		
		if ccd.screenWidth == nil then
			ccd.screenWidth = 1680
		end
		if ccd.screenHeight == nil then
			ccd.screenHeight = 1050
		end

		originalCcd.px = ccd.px
		originalCcd.py = ccd.py
		originalCcd.sx = ccd.sx
		originalCcd.sy = ccd.sy
		originalCcd.screenWidth = ccd.screenWidth
		originalCcd.screenHeight = ccd.screenHeight		
		
		local cameraAspectRation = ccd.screenWidth / ccd.screenHeight
		local currentAspectRation = screenWidth / screenHeight
		
		if currentAspectRation >= cameraAspectRation then
			-- Current aspect ratio is wider than the one used to make the level, expand horizontally
			ccd.sx = ccd.sx * screenHeight / ccd.screenHeight
			ccd.sy = ccd.sy * screenHeight / ccd.screenHeight
		else
			-- Current aspect ratio is narrower than the one used to make the level, expand vertically
			ccd.sx = ccd.sx * screenWidth / ccd.screenWidth
			ccd.sy = ccd.sy * screenWidth / ccd.screenWidth
		end

		if objects.castleCameraData.version == nil then
			-- old version has the screen center position in wrong place
			worldScale = ccd.sx
			setWorldScale(worldScale)
			screen.left = ccd.px - screenWidth * 0.5
			screen.top = ccd.py - screenHeight * 0.5
			screen.right = screen.left + screenWidth / worldScale
			screen.bottom = screen.top + screenHeight / worldScale
			screen.x = (screen.right + screen.left) * 0.5
			screen.y = (screen.bottom + screen.top) * 0.5
			--print("CScreen: " .. screen.left .. ", " .. screen.top .. " - " .. screen.right .. ", " .. screen.bottom .. "\n")
			--print("CScreen: " .. screen.x .. ", " .. screen.y .. "\n")
			ccd.px = screen.x
			ccd.py = screen.y
			--updateScale()
		else
			worldScale = ccd.sx
			setWorldScale(worldScale)
			screen.x = ccd.px
			screen.y = ccd.py
			screen.left = screen.x - screenWidth * 0.5 / worldScale
			screen.top = screen.y - screenHeight * 0.5 / worldScale
			screen.right = screen.x + screenWidth * 0.5 / worldScale
			screen.bottom = screen.y + screenHeight * 0.5 / worldScale
			--updateScale()
		end
	else
		-- camera not defined set default camera
		objects.castleCameraData = {}
		objects.castleCameraData[deviceModel] = {}
		local ccd = objects.castleCameraData[deviceModel]
		ccd.sx = 1
		ccd.sy = 1
		ccd.px = screen.x
		ccd.py = screen.y
	end
	
	animationWorldScale = worldScale 
	
	local ccd = objects.castleCameraData[deviceModel]
	ccd.top = screen.top
	ccd.left = screen.left
	ccd.right = screen.right
	ccd.bottom = screen.bottom
	cameraAnimationSlider = 1
	cameraAnimationSliderTarget = 1
	defaultCamera()
	
	local wx1, _ = worldToPhysicsTransform(ccd.left, ccd.top)
	local wx2, _ = worldToPhysicsTransform(ccd.right, ccd.bottom)
	--setTheme(currentTheme)
	
	if objects.birdCameraData ~= nil then
	
		local cameraSelected = false
		-- Try loading cameras in priority order
		for i=1,#g_cameraProfileList do
			local cameraProfile = g_cameraProfileList[i]
			if objects.birdCameraData[cameraProfile] ~= nil then
				cameraSelected = true
				if cameraProfile ~= deviceModel then
					objects.birdCameraData[deviceModel] = {}
					objects.birdCameraData[deviceModel].px = objects.birdCameraData[cameraProfile].px
					objects.birdCameraData[deviceModel].py = objects.birdCameraData[cameraProfile].py
					objects.birdCameraData[deviceModel].sx = objects.birdCameraData[cameraProfile].sx
					objects.birdCameraData[deviceModel].sy = objects.birdCameraData[cameraProfile].sy
					objects.birdCameraData[deviceModel].screenWidth = objects.birdCameraData[cameraProfile].screenWidth
					objects.birdCameraData[deviceModel].screenHeight = objects.birdCameraData[cameraProfile].screenHeight
				end
				break
			end
		end
		
		if cameraSelected == false then
			if objects.birdCameraData.px ~= nil then
				-- If no camera data is found for any profile, use generic data
				objects.birdCameraData[deviceModel] = {}
				objects.birdCameraData[deviceModel].px = objects.birdCameraData.px
				objects.birdCameraData[deviceModel].py = objects.birdCameraData.py
				objects.birdCameraData[deviceModel].sx = objects.birdCameraData.sx
				objects.birdCameraData[deviceModel].sy = objects.birdCameraData.sy
				objects.birdCameraData[deviceModel].screenWidth = objects.birdCameraData.screenWidth
				objects.birdCameraData[deviceModel].screenHeight = objects.birdCameraData.screenHeight
			else
				-- If no generic data found, assume very old format
				objects.birdCameraData[deviceModel] = {}
				objects.birdCameraData[deviceModel].px = screen.x
				objects.birdCameraData[deviceModel].py = screen.y
				objects.birdCameraData[deviceModel].sx = 1
				objects.birdCameraData[deviceModel].sy = 1
				objects.birdCameraData[deviceModel].screenWidth = screenWidth
				objects.birdCameraData[deviceModel].screenHeight = screenHeight
			end
		end
		
		local bcd = objects.birdCameraData[deviceModel]
		
		if bcd.screenWidth == nil then
			bcd.screenWidth = 1680
		end
		if bcd.screenHeight == nil then
			bcd.screenHeight = 1050
		end

		originalBcd.px = bcd.px
		originalBcd.py = bcd.py
		originalBcd.sx = bcd.sx
		originalBcd.sy = bcd.sy
		originalBcd.screenWidth = bcd.screenWidth
		originalBcd.screenHeight = bcd.screenHeight
		
		
		local cameraAspectRation = bcd.screenWidth / bcd.screenHeight
		local currentAspectRation = screenWidth / screenHeight
		
		if currentAspectRation >= cameraAspectRation then
			-- Current aspect ratio is wider than the one used to make the level, expand horizontally
			bcd.sx = bcd.sx * screenHeight / bcd.screenHeight
			bcd.sy = bcd.sy * screenHeight / bcd.screenHeight
		else
			-- Current aspect ratio is narrower than the one used to make the level, expand vertically
			bcd.sx = bcd.sx * screenWidth / bcd.screenWidth
			bcd.sy = bcd.sy * screenWidth / bcd.screenWidth
		end
		
		if objects.birdCameraData.version == nil then
			-- old version has the screen center position in wrong place
			scale = bcd.sx
			bcd.left = bcd.px - screenWidth * 0.5
			bcd.top = bcd.py - screenHeight * 0.5
			bcd.right = screen.left + screenWidth / scale
			bcd.bottom = screen.top + screenHeight / scale
			bcd.px = (screen.right + screen.left) * 0.5
			bcd.py = (screen.bottom + screen.top) * 0.5
			--print("BScreen: " .. screen.left .. ", " .. screen.top .. " - " .. screen.right .. ", " .. screen.bottom .. "\n")
			--print("BScreen: " .. screen.x .. ", " .. screen.y .. "\n")
		else
			bcd.left = bcd.px - screenWidth * 0.5 / bcd.sx
			bcd.top = bcd.py - screenHeight * 0.5 / bcd.sy
			bcd.right = screen.left + screenWidth / bcd.sx
			bcd.bottom = screen.top + screenHeight / bcd.sy
		end
	else
		
		-- bird camera not defined
		objects.birdCameraData = {}
		objects.birdCameraData[deviceModel] = {}
		local bcd = objects.birdCameraData[deviceModel]
		bcd.sx = 1
		bcd.sy = 1
		bcd.px = screen.x
		bcd.py = screen.y
		bcd.left = bcd.px - screenWidth * 0.5
		bcd.top = bcd.py - screenHeight * 0.5
		bcd.right = screen.left + screenWidth * 0.5
		bcd.bottom = screen.top + screenHeight * 0.5
	end

	local bcd = objects.birdCameraData[deviceModel]
	ccd.screenWidth = screenWidth
	ccd.screenHeight = screenHeight
	bcd.screenWidth = screenWidth
	bcd.screenHeight = screenHeight
		
	leftLimit = bcd.left - screenWidth * 0.20
	rightLimit = ccd.right + screenWidth * 0.20
	
	local leftLimitPhysics, rightLimitPhysics = worldToPhysicsTransform(leftLimit, rightLimit)
	if rightLimitPhysics > levelRightEdge then
		levelRightEdge = rightLimitPhysics
	end
	if leftLimitPhysics < levelLeftEdge then
		levelLeftEdge = leftLimitPhysics
	end
	-- set level left and right limit, other values do not affect at the moment
	levelLimitMinX = levelLeftEdge - screenWidth*0.75*physicsScale
	levelLimitMaxX = levelRightEdge + screenWidth*0.75*physicsScale
	setLevelLimits(levelLimitMinX, -10000, levelLimitMaxX, 20)
	
	-- calculate minimum scale. ie the player can't see the world smaller than this size
	maxLevelWidth = rightLimit - leftLimit
	minWorldScale = screenWidth / maxLevelWidth
	groundLimit = bcd.bottom
	if groundLimit < ccd.bottom then
		groundLimit = ccd.bottom
	end
	groundLimit = screenHeight / (minWorldScale * 5)
	if levelRestartedFrom == nil or startedFromEditor == true then 
		currentZoomedScale = bcd.sx
		if currentZoomedScale < ccd.sx then
			currentZoomedScale = ccd.sx
		end
	end
end

--PC build related

function setLevelLoading(buttonAttributes)	

	-- setEditing(false)
	-- setPhysicsEnabled(false)
	-- currentLevelNumber = page.items[selectedMenuItem].levelIndex or currentLevelNumber
	-- currentThemeNumber = page.items[selectedMenuItem].themeIndex or currentThemeNumber
	-- currentPageNumber = page.pageNumber or currentPageNumber
	-- loading = true
	-- setGameMode(updateLoading)
	setGameMode(updateGame)
	
	currentLevelNumberInTheme = buttonAttributes.pageLevelIndex or currentLevelNumberInTheme
	currentWorldNumber = buttonAttributes.worldNumber or currentWorldNumber
	
	if buttonAttributes.restartLevel == nil then
		inExtraWorld = buttonAttributes.isExtraWorld or false
	end
	
	if inExtraWorld then -- if we're starting an extra level

		if buttonAttributes.restartLevel == nil then
			levelName = buttonAttributes.filename
			levelFolder = buttonAttributes.folder
			levelIndex = buttonAttributes.levelIndex
			if levelIndex < 10 then
				levelIndex = "0"..levelIndex
			else
				levelIndex = ""..levelIndex
			end
			numberOfAttemptsInLevel = 1
			--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
			logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]) 
		else
			-- level restarted
			settings.gameRestarted = settings.gameRestarted + 1
			--print("FlurryEventWithParam: Golden egg level restarted, Level, " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
			logFlurryEventWithParam("Golden egg level restarted", "Level", "" .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]) 
			numberOfAttemptsInLevel = numberOfAttemptsInLevel + 1
		end
		currentThemeNumber = 1
	else
		if buttonAttributes.restartLevel == nil then
			levelName = buttonAttributes.filename
			levelFolder = buttonAttributes.folder
			levelIndex =  buttonAttributes.levelIndex
			if levelIndex < 10 then
				levelIndex = "0"..levelIndex
			else
				levelIndex = ""..levelIndex
			end
			
			numberOfAttemptsInLevel = 1
			levelRestartedFlurryParams = {}
			levelRestartedFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
			levelRestartedFlurryParams["From"] = "levelselection menu"
			logFlurryEventWithParams("Level started", "levelRestartedFlurryParams") 
			--print("FlurryEventWithParam: Level started, Level, " .. currentWorldNumber .. "-" ..currentLevelNumberInTheme .. "\n")
		else
			-- level restarted
			settings.gameRestarted = settings.gameRestarted + 1
			
			levelRestartedFlurryParams = {}
			levelRestartedFlurryParams["Level"] = currentWorldNumber  .. "-" .. currentLevelNumberInTheme
			levelRestartedFlurryParams["Attempts"] = "" .. numberOfAttemptsInLevel
			levelRestartedFlurryParams["Birds used"] = "" .. birdsShot
			levelRestartedFlurryParams["Birds available"] = "" .. birdsCounter
			levelRestartedFlurryParams["From"] = "" .. levelRestartedFrom
			
			logFlurryEventWithParams("Level restarted", "levelRestartedFlurryParams")

			--print("FlurryEventWithParam: Level restarted, Level, " .. currentWorldNumber .. "-" ..currentLevelNumberInTheme .. "\n")
			numberOfAttemptsInLevel = numberOfAttemptsInLevel + 1
		end
	end
	
	setEditing(false)
	setPhysicsEnabled(false)
	currentLevelNumber = buttonAttributes.levelIndex or currentLevelNumber
	currentThemeNumber = buttonAttributes.themeIndex or currentThemeNumber
	currentPageNumber = buttonAttributes.page.pageNumber or currentPageNumber
	loading = true
	setGameMode(updateLoading)
end

function loadLevelFromLevelSelection(buttonAttributes)
	
	-- if true then setLevelLoading(buttonAttributes) return end
	
	if deviceModel == "windows" and g_registrationEnabled == true then
		-- t_timeLimit = 5
		
		if g_isGameUnlocked then			
			setLevelLoading(buttonAttributes)
		else
			-- g_registrationPage:open()
			--we must switch to windowed mode before opening the dialog
			g_isFullScreenBeforeOpeningRegistration = settings.fullScreen
			if (g_isFullScreenBeforeOpeningRegistration == true) then
				g_updateCount = 0
				setFullScreenMode(false)				
			else
			
				local t_returnedKey = openRegistrationDialog("Activate the full game!", g_registrationURLs.validationURL, g_registrationURLs.registrationURL, g_registrationKeys.fullGame)
				
				if t_returnedKey ~= "" then
					g_isGameUnlocked = true
					_G.table.insert(settings.license.registeredKeyTypes, g_registrationKeys.fullGame)
				
					settings.license.hardwareID = getDeviceID()
					
					local t_button = getItemByName(mainMenu.items, "buttonActivateFullVersion")	
					t_button.visible = (g_isGameUnlocked == false)
					
					-- setLevelLoading(buttonAttributes)
				end
			
			end
			
		end
	else
		setLevelLoading(buttonAttributes)
	end	
end

function updateAvailable(isUpdateAvailable)
	g_updateCheckFlags.updateAvailable = isUpdateAvailable
end

function showUpdateNotificationPrompt()
	settings.updateNotification.updateNotified = true
	setActivePopupPage(g_updateNotificationScreen)
end

function updateNotificationCancel()
	-- settings.updateNotification.updateNotified = true
	
	setGameMode(updateMenu)
	popupPage = nil
	setActiveMenuPage(mainMenu)
	drawMenu()
	
	prepareMenuPage(mainMenu)
end

function updateNotificationConfirm()
	
	settings.updateNotification = nil		
	callVersionUpdater()
	requestExit()
end

function requestActivation()
	g_isFullScreenBeforeOpeningRegistration = settings.fullScreen
	if (g_isFullScreenBeforeOpeningRegistration == true) then
		g_updateCount = 0
		setFullScreenMode(false)				
	else
	
		local t_returnedKey = openRegistrationDialog("Activate full game!",g_registrationURLs.validationURL, g_registrationURLs.registrationURL, g_registrationKeys.fullGame)
		
		if t_returnedKey ~= "" then
			g_isGameUnlocked = true
			
			_G.table.insert(settings.license.registeredKeyTypes, g_registrationKeys.fullGame)
				
			
			settings.license.hardwareID = getDeviceID()
			local t_button = getItemByName(mainMenu.items, "buttonActivateFullVersion")	
			t_button.visible = (g_isGameUnlocked == false)
		end
	
	end
end
