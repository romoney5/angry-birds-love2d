io.stdout:setvbuf('no') --forgot what this is
local scriptPath = "/scripts"
local audioPath = "/audio"
local levelPath = "/levels_dec"
local imagePath = "/images"
local this = ""

--build options
-- local releaseBuild,showEditor,cheatsEnabled,isPremium,isKorea,isSeasonsAvailable,applyChinaRestictions,gameVersionNumber,customerString,svnRevisionNumber
-- releaseBuild = true
-- showEditor = true
-- cheatsEnabled = true
-- isPremium = false
-- isKorea = false
-- isSeasonsAvailable = true
-- applyChinaRestictions = false
-- gameVersionNumber = "1.6.1"
-- customerString = "androidmarket"
-- svnRevisionNumber = "66278"

-- local deviceModel = "bada"

settings = {}
highscores = {}
local screenWidth = love.graphics.getWidth()
local screenHeight = love.graphics.getHeight()
local keyPressed = {}
local keyReleased = {}
local keyHold = {}
local doubleClickTimer = 0
local splashTimer
local assetLoadList = {}
local clippedText = {lines={},widestLine=1}
objects = {}
blockTable = {}
cursor = {x=0,y=0}

local drawxscale = 1
local drawyscale = 1
local drawangle = 0

local audios = {}
local cachedspshs = {} --spritesheets
local cachedimgs = {} --individual sprites
-- local cachedcsprs = {} --individual composprites
local cachedaudios = {}
local playingaudio = {}
local todraw = {}
_G.res = {}

local function extractAttributes(spriteTag)
    local name = spriteTag:match('name="(.-)"') or ""
    local x = tonumber(spriteTag:match('x="(.-)"')) or 0
    local y = tonumber(spriteTag:match('y="(.-)"')) or 0
    local width = tonumber(spriteTag:match('width="(.-)"')) or 0
    local height = tonumber(spriteTag:match('height="(.-)"')) or 0
    local pivotX = tonumber(spriteTag:match('pivotX="(.-)"')) or 0
    local pivotY = tonumber(spriteTag:match('pivotY="(.-)"')) or 0
    
    return { name = name, x = x, y = y, width = width, height = height, pivotX = pivotX, pivotY = pivotY }
end

--load all the spritesheets
for i,sprite in pairs(love.filesystem.getDirectoryItems(imagePath.."/img/spritesheets")) do
	cachedspshs[sprite] = love.graphics.newImage(imagePath.."/img/spritesheets/"..sprite)
end
--load all the individual sprites
for i,v in pairs(love.filesystem.getDirectoryItems(imagePath.."/img/spriteinfo")) do
	if not v:find("COMPOSPRITES") then
		local spritesheet = cachedspshs[v..".png"]
		if love.filesystem.getInfo(imagePath.."/img/spritesheets/"..v..".png") then--imagePath.."/img/spritesheets/"..v..".png")
	        local xml = love.filesystem.read(imagePath.."/img/spriteinfo/"..v)
	        
	        local sprites = {}

		    for spriteTag in xml:gmatch("<sprite.-/>") do
		        local sprite = extractAttributes(spriteTag)
		        table.insert(sprites, sprite)
		    end

	        -- Create quads for each sprite
	        for _, sprite in ipairs(sprites) do
	            local quad = {love.graphics.newQuad(sprite.x, sprite.y, sprite.width, sprite.height,spritesheet:getWidth(),spritesheet:getHeight()),sprite.width,sprite.height,spritesheet,sprite.pivotX,sprite.pivotY}--, spritesheetImage:getDimensions())
	            cachedimgs[sprite.name] = quad
	        end
		else
			print("WARNING: Spritesheet "..v..".png not found in the  folder")
		end
	else --this is a composprite
        -- local xml = love.filesystem.read(imagePath.."/img/spriteinfo/"..v)
        -- local csprite
        -- for line in xml:gmatch("[^\r\n]+") do
        -- 	if line:find("composprite name=") then --set the current composprite sheet
        -- 		csprite = line:match('name="(.-)"')
        -- 	elseif line:find("layer sprite=") then
        -- 		local spr = line:match('sprite="(.-)"')
        -- 		cachedcsprs[spr] = 
        -- 	end
        -- end
	end
	-- print(v)
	-- cachedimgs[sprite] = love.graphics.newImage(v)
end

--override run function to allow drawing in the update hook
function love.run()
	if love.load then love.load(love.arg.parseGameArguments(arg), arg) end

	-- We don't want the first frame's dt to include time taken by love.load.
	if love.timer then love.timer.step() end

	local dt = 0

	-- Main loop time.
	return function()
		-- Process events.
		if love.event then
			love.event.pump()
			for name, a,b,c,d,e,f in love.event.poll() do
				if name == "quit" then
					if not love.quit or not love.quit() then
						return a or 0
					end
				end
				love.handlers[name](a,b,c,d,e,f)
			end
		end

		-- Update dt, as we'll be passing it to update
		if love.timer then dt = love.timer.step() end

		if love.graphics and love.graphics.isActive() then
			love.graphics.origin()
			love.graphics.clear(love.graphics.getBackgroundColor())
		end

		-- Call update and draw
		if love.update then love.update(dt) end -- will pass 0 if love.timer is disabled

		if love.graphics and love.graphics.isActive() then
			if love.draw then love.draw() end

			love.graphics.present()
		end

		if love.timer then love.timer.sleep(0.001) end
	end
end


function loadLuaFileToObject(filename,currentscript,table)
    -- local data = 
    -- print(data)--     return data
    if table then
    	local lua = loadstring(love.filesystem.read(filename) or "")
    	setfenv(lua,table)
    	lua()
    else
		loadstring(love.filesystem.read(filename) or "")()
	end
end
-- _G.res.drawString("", fpsString, screenWidth*0.5, screenHeight, "BOTTOM", "HCENTER")
function _G.res.drawString(_, text, x, y, aligny, alignx)
	-- print(x,y)
	love.graphics.printf(text or "", x, y-100, love.graphics.getWidth(), "left", 0, 2)
end

function _G.res.createAudio(rpath,name)
	audios[name] = rpath
end

function _G.res.isAudioPlaying(audio)
	if audios[audio] then
		return playingaudio[audio]==true
	end
	return false
end

function _G.res.playAudio(audio, _number, _bool, _anothernumber) --look it's not like these are documented or something..
	if cachedaudios[audio] == 0 then return end
	
	if not cachedaudios[audio] then
		if not love.filesystem.getInfo(audios[audio]) then
			cachedaudios[audio] = 0
			love.window.showMessageBox("Angry Birds", "Audio "..audios[audio].." not found.")
			return
		end
		cachedaudios[audio] = love.audio.newSource(audios[audio], "stream")
	end
	playingaudio[audio] = true
	love.audio.stop(cachedaudios[audio])
	love.audio.play(cachedaudios[audio])
end

function _G.res.stopAudio(audio)
	playingaudio[audio] = false
	if not cachedaudios[audio] then
		cachedaudios[audio] = love.audio.newSource(audios[audio], "stream")
	end
	love.audio.stop(cachedaudios[audio])
end

function _G.res.stopAllAudio()
	playingaudio = {}
	love.audio.stop()
end

function _G.res.openURL(url)
	love.system.openURL(url)
end

function loadLocalizationFile(filePath) --load localization
    local localizationTable = {}

    -- Open the file
    local file = io.open(filePath, "r")
    if not file then
        error("Localization file not found: " .. filePath)
    end

    for line in file:lines() do
        line = line:match("^%s*(.-)%s*$")

        if line ~= "" and not line:match("^#") then
            local key, value = line:match("^(.+)%=(.+)$")

            if key and value then
                local category = "TEXTS_BASIC"
                local subkey = key
                if category and subkey then
                    localizationTable[category] = localizationTable[category] or {}
                    localizationTable[category][subkey] = value
                else
                    error("Invalid key format in localization file: " .. key)
                end
            end
        end
    end

    file:close()
    localizationData = localizationTable
end
-- Load the localization file
loadLocalizationFile("localization/english.txt")

function _G.res.getString(category, key) --return a string from localization
    if localizationData and localizationData[category] then
        return localizationData[category][key] or "Key not found"
    else
        return "Category not found"
    end
end
-- print(_G.res.getString("TEXTS_BASIC", "TEXT_SPLASH_LOADING_SPRITE"))

-- love.window.updateMode(love.graphics.getWidth(), love.graphics.getHeight(), {resizable=true})
love.window.updateMode(864, 480, {resizable=true})
love.window.setIcon(love.image.newImageData(imagePath.."/img/icon.png"))

function setTopLeft(num,cam) --wh
	return
end
function setWorldScale(num)
	return
end

function loadLevel(filename)
	-- print(#objects)
	print("Speeding off to level.. "..filename..".lua")
	objects = {} --juust in case
	-- loadLuaFileToObject(filename..".lua",this,objects)
	local level = loadstring(love.filesystem.read(filename..".lua"))
	setfenv(level, objects)
	level()
	-- print(#objects)
end

function requestExit()
	-- love.window.showMessageBox("Angry Birds", "Exiting..")
	love.event.quit()
end

function love.update(dt)
	-- loadstring(io.read())()

	screenWidth = love.graphics.getWidth()
	screenHeight = love.graphics.getHeight()
	love.window.setTitle("Angry Birds ("..screenWidth.."x"..screenHeight..")")

	cursor.x, cursor.y = love.mouse.getPosition()
	update(dt,dt)

	keyPressed = {}
	keyReleased = {}
	-- keyHold = {}
end
function love.keypressed(key)
	keyPressed[string.upper(key)] = true
	keyHold[string.upper(key)] = true
end
function love.keyreleased(key, scancode)
	keyReleased[string.upper(key)] = true
	keyHold[string.upper(key)] = false
end
function love.mousepressed(x, y, button, istouch, presses)
	if button == 1 then
		keyPressed["LBUTTON"] = true
		keyHold["LBUTTON"] = true
	elseif button == 2 then
	    keyPressed["RBUTTON"] = true
		keyHold["RBUTTON"] = true
	elseif button == 3 then
		keyPressed["MBUTTON"] = true
		keyHold["MBUTTON"] = true
	end
end
function love.mousereleased(x, y, button, istouch, presses)
	if button == 1 then
		keyReleased["LBUTTON"] = true
		keyHold["LBUTTON"] = false
	elseif button == 2 then
	    keyReleased["RBUTTON"] = true
		keyHold["RBUTTON"] = false
	elseif button == 3 then
		keyReleased["MBUTTON"] = true
		keyHold["MBUTTON"] = false
	end
end

-- function keyHold(key)
-- 	if key == "LBUTTON" then
-- 		return love.mouse.isDown(1)
-- 	elseif key == "RBUTTON" then
-- 	    return love.mouse.isDown(2)
-- 	elseif key == "MBUTTON" then
-- 		return love.mouse.isDown(3)
-- 	end
-- 	return love.keyboard.isDown(string.lower(key))
-- end

function _G.res.stopAudioOutput()
	return
end

function _G.res.startAudioOutput()
	return
end

function setMusicVolume(vol)
	love.audio.setVolume(vol)
end

function setEffectsVolume(vol)
	love.audio.setVolume(vol)
end

function _G.res.getTrackVolume(track)
	return love.audio.getVolume()
end

function clipText()
	return
end

function _G.res.getFontLeading()
	return 1
end

function _G.res.getStringWidth(text)
	return screenWidth*.75
end

function _G.res.getFontHeight()
	return 1
end

function setEditing(isediting)
	return
end

function setPhysicsEnabled()
	return
end

function requestAd()
	print("Ad requested")
end
function requestVideoAd()
	print("Video Ad requested")
end
function requestAndShowVideo()
	print("Video requested")
end

function drawBackgroundNative()
	return
end

function drawForegroundNative()
	return
end

function setTheme(theme)
	currentTheme = theme
end

function setGameOn(on) --supposed to enable/disable screensaver?
	return
end

function avoidCrystalBackgroundActivity()
	return
end

function _G.res.getSpriteBounds(string,sprite)
	if cachedimgs[sprite] and cachedimgs[sprite] ~= 0 then
		return cachedimgs[sprite][2]*displayScale,cachedimgs[sprite][3]*displayScale
	end
	return 0,0
end

function _G.res.getCompoSpriteBounds(string,composprite)
	return 0,0,0,0
end

function _G.res.getSpritePivot(sheet,sprite)
	if cachedimgs[sprite] and cachedimgs[sprite] ~= 0 then
		return cachedimgs[sprite][5]*displayScale,cachedimgs[sprite][6]*displayScale
	end
	return 0,0
end

function _G.res.drawSprite(string,sprite,x,y,ypivot,xpivot,iwidth,iheight) --,ypivot (TOP,BOTTOM),xpivot (LEFT,RIGHT),width,height
	if not cachedimgs[sprite] then
		if love.filesystem.getInfo(imagePath.."/img/"..sprite..".png") then
			print("Note: Creating image "..sprite.." from the img folder")
			cachedimgs[sprite] = love.graphics.newImage(imagePath.."/img/"..sprite..".png")
		else
			cachedimgs[sprite] = 0
			print("WARNING: Image "..sprite.." not found in the img folder")
		end
	end
	-- print(width)
	-- if width then
	-- 	print(drawyscale*(height or 1)*displayScale)
	-- end
	-- height = 1
	if cachedimgs[sprite] ~= 0 then
		-- table.insert(todraw, {cachedimgs[sprite],x,y,drawxscale,drawyscale})
		local image = cachedimgs[sprite]
		-- if drawangle ~= 0 then
		-- 	print(math.sin(drawangle)*image[3])
		-- end
		local xp = image[2]/2
		if xpivot == "LEFT" then xp = 0 end
		if xpivot == "RIGHT" then xp = image[2] end
		-- local xp2 = 0
		-- if xpivot == "LEFT" then xp2 = image[2]/2 end
		-- if xpivot == "RIGHT" then xp2 = image[2] end
		local yp = image[3]/2
		if ypivot == "TOP" then yp = 0 end
		if ypivot == "BOTTOM" then yp = image[3] end
		love.graphics.draw(image[4],image[1],x-image[5]*displayScale + image[2]/2*displayScale,y-image[6]*displayScale + image[3]/2*displayScale,
			drawangle,drawxscale*(iwidth and iwidth/image[2]/displayScale or 1)*displayScale,drawyscale*(iheight and iheight/image[3]/displayScale or 1)*displayScale, xp, yp)
	end
end
function setBGColor(r,g,b) --set the background color
	love.graphics.setBackgroundColor(r/255,g/255,b/255)
end
function setRenderState(_,_,xs,ys,angle)
	drawxscale = xs
	drawyscale = ys
	drawangle = angle or 0
end

function drawRect( xpos, ypos, _, _, _, _, xs, ys, _)
	return
end

function setPhysicsSimulationScale(scale)
	return
end

function createBox() --too many properties
	return
end

local function serializeTable(t, indent)
    local serialized = ""
    indent = indent or ""

    for key, value in pairs(t) do
        local formattedKey = tostring(key)
        if type(value) == "table" then
            serialized = serialized .. indent .. formattedKey .. " = {\n" .. serializeTable(value, indent .. "    ") .. indent .. "},\n"
        else
            local formattedValue = tostring(value)
            if type(value) == "string" then
                formattedValue = "\"" .. formattedValue .. "\""
            end
            serialized = serialized .. indent .. formattedKey .. " = " .. formattedValue .. ",\n"
        end
    end

    return serialized
end

function saveLuaFile(fileName, tableName, appData)
    local tableToSave = _G[tableName]
    
    if not tableToSave or type(tableToSave) ~= "table" then
        error("Table "..tableName.." does not exist")
    end

    local serializedData = tableName.." = {\n" .. serializeTable(tableToSave,"\t") .. "}"

    local file = io.open(fileName, "w")
    if not file then
        error("Could not open file: " .. fileName)
    end

    file:write(serializedData)
    file:close()
    print("Table "..tableName.." saved to "..fileName)
end

function checkForLuaFile(filename)
	return love.filesystem.getInfo(filename) ~= nil
end

function logFlurryEvent(text)
	print("Flurry event log: "..text)
end

function logFlurryEventWithParams(text, text2)
	print("Flurry event log with params: "..text..": "..text2)
end
-- function love.draw()
-- 	for i,v in pairs(todraw) do
-- 		-- love.graphics.draw(v[1],v[2]-(v[1]:getWidth()*.5),v[3]-(v[1]:getHeight()*.5),
-- 		-- 	0,v[4],v[5])
-- 		love.graphics.draw(v[1][4],v[1][1],v[2]-v[1][5],v[3]-v[1][6],
-- 			0,v[4],v[5])
-- 	end
-- 	todraw = {}
--    -- love.graphics.print("Hello World!", 400, 300)
-- end


-- load global options from separate file
loadLuaFileToObject(scriptPath .. "/options.lua", this)--, "options")
loadLuaFileToObject(scriptPath .. "/animations.lua", this)--, "animations")
loadLuaFileToObject(scriptPath .. "/particles.lua", this)--, "particles")
loadLuaFileToObject(scriptPath .. "/starLimits.lua", this)--, "starLimits")
loadLuaFileToObject(scriptPath .. "/blocks.lua", this, blockTable)
loadLuaFileToObject("settings.lua", this)--, "settings")

postHighscores = true
bingIsEnabled = false

if customerString == "hannspree" or customerString == "nook" or deviceModel == "bada" then
	isSeasonsAvailable = false
end

lockLevelsButtonVisible = false
releaseSplashes = false

--cheatsEnabled = true
--releaseBuild = false
--facebookTimeout = 0
--FACEBOOK_TIMEOUT = 10

-- Use this to visualize the camera system
showCameraDebugData = false

eagleLockedTime = 3600
iapInitTimeOut = 20


LP5_PAGE2_LOCKED = false
LP5_PAGE3_LOCKED = false

LP6_PAGE2_LOCKED = true
LP6_PAGE3_LOCKED = true


--[[
	["Cave Explorer"] = { id = "", icon = "ACIEVEMENT_CAVE_EXPLORER" },
	["Cave Conquer"] = { id = "", icon = "ACHIEVEMENT_CAVE_CONQUER" },
	["King of the Caves"] = { id = "", icon = "ACHIEVEMENT_KING_OF_THE_CAVES" },
	["Ultimate Bejeweler"] = { id = "", icon = "ACHIEVEMENT_ULTIMATE_BEJEWELER"},
	["Hard as a Rock"] = { id = "", icon = "ACHIEVEMENT_HARD_AS_A_ROCK" },

]]

--iapEnabled = false
--mightyEagleItemId = "com.rovio.hangingjack.feature1" -- CHANGE THIS IN RELEASE VERSION!

mightyEagleItemId = "com.clickgamer.angrybirds.mightyeagle2"
if deviceModel == "ipad" then
	mightyEagleItemId = "com.chillingo.angrybirdsipad.mightyeagle"
end

if deviceModel == "palm" or deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" or applyChinaRestictions then
	bingIsEnabled = false
end

if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" or deviceModel == "android" then
	webViewIsSupported = true
end
--webViewIsSupported = false

--if(releaseBuild ~= true) then
--end

-- All iOS devices here
iOS = false
if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
	iOS = true
end

-- This can be further extented later
mightyEagleSupported = iOS

if isLiteVersion then
	iapEnabled = false
end

if isPremium then
	settings.isPremium = true
end

if iapEnabled ~= true then
	settings.mightyEagleEnabled = nil
	settings.eagleUsedTime = nil
	settings.eaglesUsedIn = {}
end

if releaseBuild then
	showEditor = false
	postHighscores = true
	
	mightyEagleItemId = "com.clickgamer.angrybirds.mightyeagle2"
	if deviceModel == "ipad" then
		mightyEagleItemId = "com.chillingo.angrybirdsipad.mightyeagle"
	end
end

tapRadius = 15 * screenWidth/480

-- queue for achievements  to be unlocked
achievementUnlockQueue = {}

-- Filled from C++
--imagePath = "images"
--fontPath = "fonts"
--audioPath = "audio"
--localizationPath = "localization"
--levelPath = "levels"

-- Create urls
local variant = "full"
if isLiteVersion then
	variant = "lite"
end

if isHDVersion then
	variant = "HD"
end

local appStoreFullType = "originalfull"
local appStoreSeasonsFullType = "halloweenfull"

if customerString ~= "rovio" then
	appStoreFullType = appStoreFullType .."_" .. customerString
	appStoreSeasonsFullType = appStoreSeasonsFullType .."_" .. customerString
end

--APP_STORE_SEASONS_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=halloween&variant=" .. variant"
APP_STORE_FULL_VERSION_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=".. appStoreFullType .."&variant=" .. variant .."&customer=" ..customerString
APP_STORE_HALLOWEEN_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=".. appStoreSeasonsFullType .."&variant="  .. variant .."&customer=" ..customerString
NEWSLETTER_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=newsletter&variant=" .. variant .."&customer=" ..customerString
ANDROID_MARKET_FULL_VERSION_URL = "http://www.angrybirds.com/redirect.php?device=android&variant=litebeta2&type=originalfull&product=angrybirds"
REPORT_BUG_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&variant=litebeta2&type=reportbug&product=angrybirds"
ANGRY_BIRDS_TRAILER_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=trailer&variant=" .. variant .."&customer=" ..customerString
OVI_STORE_URL = "http://www.angrybirds.com/redirect.php?device=N900&product=angrybirds&variant=" .. variant .."&customer=" ..customerString

--OVI_STORE_URL_S60 = "http://lr.ovi.mobi/store/10042237_AngryBirds" -- Redirect not allowed by Nokia
OVI_STORE_URL_S60 = "http://www.angrybirds.com/redirect.php?device=s60&variant=lite&type=originalfull&product=angrybirds&variant=" .. variant .."&customer=" ..customerString
OVI_STORE_MORE_GAMES_URL_S60 = "http://www.angrybirds.com/redirect.php?device=s60&variant=full&type=moregames&product=angrybirds&variant" .. variant .."&customer=" ..customerString
ROVIO_IN_OVI_STORE_URL = "http://store.ovi.com/publisher/RovioMobile/"
LP1_IN_OVI_STORE_URL = "http://www.angrybirds.com/redirect.php?device=N900&type=lp1&product=angrybirds&variant=" .. variant .."&customer=" ..customerString
LP2_IN_OVI_STORE_URL = "http://www.angrybirds.com/redirect.php?device=N900&type=lp2&product=angrybirds&variant=" .. variant .."&customer=" ..customerString
FACEBOOK_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=facebook&variant=" .. variant .."&customer=" ..customerString
TWITTER_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=twitterfollow&variant=" .. variant .."&customer=" ..customerString
MIGHTY_EAGLE_TRAILER = "http://www.angrybirds.com/redirect.php?type=trailer2&variant=" .. variant .."&customer=" ..customerString

ROVIO_UPDATE_URL_S60 = "http://www.angrybirds.com/redirect.php?device=s60&product=angrybirds&variant=full&type=checklatestfull&version="..gameVersionNumber.."&lang="

if applyChinaRestictions then
	ROVIO_UPDATE_URL_S60 = "http://www.angrybirds.com/redirect.php?device=s60&product=angrybirds&variant=full_china&type=checklatestfull&version="..gameVersionNumber.."&lang="
end

ABSHOP_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=shop&variant=" .. variant .."&customer=" ..customerString
APPLE_GIFT_PURCHASE_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=purchasegift"
LENOVO_NO_ADS_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=lenovonoads"
RIO_CONTEST_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .. "&product=angrybirds&type=riocontest"
PRIVACY_POLICY_URL = "http://www.rovio.com/index.php?page=privacy-policy"
EULA_URL = "http://www.rovio.com/eula/"
BING_SEARCH_URL = "http://www.bing.com/search/search.aspx?a=results&q="
AB_FBCONNECT_URL = "http://www.angrybirds.com/redirect.php?device=".. deviceModel .."&product=angrybirds&variant=full&version=".. gameVersionNumber .."&type=facebooklike"
ABLIKE_URL = "http://www.angrybirds.com/redirect.php?device=" .. deviceModel .."&product=angrybirds&variant=".. variant .."&version=".. gameVersionNumber .."&type=ablike"

uniqueDeviceId = uniqueDeviceId or "none"
--print("gamelogic.lua:createStartUpAssets(): uniqueDeviceId: ".. uniqueDeviceId)

if not releaseBuild then
	ROVIO_NEWS_URL = "http://dev.angrybirds.com/card/news-dyn.php?device=" .. deviceModel .."&product=angrybirds&variant=".. variant .."&version=".. gameVersionNumber .."&screenWidth=".. screenWidth .."&screenHeight=".. screenHeight .."&id=".. uniqueDeviceId .."&customer="..customerString
else
	ROVIO_NEWS_URL = "http://rovio-news-app.angrybirdsgame.com/news/?device=" .. deviceModel .."&product=angrybirds&variant=".. variant .."&version=".. gameVersionNumber .."&screenWidth=".. screenWidth .."&screenHeight=".. screenHeight .."&id=".. uniqueDeviceId .."&customer="..customerString
end

function createStartUpAssets()
	if deviceModel == "iphone" then
		g_cameraProfileList = { deviceModel, "osx", "ipad", "iphone" }
	elseif deviceModel == "ipad" then
		g_cameraProfileList = { deviceModel, "iphone" }
	elseif deviceModel == "android" and isHDVersion then
		g_cameraProfileList = { deviceModel, "ipad", "iphone" }
	else
		g_cameraProfileList = { deviceModel, "iphone" }
	end
	
	
	
	--urls were here
	
	_G.res.createTextGroupSet(localizationPath .. "/TEXTS_BASIC.dat")
	loadImages( { "SPLASHES" } )
	
	-- if we want to play audio during the startup scene
	_G.res.createAudioOutput(1, 16, 16000)
end

function selectAssetProfile(group)
	-- Default profile is iPhone because it's probably the most up to date
	local profileName = "480x320"
	
	if deviceModel == "iphone" then
		profileName = "480x320"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "iphone4" then
		--profileName = "960x640"
		profileName = "480x320"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "ipad" then
		profileName = "1024x768"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "n900" then
		profileName = "864x480"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "bada" then
		profileName = "864x480"
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "s60" then
		if isKorea then
			if group == "SPLASHES" then
				profileName = "640x360_korea"
			else
				profileName = "640x360"
			end
		elseif applyChinaRestictions then
			if group == "CHINA" then
				profileName = "640x360_china"
			else
				profileName = "640x360"
			end
		else
			profileName = "640x360"
		end
		
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end
		
	elseif deviceModel == "windows" then
		--[[local i, j = _G.string.find(imagePath, "/")
		profileName = _G.string.sub(imagePath, i+1, _G.string.len(imagePath))
		if isLiteVersion then
			profileName = profileName .. "_lite"
		end]]
		profileName = ""
		
	elseif deviceModel == "palm" then
		-- Palm HD
		
		if screenWidth >= 1024 then
			profileName = "1024x768_palmhd"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
	
		-- Palm mobile phones
		elseif (group == "MENU" or group == "TUTORIALS_COMPOSPRITES") and screenWidth < 800 then
			profileName = "400x320_palm_partial"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
		else profileName = "864x480"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
		end		
		--profileName = "1024x768_palmhd"
		
		
		
		
		
		
		
	--[[
	elseif deviceModel == "palm" then
		-- Palm Tablet
		if screenWidth > 480 then
			profileName = "1024x768"
		-- Palm Pre
		elseif screenWidth == 480 then
			profileName = "480x320"
			if isLiteVersion then
				profileName = profileName .. "_lite_palm"
			end
			
		-- Palm Pixi
		else
			profileName = "400x320"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
		end]]
		
	elseif deviceModel == "android" then
		if isHDVersion then
			profileName = "1280x800"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
		elseif (group == "MENU" or group == "TUTORIALS_COMPOSPRITES") and screenHeight < 320 then
			profileName = "320x240_android_partial"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
		elseif (group == "MENU" or group == "TUTORIALS_COMPOSPRITES") and screenHeight < 480 then
			profileName = "480x320_android_partial"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
		else
			profileName = "864x480"

			
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
			if isBetaVersion then
				profileName = profileName .. "_beta"
			end
			
		end
	end
	
	return profileName
end

function selectFontProfile()
	-- Default profile is iPhone because it's probably the most up to date
	local profileName = "480x320"
	
	if deviceModel == "iphone" or deviceModel == "iphone4" then
		profileName = "480x320"
	
	elseif deviceModel == "palm" then
		if screenWidth >= 1024 then -- webos/palm/hp tablets
			profileName = "1024x768_palmhd"
		elseif screenWidth < 800 then  -- webos/palm/hp mobile phones
			profileName = "400x320"
		else
			profileName = "864x480"
		end
	
	
--[[	
	elseif deviceModel == "palm" then
		if screenWidth > 480 then
			profileName = "1024x768"
		elseif screenWidth == 480 then
			profileName = "480x320"
			if isLiteVersion then
				profileName = profileName .. "_lite_palm"
			end
			
		-- Palm Pixi
		else
			profileName = "400x320"
			if isLiteVersion then
				profileName = profileName .. "_lite"
			end
		end]]
		
	elseif deviceModel == "ipad" then
		profileName = "1024x768"
		
	elseif deviceModel == "n900" then
		profileName = "864x480"
		
	elseif deviceModel == "bada" then
		profileName = "864x480"
		
	elseif deviceModel == "s60" then
		profileName = "640x360"
		
	elseif deviceModel == "windows" then
		profileName = ""
		
	elseif deviceModel == "android" then
		if screenHeight < 320 then
			profileName = "320x240"
		elseif screenHeight < 480 then
			profileName = "480x320"
		else
			profileName = "864x480"
		end
	end
	
	return profileName
end

--romoney5- these are commented, since they might not be needed in love
function loadImages(groups)

	-- for g = 1, #groups do
	-- 	local profileName = selectAssetProfile( groups[g] )
	-- 	if assetLoadList[profileName] ~= nil then
	-- 		local files = assetLoadList[profileName][groups[g]]
	-- 		if files ~= nil then
	-- 			for i=1, #files do
	-- 				_G.res.createSpriteSheet(imagePath .. "/" .. profileName .. "/" .. files[i])
	-- 			end
	-- 		end
	-- 	end
	-- end
end

function loadCompoSprites(groups)
	-- for g = 1, #groups do
	-- 	local profileName = selectAssetProfile( groups[g] )
	-- 	if assetLoadList[profileName] ~= nil then
	-- 		local files = assetLoadList[profileName][groups[g]]
	-- 		if files ~= nil then
	-- 			for i=1, #files do
	-- 				_G.res.createCompoSpriteSet(imagePath .. "/" .. profileName .. "/" .. files[i])
	-- 			end
	-- 		end
	-- 	end
	-- end
end

function releaseImages(groups)

	-- for g = 1, #groups do
	-- 	local profileName = selectAssetProfile( groups[g] )
	-- 	if assetLoadList[profileName] ~= nil then
	-- 		local files = assetLoadList[profileName][groups[g]]
	-- 		if files ~= nil then
	-- 			for i=1, #files do
	-- 				_G.res.releaseSpriteSheet(imagePath .. "/" .. profileName .. "/" .. files[i])
	-- 			end
	-- 		end
	-- 	end
	-- end
end

function releaseCompoSprites(groups)
	-- for g = 1, #groups do
	-- 	local profileName = selectAssetProfile( groups[g] )
	-- 	if assetLoadList[profileName] ~= nil then
	-- 		local files = assetLoadList[profileName][groups[g]]
	-- 		if files ~= nil then
	-- 			for i=1, #files do
	-- 				_G.res.releaseCompoSpriteSet(imagePath .. "/" .. profileName .. "/" .. files[i])
	-- 			end
	-- 		end
	-- 	end
	-- end
end

function loadFonts()
	-- local profileName = selectFontProfile()
	
	-- fontBasic = _G.res.getString("TEXTS_BASIC", "FONT_BASIC")
	-- fontMenu = _G.res.getString("TEXTS_BASIC", "FONT_MENU")
	
	-- _G.res.createBitmapFont(fontPath .. "/" .. profileName .. "/" .. fontBasic .. ".dat")
	-- _G.res.createBitmapFont(fontPath .. "/" .. profileName .. "/" .. fontMenu .. ".dat")
	-- _G.res.createBitmapFont(fontPath .. "/" .. profileName .. "/FONT_SCORE.dat")
	-- _G.res.createBitmapFont(fontPath .. "/" .. profileName .. "/FONT_BIG_NUMBERS.dat")
	-- _G.res.createBitmapFont(fontPath .. "/" .. profileName .. "/FONT_LS_SMALL.dat")
	
	-- if gameCenterSupported then
	-- 	_G.res.createBitmapFont(fontPath .. "/" .. profileName .. "/FONT_GAMECENTER_BASIC.dat")
	-- 	_G.res.createBitmapFont(fontPath .. "/" .. profileName .. "/FONT_GAMECENTER_NUMBERS.dat")
	-- end
	
end


function changeLocale(locale)
	 print("LOCAL CHANGED TO "..locale.."\n")
	_G.res.loadLocale("TEXTS_BASIC", locale)
	_G.res.useLocale(locale)	
end

function loadAllThemeGraphics()
	-- for k,v in _G.pairs(blockTable.themes) do
	-- 	if(k ~= "settings") then
	-- 		loadImages({v.graphicSetName})
	-- 		loadCompoSprites({v.graphicSetName.."_COMPOSPRITES"})		
	-- 	end
		--[[
		if(k == name) then
			print(" ** loading theme graphics, name = "..name ) 
			print(" ** graphicSetName = "..(v.graphicSetName).."\n")
			--loadImages({v.imageSheet})		
			--loadImages({v.compoSprites})		
			--newSet = v.graphicSetName
		else	
			
			if(k ~= "settings" and v.graphicSetName ~= themeName and v.graphicSetName ~= oldGFXSet) then
				print(" - releasing theme graphics, name = "..k.."\n" ) 
				print(" - graphicSetName = "..(v.graphicSetName).."\n")			
				--loadImages({v.graphicSetName})
				--loadCompoSprites({v.graphicSetName.."_COMPOSPRITES"})
				releaseImages({v.graphicSetName})
				releaseImages({v.graphicSetName.."_COMPOSPRITES"})						
			end
		end]]
	-- end
end

--oldGFXSet = nil

function loadThemeGraphics(name)
	print (" ::  LoadThemeGraphics() \n")
	local themeName = nil
	for k,v in _G.pairs(blockTable.themes) do
		if(k == name) then
			themeName = v.graphicSetName			
			break
		end		
	end
	
	
	print(" -- THEME GRAPHICS SET NAME = "..themeName.."\n")
	local newSet = nil
	for k,v in _G.pairs(blockTable.themes) do
		if(k == name) then
			print(" ** loading theme graphics, name = "..name ) 
			print(" ** graphicSetName = "..(v.graphicSetName).."\n")
			--loadImages({v.imageSheet})		
			--loadImages({v.compoSprites})		
			loadImages({v.graphicSetName})
			loadCompoSprites({v.graphicSetName.."_COMPOSPRITES"})
			--newSet = v.graphicSetName
		else	
			
			if(k ~= "settings" and v.graphicSetName ~= themeName and v.graphicSetName ~= oldGFXSet) then
				print(" - releasing theme graphics, name = "..k.."\n" ) 
				print(" - graphicSetName = "..(v.graphicSetName).."\n")			
				--loadImages({v.graphicSetName})
				--loadCompoSprites({v.graphicSetName.."_COMPOSPRITES"})
				releaseImages({v.graphicSetName})
				releaseImages({v.graphicSetName.."_COMPOSPRITES"})						
			end
		end
	end
	
	--oldGFXSet = newSet 
	--[[
	for i = 1,17 do
		if(i ~= index) then
			--releaseImages({"THEME_"..i})
			--releaseCompoSprites({"THEME_"..i.."_COMPOSPRITES"})
		else
			loadImages({"THEME_"..index})
			loadCompoSprites({"THEME_"..index.."_COMPOSPRITES"})
		end
	
	end]]
end

function createAssets()

	-- uncomment for different language
	--_G.res.loadLocale("TEXTS_BASIC", "es_ES")
	--_G.res.useLocale("es_ES")	

		
	loadImages( { "INGAME", "OTHER", "ACHIEVEMENTS", "MENU" } )	
	loadBackgrounds()
	
--	for i = 1, 10 do
	--	loadImages({"THEME_"..i})
	--	loadCompoSprites({"THEME_"..i.."_COMPOSPRITES"})
	--end
	--settings.currentThemeIndex = settings.currentThemeIndex or 1
	
	--loadThemeGraphics(settings.currentThemeIndex)
	
	if applyChinaRestictions then
		loadImages({"CHINA"})
	end
	
	loadCompoSprites( { "TUTORIALS_COMPOSPRITES", "INGAME_COMPOSPRITES", "ROVIO_NEWS_COMPOSPRITES" } )
	loadFonts()
	
	defaultMenuFont = fontBasic
	setFont(defaultMenuFont)
	
	-- _G.res.createAudio(audioPath .. "/sfx/bad shot a1.wav", "bad shot a1")
	-- _G.res.createAudio(audioPath .. "/sfx/bad shot a2.wav", "bad shot a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a1.wav", "bird 01 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a2.wav", "bird 01 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a3.wav", "bird 01 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a4.wav", "bird 01 collision a4")
	
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a1_low.wav", "bird 01 collision a1_low")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a2_low.wav", "bird 01 collision a2_low")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a3_low.wav", "bird 01 collision a3_low")
	_G.res.createAudio(audioPath .. "/sfx/bird 01 collision a4_low.wav", "bird 01 collision a4_low")
	
	
	_G.res.createAudio(audioPath .. "/sfx/bird 01 flying.wav", "bird_01_flying")
	_G.res.createAudio(audioPath .. "/sfx/bigbrother_fly.wav", "big_brother_flying")
	_G.res.createAudio(audioPath .. "/sfx/bigbrother_awakens.wav", "big_brother_awakens")
	
	_G.res.createAudio(audioPath .. "/sfx/bird 01 select.wav", "bird_01_select")
	_G.res.createAudio(audioPath .. "/sfx/bigbrother_select.wav", "big_brother_select")
	--_G.res.createAudio(audioPath .. "/sfx/bird 01 unselect.wav", "bird_01_unselect")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a1.wav", "bird 02 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a2.wav", "bird 02 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a3.wav", "bird 02 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a4.wav", "bird 02 collision a4")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 collision a5.wav", "bird 02 collision a5")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 flying.wav", "bird_02_flying")
	_G.res.createAudio(audioPath .. "/sfx/bird 02 select.wav", "bird_02_select")
	--_G.res.createAudio(audioPath .. "/sfx/bird 02 unselect.wav", "bird_02_unselect")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a1.wav", "bird 03 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a2.wav", "bird 03 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a3.wav", "bird 03 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a4.wav", "bird 03 collision a4")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 collision a5.wav", "bird 03 collision a5")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 flying.wav", "bird_03_flying")
	_G.res.createAudio(audioPath .. "/sfx/bird 03 select.wav", "bird_03_select")
	--_G.res.createAudio(audioPath .. "/sfx/bird 03 unselect.wav", "bird_03_unselect")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 flying.wav", "bird_04_flying")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 select.wav", "bird_04_select")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 collision a1.wav", "bird 04 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 collision a2.wav", "bird 04 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 collision a3.wav", "bird 04 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 04 collision a4.wav", "bird 04 collision a4")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a1.wav", "bird 05 collision a1")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a2.wav", "bird 05 collision a2")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a3.wav", "bird 05 collision a3")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a4.wav", "bird 05 collision a4")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 collision a5.wav", "bird 05 collision a5")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 flying.wav", "bird_05_flying")
	_G.res.createAudio(audioPath .. "/sfx/bird 05 select.wav", "bird_05_select")
	_G.res.createAudio(audioPath .. "/sfx/bird_06_flying.wav", "bird_06_flying")
	_G.res.createAudio(audioPath .. "/sfx/boomerang_select.wav", "boomerang_select")
	--_G.res.createAudio(audioPath .. "/sfx/bird 05 unselect.wav", "bird_05_unselect")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 06 flying.wav", "bird_06_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 07 flying.wav", "bird_07_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 08 flying.wav", "bird_08_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 09 flying.wav", "bird_09_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 10 flying.wav", "bird_10_flying")
	-- _G.res.createAudio(audioPath .. "/sfx/bird 11 flying.wav", "bird_11_flying")

	_G.res.createAudio(audioPath .. "/sfx/bird misc a1.wav", "bird_misc_a1")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a2.wav", "bird_misc_a2")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a3.wav", "bird_misc_a3")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a4.wav", "bird_misc_a4")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a5.wav", "bird_misc_a5")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a6.wav", "bird_misc_a6")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a7.wav", "bird_misc_a7")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a8.wav", "bird_misc_a8")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a9.wav", "bird_misc_a9")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a10.wav", "bird_misc_a10")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a11.wav", "bird_misc_a11")
	_G.res.createAudio(audioPath .. "/sfx/bird misc a12.wav", "bird_misc_a12")

	_G.res.createAudio(audioPath .. "/sfx/bird destroyed.wav", "bird_destroyed")
	--_G.res.createAudio(audioPath .. "/sfx/bird flying generic loop 2.wav", "bird flying generic loop 2")
	--_G.res.createAudio(audioPath .. "/sfx/bird flying generic loop.wav", "bird flying generic loop")
	--_G.res.createAudio(audioPath .. "/sfx/bird next a1.wav", "bird next a1")
	--_G.res.createAudio(audioPath .. "/sfx/bird next a2.wav", "bird next a2")
	--_G.res.createAudio(audioPath .. "/sfx/bird next a3.wav", "bird next a3")
	_G.res.createAudio(audioPath .. "/sfx/bird next military a1.wav", "bird next military a1")
	_G.res.createAudio(audioPath .. "/sfx/bird next military a2.wav", "bird next military a2")
	_G.res.createAudio(audioPath .. "/sfx/bird next military a3.wav", "bird next military a3")
	--_G.res.createAudio(audioPath .. "/sfx/bird shot.wav", "bird_shot")
	-- _G.res.createAudio(audioPath .. "/sfx/good shot a1.wav", "good shot a1")
	-- _G.res.createAudio(audioPath .. "/sfx/good shot a2.wav", "good shot a2")
	-- _G.res.createAudio(audioPath .. "/sfx/good shot a3.wav", "good shot a3")
	_G.res.createAudio(audioPath .. "/sfx/bird shot-a1.wav", "bird shot a1")
	_G.res.createAudio(audioPath .. "/sfx/bird shot-a2.wav", "bird shot a2")
	_G.res.createAudio(audioPath .. "/sfx/bird shot-a3.wav", "bird shot a3")
	--_G.res.createAudio(audioPath .. "/sfx/level clear a1.wav", "level clear a1")
	--_G.res.createAudio(audioPath .. "/sfx/level clear a2.wav", "level clear a2")
	_G.res.createAudio(audioPath .. "/sfx/level clear military a1.mp3", "level clear military a1")
	_G.res.createAudio(audioPath .. "/sfx/level clear military a2.mp3", "level clear military a2")
	--_G.res.createAudio(audioPath .. "/sfx/level failed a1.wav", "level failed a1")
	--_G.res.createAudio(audioPath .. "/sfx/level failed a2.wav", "level failed a2")
	_G.res.createAudio(audioPath .. "/sfx/level failed piglets a1.mp3", "level failed piglets a1")
	_G.res.createAudio(audioPath .. "/sfx/level failed piglets a2.mp3", "level failed piglets a2")
	--_G.res.createAudio(audioPath .. "/sfx/level start a1.wav", "level start a1")
	--_G.res.createAudio(audioPath .. "/sfx/level start a2.wav", "level start a2")
	_G.res.createAudio(audioPath .. "/sfx/level start military a1.mp3", "level start military a1")
	_G.res.createAudio(audioPath .. "/sfx/level start military a2.mp3", "level start military a2")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a1.wav", "light collision a1")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a2.wav", "light collision a2")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a3.wav", "light collision a3")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a4.wav", "light collision a4")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a5.wav", "light collision a5")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a6.wav", "light collision a6")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a7.wav", "light collision a7")
	_G.res.createAudio(audioPath .. "/sfx/ice light collision a8.wav", "light collision a8")
	_G.res.createAudio(audioPath .. "/sfx/light damage a1.wav", "light damage a1")
	_G.res.createAudio(audioPath .. "/sfx/light damage a2.wav", "light damage a2")
	_G.res.createAudio(audioPath .. "/sfx/light damage a3.wav", "light damage a3")
	_G.res.createAudio(audioPath .. "/sfx/light destroyed a1.wav", "light destroyed a1")
	_G.res.createAudio(audioPath .. "/sfx/light destroyed a2.wav", "light destroyed a2")
	_G.res.createAudio(audioPath .. "/sfx/light destroyed a3.wav", "light destroyed a3")
	_G.res.createAudio(audioPath .. "/sfx/light rolling.wav", "light_rolling")
	_G.res.createAudio(audioPath .. "/sfx/menu back.wav", "menu_back")
	_G.res.createAudio(audioPath .. "/sfx/menu confirm.wav", "menu_confirm")
	_G.res.createAudio(audioPath .. "/sfx/menu select.wav", "menu_select") -- is this used anywhere?
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a1.wav", "piglette collision a1")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a2.wav", "piglette collision a2")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a3.wav", "piglette collision a3")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a4.wav", "piglette collision a4")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a5.wav", "piglette collision a5")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a6.wav", "piglette collision a6")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a7.wav", "piglette collision a7")
	_G.res.createAudio(audioPath .. "/sfx/piglette collision a8.wav", "piglette collision a8")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a1.wav", "piglette damage a1")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a2.wav", "piglette damage a2")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a3.wav", "piglette damage a3")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a4.wav", "piglette damage a4")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a5.wav", "piglette damage a5")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a6.wav", "piglette damage a6")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a7.wav", "piglette damage a7")
	_G.res.createAudio(audioPath .. "/sfx/piglette damage a8.wav", "piglette damage a8")
	_G.res.createAudio(audioPath .. "/sfx/piglette destroyed.wav", "piglette_destroyed")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a1.wav", "rock collision a1")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a2.wav", "rock collision a2")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a3.wav", "rock collision a3")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a4.wav", "rock collision a4")
	_G.res.createAudio(audioPath .. "/sfx/rock collision a5.wav", "rock collision a5")
	_G.res.createAudio(audioPath .. "/sfx/rock damage a1.wav", "rock damage a1")
	_G.res.createAudio(audioPath .. "/sfx/rock damage a2.wav", "rock damage a2")
	_G.res.createAudio(audioPath .. "/sfx/rock damage a3.wav", "rock damage a3")
	_G.res.createAudio(audioPath .. "/sfx/rock destroyed a1.wav", "rock destroyed a1")
	_G.res.createAudio(audioPath .. "/sfx/rock destroyed a2.wav", "rock destroyed a2")
	_G.res.createAudio(audioPath .. "/sfx/rock destroyed a3.wav", "rock destroyed a3")
	_G.res.createAudio(audioPath .. "/sfx/rock rolling.wav", "rock_rolling")
	_G.res.createAudio(audioPath .. "/sfx/special boost.wav", "special_boost")
	_G.res.createAudio(audioPath .. "/sfx/special egg explosion.wav", "special_explosion")
	_G.res.createAudio(audioPath .. "/sfx/special group.wav", "special_egg")
	_G.res.createAudio(audioPath .. "/sfx/special egg.wav", "special_group")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a1.wav", "wood collision a1")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a2.wav", "wood collision a2")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a3.wav", "wood collision a3")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a4.wav", "wood collision a4")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a5.wav", "wood collision a5")
	_G.res.createAudio(audioPath .. "/sfx/wood collision a6.wav", "wood collision a6")
	_G.res.createAudio(audioPath .. "/sfx/wood damage a1.wav", "wood damage a1")
	_G.res.createAudio(audioPath .. "/sfx/wood damage a2.wav", "wood damage a2")
	_G.res.createAudio(audioPath .. "/sfx/wood damage a3.wav", "wood damage a3")
	_G.res.createAudio(audioPath .. "/sfx/wood destroyed a1.wav", "wood destroyed a1")
	_G.res.createAudio(audioPath .. "/sfx/wood destroyed a2.wav", "wood destroyed a2")
	_G.res.createAudio(audioPath .. "/sfx/wood destroyed a3.wav", "wood destroyed a3")
	_G.res.createAudio(audioPath .. "/sfx/wood rolling.wav", "wood_rolling")
	_G.res.createAudio(audioPath .. "/sfx/balloon_pop.wav", "balloon_pop")
	
	-- new
	_G.res.createAudio(audioPath .. "/sfx/bird pushing egg out.wav", "bird_pushing_egg_out")
	--_G.res.createAudio(audioPath .. "/sfx/bird releaved.wav", "bird_releaved")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette sneezing.wav", "piglette_sneezing")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a1.wav", "piglette snoring a1")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a2.wav", "piglette snoring a2")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a3.wav", "piglette snoring a3")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a4.wav", "piglette snoring a4")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette snoring a5.wav", "piglette snoring a5")
	_G.res.createAudio(audioPath .. "/sfx/slingshot streched.wav", "slingshot_stretched")
	-- _G.res.createAudio(audioPath .. "/sfx/special tweat.wav", "special_tweat")
	_G.res.createAudio(audioPath .. "/sfx/tnt box explodes.wav", "tnt_explodes")
	_G.res.createAudio(audioPath .. "/sfx/boomerang_swish.wav", "boomerang_swish")
	_G.res.createAudio(audioPath .. "/sfx/boomerang_activate.wav", "boomerang_activate")
	_G.res.createAudio(audioPath .. "/sfx/trampoline.wav", "trampoline")
	
	_G.res.createAudio(audioPath .. "/sfx/redbird_yell01.wav", "red_special_1")
	_G.res.createAudio(audioPath .. "/sfx/redbird_yell02.wav", "red_special_2")
	_G.res.createAudio(audioPath .. "/sfx/redbird_yell03.wav", "red_special_3")
	
	--_G.res.createAudio(audioPath .. "/sfx/redbird_yell01_low.wav", "big_brother_special_1")
	--_G.res.createAudio(audioPath .. "/sfx/redbird_yell02_low.wav", "big_brother_special_2")
	--_G.res.createAudio(audioPath .. "/sfx/redbird_yell03_low.wav", "big_brother_special_3")
	_G.res.createAudio(audioPath .. "/sfx/bigbrother_yell.wav", "big_brother_special_1")
	
	
	_G.res.createAudio(audioPath .. "/sfx/mightyeagle.wav", "mighty_eagle_yell")
	
	_G.res.createAudio(audioPath .. "/sfx/sardine_can_shot.mp3", "sardine_can_shot")
	_G.res.createAudio(audioPath .. "/sfx/sardine_can_physics_a2.mp3", "sardine_can_physics_a2")
	_G.res.createAudio(audioPath .. "/sfx/mighty_eagle_bounce.mp3", "mighty_eagle_thump")
	_G.res.createAudio(audioPath .. "/sfx/mighty_eagle_fly.mp3", "mighty_eagle_fly")
	
		
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a1.wav", "piglette_a1")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a2.wav", "piglette_a2")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a3.wav", "piglette_a3")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a4.wav", "piglette_a4")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a5.wav", "piglette_a5")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette oink a6.wav", "piglette_a6")
	-- _G.res.createAudio(audioPath .. "/sfx/piglette oink a7.wav", "piglette_a7")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a8.wav", "piglette_a8")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a9.wav", "piglette_a9")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a10.wav", "piglette_a10")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a11.wav", "piglette_a11")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink a12.wav", "piglette_a12")
	_G.res.createAudio(audioPath .. "/sfx/star_collect.wav", "star_collect")
	_G.res.createAudio(audioPath .. "/sfx/button_radio.wav", "button_radio")
	_G.res.createAudio(audioPath .. "/sfx/goldenegg.wav", "goldenegg")
	_G.res.createAudio(audioPath .. "/sfx/piano-c.wav", "noteC")
	_G.res.createAudio(audioPath .. "/sfx/piano-cis.wav", "noteCis")
	_G.res.createAudio(audioPath .. "/sfx/piano-d.wav", "noteD")
	_G.res.createAudio(audioPath .. "/sfx/piano-dis.wav", "notedis")
	_G.res.createAudio(audioPath .. "/sfx/piano-e.wav", "noteE")
	_G.res.createAudio(audioPath .. "/sfx/piano-f.wav", "noteF")
	_G.res.createAudio(audioPath .. "/sfx/piano-fis.wav", "noteFis")
	_G.res.createAudio(audioPath .. "/sfx/piano-g.wav", "noteG")
	
	_G.res.createAudio(audioPath .. "/music/level_complete.mp3", "level_complete")
	_G.res.createAudio(audioPath .. "/music/game_complete.mp3", "game_complete")
	
	_G.res.createAudio(audioPath .. "/music/title_theme.mp3", "title_theme")
		
	_G.res.createAudio(audioPath .. "/music/ambient_white_dryforest.mp3", "ambient_theme1")
	_G.res.createAudio(audioPath .. "/music/ambient_green_jungleish.mp3", "ambient_theme2")
	_G.res.createAudio(audioPath .. "/music/ambient_red_savannah.mp3", "ambient_theme3")
	_G.res.createAudio(audioPath .. "/music/ambient_city.mp3", "ambient_theme7")
	_G.res.createAudio(audioPath .. "/music/birds_outro.mp3", "birds_outro")
	_G.res.createAudio(audioPath .. "/music/birds_intro.mp3", "birds_intro")
	_G.res.createAudio(audioPath .. "/music/birds_boss.mp3", "birds_boss")
	_G.res.createAudio(audioPath .. "/music/funky_theme.mp3", "funky_theme")
	_G.res.createAudio(audioPath .. "/sfx/piglette oink story.wav", "piglette_oink_story")
	_G.res.createAudio(audioPath .. "/sfx/ball_bounce.wav", "ball_bounce")
	
	_G.res.createAudio(audioPath .. "/music/ambient_construction.mp3", "construction_theme1")
	
	-- sequencer
	_G.res.createAudio(audioPath .. "/sfx/pig_bd.wav", "pig_bd")
	_G.res.createAudio(audioPath .. "/sfx/pig_snare_1.wav", "pig_snare_1")
	_G.res.createAudio(audioPath .. "/sfx/pig_snare_2.wav", "pig_snare_2")
	_G.res.createAudio(audioPath .. "/sfx/pig_snare_3.wav", "pig_snare_3")
	_G.res.createAudio(audioPath .. "/sfx/pig_snare_4.wav", "pig_snare_4")
	_G.res.createAudio(audioPath .. "/sfx/pig_hi-hat_1.wav", "pig_hi-hat_1")
	_G.res.createAudio(audioPath .. "/sfx/pig_hi-hat_2.wav", "pig_hi-hat_2")
	
	-- accordion
	_G.res.createAudio(audioPath .. "/sfx/cminor_left.wav", "cminor_left")
	_G.res.createAudio(audioPath .. "/sfx/dismajor_left.wav", "dismajor_left")
	_G.res.createAudio(audioPath .. "/sfx/fmajor_left.wav", "fmajor_left")
	_G.res.createAudio(audioPath .. "/sfx/gminor_left.wav", "gminor_left")
	_G.res.createAudio(audioPath .. "/sfx/bmajor_left.wav", "bmajor_left")
	
	_G.res.createAudio(audioPath .. "/sfx/cminor_right.wav", "cminor_right")
	_G.res.createAudio(audioPath .. "/sfx/dismajor_right.wav", "dismajor_right")
	_G.res.createAudio(audioPath .. "/sfx/fmajor_right.wav", "fmajor_right")
	_G.res.createAudio(audioPath .. "/sfx/gminor_right.wav", "gminor_right")
	_G.res.createAudio(audioPath .. "/sfx/bmajor_right.wav", "bmajor_right")
	
	_G.res.createAudio(audioPath .. "/sfx/accordion_empty_pull.wav", "empty_accordion_left")
	_G.res.createAudio(audioPath .. "/sfx/accordion_empty_push.wav", "empty_accordion_right")
	_G.res.createAudio(audioPath .. "/sfx/accordion_break.wav", "accordion_break")

	_G.res.createAudio(audioPath .. "/sfx/pig_singing_1.wav", "pig_singing_1")
	_G.res.createAudio(audioPath .. "/sfx/pig_singing_2.wav", "pig_singing_2")
	_G.res.createAudio(audioPath .. "/sfx/pig_singing_3.wav", "pig_singing_3")
	_G.res.createAudio(audioPath .. "/sfx/pig_singing_4.wav", "pig_singing_4")
	_G.res.createAudio(audioPath .. "/sfx/pig_singing_5.wav", "pig_singing_5")
	_G.res.createAudio(audioPath .. "/sfx/pig_singing_6.wav", "pig_singing_6")
	_G.res.createAudio(audioPath .. "/sfx/pig_singing_7.wav", "pig_singing_7")
	_G.res.createAudio(audioPath .. "/sfx/pig_singing_8.wav", "pig_singing_8")
	
	_G.res.createAudio(audioPath .. "/music/ab_cave_ambient.mp3", "ambient_cave")
	_G.res.createAudio(audioPath .. "/sfx/jewel_break_01.wav", "jewel_break_1")
	_G.res.createAudio(audioPath .. "/sfx/jewel_break_02.wav", "jewel_break_2")
	_G.res.createAudio(audioPath .. "/sfx/jewel_break_03.wav", "jewel_break_3")
	_G.res.createAudio(audioPath .. "/sfx/stalaktite_break_01.wav", "stalaktite_break_1")
	_G.res.createAudio(audioPath .. "/sfx/stalaktite_break_02.wav", "stalaktite_break_2")
	_G.res.createAudio(audioPath .. "/sfx/stalaktite_break_03.wav", "stalaktite_break_3")

	
	audioGroups = {
		--bad_shot = { "bad shot a1", "bad shot a2" },
		bird_01_collision = { "bird 01 collision a1", "bird 01 collision a2", "bird 01 collision a3", "bird 01 collision a4" },
		bird_02_collision = { "bird 02 collision a1", "bird 02 collision a2", "bird 02 collision a3", "bird 02 collision a4", "bird 02 collision a5" },
		bird_03_collision = { "bird 03 collision a1", "bird 03 collision a2", "bird 03 collision a3", "bird 03 collision a4", "bird 03 collision a5" },
		bird_04_collision = { "bird 04 collision a1", "bird 04 collision a2", "bird 04 collision a3", "bird 04 collision a4" },
		bird_05_collision = { "bird 05 collision a1", "bird 05 collision a2", "bird 05 collision a3", "bird 05 collision a4", "bird 05 collision a5" },
		big_brother_collision = { "bird 01 collision a1_low", "bird 01 collision a2_low", "bird 01 collision a3_low", "bird 01 collision a4_low" },
		bird_next = { "bird next a1", "bird next a2", "bird next a3" },
		bird_next_military = { "bird next military a1", "bird next military a2", "bird next military a3" },
		bird_shot = { "bird shot a1", "bird shot a2", "bird shot a3"},
		--good_shot = { "good shot a1", "good shot a2", "good shot a3"},
		--level_clear = { "level clear a1", "level clear a2" },
		level_clear_military = { "level clear military a1", "level clear military a2" },
		--level_failed = { "level failed a1", "level failed a2" },
		level_failed_piglets = { "level failed piglets a1", "level failed piglets a2" },
		--level_start = { "level start a1", "level start a2" },
		level_start_military = { "level start military a1", "level start military a2" },
		light_collision = { "light collision a1", "light collision a2", "light collision a3", "light collision a4", "light collision a5", "light collision a6", "light collision a7", "light collision a8" },
		light_damage = { "light damage a1", "light damage a2", "light damage a3" },
		light_destroyed = { "light destroyed a1", "light destroyed a2", "light destroyed a3" },
		piglette_collision = { "piglette collision a1", "piglette collision a2", "piglette collision a3", "piglette collision a4", "piglette collision a5", "piglette collision a6", "piglette collision a7", "piglette collision a8" },
		piglette_damage = { "piglette damage a1", "piglette damage a2", "piglette damage a3", "piglette damage a4", "piglette damage a5", "piglette damage a6", "piglette damage a7", "piglette damage a8" },
		rock_collision = { "rock collision a1", "rock collision a2", "rock collision a3", "rock collision a4", "rock collision a5" },
		rock_damage = { "rock damage a1", "rock damage a2", "rock damage a3" },
		rock_destroyed = { "rock destroyed a1", "rock destroyed a2", "rock destroyed a3" },
		wood_collision = { "wood collision a1", "wood collision a2", "wood collision a3", "wood collision a4", "wood collision a5", "wood collision a6" },
		wood_damage = { "wood damage a1", "wood damage a2", "wood damage a3" },
		wood_destroyed = { "wood destroyed a1", "wood destroyed a2", "wood destroyed a3" },
		bird_misc = { "bird_misc_a1", "bird_misc_a2", "bird_misc_a3", "bird_misc_a4", "bird_misc_a5", "bird_misc_a6", "bird_misc_a7", "bird_misc_a8", "bird_misc_a9", "bird_misc_a10", "bird_misc_a11", "bird_misc_a12" },
		--piglette_snoring = { "piglette snoring a1", "piglette snoring a2", "piglette snoring a3", "piglette snoring a4", "piglette snoring a5" },
		piglette = { "piglette_a1", "piglette_a2", "piglette_a3", "piglette_a4", "piglette_a5", "piglette_a8", "piglette_a9", "piglette_a10", "piglette_a11", "piglette_a12" },
		--, "piglette_a6", "piglette_a7"
		red_special = { "red_special_1", "red_special_2", "red_special_3" },
		--big_brother_special = { "big_brother_special_1", "big_brother_special_2", "big_brother_special_3" },
		big_brother_special = { "big_brother_special_1", },
		pig_accordion = {"pig_singing_1", "pig_singing_2", "pig_singing_3", "pig_singing_4", "pig_singing_5", "pig_singing_6", "pig_singing_7", "pig_singing_8" },
		stalaktite_break = {"stalaktite_break_1", "stalaktite_break_2", "stalaktite_break_3" },
		jewel_break = {"jewel_break_1", "jewel_break_2", "jewel_break_3" },
	}
	
	if settings.currentMainMenuSong then
		currentMainMenuSong = settings.currentMainMenuSong
	else
		currentMainMenuSong = "title_theme"
	end

	if settings.audioEnabled == false then
		_G.res.stopAudioOutput()
		setEffectsVolume(0)
		setMusicVolume(0)
	else
		_G.res.startAudioOutput()
		setEffectsVolume(1)
		setMusicVolume(1)
	end
	
	settings.currentMainMenuTheme = settings.currentMainMenuTheme or "theme1"
	--[[
	if(settings.currentMainMenuTheme ~= nil) then
		for k,v in _G.pairs(blockTable.themes) do
			if(k == settings.currentMainMenuTheme) then
				loadThemeGraphics(k)
				break
			end
		end
	end]]
	loadAllThemeGraphics()
	
	assetsCreated = true
end 

function saveLuaFileWrapper(fileName, tableName, appData)
	if isLiteVersion == true and deviceModel == "s60" then
		if tableName == "settings" then
			fileName = "settings_trial.lua"
		end
		
		if tableName == "highscores" then
			fileName = "highscores_trial.lua"
		end
	end
	
	saveLuaFile(fileName, tableName, appData)
end

function getAudioName(name)
	if audioGroups[name] ~= nil then
		local index = _G.math.random(1, #audioGroups[name])
		return audioGroups[name][index]
	end

	return name
end

--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Game main function, this is called every frame by the engine
--void GameLua::drawLine2D(float x0, float y0, float x1, float y1, float w, float r, float g, float b, float a)
-- XXX: ADD TO OTHERS
function drawLine(r,g,b,a,x1,y1,x2,y2,inWorld, lineSize)
	local lz = lineSize or 1
	
	if(inWorld == false) then
		setRenderState(0,0,1,1)
	end
	
		drawLine2D(x1,y1,x2,y2,lz,r,g,b,a)
end

-- XXX: ADD TO OTHERS
function drawString(text, scale,x,y, anchorX, anchorY, inWorld)
	local ax = anchorX or "HCENTER"
	local ay = anchorY or "VCENTER"
	
	--void GameLua::drawRect( float r, float g, float b, float a, float x1, float y1, float x2, float y2, bool inWorld)
	--drawRect(1.0,1.0,1.0,1.0, 0,screenHeight / 2 + 1, screenWidth, screenHeight / 2 , false)
	--drawLine(255,255,255,255,0,0, screenWidth, screenHeight, false, 12)
	setFont(fontBasic);
	--setRenderState(x * scale, y * scale, scale,scale)
	if(inWorld ~= true) then
		setRenderState(0, 0 , scale,scale)	
		_G.res.drawString("", text, x * ((screenWidth / scale) / screenWidth), y * ((screenHeight / scale) / screenHeight), ay, ax)
	else
		local xp,yp = worldToScreenTransform(x,y)
		scale = scale * worldScale
		setRenderState(0,0,scale,scale,0,0)	
		_G.res.drawString("", text, xp * ((screenWidth / scale) / screenWidth), yp * ((screenHeight / scale) / screenHeight), ay, ax)
	end
	setRenderState(0,0,1,1)
end

showFps = false

if not releaseBuild or cheatsEnabled then
	showFps = true
end

showBG = true
showSleepingObjects = false

fpsTimer = 0
fpsFrames = 0
fps = 0
zoomLevel = 0
-- XXX: ADD TO OTHERS
function initCollisionDummy(selectedObject)
	local name = selectedObject.name
	--local name = selectedObjects[1].name
	local selected = objects.world[name]
	local blockDef = blockTable.blocks[selected.definition]
	local dir = 1
			
	adjustedBlockDef = adjustedBlockDef or {}
	adjustedBlockDef.objectNames = adjustedBlockDef.objectNames or {}
						
	adjustedBlockDef.objectNames[name] = adjustedBlockDef.objectNames[name] or {}
			
			-- Initialize dummy
	if(adjustedBlockDef.objectNames[name].radius == nil and blockDef.radius) then
		adjustedBlockDef.objectNames[name].radius = blockDef.radius			
	end

	if(adjustedBlockDef.objectNames[name].spritePivotX == nil and blockDef.spritePivotX) then
		adjustedBlockDef.objectNames[name].spritePivotX = blockDef.spritePivotX			
	end

	if(adjustedBlockDef.objectNames[name].spritePivotY == nil and blockDef.spritePivotY) then
		adjustedBlockDef.objectNames[name].spritePivotY = blockDef.spritePivotY			
	end
			
				
	if(adjustedBlockDef.objectNames[name].width == nil and blockDef.width) then
		adjustedBlockDef.objectNames[name].width = blockDef.width			
	end

	if(adjustedBlockDef.objectNames[name].height == nil and blockDef.height) then
		adjustedBlockDef.objectNames[name].height = blockDef.height			
	end
			
	if(adjustedBlockDef.objectNames[name].vertices == nil and blockDef.vertices ~= nil) then
		--adjustedBlockDef.objectName.height = blockDef.height			
		adjustedBlockDef.objectNames[name].vertices = {}
		for k,v in _G.pairs(blockDef.vertices) do					
			_G.table.insert(adjustedBlockDef.objectNames[name].vertices, {x = v.x, y = v.y})
		end
	end
end


function update(dt, realDt)

	if(releaseSplashes == true and currentMenuPage == mainMenu) then
		releaseImages( {"SPLASHES"} )
		releaseSplashes = false
	end


	--[[
	if(isWebViewLoading) then		
		if(facebookTimeout > 0) then
			facebookTimeout = facebookTimeout - dt			
			if(facebookTimeout <= 0) then
				ABLikeView:delete()
				ABLikeView = nil
				facebookTimeout = 0
				isWebViewLoading = false
				ABLikeViewCreated = nil
				popupPage = nil
			end
		end		
	end]]
	--if keyPressed["G"] then
	--	printGlobals()
	--end
	
	-- if keyPressed["Q"] or keyPressed["0"] then
		-- requestExit()
		-- return
	-- end

	
	--[[
	if(levelOrder ~= nil) then

		for k,v in _G.pairs(levelOrder.episodes) do
			for kk,vv in _G.pairs(v) do
				--print("Looking for : "..vv.."\n")
				local feathers = calculateFeathers({levelOrder[vv]})
				if(feathers > 0) then
					--print("feathers at "..kk.." == "..feathers.."\n")				
				end
			end	
		end

	
	end]]
	-- if keyHold["E"] then
	-- 	_G.res.drawSprite("","SPLASH_ROVIO",cursor.x,cursor.y)
	-- end
	
	if(releaseBuild == false) then
		if(keyHold["CONTROL"]) then
			if(keyPressed["1"]) then
				changeLocale("en_EN")
			elseif(keyPressed["2"]) then
				changeLocale("fr_FR")
			elseif(keyPressed["3"]) then
				changeLocale("it_IT")
			elseif(keyPressed["4"]) then
				changeLocale("de_DE")
			elseif(keyPressed["5"]) then
				changeLocale("es_ES")
			elseif(keyPressed["6"]) then
				changeLocale("zh_CN")
			elseif(keyPressed["7"]) then
				changeLocale("zh_TW")
			elseif(keyPressed["8"]) then
				changeLocale("ja_JA")
			end
		end
	end	
	
	if (oldScreenWidth ~= screenWidth or oldScreenHeight ~= screenHeight) and deviceModel == "iphone4" then
		-- iphone4 changes screen resolution between 960x640 and 480x320 resolution so the cameras and floating scores scaling need to be reset after resolution change
		-- if objects.castleCameraData ~= nil and objects.castleCameraData[deviceModel] ~= nil then
		-- 	resetCameras()
		-- 	for i = 1, #floatingScores do
		-- 		floatingScores[i].xs = floatingScores[i].xs * ( screenWidth / oldScreenWidth)
		-- 	end
		-- end
		if popupPage ~= nil then
			if popupPage == achievementPopUpPage then
				-- reset the layout of gamecenter achievement popup except the animation
				local tempAnimationState = popupPage.animationState
				local tempAnimationTimer = popupPage.animationTimer
				prepareMenuPage(achievementPopUpPage)
				popupPage.animationState = tempAnimationState 
				popupPage.animationTimer = tempAnimationTimer 
			end
		end
	end

	if prepareMenusAfterAd == true then
		prepareMenusAfterAd = false
		if birdTutorialPopups ~= nil and #birdTutorialPopups > 0 then
			prepareMenuPage(tutorials)
		end
		if currentMenuPage ~= nil then
			prepareMenuPage(currentMenuPage)	
		end
		if popupPage ~= nil then
			prepareMenuPage(popupPage)
		end
	end

	if newMenuPageNeedsPrepare == true or currentMenuPage ~= newMenuPage then
		setActiveMenuPageDelayed(newMenuPage, newMenuPageNeedsPrepare, newMenuPageResumed)
		newMenuPageNeedsPrepare = nil
	end
	

	if loadLevelDelayed ~= nil then
		--loadLevelInternal(loadLevelDelayed)
		initCameras()
		loadLevelDelayed = nil
		setGameMode(updateGame)
		updateGame(dt)
		drawGame()
		if currentFrame == nil then
			showAdFrame = 10
		else
			showAdFrame = currentFrame + 10
		end
		--[[
		if videoReady then
			showVideoAd()
		else
			showAd()
		end
		]]
	end
	
	if additionalPopupPageDelay ~= true and newPopupPage ~= nil and popupPage ~= newPopupPage then
		popupPage = newPopupPage
		if popupPage == upsellPage then
			releaseCutScenes()
		end
		
		if newPopupPageNeedsPrepare ~= false then
			prepareMenuPage(popupPage)
			if popupPage == goldenEggAchievedPage then
				print("goldenEggAchievedPage prepared\n")
			end
		end
		print("popup delayed: "..popupPage.name)
		newPopupPageNeedsPrepare = nil
		newPopupPage = nil
	end
	
	if additionalPopupPageDelay == true then
		additionalPopupPageDelay = nil
	end

	-- Initialize current game mode to splash sequence
	currentGameMode = currentGameMode or updateSplashes

	-- Keep track of elapsed time
	time = time and time + dt or 0
	playtimeCounter = playtimeCounter and playtimeCounter + dt or 0
	if lastVideoAdTime == nil then
		lastVideoAdTime = time
	end
	
	-- iap init timer handling
	if iapInitTimer ~= nil then
		iapInitTimer = iapInitTimer - dt
		if iapInitTimer <= 0 then
			iapInitTimer = nil
			iapBuyItem(mightyEagleItemId, "inAppPurchaseBuyCallback")
		end
	end
	
	if settings.eagleUsedTime ~= nil then
		local timeLeft = eagleLockedTime - timeDiff(currentTime(), settings.eagleUsedTime)
		if timeLeft > 0 and timeLeft <= 5 and (eagleInfoTimer == nil or eagleInfoTimer < timeLeft) then
			eagleInfoTimer = timeLeft
		end
		if eagleInfoTimer ~= nil and (currentMenuPage == pausePage or currentMenuPage == levelFailed or currentGameMode == updateGame) then
			eagleInfoTimer = eagleInfoTimer - dt
			if levelFailed ~= nil and levelFailed.items ~= nil and currentMenuPage == levelFailed and 
			   getItemByName(levelFailed.items, "buttonEagleLost").visible == true then
				local eagleTimeLeft = getItemByName(levelFailed.items, "eagleTimeLeft")
				eagleTimeLeft.text = formatTime(timeLeft)
				prepareTextItem(levelFailed, eagleTimeLeft)
				eagleTimeLeft.visible = true
				if eagleInfoTimer < 0 or timeLeft < 1 then
					eagleTimeLeft.visible = false
					eagleInfoTimer = nil
				end
			elseif eagleInfoTimer < 0 then 
				eagleInfoTimer = nil
			end
		end
	end
	
	-- Check for double clicks
	doubleClick = false
	
	if doubleClickTimer == nil then
		doubleClickTimer = 0
	end
	
	-- hiding and requesting ads, animating scores
	if deviceModel == "android" or ((deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad") and isLiteVersion) then 
		local adDuration = 15
		local animationDuration = 0.7
		if isShowingAd == true and isHidingAd ~= true and 
			((time - lastAdTime > adDuration and (currentGameMode == updateGame or (currentGameMode == updateMenu and currentMenuPage ~= levelComplete and currentMenuPage ~= levelFailed))) or
			 (currentGameMode ~= updateGame and currentMenuPage ~= levelComplete and currentMenuPage ~= levelFailed and currentMenuPage ~= pausePage)) then
			adHidingStartedTime = time
			hideAd()
		end
		
		if isHidingAd == true and isShowingAd == true and adHidingStartedTime ~= nil then
			scoreAdOffsetY = bannerHeight - (bannerHeight * (time - adHidingStartedTime) / animationDuration)
		elseif isHidingAd ~= true and isShowingAd == true then
			scoreAdOffsetY = bannerHeight * (_G.math.min(time - adShowingStartedTime, animationDuration) / animationDuration)
		elseif isShowingAd ~= true then
			scoreAdOffsetY = 0
		end
		
		if videoAdRequested ~= true and videoReady ~= true and time - lastVideoAdTime > 300 then
			requestVideoAd()
			videoAdRequested = true
			print("Requesting next video ad\n")
		end
	end
	
	if keyPressed["LBUTTON"] then
		if doubleClickState ~= 2 then
			doubleClickState = 1
			doubleClickTimer = 0.5
		else
			doubleClickState = 3
		end
	elseif doubleClickTimer > 0 and keyReleased["LBUTTON"] then
		if doubleClickState == 1 then
			doubleClickState = 2
		elseif doubleClickState == 3 then
			doubleClick = true
		end
	end
	
	doubleClickTimer = doubleClickTimer - dt
	if doubleClickTimer <= 0 then
		doubleClickTimer = 0
		doubleClickState = 0
	end
	
	
	-- Update current "game scene"
	currentGameMode(dt, time)


	if keyPressed["F"] then
		showFps = not showFps
	end

	if keyPressed["9"] then
		showBG = not showBG
	end

	if keyPressed["8"] then
		showSleepingObjects = not showSleepingObjects
	end
	
	
	
	if showFps and assetsCreated == true then
		if fpsTimer >= 1 then
			fps = fpsFrames / fpsTimer
			fpsTimer = 0
			fpsFrames = 0
		end
		fpsString = _G.string.format("%.1f", fps)
		setFont(fontBasic);
		_G.res.drawString("", fpsString, screenWidth*0.5, screenHeight, "BOTTOM", "HCENTER")
		fpsTimer = fpsTimer + realDt
		fpsFrames = fpsFrames + 1
	end
	
	
	
	
	if playtimeCounter ~= nil then
		local currentPlaytime = playtimeCounter
		if settings.playtime ~= nil then
			currentPlaytime = (settings.playtime * 1) + playtimeCounter
		end
		if angryBirdsFanAchieved == nil and currentPlaytime >= 18000 then
			addToAchievementUnlockQueue("Angry Birds Fan", true)
			angryBirdsFanAchieved = true
		end
		
		if trueAngryBirdsFanAchieved == nil and currentPlaytime >= 54000 then
			addToAchievementUnlockQueue("True Angry Birds Fan", true)
			trueAngryBirdsFanAchieved = true
		end
		
		if angryBirdsAddicted == nil and currentPlaytime >= 108000 then
			addToAchievementUnlockQueue("Angry Birds Addict", true)
			angryBirdsAddicted = true
		end
	end
	
	if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
		
		if #achievementUnlockQueue > 0 then
			if lastAchievementUnlockTime == nil then
				lastAchievementUnlockTime = -3
			end
			
			if time - lastAchievementUnlockTime > 3 then
				if gameCenterEnabled then
					if gameCenter and gameCenter.achievements and gameCenter.achievements.loading ~= true then
						unlockAchievement(achievementUnlockQueue[1].id, achievementUnlockQueue[1].desc)
						_G.table.remove(achievementUnlockQueue, 1)
						lastAchievementUnlockTime = time
					end
				else
					unlockAchievement(achievementUnlockQueue[1].id, achievementUnlockQueue[1].desc)
					_G.table.remove(achievementUnlockQueue, 1)
					lastAchievementUnlockTime = time
				end
			end
		end
	
		if checkForCrystalEnabled == true and userEnabledCrystal() == true then
			checkForCrystalEnabled = false
			showCrystalInMainMenu = true
			activateCrystalUIAtProfile()
		end
	end
	
	if oldScreenWidth ~= screenWidth or oldScreenHeight ~= screenHeight then
		oldScreenWidth = screenWidth
		oldScreenHeight = screenHeight
	end
end

function gameResumed()
	getCurrentLocale()
	
	if currentMenuPage ~= nil then

		-- this is done mainly to update item positions to correct place when facebook like-button was clicked.
		if _G.string.sub(currentMenuPage.name,1, 19) == "levelSelectionPages" then
			setActiveMenuPage(currentMenuPage, false, true)		
			prepareMenuPage(currentMenuPage)		
			updateMenuPage(currentMenuPage,0)
		else
			setActiveMenuPage(currentMenuPage, true, true)				
		end
		
		
		
	end
		
	
	if(popupPage ~= nil) then
		prepareMenuPage(popupPage)
	end

	if currentBirdIndex and rubberBandPos and levelStartPosition then
		rubberBandPos.x, rubberBandPos.y = levelStartPosition.x, levelStartPosition.y
		rubberBandLength = 0
		dragStarted = false
	end
	if gameCenterEnabled and gameCenter and gameCenter.leaderboards and leaderboards then
		if not isLiteVersion then
			refreshLocalGameCenterData()
		end
		if levelOrder_allLevels then
			postTotalHighScores()
		end
	end
end

function gamePaused()
	calculatePlaytime()
	saveLuaFileWrapper("settings.lua", "settings", true)
	if currentGameMode == updateGame and popupPage ~= mightyEagleDemoPage and startedFromEditor ~= true then	
		showPauseMenu()
		setPhysicsEnabled(false)
		pausePage.offsetX = 0
		pausePage.backgroundOverlay.shade = 0.65
		setAnimationState("ingamePausePageScroll", "VISIBLE")
		drawGame()
	end
end

function setFont(fontName)
	-- _G.res.useFont(fontName)
end

function setGameMode(gameMode)
	currentGameMode = gameMode
	if currentGameMode == updateGame then
		setGameOn(true)
		avoidCrystalBackgroundActivity(true)
	else
		setGameOn(false)
		avoidCrystalBackgroundActivity(false)
	end
end

function setActivePopupPage(popupPage, prepare, info)	
	newPopupPage = popupPage
	
	--[1.5.4
	if(popupPage == mightyEagleDemoPage and info ~= nil) then
		print("(1.5.4) mighty eagle demo page opened from "..info.."\n")
		logFlurryEventWithParam("ME: popup opened", "From", info)	
	end
	
	-- Checked just in case..
	if(newPopupPage ~= nil and info ~= nil) then
		print("(1.5.4) INFO FOR POPUP PAGE = "..info.."\n")
		newPopupPage.info = info	
	end
	
	-- 1.5.4]
	newPopupPageNeedsPrepare = prepare
end

function changeSliderStatus()
	local buttonSliderBG = getItemByName(mainMenu.items, "buttonSliderBG")
	local sliderBGRight = getItemByName(mainMenu.items, "sliderBGRight")
	if buttonSliderBG.state == "closed" then
		sliderBGRight.visible = true
		buttonSliderBG.state = "opening"
	elseif buttonSliderBG.state == "open" then
		buttonSliderBG.state = "closing"
	end
end

function changeOptionSliderStatus()
	local buttonSliderBGOptions = getItemByName(mainMenu.items, "buttonSliderBGOptions")
	local sliderBGLeft = getItemByName(mainMenu.items, "sliderBGLeft")
	if buttonSliderBGOptions.state == "closed" then
		sliderBGLeft.visible = true
		buttonSliderBGOptions.state = "opening"
	elseif buttonSliderBGOptions.state == "open" then
		buttonSliderBGOptions.state = "closing"
	end
end

function setActiveMenuPage(menuPage, prepare, resume)
	--print("setActiveMenuPage: "..menuPage.name)
	newMenuPage = menuPage
	newMenuPageNeedsPrepare = prepare
	newMenuPageResumed = resume
	if newMenuPage ~= nil and newMenuPage.bgColor ~= nil then
		setBGColor(newMenuPage.bgColor.red, newMenuPage.bgColor.green, newMenuPage.bgColor.blue)
	end
end

function setActiveMenuPageDelayed(menuPage, prepare, resumed)
	oldMenuPage = currentMenuPage
	
	if oldMenuPage ~= nil and oldMenuPage ~= menuPage then
		onExitPage(oldMenuPage)
	end
	
	currentMenuPage = menuPage
		
	if prepare ~= false and currentMenuPage ~= nil then
		if currentMenuPage == about then
			prepareMenuPage(mainMenu)
			prepareMenuPage(about)
		else
			prepareMenuPage(currentMenuPage, resumed)
		end
	end
	
	if showCrystalInMainMenu then
		if menuPage == mainMenu then
			activateCrystalUI()
		else
			playerInitializedCrystalUiDeactivation = false
			deactivateCrystalUI()
		end
	end
end

function onExitPage(menuPage)
	if menuPage == mainMenu then
		local buttonSliderBG = getItemByName(mainMenu.items, "buttonSliderBG")
		local buttonSliderBGOptions = getItemByName(mainMenu.items, "buttonSliderBGOptions")
		
		if buttonSliderBG.state == "opening" then
			buttonSliderBG.state = "open"
		elseif buttonSliderBG.state == "closing" then
			buttonSliderBG.state = "closed"
		end
		
		if buttonSliderBGOptions.state == "opening" then
			buttonSliderBGOptions.state = "open"
		elseif buttonSliderBGOptions.state == "closing" then
			buttonSliderBGOptions.state = "closed"
		end
	end
end

function crystalUiDeactivated()
	if playerInitializedCrystalUiDeactivation ~= false then
		showCrystalInMainMenu = false
	end
	
	playerInitializedCrystalUiDeactivation = true
end

function goldenEggAchieved(level)
	if settings.openGoldenEggLevels[level] == nil then
		settings.openGoldenEggLevels[level] = 0
		highscores[goldenEggLevelMapping[level]] = {completed = false, birds = 0, score = 0, lowScore = 0}
		saveLuaFileWrapper("highscores.lua", "highscores", true)
		saveLuaFileWrapper("settings.lua", "settings", true)
		additionalPopupPageDelay = true
		setActivePopupPage(goldenEggAchievedPage)
		
		if calculateOpenGoldenEggLevels() == 10 then
			addToAchievementUnlockQueue("Egg Hunter")
		end
		if deviceModel == "iphone4" then
			changeResolution = true
			wantedResolution = "HALF"
			print("change resolution to half\n")
		end
	end
end

function showAchievementPopUp()
	if gameCenterEnabled and gameCenter and gameCenter.achievements 
	  and gameCenter.achievements.showPopUpID then
		local achi = gameCenter.achievements[gameCenter.achievements.showPopUpID]
		if achi then
			if deviceModel == "iphone4" and currentGameMode ~= updateMenu then
					changeResolution = true
					wantedResolution = "FULL"
			end	

			prepareMenuPage(achievementPopUpPage)
			setActivePopupPage(achievementPopUpPage)
			local bgBox = getItemByName(achievementPopUpPage.items, "achievementBox")
			achievementPopUpPage.animationTimer = 2.7
			bgBox.y = screenHeight
			
			if currentGameMode == updateGame then
				setPhysicsEnabled(true)
			end
		end
	end
end

function goldenEggStarAchieved(level)
	setActivePopupPage(goldenEggStarAchievedPage)
	goldenEggStarAchievedPage.currentLevel = level
	
	if settings.openGoldenEggLevels[level] == 2 then
		goldenEggStarAchievedPage.items[1].sprite = "GOLDEN_EGG_STAR_COLLECTED"
		goldenEggStarAchievedPage.items[2].visible = false
	else
		goldenEggStarAchievedPage.items[1].sprite = "GOLDEN_EGG_STAR"
		goldenEggStarAchievedPage.items[2].visible = true
		_G.res.playAudio("star_collect", 1, false)
	end
		
	settings.openGoldenEggLevels[level] = 2
	if highscores[goldenEggLevelMapping[level]] ~= nil then
		highscores[goldenEggLevelMapping[level]].completed = true
	else
		highscores[goldenEggLevelMapping[level]] = {completed = true, birds = 0, score = 0, lowScore = 0}
	end
	saveLuaFileWrapper("highscores.lua", "highscores", true)
	saveLuaFileWrapper("settings.lua", "settings", true)
	
	if calculateStarsFromGoldenEggLevels() == 10 then
		addToAchievementUnlockQueue("Egg Cracker")
	end
	
	--print("FlurryEventWithParam: Golden egg level completed, param: Level, paramValue: " .. goldenEggLevelMapping[level] .. "\n")
	logFlurryEventWithParam("Golden egg level completed", "Level", "" .. goldenEggLevelMapping[level]) 
end

function aboutGoldenEggAchieved()
	getItemByName(about.items, "goldenEgg").visible = false
	goldenEggAchieved("Level5")
end

function episode3LevelSelectionEggAchieved()
	getItemByName(levelSelectionPagesPack3.items, "goldenEgg").visible = false
	goldenEggAchieved("Level11")
end

function mightyEagleNotificationCallback()
	settings.eaglesUsedIn = {}
	settings.eagleUsedTime = nil
end

function increaseAttemptsAfterEagleOffer()
	if settings.attemptsAfterEagleOffer == nil then
		settings.attemptsAfterEagleOffer = {}
	end
	if iapEnabled == true and (highscores[levelName] == nil or highscores[levelName].completed ~= true) then
		if levelSelectionPages == levelSelectionPagesBasic and currentWorldNumber ~= 1 then
			if settings.attemptsAfterEagleOffer.basic == nil then
				settings.attemptsAfterEagleOffer.basic = 1
			else
				settings.attemptsAfterEagleOffer.basic = settings.attemptsAfterEagleOffer.basic + 1
			end
		elseif levelSelectionPages == levelSelectionPagesExtra then
			if settings.attemptsAfterEagleOffer.extra == nil then
				settings.attemptsAfterEagleOffer.extra = 1
			else
				settings.attemptsAfterEagleOffer.extra = settings.attemptsAfterEagleOffer.extra + 1
			end
		elseif levelSelectionPages == levelSelectionPagesPack3 then
			if settings.attemptsAfterEagleOffer.pack3 == nil then
				settings.attemptsAfterEagleOffer.pack3 = 1
			else
				settings.attemptsAfterEagleOffer.pack3 = settings.attemptsAfterEagleOffer.pack3 + 1
			end
		elseif levelSelectionPages == levelSelectionPagesPack4 then
			if settings.attemptsAfterEagleOffer.pack4 == nil then
				settings.attemptsAfterEagleOffer.pack4 = 1
			else
				settings.attemptsAfterEagleOffer.pack4 = settings.attemptsAfterEagleOffer.pack4 + 1
			end
		elseif levelSelectionPages == levelSelectionPagesPack5 then
			if settings.attemptsAfterEagleOffer.pack5 == nil then
				settings.attemptsAfterEagleOffer.pack5 = 1
			else
				settings.attemptsAfterEagleOffer.pack5 = settings.attemptsAfterEagleOffer.pack5 + 1
			end
		end
	end
end

--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- Mode for splash sequences

function updateSplashes(dt, time)
	
	
	-- Initialize on first time
	if splashTimer == nil then
		splashTimer = 0
		current = 1
		splashes = { 	{ sprite = "SPLASH_CLICKGAMER", time = 2, bgColor = { red = 255, green = 255, blue = 255} },
						{ sprite = "SPLASH_ROVIO", time = 2, bgColor = { red = 255, green = 255, blue = 255}},
						{ sprite = "SPLASH_ANGRY_BIRDS", time = 1, bgColor = { red = 0, green = 0, blue = 0}} }
		
		if isKorea then
			_G.table.insert(splashes, 2, { sprite = "KOREA_IMAGE_1", time = 3, bgColor = { red = 255, green = 255, blue = 255}})
		end
		
		if deviceModel == "bada" then
			current = 3
		elseif deviceModel ~= "iphone" and deviceModel ~= "ipad" and deviceModel ~= "iphone4" then
			current = 2
		end
		setBGColor(splashes[current].bgColor.red, splashes[current].bgColor.green, splashes[current].bgColor.blue)
	end

	-- Update timer
	splashTimer = splashTimer + dt
	
	if keyPressed["LBUTTON"] and splashes[current].sprite ~= "KOREA_IMAGE_1" then
		splashTimer = splashes[current].time + 1
	end

	
	local sw, sh = _G.res.getSpriteBounds("", splashes[current].sprite)
	local scale = false
	local xs, ys = 1, 1
	local xCoord, yCoord =  screenWidth / 2, screenHeight / 2
	if splashes[current].sprite == "SPLASH_ROVIO" and screenHeight * 0.8 < sh then
		scale = true
		ys = screenHeight / sh
		xs = screenHeight / sh
		local newWidth = sw * xs
		if newWidth > screenWidth then
			ys = screenWidth / sw
			xs = screenWidth / sw
		end
	elseif splashes[current].sprite ~= "SPLASH_ROVIO" and splashes[current].sprite ~= "KOREA_IMAGE_1" and screenHeight ~= sh then
		if splashes[current].sprite ~= "SPLASH_CLICKGAMER" and deviceModel ~= "ipad" then
			scale = true
			ys = screenHeight / sh
			xs = screenHeight / sh
			local newWidth = sw * xs
			if newWidth > screenWidth then
				ys = screenWidth / sw
				xs = screenWidth / sw
			end
		end
	end
			
	if scale then
		setRenderState(0, 0, xs, ys)
		_G.res.drawSprite("", splashes[current].sprite, _G.math.floor(xCoord / xs), _G.math.floor(yCoord / ys))
		if splashes[current].sprite == "SPLASH_ANGRY_BIRDS" then
			if (isBetaVersion and deviceModel == "android") or isLiteVersion then
				_G.res.drawSprite("", "LITE_SPLASH", _G.math.floor(xCoord / xs), _G.math.floor(yCoord / ys))
			end
			--setRenderState(0, 0, 1, 1)
			if isBetaVersion and deviceModel == "android" then
				_G.res.drawSprite("", "SPLASH_LOADING", screenWidth, screenHeight)
			else
				_G.res.drawSprite("", _G.res.getString("TEXTS_BASIC", "TEXT_SPLASH_LOADING_SPRITE"), screenWidth / xs, screenHeight / ys)
			end		
		end
		setRenderState(0, 0, 1, 1)
	else
		_G.res.drawSprite("", splashes[current].sprite, screenWidth/2, screenHeight/2)
		-- loading text in different languages
		if splashes[current].sprite == "SPLASH_ANGRY_BIRDS" then
			_G.res.drawSprite("", _G.res.getString("TEXTS_BASIC", "TEXT_SPLASH_LOADING_SPRITE"), screenWidth, screenHeight)
			if (isBetaVersion and deviceModel == "android") or isLiteVersion then
				_G.res.drawSprite("", "LITE_SPLASH", screenWidth / 2, screenHeight / 2)
				_G.res.drawSprite("", "SPLASH_LOADING", screenWidth, screenHeight)
			end
		elseif splashes[current].sprite == "KOREA_IMAGE_1" then
			_G.res.drawSprite("", "KOREA_IMAGE_2", screenWidth - 30, screenHeight - 35)
		end
	end
	
	if current >= 3 and splashTimer > dt and assetsCreated ~= true then
		if (isLiteVersion or deviceModel == "android") and not settings.isPremium then
			requestAndShowVideo()
		end
		createAssets()
	end
	
	-- Change sprite if showed long enough
	if splashTimer > splashes[current].time then
		splashTimer = 0
		current = current + 1
		if splashes[current] ~= nil then
			setBGColor(splashes[current].bgColor.red, splashes[current].bgColor.green, splashes[current].bgColor.blue)
		end
		if current > #splashes then
			initialize()
			releaseSplashes = true
			setTheme(currentMainMenuTheme)
			if settings.gfxLowQuality == false or settings.gfxLowQuality == nil then
				drawBackgroundNative()	
				-- ugly fix.. draw the splash page again there, since drawBackgroundNative draws the game on top of the splash a little bit
				setRenderState(0,0,1,1,0,0)
				_G.res.drawSprite("", "SPLASH_ANGRY_BIRDS", screenWidth / 2, screenHeight / 2)				
			end
			setGameMode(updateMenu)
		end
	end
	
end

-- change ingame settings here so that the settings are refreshed properly
function updateValues()
	defaultForce = -925.0
	boostForce = defaultForce
--	colorDamageFactor = 4
--	blueBirdFactor = 0.725
--	yellowBirdFactor = 0.65
--	blueBirdFactor = 0.725
--	yellowBirdFactor = 0.6
	collisionParticleForceThreshold = 10
	collisionSoundForceThreshold = 3
	blockDestroyedScoreIncrement = 500
	pigletteDestroyedScoreIncrement = 5000
	birdsLeftScoreIncrement = 10000
	hardLimitSimultaneousParticles = 150
	softLimitSimultaneousParticles = 75
end


-------------
--Scene-class
-------------

Scene = {}

function Scene:new(o)
	o = o or {}
	o.pages = {}
	o.order = {}
	_G.setmetatable(o, self)
	self.__index = self
	o:init()
	return o
end

function Scene:init() end

function Scene:onEntry() 
	for i = 1, #self.order do
		self.pages[self.order[i]]:onEntry()
	end
end

function Scene:onExit() 
	for i = 1, #self.order do	
		self.pages[self.order[i]]:onExit()
	end
end

function Scene:insertPage(key, page, pushback)
	--self:setPageDefaults(page)
	if not pushback then
		_G.table.insert(self.order, key)
		self.pages[key] = page
	else
		local index = self:getIndexOfPage(pushback)
		if index then
			_G.table.insert(self.order, index, key)
			self.pages[key] = page
		end
	end	
end

function Scene:removePage(key)
	local index = self:getIndexOfPage(key)
	if index then
		_G.table.remove(self.order, index)
		for i, v in _G.ipairs(self.pages) do
			if v == self.pages.key then
				_G.table.remove(self.pages, i)
				return
			end
		end
	end
end

function Scene:getIndexOfPage(name)
	for i = 1, #self.order do
		if self.order[i] == name then
			return i
		end
	end
	return false
end

function Scene:update(dt, time)
	if self.visible ~= false then
		for k, v in _G.pairs(self.order) do
			if self.pages[v].visible ~= false then				
				self.pages[v]:update(dt, time)
			end
		end
	end
end

function Scene:draw()
	if self.visible ~= false then
		for k, v in _G.pairs(self.order) do
			if self.pages[v].visible ~= false then
				self.pages[v]:draw()
			end
		end
	end
end


------------
--Page-class
------------
Page = {}
    
function Page:new(o)
	o = o or {}
	o.items = {}
	o.order = {}
	_G.setmetatable(o, self)
	self.__index = self
	o:init()
	return o
end

function Page:init()
-- Overridden in classes that inherit this but needs to be declared here.
end

function Page:insertItem(key, item, pushback)
	
	self:setItemDefaults(item)
	
	if not pushback then
		_G.table.insert(self.order, key)
		self.items[key] = item
	else
		local index = self:getIndexOfItem(pushback)
		if index then
			_G.table.insert(self.order, index, key)
			self.items[key] = item
		end
	end	
end

function Page:removeItem(key)
	local index = self:getIndexOfItem(key)
	if index then
		_G.table.remove(self.order, index)
		for i, v in _G.ipairs(self.items) do
			if v == self.items.key then
				_G.table.remove(self.items, i)
				return
			end
		end
	end
end

function Page:setItemDefaults(item)
	
	item.x, item.y = item.x or 0, item.y or 0
	
	if item.sprite then
		item.sheet = item.sheet or self.sheet
	elseif item.text then
		item.font = item.font or self.font or defaultMenuFont
	end
	
	if item.renderState then
		item.xs = item.xs or 1
		item.ys = item.ys or 1
		item.angle = item.angle or 0
		if item.useSpritePivot and item.sprite then
			item.pivotX, item.pivotY = _G.res.getSpritePivot(item.sheet, item.sprite)
		else
			item.pivotX, item.pivotY = item.pivotX or 0, item.pivotY or 0
		end
	end
end

function Page:getIndexOfItem(name)
	for i = 1, #self.order do
		if self.order[i] == name then
			return i
		end
	end
	return false
end

function Page:getActivatedItems()
	local activatedItems = {}
	local activatedItemsTouchData = {}
	for k, v in _G.pairs(touches) do
		for key, value in _G.pairs(self.items) do
			if value.visible ~= false and value.selectable ~= false 
			  and value:checkBounds(v.x, v.y) then
				if #activatedItems == 0 or #activatedItems >= 1 and activatedItems[1] ~= key then
					_G.table.insert(activatedItems, key)
					activatedItemsTouchData[key] = k
				end
			end
		end
	end
	if #activatedItems >= 1 then
		return activatedItems, activatedItemsTouchData
	else
		return false
	end
end

function Page:getHoveredItems()
	local hoveredItems = {}
	for key, value in _G.pairs(self.items) do
		if value.visible ~= false and value.selectable ~= false 
		  and value:checkBounds(cursor.x, cursor.y) then
			if #hoveredItems == 0 or #hoveredItems >= 1 and hoveredItems[1] ~= key then
				_G.table.insert(hoveredItems, key)
			end
		end
	end

	if #hoveredItems >= 1 then
		return hoveredItems
	else
		return false
	end
end	


function Page:checkClicks()
	-- TODO: selectionCandidate functionality for overlapping sprites, texts and/or touch areas.
	-- Needs to take pivot and anchor into account.

	for k, v in _G.pairs(self.items) do
		if v.visible ~= false and v.selectable ~= false 
		 and (v.activateOnRelease ~= true and keyPressed["LBUTTON"] or v.activateOnRelease and keyReleased["LBUTTON"])
		 and v:checkBounds(cursor.x, cursor.y) then 
			if v.action then
				for key, value in _G.pairs(v.action) do
					key(value)
				end
			end
			return v
		end
	end
	return false
end


function Page:getClickedItem()
	-- TODO: selectionCandidate functionality for overlapping sprites, texts and/or touch areas.
	-- Needs to take pivot and anchor into account.

	for k, v in _G.pairs(self.items) do
		if v.visible ~= false and v.selectable ~= false 
		 and (v.activateOnRelease ~= true and keyPressed["LBUTTON"] or v.activateOnRelease and keyReleased["LBUTTON"])
		 and v:checkBounds(cursor.x, cursor.y) then 
			return v
		end
	end
	return false
end

function Page:draw()
	for i = 1, #self.order do
		local item = self.items[self.order[i]]
		if item.visible ~= false then
			item:draw()
		end
	end
end

------------
--Item-class
------------
Item = {}
    
function Item:new(o)
	o = o or {}
	o.x, o.y = o.x or 0, o.y or 0
	_G.setmetatable(o, self)
	self.__index = self
	o:init()
	return o
end

function Item:init()
end

function Item:checkBounds(xCoord, yCoord)
	if self.h == nil or self.w == nil then
		return false -- Height and width for click area must be set.
	else
		return yCoord >= self.y and yCoord <= self.y + self.h and
			xCoord >= self.x and xCoord <= self.x + self.w
	end
end



----------------------------------
--RectItem-class, inherits Item
----------------------------------

RectItem = Item:new()

function RectItem:init()
	self.red = self.red or 0
	self.green = self.green or 0
	self.blue = self.blue or 0
	self.alpha = self.alpha or 0
	self.x1 = self.x1 or 0
	self.x2 = self.x2 or screenWidth
	self.y1 = self.y1 or 0
	self.y2 = self.y2 or screenHeight
	self.inWorld = self.inWorld or false
end
					  
function RectItem:draw()
	if self.renderState then
		setRenderState(-screen.left, -screen.top, worldScale, worldScale, 0, 0, 0)
	end
	drawRect(self.red, self.green, self.blue, self.alpha, self.x1, self.y1, self.x2, self.y2, self.inWorld)
	setRenderState(0, 0, 1, 1, 0, 0, 0)
end

----------------------------------
--SpriteItem-class, inherits Item
----------------------------------

SpriteItem = Item:new()

function SpriteItem:checkBounds(xCoord, yCoord)

	if self.clickArea ~= nil then	   
		return xCoord >= self.clickArea.xLeft and xCoord <= self.clickArea.xRight and
			   yCoord >= self.clickArea.yTop and yCoord <= self.clickArea.yBot
	end
	self.sheet = self.sheet or ""
	local width, height = _G.res.getSpriteBounds(self.sheet, self.sprite)
	local pivotX, pivotY = _G.res.getSpritePivot(self.sheet, self.sprite)
	
	if self.renderState then
		local scaleCorrectionX, scaleCorrectionY = 0, 0
		local xs, ys = self.xs or 1, self.ys or 1
		if self.scale ~= nil then
			xs, ys = self.scale, self.scale
		end
		if xs ~= 1 then
			scaleCorrectionX = ((width * xs) - width) / 2
		end
		if ys ~= 1 then
			scaleCorrectionY = ((height * ys) - height) / 2
		end

		return yCoord >= (self.y - pivotY - scaleCorrectionY) and yCoord <= (self.y - pivotY + height + scaleCorrectionY)
			and xCoord >= (self.x - pivotX - scaleCorrectionX) and xCoord <= (self.x - pivotX + width + scaleCorrectionX)
	elseif self.inWorld then
		local scaleCorrectionX, scaleCorrectionY = 0, 0
		local xs, ys = self.xs or 1, self.ys or 1
		if self.scale ~= nil then
			xs, ys = self.scale, self.scale
		end
		worldScale = worldScale or 1
		--if xs > 1 then
			scaleCorrectionX = ((width * xs * worldScale) - width) / 2
		--end
		--if ys > 1 then
			scaleCorrectionY = ((height * ys * worldScale) - height) / 2
		--end
	
		local tmpx, tmpy = physicsToScreenTransform(self.x, self.y)	
		return yCoord >= (tmpy - pivotY - scaleCorrectionY) and yCoord <= (tmpy - pivotY + height + scaleCorrectionY)
			and xCoord >= (tmpx - pivotX - scaleCorrectionX) and xCoord <= (tmpx - pivotX + width + scaleCorrectionX)
	end
	
	return yCoord >= (self.y - pivotY) and yCoord <= (self.y - pivotY + height) and
		xCoord >= (self.x - pivotX) and xCoord <= (self.x - pivotX + width)
end

function SpriteItem:draw()
	if self.renderState then

		local xCoord, yCoord = self.x, self.y
		local xs, ys = self.xs or 1, self.ys or 1
		local angle = self.angle or 0
		local px, py = self.pivotX or 0, self.pivotY or 0
		if xs ~= 1 then
			xCoord =  xCoord / xs
		end
		if ys ~= 1 then
			yCoord = yCoord / ys
		end
		setRenderState(0, 0, xs, ys, angle, px, py)
		if self.drawToScreenSize then
			--local hAnchor = self.hAnchor or "HCENTER"
			--local vAnchor = self.vAnchor or "TOP"
			local sw, sh = _G.res.getSpriteBounds(self.sheet, self.sprite)
			local aspect = sw / sh
			local width = screenHeight * aspect
			local px, py = _G.res.getSpritePivot(self.sheet, self.sprite)
			
		
		--	if screenHeight > sh and screenWidth <= sw then
		--		_G.res.drawSprite(self.sheet, self.sprite, (sw - width) / 2, 0, "LEFT", "TOP", width, screenHeight)
		--	else
				_G.res.drawSprite(self.sheet, self.sprite, 0, 0, "LEFT", "TOP", screenWidth, screenHeight)
		--	end
			
			
			--_G.res.drawSprite(self.sheet, self.sprite, _G.math.floor(xCoord), _G.math.floor(yCoord) - screenHeight / 2, hAnchor, vAnchor, sw * screenHeight / sh, screenHeight)
		else
			_G.res.drawSprite(self.sheet, self.sprite, _G.math.floor(xCoord), _G.math.floor(yCoord))
		end
		setRenderState(0, 0, 1, 1, 0, 0, 0)
	else
		_G.res.drawSprite(self.sheet, self.sprite, self.x, self.y)
	end
end

-------------------------------
--TextItem-class, inherits Item
-------------------------------

TextItem = Item:new({text = "", group = "TEXTS_BASIC", textBoxSize = screenWidth, hanchor = "HCENTER", vanchor = "VCENTER"})

-- function TextItem:draw()
	-- _G.res.drawString(self.group, self.text, self.x, self.y, self.hanchor, self.vanchor )
-- end

function TextItem:init()
	self.text = self.text or ""
	self.group = self.group or "TEXTS_BASIC"
	self.textBoxSize = self.textBoxSize or screenWidth
	self.hanchor = self.hanchor or "HCENTER"
	self.vanchor = self.vanchor or "VCENTER"
	self.width = _G.res.getStringWidth(_G.res.getString(self.group, self.text))
end

function TextItem:clip()
	setFont(self.font)
	clipText(self.group, self.text, self.textBoxSize)
	local fl = _G.res.getFontLeading()
	self.textBlockHeight = #clippedText.lines * fl
	self.widestLine = clippedText.widestLine
	self.lines = {}
	
	local k = 1
	local yCorrection = 0
	if self.vanchor == "VCENTER" then
		yCorrection = (-self.textBlockHeight / 2) + (fl / 2)
	elseif self.vanchor == "BOTTOM" then
		yCorrection = -self.textBlockHeight + fl
	end
	while  k <= #clippedText.lines do
		local l = clippedText.lines[k]
		local tmpItm = TextItem:new({font = self.font, text = l, x = self.x, y = self.y + yCorrection, hanchor = self.hanchor, vanchor = self.vanchor})
		_G.table.insert(self.lines, tmpItm)
		k = k + 1
		yCorrection = yCorrection + fl
	end
	self.clipped = true
end

function TextItem:checkBounds(xCoord, yCoord)
	local w = _G.res.getStringWidth(_G.res.getString(self.group, self.text))
	if w > self.width then
		self.width = w
	end
	
	if self.clipped then
		for i = 1, #self.lines do
			if self.lines[i]:checkBounds(xCoord, yCoord) then
				return true
			end
		end
	else	
		local fl = _G.res.getFontLeading()
		local xCorrection, yCorrection = 0, 0
		if self.hanchor == "HCENTER" then
			xCorrection = -self.width / 2
		elseif self.hanchor == "RIGHT" then
			xCorrection = -self.width
		elseif self.hanchor == "LEFT" then
			xCorrection = 0
		end

		if self.vanchor == "VCENTER" then
			yCorrection = -fl / 2
		elseif self.vanchor == "BOTTOM" then
			yCorrection = -fl
		elseif self.vanchor == "TOP" then
			yCorrection = 0
		end
	
		return yCoord >= self.y + yCorrection and yCoord <= self.y + yCorrection + fl and
			xCoord >= self.x + xCorrection and xCoord <= self.x + xCorrection + self.width
	end
end

function TextItem:draw()
	if self.visible ~= false then
		setFont(self.font)
		if self.clipped then
			for i = 1, #self.lines do
				self.lines[i]:draw()
			end
		else
			_G.res.drawString(self.group, self.text, self.x, self.y, self.hanchor, self.vanchor )
		end
	end
end

function initialize()
	_G.math.randomseed(_G.os.time())
	
	--[[
	defaultLanguage = "en_EN"
	currentLanguage = defaultLanguage
	-- IF you add languages remember to add short language name, language sprite (flag) and about sprite as well
	languageNames = {"en_EN", "fr_FR", "it_IT", "de_DE", "es_ES" } --, "jp_JP", "cn_TC"}
	shortLanguageNames = {"en", "fr", "it", "de", "es" } --, "jp", "cn" }
	currentLanguageId = 1
	languageSprites = { 
		en_EN = "SETTINGS_FLAG_EN",
		fr_FR = "SETTINGS_FLAG_FR",
		it_IT = "SETTINGS_FLAG_IT",
		de_DE = "SETTINGS_FLAG_DE",
		es_ES = "SETTINGS_FLAG_ES",
		--jp_JP = "SETTINGS_FLAG_JP",
		--cn_TC = "SETTINGS_FLAG_CN",
	}

	if settings.currentLanguage == nil then
		settings.currentLanguage = "en_EN"
	end
	
	currentLanguage = settings.currentLanguage
	_G.res.loadLocale("TEXTS_BASIC", settings.currentLanguage)
	_G.res.useLocale(settings.currentLanguage)
	--]]
	
	numberKeys = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "0" }

	-- these coordinates are the screen in world space, scaling affects here
	screen = { x = screenWidth*0.5, y = screenHeight*0.5, top = 0, left = 0, bottom = screenHeight, right = screenWidth }

	if showCameraDebugData then
		visualizeScreen = { x = 0, y = 0 }
	end
	
	oldScreenWidth = screenWidth
	oldScreenHeight = screenHeight	
	
	bannerWidth = 320 * (screenHeight / 320)
	bannerHeight = 48 * (screenHeight / 320)
	
	if deviceModel == "android" and isHDVersion then
		bannerHeight = 48
	end
		
	cameraShakeX, cameraShakeY = 0, 0
		
	floatingScoreScaling = 1
	if deviceModel == "iphone4" then
		floatingScoreScaling = 2
	end
	
	loading = false
	
	menuSunsetAngle = 0
	
	goldenEggsStarEffectAngle = 0

	rubberBandPos = { x = 0, y = 0 }
	rubberBandSpeed = 0

	floatingScores = {}

	objectCounts = {}

	scoreTable = {}

	draggingSpeed = 0
	draggingStartPosPhysics = { x = -1, y = -1 }
	draggingStartPosWorld = { x = -1, y = -1 }
	draggingStartPosScreen = { x = -1, y = -1 }
	selectedObjects = { }
	selectedObjectPos = { x = 0, y = 0 }
	selectedBird = nil

	objectToAdd = nil
	objectToAddAngle = 0

	currentGroupIndex = 1
	currentGroup = nil

	currentThemeIndex = 1
	currentTheme = nil

	cameraTargetObject = nil

	doubleClickTimer = 0
	quadClickTimer = 0
	quadClickCounter = 0
	gameTimer = 0
	levelCompleteTimer = 0
	birdBuffTimer = 0
	currentBirdIndex = 1
	currentBirdName = nil
	flyingBird = nil
	birdSpecialtyAvailable = false
	particleAmount = 0
	blockMoveTimer = 0
	
	cursor.x, cursor.y = 0, 0
	cursorPhysics = {x = 0, y = 0}
	cursorWorld = {x = 0, y = 0}
	oldCursorWorld = {x = 0, y = 0}
	oldCursor = {x = 0, y = 0}
	tapPosWorld = {x = 0, y = 0}

	springConstant = 1500
	springDampening = 50

	difficultyLevel = 1
	score = 0
	zoomLevel = 0
	
	defaultForce = -800.0
	blockDestroyedScoreIncrement = 100

	physicsToWorld = 20
	physicsScale = 1/physicsToWorld
	shootRange = 2.2

	continueButtonY = screenHeight*0.5 + 70

	oldScale = 1
	levelStartPosition = { x = 0, y = 0 }
	animationScreen = { x = 0, y = 0 }
	animationWorldScale = 1

	setPhysicsSimulationScale(physicsToWorld)

	levelName = ""

	cameraFunction = defaultCamera
	castleCameraTimer = 0

	levelStartTimer = 0

	currentLevelNumber = -1
	currentThemeNumber = -1
	currentWorldNumber = -1
	inExtraWorld = false
	currentLevelNumberInTheme = -1
	currentPageNumber = -1
	
	collisionParticleForceThreshold = 5

	physicsEnabled = false
	levelSaved = true
	selectionRectActive = false
	birdFired = false

	loadingPageDrawn = false
	
	-- particle table
	particles = {}

	-- main menu page animations
	elementAnimations = {}
	
	initializeMenu()

	updateValues()

	setPhysicsEnabled(false)
	isShowingAd = false
	requestAd()
	adRequested = true
	
	cos = _G.math.cos
	sin = _G.math.sin

	-- in-app purchase
	if iapEnabled == true then
		setNotificationCallback("mightyEagleNotificationCallback")
	end
		
	--createDirectory("/temp")
end

-- in-app purchase starts
function inAppPurchaseInitCallback(pid, status, errorCode)
	-- pid is not used for anything 
	if status ~= nil and errorCode ~= nil then
		print("gameLogic.lua::itemPurchaseCallback(): status: ".. status .. ", errorCode: ".. errorCode .. "\n")
		if status == 1 then
			local count = iapGetItemCount()
			print("  gameLogic.lua::itemPurchaseCallback(): itemCount: ".. count .. "\n")
			if count > 0 then
				local eagleItemFound = false
				for i = 0, count - 1 do
					local item = iapGetItemAt(i)
					print("  gameLogic.lua::itemPurchaseCallback(): item(i): ")
					print("    name: ".. item.name ..", id: ".. item.id ..", type: ".. item.type ..", quantity: ".. item.quantity ..", desc: ".. item.description .."\n")
					if item.id == mightyEagleItemId then
						eagleItemFound = true
						mightyEagleItem = { name = item.name, id = item.id, type = item.type, quantity = item.quantity, description = item.description }
					end
				end
				if eagleItemFound ~= true then
					print("  gameLogic.lua::itemPurchaseCallback(): mighty eagle item not found\n")
					--iapEnabled = false
				end
			else
				print("  gameLogic.lua::itemPurchaseCallback(): no items found\n")
				--iapEnabled = false
			end
		else
			print("  gameLogic.lua::itemPurchaseCallback(): init failed\n")
			--iapEnabled = false
		end
	end
	-- iapBuyItem is called when iapInitTimer <= 0 
	iapInitTimer = 0
end

function purchaseMightyEagle()
	print("gameLogic.lua:: purchaseMightyEagle(): enter\n")
	--print("Initializing In-App purchase\n")
	iapInitItemPurchase("inAppPurchaseInitCallback")
	iapInitTimer = iapInitTimeOut
end


function inAppPurchaseBuyCallback(pid, status, errorCode)
	local elements = getItemByName(mainMenu.items, "buttonSliderBGOptions").elements
	if status ~= nil and errorCode ~= nil then 
		print("gameLogic.lua::inAppPurchaseBuyCallback(): status: " .. status .. ", errorCode: ".. errorCode .. "\n")
		if status == 2 then
			print("  fail\n")
			if errorCode == 2 then
				print("  user cancel\n")
				cancelMightyEaglePurchase()
				return 
			else
				logFlurryEvent("Mighty eagle purchase failed") 
				print("  other\n")
			end
		end
		--local item = iapGetItemAt(1)
		--print("gameLogic.lua::inAppPurchaseBuyCallback(): item(1) (".. item.id ..") quantity now: ".. item.quantity .. "\n")
		
		if (status == 1 or status == 3) and pid == mightyEagleItemId then
			settings.mightyEagleEnabled = true
			-- changes trial scores to real scores.
			--updateTrialEagleValueAtHighscores()
			settings.mightyEagleUpsellPageViewed = true
			saveLuaFileWrapper("settings.lua", "settings", true)
			addToAchievementUnlockQueue("Aquiline Benefactor")
			_G.table.insert(mainMenu.items, {name = "trailerEagle", sprite = "BUTTON_MEVIDEO", callFunction = gotoMightyEagleTrailer, selectable = false, visible = false })
			if status == 1 then
				print("  success\n")
				--[[
				if(currentWorldNumber ~= nil and currentLevelNumberInTheme ~= nil) then
					if(currentMenuPage ~= mainMenu) then
						params = {}
						params["From"] = getWorldLevelNumberCombination()
						local usedAsLevelSkip = "no"
						--and highscores ~= nil
						if(levelName ~= nil ) then
							if(highscores[levelName] == nil or (highscores[levelName] ~= nil and highscores[levelName].completed ~= true)) then
								usedAsLevelSkip = "yes"							
							end
						end
						params["levelSkip"] = usedAsLevelSkip
						logFlurryEventWithParams("ME: purchased", "params")					
						--print("mighty eagle purchased at "..getWorldLevelNumberCombination()..", level skip = "..usedAsLevelSkip.."\n")
					else
						params = {}
						params["From"] = "MainMenu"
						params["levelSkip"] = "no"
						logFlurryEventWithParams("ME: purchased", "params")										
						--print("mighty eagle purchased at MainMenu, level skip = no \n")
					end
				else
					logFlurryEvent("Mighty eagle purchased")
				end]]
			elseif status == 3 then
				print("  restored")
				logFlurryEvent("Mighty eagle restored")
			end
			print("gameLogic.lua::inAppPurchaseBuyCallback(): Mighty Eagle Enabled\n")
		end
	end
	if currentMenuPage == mainMenu then
		-- back to mainmenu
		setActiveMenuPageDelayed(mainMenu, true)
		print("gameLogic.lua::inAppPurchaseBuyCallback(): back to mainmenu\n")
	elseif currentMenuPage == levelFailed then
		if settings.mightyEagleEnabled == true then
			getItemByName(levelFailed.items, "buttonEagle").visible = true
			getItemByName(levelFailed.items, "buttonEagleLost").visible = false
			getItemByName(levelFailed.items, "buttonEagleBuy").visible = false
		else
			getItemByName(levelFailed.items, "buttonEagleBuy").visible = true
		end
		setActiveMenuPageDelayed(levelFailed, true)
	elseif currentGameMode == updateGame then
		print("going to pause menu\n")
		showPauseMenu()
		setPhysicsEnabled(false)
		pausePage.offsetX = 0
		pausePage.backgroundOverlay.shade = 0.65
		setAnimationState("ingamePausePageScroll", "VISIBLE")
	end
	popupPage = nil
end
-- in-app purchase ends

-- Initialization ends
-------------------------------------------------------------------------------
-- Menu stuff starts

--[[
Possible menu item values
-updateFunction = the function that is set as active update function when this menuitem is selected
-page = the next menu page if this item is used to change menu pages
-action = the action that is sent to game when this menu item is selected
-visible = is this item visible, if this is not set default is true
-selectable = can this item be selected
-sprite = sprite that is used to draw this menu item
-text = text that is used to draw this menu item
-textBoxSize = width that this text item can use, text is cut to fit this width
-x = preset x position of this menu item
-y = preset y position of this menu item
-hanchor = horizontal anchor of this menu item
-vanchor = vertical anchor of this menu item
-font = the font used to draw this item
-sound = sound to play when item is selected

template item
items = {
	{ updateFunction = updateGame, page = nil, action = -1, visible = true, selectable = true, sprite = nil, text = "TID_NONE", textBoxSize = 200, x = 0, y = 0, hanchor = "HCENTER", vanchor = "VCENTER")
}

Menu page values
-titleText = text that is shown as title text
-titleFont = font that is used for title text
-titleSprite = image that is shown as title image
-backgroundSprite = sprite that is drawn to the background
-backgroundOverlaySprite = sprite that drawn after the draw function has been called, tiled if necessary
-backgroundDrawFunction = function that is called to draw the background
-popup = is this menu page a popup page
-font = default font for this page
-state = current state of the page "READY" means ready for input
-sound = selectable item selection sound
]]

function initializeMenu()

	if isLiteVersion then
		levelOrder = {
			packs = {
			"pack1",
			},
			
			pack1 = {
		-- 1 - 10
				"Level1",
				"Level2",
				"Level7",
				"Level13",
				"Level17",
				"Level16",

	--			"Level227",
	--			"Level228",
	--			"Level229",
	--			"Level222",
	--			"Level218",
	--			"Level213",

	--			"LevelLite1",
	--			"LevelLite2",
	--			"LevelLite3",
	--			"LevelLite4",
	--			"LevelLite5",
	--			"LevelLite6",

				"LevelLite9",
				"LevelLite8",
				"LevelLite10",
				"LevelLite7",
				"LevelLite12",
				"LevelLite11", 
				
				"LevelLite13", 
				"LevelLite14", 
				"LevelLite15", 
				"LevelLite16", 
				"LevelLite17", 
				"LevelLite18", 
			}
		}
	else
		levelOrder = {
			packs = {
				"pack1",
				"pack2",
				"pack3",
				"pack4",
				"pack5",
				"pack6",
				"pack7",
				"pack8",
				"pack9",
				"pack10",
				"pack11",
				"pack12",
				"pack13",
				"pack14",
				"pack15",
				"pack16",
				"pack17",
				"goldeneggs1",
				"packLite",
			},
			
			episodes = { {"pack1", "pack2", "pack3"}, {"pack4", "pack5"}, {"pack6", "pack7", "pack8"},
						 {"pack9", "pack10", "pack11"}, {"pack12", "pack13", "pack14"}, {"pack15", "pack16", "pack17"}
			},
			
			pack1 = {
		-- 1 - 10
				"Level1",
				"Level57",
				"Level53",
				"Level3",
				"Level6",
				"Level2",
				"Level4",
				"Level5",
				"Level7",
				"Level8",

		-- 11 - 21
				"Level9",
				"Level13",
				"Level10",
				"Level39",
				"Level12",
				"Level15",
				"Level17",
				"Level14",
				"Level16",
				"Level23",

				"Level44",
			},
			pack2 = {
		-- 22 - 31
				"Level52",
				"Level34",
				"Level42",
				"Level24",
				"Level88",
				"Level36",
				"Level31",
				"Level21",
				"Level41",
				"Level76",

		-- 32 - 42
				"Level38",
				"Level35",
				"Level20",
				"Level26",
				"Level66",
				"Level85",
				"Level27",
				"Level32",
				"Level72",
				"Level90",

				"Level96",
			},
			pack3 = {

		-- 43 - 52
				"Level43",
				"Level77",
				"Level28",
				"Level29",
				"Level87",
				"Level18",
				"Level91",
				"Level49",
				"Level45",
				"Level75",

		-- 53 - 63
				"Level51",
				"Level30",
				"Level79",
				"Level40",
				"Level59",
				"Level58",
				"Level95",
				"Level82",
				"Level22",
				"Level89",

				"Level81"
			},
			pack4 = {
				"LevelP2_103",
				"LevelP2_91",
				"LevelP2_65",
				"LevelP2_96",
				"LevelP2_69",
				"LevelP2_88",
				"LevelP2_64",
				"LevelP2_80",
				"LevelP2_108",
				"LevelP2_85",

		-- 11 - 21
				"LevelP2_82",
				"LevelP2_66",
				"LevelP2_104",
				"LevelP2_210",
				"LevelP2_83",
				"LevelP2_79",
				"LevelP2_77",
				"LevelP2_114",
				"LevelP2_81",
				"LevelP2_68",

				"LevelP2_95",

			},
			pack5 = {
		-- 22 - 31
				"LevelP2_78",
				"LevelP2_100",
				"LevelP2_92",
				"LevelP2_94",
				"LevelP2_89",
				"LevelP2_73",
				"LevelP2_76",
				"LevelP2_122", 
				"LevelP2_99",
				"LevelP2_84",

		-- 32 - 42
				"LevelP2_86",
				"LevelP2_74",
				"LevelP2_115",
				"LevelP2_98",
				"LevelP2_71",
				"LevelP2_72",
				"LevelP2_87",
				"LevelP2_93",
				"LevelP2_67",
				"LevelP2_97",

				"LevelP2_90",		
			},
		
			goldeneggs1 = {
				"LevelGE_4",
				"LevelGE_3",
				"LevelGE_2",
				"LevelGE_1",
				"LevelGE_5",
				"LevelGE_6",
				"LevelGE_7",
				"LevelGE_8",
				"LevelGE_9",
				"LevelGE_10",
				"LevelGE_11",
				"LevelGE_12", -- does not work, replace with working one
				"LevelGE_13", -- does not work, replace with working one
				"LevelGE_14",
				"LevelGE_15",
				"LevelGE_16",
				"LevelGE_17",
				"LevelGE_18",
				"LevelGE_19",
				"LevelGE_20",
				"LevelGE_21",
				"LevelGE_22",
				"LevelGE_23",
			},
			packLite = {
				"Level1",
				"Level2",
				"Level7",
				"Level13",
				"Level17",
				"Level16",

				"LevelLite9",
				"LevelLite8",
				"LevelLite10",
				"LevelLite7",
				"LevelLite12",
				"LevelLite11", 
				
				"LevelLite13", 
				"LevelLite14", 
				"LevelLite15", 
				
				"LevelLite16", 
				"LevelLite17", 
				"LevelLite18", 
			},
			pack6 = {			
				"LevelP3_212",
				"LevelP3_134",
				"LevelP3_162",
				"LevelP3_271",
				"LevelP3_224",
				"LevelP3_253",
				"LevelP3_225",
				"LevelP3_232",
				"LevelP3_150",
				"LevelP3_211",
				
				"LevelP3_223",
				"LevelP3_226",
				"LevelP3_215",
				"LevelP3_220",
				"LevelP3_231",

			},
			pack7 = {
				"LevelP3_166",
				"LevelP3_237",
				"LevelP3_216",
				"LevelP3_298",
				"LevelP3_303",
				"LevelP3_214",
				"LevelP3_159",
				"LevelP3_164",
				"LevelP3_299",
				"LevelP3_302",
				"LevelP3_219",
				"LevelP3_163",
				"LevelP3_160",
				"LevelP3_161",
				"LevelP3_304",
			},
			pack8 = {
				"LevelP3_297",
				"LevelP3_221",
				"LevelP3_306",
				"LevelP3_301",
				"LevelP3_312",
				"LevelP3_309",
				"LevelP3_168",
				"LevelP3_311",
				"LevelP3_308",
				"LevelP3_310",
				"LevelP3_217",
				"LevelP3_307",
				"LevelP3_296",
--				"LevelP3_167",
				"LevelP3_149",
				"LevelP3_313",
			},
			pack9 = {			
				"LevelP4_421",
				"LevelP4_423",
				"LevelP4_424",
				"LevelP4_425",
				"LevelP4_426",
				"LevelP4_427",
				"LevelP4_428",
				"LevelP4_429",
				"LevelP4_431",
				"LevelP4_432",
				"LevelP4_433",
				"LevelP4_436",
				"LevelP4_439",
				"LevelP4_440",
				"LevelP4_441",

			},
			pack10 = {			
				"LevelP4_442",
				"LevelP4_443",
				"LevelP4_444",
				"LevelP4_445",
				"LevelP4_448",
				"LevelP4_449",
				"LevelP4_451",
				"LevelP4_452",
				"LevelP4_453",
				"LevelP4_454",

				"LevelP4_455",
				"LevelP4_457",
				"LevelP4_458",
				"LevelP4_459",
				"LevelP4_462",

			},
			pack11 = {			
				"LevelP4_463",
				"LevelP4_464",
				"LevelP4_465",
				"LevelP4_466",
				"LevelP4_467",
				"LevelP4_468",
				"LevelP4_469",
				"LevelP4_470",
				"LevelP4_471",
				"LevelP4_472",
				
				"LevelP4_473",
				"LevelP4_474",
				"LevelP4_475",
				"LevelP4_477",
				"LevelP4_478",

			},
			pack12 = {			
				"LevelP5_610",
				"LevelP5_356",
				"LevelP5_615",
				"LevelP5_616",
				"LevelP5_620",
				"LevelP5_341",
				"LevelP5_339",
				"LevelP5_628",
				"LevelP5_634",
				"LevelP5_640",
				"LevelP5_347",
				"LevelP5_357",
				"LevelP5_343",
				"LevelP5_352",
				"LevelP5_350",
			},
			pack13 = {			
				"LevelP5_345",
				"LevelP5_363",
				"LevelP5_631",
				"LevelP5_355",
				"LevelP5_348",
				"LevelP5_366",
				"LevelP5_635",
				"LevelP5_669",
				"LevelP5_623",
				"LevelP5_650",
				"LevelP5_664",
				"LevelP5_354",
				"LevelP5_360",
				"LevelP5_672",
				"LevelP5_361",
			},
			pack14 = {			
				"LevelP5_367",
				"LevelP5_671",
				"LevelP5_342",
				"LevelP5_364",
				"LevelP5_340",
				"LevelP5_362",
				"LevelP5_627",
				"LevelP5_648",
				"LevelP5_656",
				"LevelP5_351",
				"LevelP5_662",
				"LevelP5_668",
				"LevelP5_651",
				"LevelP5_663",
				"LevelP5_359",
				"LevelFB_1",
				"LevelFB_2",
				"LevelFB_3",
			},
			pack15 = {
				"LevelP6_8",
				"Level711",
				"LevelP6_1",
				"Level702",
				"LevelP6_2",
				"Level707",
				"LevelP6_28",
				"Level708",
				"Level709",
				"LevelP6_16",
				"LevelP6_22",
				"Level695",
				"LevelP6_12",
				"LevelP6_26",
				"LevelP6_20",
				
			},
			
			pack16 = {
				"LevelP6_4",
				"LevelP6_15",
				"Level703",
				"LevelP6_3",
				"Level704",
				"Level705",
				"LevelP6_23",
				"LevelP6_25",
				"Level697",
				"LevelP6_29",
				"LevelP6_5",
				"LevelP6_13",
				"LevelP6_19",
				"LevelP6_11",
				"Level701",
				
			},
			pack17 = {
		
				"LevelP6_27",
				"LevelP6_21",
				"LevelP6_18",
				"Level713_1",
				"LevelP6_24",
				"LevelP6_9",
				"Level707_1",
				"LevelP6_30",
				"LevelP6_10",
				"Level698_1",
				"LevelP6_14",
				"LevelP6_7",
				"LevelP6_17",
				"LevelP6_6",
				"Level711_1",
				
			},
		}
	end
	if isLiteVersion then
		levelOrder_packBasic = { levelOrder["pack1"] }
	else
		levelOrder_packBasic = { levelOrder["pack1"], levelOrder["pack2"], levelOrder["pack3"] }
	end
	levelOrder_packOne = { levelOrder["pack4"], levelOrder["pack5"] }
	levelOrder_packThree = { levelOrder["pack6"], levelOrder["pack7"], levelOrder["pack8"] }
	levelOrder_packFour = { levelOrder["pack9"], levelOrder["pack10"], levelOrder["pack11"] }
	levelOrder_packFive = { levelOrder["pack12"], levelOrder["pack13"], levelOrder["pack14"]  }
	-- ADDED
	levelOrder_packSix = { levelOrder["pack15"], levelOrder["pack16"], levelOrder["pack17"]  }
	levelOrder_goldenEggs = levelOrder["goldeneggs1"]
	levelOrder_allLevels = { levelOrder["pack1"], levelOrder["pack2"], levelOrder["pack3"],
							 levelOrder["pack4"], levelOrder["pack5"], 
							 levelOrder["pack6"], levelOrder["pack7"], levelOrder["pack8"],
							 levelOrder["pack9"], levelOrder["pack10"], levelOrder["pack11"],
							 levelOrder["pack12"], levelOrder["pack13"], levelOrder["pack14"],
							 -- ADDED
							 levelOrder["pack15"], levelOrder["pack16"], levelOrder["pack17"] }

	goldenEggLevelMapping = { Level1 = "LevelGE_4", Level2 = "LevelGE_3", Level3 = "LevelGE_2",
		Level4 = "SOUNDBOARD1", Level5 = "LevelGE_14", Level6 = "LevelGE_15", Level7 = "RADIO",
		Level8 = "LevelGE_1", Level9 = "LevelGE_5", Level10 = "LevelGE_6", Level11 = "LevelGE_7",
		Level12 = "KEYBOARD", Level13 = "LevelGE_8", Level14 = "LevelGE_9", Level15 = "LevelGE_10",
		Level16 = "LevelGE_11",Level17 = "SEQUENCER", Level18 = "LevelGE_16", Level19 = "LevelGE_17",
		Level20 = "LevelGE_18",	Level21 = "ACCORDION", Level22 = "LevelGE_19", Level23 = "LevelGE_20", 
		Level24 = "LevelGE_21", Level25 = "LevelGE_22", Level26 = "LevelGE_23"}
	
	-- remove FB levels from chinese builds
	if applyChinaRestictions then
		_G.table.remove(levelOrder["pack14"], #levelOrder["pack14"])
		_G.table.remove(levelOrder["pack14"], #levelOrder["pack14"])
		_G.table.remove(levelOrder["pack14"], #levelOrder["pack14"])
	end
	
	-- initialize settings
	if settings.flurryFirstTimeLevelCollected == nil then
		for k,v in _G.pairs(highscores) do
			print("highscores: "..k)
			for k2,v2 in _G.pairs(levelOrder_allLevels) do
				for k3,v3 in _G.pairs(v2) do
					if k == v3 then
						--print("level "..k.." is in pack: "..k2.." in position: "..k3)
						levelCompleteFirstTimeFlurryParams = {}
						levelCompleteFirstTimeFlurryParams["Level"] = k2  .. "-" .. k3
						logFlurryEventWithParams("Level complete first time", "levelCompleteFirstTimeFlurryParams")
					end
				end
			end
		end
		settings.flurryFirstTimeLevelCollected = true
	end
	--[[
	if settings.flurryFirstTimeLevelCompleteStars == nil then
		for k,v in _G.pairs(highscores) do
			if starTable[k] then
				for k2,v2 in _G.pairs(levelOrder_allLevels) do
					for k3,v3 in _G.pairs(v2) do
						levelCompleteFirstTimeFlurryParams = {}
						levelCompleteFirstTimeFlurryParams["Level"] = k2  .. "-" .. k3
						
						if k == v3 then
							if v.score >= starTable[k].goldScore then
								logFlurryEventWithParams("Level complete first time 3 stars", "levelCompleteFirstTimeFlurryParams")
								print("3 stars flurry events sent! level == "..k2.."-"..k3)
							end
							if v.score >= starTable[k].silverScore then
								logFlurryEventWithParams("Level complete first time 2 stars", "levelCompleteFirstTimeFlurryParams")								
								print("2 stars flurry events sent! level == "..k2.."-"..k3)
							end
						end
					end
				end
			end
		end
		settings.flurryFirstTimeLevelCompleteStars = true
	end]]

	if settings.audioEnabled == nil then
		settings.audioEnabled = true
	end
	
	if settings.currentZoomLevelMainMenu == nil then
		settings.currentZoomLevelMainMenu = 1.83
	end
	
	if settings.gfxLowQuality == nil then
		settings.gfxLowQuality = false
	end
	
	if deviceModel ~= "android" or isHDVersion then
		settings.gfxLowQuality = nil
	end
	
	if settings.wilhelmTell == nil then
		settings.wilhelmTell = false
	end
	
	if settings.bullsEye == nil then
		settings.bullsEye = false
	end
	
	if settings.cumulativeStars == nil then
		local score, gainedStarsBasic, totalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
		local score, gainedStarsOne, totalStars = calculateTotalScoreAndStars(levelOrder_packOne)
		local score, gainedStarsThree, totalStars = calculateTotalScoreAndStars(levelOrder_packThree)
		local score, gainedStarsFour, totalStars = calculateTotalScoreAndStars(levelOrder_packFour)
		
		settings.cumulativeStars = gainedStarsBasic + gainedStarsOne + gainedStarsThree + gainedStarsFour
	end
		
	if settings.gameStarts == nil then
		settings.gameStarts = 1
	end
	
	if settings.totalLevelsCompleted == nil then
		local totalLevelsBasic = calculateTotalLevelsCompleted(levelOrder_packBasic)
		local totalLevelsOne = calculateTotalLevelsCompleted(levelOrder_packOne)
		local totalLevelsThree = calculateTotalLevelsCompleted(levelOrder_packThree)
		local totalLevelsFour = calculateTotalLevelsCompleted(levelOrder_packFour)
		local totalLevelsFive = calculateTotalLevelsCompleted(levelOrder_packFive)
		
		settings.totalLevelsCompleted = totalLevelsBasic + totalLevelsOne + totalLevelsThree + totalLevelsFour + totalLevelsFive
	end
	
	if settings.cumulativeScore == nil then
		local totalScoreBasic, gainedStarsBasic, totalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
		local totalScoreOne, gainedStarsOne, totalStars = calculateTotalScoreAndStars(levelOrder_packOne)
		local totalScoreThree, gainedStarsThree, totalStars = calculateTotalScoreAndStars(levelOrder_packThree)
		local totalScoreFour, gainedStarsFour, totalStars = calculateTotalScoreAndStars(levelOrder_packFour)
		
		settings.cumulativeScore = _G.string.format("%d", totalScoreBasic + totalScoreOne + totalScoreThree + totalScoreFour)
	end
	
	if settings.gameRestarted == nil then
		settings.gameRestarted = 0
	end
	
	if settings.birdsShooted == nil then
		settings.birdsShooted = 0
	end
	
	if settings.lastOpenLevel == nil then
		--settings.lastOpenLevel = 1
		settings.lastOpenLevel = checkLastOpenLevel(levelOrder_packBasic)
	end
	
	if settings.lastOpenLevelLP2 == nil then
		--settings.lastOpenLevelLP2 = 1
		settings.lastOpenLevelLP2 = checkLastOpenLevel(levelOrder_packOne)
	end
	
	if settings.lastOpenLevelLP3 == nil then
		--settings.lastOpenLevelLP3 = 1
		settings.lastOpenLevelLP3 = checkLastOpenLevel(levelOrder_packThree)
	end
	
	if settings.lastOpenLevelLP4 == nil then
		--settings.lastOpenLevelLP4 = 1
		settings.lastOpenLevelLP4 = checkLastOpenLevel(levelOrder_packFour)
	end
	
	if settings.lastOpenLevelLP5 == nil then
		--settings.lastOpenLevelLP5 = 1
		settings.lastOpenLevelLP5 = checkLastOpenLevel(levelOrder_packFive)
	end
	-- ADDED
	if settings.lastOpenLevelLP6 == nil then
		--settings.lastOpenLevelLP5 = 1
		settings.lastOpenLevelLP6 = checkLastOpenLevel(levelOrder_packSix)
	end
	
	if not isLiteVersion then
		if settings.theme1Completed ~= true then
			local episode1firstPack = levelOrder_packBasic[1]
			if highscores[episode1firstPack[#episode1firstPack]] ~= nil 
			  and highscores[episode1firstPack[#episode1firstPack]].completed then
				settings.theme1Completed = true
			end
		end
		
		if settings.theme2Completed ~= true then
			local episode1secondPack = levelOrder_packBasic[2]
			if highscores[episode1secondPack[#episode1secondPack]] ~= nil 
			  and highscores[episode1secondPack[#episode1secondPack]].completed then
				settings.theme2Completed = true
			end
		end
		
		if settings.gameCompleted ~= true then
			local episode1lastPack = levelOrder_packBasic[3]
			if highscores[episode1lastPack[#episode1lastPack]] ~= nil 
			  and highscores[episode1lastPack[#episode1lastPack]].completed then
				settings.gameCompleted = true
				settings.lastOpenLevel = 64
			end
		end
		
		if settings.theme4Completed ~= true then
			local episode2firstPack = levelOrder_packOne[1]
			if highscores[episode2firstPack[#episode2firstPack]] ~= nil
			  and highscores[episode2firstPack[#episode2firstPack]].completed then
				settings.theme4Completed = true
			end
		end
		
		if settings.theme5Completed ~= true then
			local episode2lastPack = levelOrder_packOne[2]
			if highscores[episode2lastPack[#episode2lastPack]] ~= nil
			  and highscores[episode2lastPack[#episode2lastPack]].completed then
				settings.theme5Completed = true
				settings.lastOpenLevelLP2 = 43
			end
		end
		
		if settings.theme6Completed ~= true then
			local episode3firstPack = levelOrder_packThree[1]
			if highscores[episode3firstPack[#episode3firstPack]] ~= nil
			  and highscores[episode3firstPack[#episode3firstPack]].completed then
				settings.theme6Completed = true
			end
		end
		
		if settings.theme7Completed ~= true then
			local episode3secondPack = levelOrder_packThree[2]
			if highscores[episode3secondPack[#episode3secondPack]] ~= nil
			  and highscores[episode3secondPack[#episode3secondPack]].completed then
				settings.theme7Completed = true
			end
		end
		
		if settings.theme8Completed ~= true then
			local episode3lastPack = levelOrder_packThree[3]
			if highscores[episode3lastPack[#episode3lastPack]] ~= nil
			  and highscores[episode3lastPack[#episode3lastPack]].completed then
				settings.theme8Completed = true
				settings.lastOpenLevelLP3 = 46
			end
		end
		
		if settings.theme9Completed ~= true then
			local episode4firstPack = levelOrder_packFour[1]
			if highscores[episode4firstPack[#episode4firstPack]] ~= nil
			  and highscores[episode4firstPack[#episode4firstPack]].completed then
				settings.theme9Completed = true
			end
		end
		
		if settings.theme10Completed ~= true then
			local episode4secondPack = levelOrder_packFour[2]
			if highscores[episode4secondPack[#episode4secondPack]] ~= nil
			  and highscores[episode4secondPack[#episode4secondPack]].completed then
				settings.theme10Completed = true
			end
		end
		
		if settings.theme11Completed ~= true then
			local episode4lastPack = levelOrder_packFour[3]
			if highscores[episode4lastPack[#episode4lastPack]] ~= nil
			  and highscores[episode4lastPack[#episode4lastPack]].completed then
				settings.theme11Completed = true
			end
		end
		
		if settings.theme12Completed ~= true then
			local episode5lastPack = levelOrder_packFive[1]
			if highscores[episode5lastPack[#episode5lastPack]] ~= nil
			  and highscores[episode5lastPack[#episode5lastPack]].completed then
				settings.theme12Completed = true
			end
		end
		
		-- if settings.theme13Completed ~= true then
			-- local episode5lastPack = levelOrder_packFive[1]
			-- if highscores[episode5lastPack[#episode5lastPack]] ~= nil
			  -- and highscores[episode5lastPack[#episode5lastPack]].completed then
				-- settings.theme13Completed = true
			-- end
		-- end

		-- TODO: ADD FOR NEW EPISODE (6)!
		
		if settings.threeStars ~= true then
			local episode1TotalScore, episode1Stars, episode1TotalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
			if episode1Stars >= episode1TotalStars then
				settings.threeStars = true
			end
		end
	
		if settings.threeStarsLP2 ~= true then
			local episode2TotalScore, episode2Stars, episode2TotalStars = calculateTotalScoreAndStars(levelOrder_packOne)
			if episode2Stars >= episode2TotalStars then
				settings.threeStarsLP2 = true
			end
		end
	
		if settings.threeStarsLP3 ~= true then
			local episode3TotalScore, episode3Stars, episode3TotalStars = calculateTotalScoreAndStars(levelOrder_packThree)
			if episode3Stars >= episode3TotalStars then
				settings.threeStarsLP3 = true
			end
		end
		
		if settings.threeStarsLP4 ~= true then
			local episode4TotalScore, episode4Stars, episode4TotalStars = calculateTotalScoreAndStars(levelOrder_packFour)
			if episode4Stars >= episode4TotalStars then
				settings.threeStarsLP4 = true
			end
		end
		
		if settings.threeStarsLP5 ~= true then
			local episode5TotalScore, episode5Stars, episode5TotalStars = calculateTotalScoreAndStars(levelOrder_packFive)
			if episode5Stars >= episode5TotalStars then
				settings.threeStarsLP5 = true
			end
		end
		
	end
			
	if settings.currentLevelSelectionPages == nil then
		settings.currentLevelSelectionPages = {}
		settings.currentLevelSelectionPages.basic = 1
		settings.currentLevelSelectionPages.extra = 1
		settings.currentLevelSelectionPages.pack3 = 1
		settings.currentLevelSelectionPages.pack4 = 1
		settings.currentLevelSelectionPages.goldeneggs = 1
	end
		
	if settings.currentLevelSelectionPages.pack5 == nil then
		settings.currentLevelSelectionPages.pack5 = 1
	end
	-- ADDED
	if settings.currentLevelSelectionPages.pack6 == nil then
		settings.currentLevelSelectionPages.pack6 = 1
	end
	
	if settings.eaglesUsedIn == nil then
		settings.eaglesUsedIn = {}
		settings.eagleUsedTime = nil
	end
	
	if settings.mightyEagleEnabled ~= true and checkEagleStatusFromHighscores(levelOrder_allLevels) == true then
		settings.mightyEagleEnabled = true
		settings.mightyEagleUpsellPageViewed = true
	end	
	
	if settings.openGoldenEggLevels == nil then
		settings.openGoldenEggLevels = {}
		for k, v in _G.pairs(goldenEggLevelMapping) do
			if highscores[v] ~= nil then
				if highscores[v].completed then
					settings.openGoldenEggLevels[k] = 2
				else
					settings.openGoldenEggLevels[k] = 1
				end
			end
		end
	end
	
	-- code to unlock all golden eggs
	--[[
	if releaseBuild ~= true then
		if settings.openGoldenEggLevels == nil then
			settings.openGoldenEggLevels = {}
		end
		for k, v in _G.pairs(goldenEggLevelMapping) do
			if settings.openGoldenEggLevels[k] == nil then
				settings.openGoldenEggLevels[k] = 0
			end
		end
	end]]

	
	if settings.currentLevelSelectionPages.goldeneggs == nil then
		settings.currentLevelSelectionPages.goldeneggs = 1
	end
	if settings.currentLevelSelectionPages.pack3 == nil then
		settings.currentLevelSelectionPages.pack3 = 1
	end
	if settings.currentLevelSelectionPages.pack4 == nil then
		settings.currentLevelSelectionPages.pack4 = 1
	end
	
	if settings.selectedEpisode == nil then
		settings.selectedEpisode = 1
	end
	
	if settings.tutorials == nil then
		settings.tutorials = {}
	end
		
	if settings.gameStarts	== nil then
		settings.gameStarts = 1
	else
		if settings.playtime ~= nil then
			settings.averagePlaytime = _G.string.format("%.0f", settings.playtime / settings.gameStarts)
		end
		settings.gameStarts = settings.gameStarts + 1
	end
	
	saveLuaFileWrapper("settings.lua", "settings", true)
	
	createMenuPages()
	
	selectedMenuItem = -1
	setActiveMenuPage(mainMenu)
	oldMenuPage = nil
	
	if releaseBuild ~= true then
		settings.lastOpenLevel = 200
		settings.lastOpenLevelLP2 = 200
		settings.lastOpenLevelLP3 = 200
		settings.lastOpenLevelLP4 = 200
		settings.lastOpenLevelLP5 = 200
		settings.lastOpenLevelLP6 = 200
		settings.gameCompleted = true
	end
	
	limitLevels = false
	openDemoLevels = { 1, 6, 17, 26, 34, 36, 45, 49, 58 }
	
	newAnimation("settingsPageScroll", "HIDDEN", settingsPage, 600, 600)
	newAnimation("aboutPageScroll", "HIDDEN", about, 600, 600)
	newAnimation("ingamePausePageScroll", "HIDDEN", pausePage, 600, 600)
	
	popupPage = nil
	birdAnimations = {}
	
	baitSardine = {
        y = 0,
        x = 0,
        name = "BaitSardine_1",
        startNumber = nil,
        angle = 0,
        definition = "BaitSardine",
		}
	
	if isBetaVersion then
		setActivePopupPage(betaDisclaimerPage)
	end	
	
	if iapEnabled == true and settings.mightyEagleUpsellPageViewed ~= true and deviceModel ~= "android" and deviceModel ~= "palm" and deviceModel ~= "s60" then
		setActivePopupPage(mightyEagleDemoPage, nil, "first time start main menu")
		settings.mightyEagleUpsellPageViewed = true
	end
	
	--updateTrialEagleValueAtHighscores()
end

function getWorldLevelNumberCombination()
	local level = "999-999"
	if(currentWorldNumber ~= nil and currentLevelNumberInTheme ~= nil) then
		level = currentWorldNumber.."-"..currentLevelNumberInTheme	
	end
	return level
end

-- 1.5.4
--[[
function storeLevelStart(levelName)
	
	statistics = statistics or {}
	
	local level = getWorldLevelNumberCombination()
	
	if(statistics[level] == nil) then
		statistics[level] = {}
	end
	
	if(statistics[level].starts == nil) then
		statistics[level].starts = 1
	else
		statistics[level].starts = statistics[level].starts + 1		
	end
	print("(1.5.4) starts on level "..level.." = "..statistics[level].starts.."\n")

	--local flurryParams = {}
	--flurryParams["LevelName"] = levelName
	--flurryParams["attempts"] = statistics[levelName].starts
	--logFlurryEventWithParams("Level started", "flurryParams") 

end]]


function makeEditLevelPack(index, currentLevel)
	local page = {}
	
	page.name = "levelSelectionEdit" .. index
	page.theme = index
	page.back = nil
	page.font = fontBasic
	page.state = "READY"
	page.title = { text = "Theme" .. index, x = screenWidth * 0.5, y = 7, vanchor = "TOP", hanchor = "HCENTER" }
	page.items = {}	

	local linesPerPage = 3
	local itemsPerLine = 10
	local itemsPerPage = 21 --itemsPerLine * linesPerPage
	local levelNumber = currentLevel
	
	local pageLevelIndex = 0
	local currentPage = index
		
	if levelOrder.packs[currentPage] ~= nil then
		page.title.text = levelOrder.packs[currentPage]
		itemsPerPage = #levelOrder[levelOrder.packs[currentPage]]
	end	
	
	for line = 1, linesPerPage do
		local yDivider = line / (linesPerPage + 1)
		for index = 1, itemsPerLine do
			pageLevelIndex = pageLevelIndex + 1
			
			if pageLevelIndex <= itemsPerPage then
				levelNumber = levelNumber + 1
				_G.table.insert(page.items, 
					{
						boss = false,
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						themeIndex = page.theme,
						text =  "" .. levelNumber,
						folder = levelPath .. "/pack" .. currentPage .. "/",					
						filename = "Level" .. levelNumber,
						updateFunction = updateEditor, 
						x = screenWidth / (itemsPerLine + 0.5) * index - 12,
						y = screenHeight * yDivider,
					}
				)
				
				if levelOrder.packs[currentPage] ~= nil then
					page.items[#page.items].filename = levelOrder[levelOrder.packs[currentPage]][pageLevelIndex]
					page.items[#page.items].folder = levelPath .. "/" .. levelOrder.packs[currentPage] .. "/"
				end	

				if checkForLuaFile(page.items[#page.items].folder .. page.items[#page.items].filename .. ".lua") == true then
					page.items[#page.items].sprite = "LS_LEVEL_BG_NORMAL_OPEN_1"
					page.items[#page.items].sheet = "LEVELSELECTION_SHEET_1"
				end
			end
		end
	end
	
	return page, levelNumber
end

function startCrystal()

	if isCrystalUIShowing() then
		showCrystalInMainMenu = false
		deactivateCrystalUI()
	else
		showCrystalInMainMenu = true
		postTotalHighScores()
		logFlurryEvent("Crystal UI started")
		activateCrystalUI()
	end
	
end

function changeGFXQuality()
	settings.gfxLowQuality = not settings.gfxLowQuality
	getItemByName(mainMenu.items, "gfxQualityButtonOff").visible = settings.gfxLowQuality
end

-- <GameCenter>
-- <GameCenter getters>
function refreshLocalGameCenterData()
	print("gamelogic refreshLocalGameCenterData \n")
	if gameCenterEnabled and leaderboards then
		for k, v in _G.pairs(leaderboards) do
			getLeaderboardScoresForRange(v, 1, 1)
		end
	end
end

-- <leaderboard name getters>
function getLeaderboardNameForWorld(worldNumber)
	local lboardName = false
	if worldNumber <= #levelOrder_allLevels then
		lboardName = "totalScoreWorld" .. worldNumber
	end
	return lboardName
end

function getLeaderboardNameForEpisode(episodeNumber)
	local lboardName = false
	if episodeNumber <= #levelOrder.episodes then
		lboardName = "totalScoreEpisode" .. episodeNumber
	end
	return lboardName
end

function getLeaderboardNameForTotalScore()
	if isLiteVersion then
		return "liteTotalScore"
	else
		return "totalScore"
	end
end
-- </leaderboard name getters>

-- <score getters>
function getTotalScore()
	local totalScore = 0
	for i = 1, #levelOrder.episodes do
		for k, pack in _G.ipairs(levelOrder.episodes[i]) do
			for level = 1, #levelOrder[pack] do
				if highscores[levelOrder[pack][level]] ~= nil and highscores[levelOrder[pack][level]].score ~= nil then
					totalScore = totalScore + highscores[levelOrder[pack][level]].score
				end
			end
		end
	end
	return totalScore
end

function getEpisodeScore(episode)
	local totalScore = 0
		
	for k, pack in _G.ipairs(levelOrder.episodes[episode]) do
		for level = 1, #levelOrder[pack] do
			if highscores[levelOrder[pack][level]] ~= nil and highscores[levelOrder[pack][level]].score ~= nil then
				totalScore = totalScore + highscores[levelOrder[pack][level]].score
			end
		end
	end
	
	return totalScore
end

function getWorldScore(worldNumber)
	local totalScore = 0
	
	for level = 1, #levelOrder["pack" .. worldNumber] do
		if highscores[levelOrder["pack" .. worldNumber][level]] ~= nil and highscores[levelOrder["pack" .. worldNumber][level]].score ~= nil then
			totalScore = totalScore + highscores[levelOrder["pack" .. worldNumber][level]].score
		end
	end
	
	return totalScore
end
-- </score getters>

function getLevelPackNumber(levelName)
	if levelOrder and levelOrder.packs then
		for i = 1, #levelOrder.packs do
			local pack = levelOrder[levelOrder.packs[i]]
			for k, v in _G.pairs(pack) do
				if v == levelName then
					return i
				end
			end
		end
	end
end

function getLeaderboardNamesForLevel(levelName)
	if levelOrder and levelOrder.packs and levelOrder.episodes then
		local worldNumber = 0
		-- iterate through episodes
		for i = 1, #levelOrder.episodes do
			local epPack = levelOrder.episodes[i]
			local epTotalScore = 0
			-- iterate through worlds
			for j = 1, #epPack do
				worldNumber = worldNumber + 1
				-- iterate through levels
				for k, v in _G.pairs(levelOrder[epPack[j]]) do
					if v == levelName then
						local lboardNames = {}
						local lboardNameWorld = getLeaderboardNameForWorld(worldNumber)
						local lboardNameEpisode = getLeaderboardNameForEpisode(i)
						local lboardNameTotal = getLeaderboardNameForTotalScore()
						if lboardNameWorld then
							_G.table.insert(lboardNames, lboardNameWorld)
						end
						if lboardNameEpisode then
							_G.table.insert(lboardNames, lboardNameEpisode)
						end
						if lboardNameTotal then
							_G.table.insert(lboardNames, lboardNameTotal)
						end
						return lboardNames
					end
				end
			end
		end
	end
	return false
end
-- </GameCenter getters>

function setPostedStatus(levelName)
	if gameCenterEnabled and gameCenter and gameCenter.leaderboards and leaderboards then
		local lboardNames = getLeaderboardNamesForLevel(levelName)
		if lboardNames then
			for k, v in _G.pairs(lboardNames) do
				if gameCenter.leaderboards[leaderboards[v]] then
					print("Setting posted status to false for leaderboard " .. v .. ".\n")
					gameCenter.leaderboards[leaderboards[v]].posted = false
				end
			end
		end
	end
	
end

function setIndicatorPositions()
	if gameCenterEnabled and gameCenter and gameCenter.leaderboards and leaderboards then
		local bg = getItemByName(episodeSelectionPage.items[1].children, "ep1MeterBG")
		local _, bgH = _G.res.getSpriteBounds("", bg.sprite)
		if bg.x and bgH ~= 0 then
			
			for i = 1, #levelOrder.episodes do
				local lboardName = getLeaderboardNameForEpisode(i)
				if lboardName then
					local lboardId = leaderboards[lboardName]
					if lboardId then
						if gameCenter.leaderboards[lboardId] and gameCenter.leaderboards[lboardId].loading ~= true then
							local lboard = gameCenter.leaderboards[lboardId]
							if lboard.localRank and lboard.range then
								local localRank = lboard.localRank
								local range = lboard.range
								local posInMeter = 1
								if localRank > 0 then
									if range > 1 then
										posInMeter = (localRank - 1) / (range - 1)
									else -- range and rank are 1
										posInMeter = 0
									end
								end
								local epMeterIndicator = getItemByName(episodeSelectionPage.items[i].children, "ep" .. i .. "MeterIndicator")
								if epMeterIndicator then
									epMeterIndicator.x, epMeterIndicator.y = bg.x, _G.math.min(bg.y - (bgH * 0.645) + ((bgH * 0.645) * posInMeter), bg.y)
								else
									print("No global rank meter added to episode " .. i .. "\n")
								end
							end
						end
					end
				end
			end
			
		end
	end
end

function disableGameCenter()
	if mainMenu and mainMenu.items and episodeSelectionPage and episodeSelectionPage.items then
		local leaderboards = getItemByName(mainMenu.items, "leaderboards")
		if leaderboards then
			leaderboards.callFunction = initGameCenter
		end
		
		local achievements = getItemByName(mainMenu.items, "achievements")
		if achievements then
			achievements.callFunction = initGameCenter
		end
		
		for i = 1, #levelOrder.episodes do
			local epMeterBG = getItemByName(episodeSelectionPage.items, "ep" .. i .. "MeterBG")
			if epMeterBG then
				epMeterBG.visible = false
			end
			local epMeterIndicator = getItemByName(episodeSelectionPage.items, "ep" .. i .."MeterIndicator")
			if epMeterIndicator then
				epMeterIndicator.visible = false
			end
		end
	
	end
end

function enableGameCenter()
	if mainMenu and mainMenu.items and episodeSelectionPage and episodeSelectionPage.items then
		local leaderboards = getItemByName(mainMenu.items, "leaderboards")
		if leaderboards then
			leaderboards.callFunction = showLoadingLeaderboards
		end
		
		local achievements = getItemByName(mainMenu.items, "achievements")
		if achievements then
			achievements.callFunction = showLoadingAchievements
		end
		
		for i = 1, #levelOrder.episodes do
			local epMeterBG = getItemByName(episodeSelectionPage.items, "ep" .. i .. "MeterBG")
			if epMeterBG then
				epMeterBG.visible = true
			end
			local epMeterIndicator = getItemByName(episodeSelectionPage.items, "ep" .. i .."MeterIndicator")
			if epMeterIndicator then
				epMeterIndicator.visible = true
			end
		end

	end
end

-- GameCenter stuff ends.

function createBGBox(index)
	 local bgBox = {topLeft = "EPISODE"..index.."_TOP_LEFT", left = "EPISODE"..index.."_LEFT", bottomLeft = "EPISODE"..index.."_BOTTOM_LEFT", bottomMiddle = "EPISODE"..index.."_BOTTOM_MIDDLE",
					  bottomRight = "EPISODE"..index.."_BOTTOM_RIGHT", right = "EPISODE"..index.."_RIGHT", topRight = "EPISODE"..index.."_TOP_RIGHT", topMiddle = "EPISODE"..index.."_TOP_MIDDLE",
					  center = "EPISODE"..index.."_CENTER"}

	return bgBox
end


function createEpisodeBox(index)
	local scoreSpriteName = _G.res.getString("TEXTS_BASIC", "TEXT_SCORE_SPRITE")

	local updateFunc = nil
	if(index == 1) then
		updateFunc = gotoLevelSelection
	elseif(index == 2) then
		updateFunc = gotoLevelSelectionPack2
	elseif(index == 3) then
		updateFunc = gotoLevelSelectionPack3
	elseif(index == 4) then
		updateFunc = gotoLevelSelectionPack4
	elseif(index == 5) then
		updateFunc = gotoLevelSelectionPack5
	elseif(index == 6) then
		updateFunc = gotoLevelSelectionPack6
	end

	local scoreBox = {topLeft = "SCORE_TOP_LEFT", left = "SCORE_LEFT", bottomLeft = "SCORE_BOTTOM_LEFT", bottomMiddle = "SCORE_BOTTOM_MIDDLE",
					  bottomRight = "SCORE_BOTTOM_RIGHT", right = "SCORE_RIGHT", topRight = "SCORE_TOP_RIGHT", topMiddle = "SCORE_TOP_MIDDLE",
					  center = "SCORE_CENTER"}
	
	local featherBox = {topLeft = "", left = "EPISODE"..index.."_LEFT", bottomLeft = "EPISODE"..index.."_BOTTOM_LEFT", bottomMiddle = "EPISODE"..index.."_BOTTOM_MIDDLE",
					  bottomRight = "EPISODE"..index.."_BOTTOM_RIGHT", right = "EPISODE"..index.."_RIGHT", topRight = "", topMiddle = "",
					  center = "EPISODE"..index.."_CENTER"}
	
	
	_G.table.insert(episodeSelectionPage.items, index, 
	
	{
		name = "episode"..index, updateFunction = updateFunc, box = { topLeft = "EPISODE"..index.."_TOP_LEFT", left = "EPISODE"..index.."_LEFT", 
												   bottomLeft = "EPISODE"..index.."_BOTTOM_LEFT", bottomMiddle = "EPISODE"..index.."_BOTTOM_MIDDLE",
												   bottomRight = "EPISODE"..index.."_BOTTOM_RIGHT", right = "EPISODE"..index.."_RIGHT",
												   topRight = "EPISODE"..index.."_TOP_RIGHT", topMiddle = "EPISODE"..index.."_TOP_MIDDLE",
												   center = "EPISODE"..index.."_CENTER"}, sheet = "", hanchor = "HCENTER", vanchor = "VCENTER",
		children = { 
					 {name = "ep"..index.."FeathersBox", box = featherBox, hanchor = "HCENTER", vanchor = "TOP"},
					 {name = "ep"..index.."BgBox", box = createBGBox(index), hanchor = "HCENTER", vanchor = "VCENTER"},
					 {name = "episode"..index.."YellowLine", box = {topMiddle = "EPISODE_YELLOW_LINE"}, sheet = "", hanchor = "HCENTER", vanchor = "TOP"},					 {name = "ep"..index.."FeatherSprite", sprite = "EPISODE_SELECTION_FEATHER"},
					
					{name = "ep"..index.."Sprite", sprite = "LS_PACK_THUMB_0"..index..""},
					 {name = "ep"..index.."ScoreBox1", box = scoreBox, hanchor = "LEFT", vanchor = "BOTTOM"},
					 {name = "ep"..index.."ScoreBox2", box = scoreBox, hanchor = "RIGHT", vanchor = "BOTTOM"},
					 {name = "episode"..index.."Text", text = "TEXT_LP_NAME_"..index.."", hanchor="HCENTER", vanchor="BASELINE", font = fontBasic },
					 {name = "episode"..index.."Score", text = "", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" },
					 {name = "episode"..index.."Stars", text = "", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="BOTTOM" },
					 {name = "episode"..index.."ScoreText", sprite = scoreSpriteName, selectable = false, visible = false, vanchor = "TOP", hanchor = "HCENTER"},
--					 {name = "appStore", sprite = "AVAILABLE_ON_APP_STORE"},
					 {name = "ep"..index.."StarSprite", sprite = "LS_STAR_GOLD", hanchor = "HCENTER", vanchor = "VCENTER"},
					 {name = "episode"..index.."FeatherScore", text = "", font = "FONT_LS_SMALL", hanchor = "HCENTER", vanchor = "VCENTER"},					 
					 {name = "lock", sprite = "LS_LEVEL_PACK_LOCK"},
					}
	})
	
	if(index > 1) then
		--12
		local item = getItemByName(episodeSelectionPage.items, "episode"..index)
		
		_G.table.insert(item.children, 12,
			{name = "appStore", sprite = "AVAILABLE_ON_APP_STORE"}
		)
	
	end
end

function createMenuPages()

	createPopupBoxSpriteTables()
	
	
	mainMenu = {}
	episodeSelectionPage = {}
	gameStart = {}
	theme4Start = {}
	theme6Start = {}
	theme9Start = {}
	theme12Start = {}
	upsellPage = {}
	-- ADDED
	theme15Start = {}
	
	if gameCenterSupported then
		achievementPopUpPage = {
			name = "achievementPopUpPage",
			popup = true,
			back = nil,
			state = "NOTREADY",
			items = {
				{ name = "achievementBox", box = achievementBoxSprites, sheet = "", hanchor = "RIGHT", vanchor = "TOP",
					children = {{ name = "achievementIcon", sprite = "", selectable = false},
							   { name = "achievementTitle", text = "", font = "FONT_GAMECENTER_BASIC", selectable = false, hanchor = "HCENTER", vanchor = "TOP"},
							   { name = "achievementText", text = "", font = "FONT_GAMECENTER_BASIC", selectable = false, hanchor = "LEFT", vanchor = "BOTTOM"}},
			   }
			}
		}

	end
	
	goldenEggAchievedPage = {
		name = "goldenEggAchievedPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		items = {
			{sprite = "GOLDEN_EGG_5", selectable = false},
		}
	}	
	
	goldenEggStarAchievedPage = {
		name = "goldenEggStarAchievedPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		items = {
			{sprite = "GOLDEN_EGG_STAR", selectable = false},
			{sprite = "", selectable = false},
		}
	}
	
	boomerangBirdAchievedPage = {
		name = "boomerangBirdAchievedPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		items = {
			{sprite = "BIRD_BOOMERANG_STILL", selectable = false},
		}
	}
	
	--[[
	mightyEagleAvailablePage = {
		name = "mightyEagleAvailablePage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		items = {
			{sprite = "BUTTON_EAGLE", selectable = false},
		}
	}
	]]
	
	mightyEaglePaymentPage = {
		name = "mightyEaglePaymentPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		--backgroundBox = { name = "backgroundMightyEagle", sprites = whiteBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			--{sprite = "NOKIA_LOGO", selectable = false},
			--{ name = "confirming", sprite = "NOKIA_CONFIRMING_PAYMENT", selectable = false, visible = true},
			{ name = "progress", sprite = "IN_APP_LOADING", selectable = false, visible = false, angle = 0, timer = 0},
			--{sprite = "NOKIA_PAYMENT_SUCCESSFUL", selectable = false, visible = false},
			--{sprite = "NOKIA_OK", selectable = true, visible = false, callFunction = closeMightyEaglePurchasePage},
		}
	}
	
	--[[
	mightyEaglePurchasePage = {
		name = "mightyEaglePurchasePage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundBox = { name = "backgroundMightyEagle", sprites = whiteBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{sprite = "NOKIA_CONFIRM_PURCHASE", selectable = false},
			{sprite = "NOKIA_PHONE_BILL", selectable = false},
			{sprite = "NOKIA_MIGHTY_EAGLE", selectable = false},
			{sprite = "NOKIA_CONFIRM", selectable = true, updateFunction = updateMenu, page = mightyEaglePaymentPage},
			{sprite = "NOKIA_CANCEL", selectable = true, callFunction = closeMightyEaglePurchasePage},
			{sprite = "NOKIA_LOGO", selectable = false},
		}
	}
	]]
	
	--[[
	mightyEagleIngamePage = {
		name = "mightyEagleIngamePage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundMightyEagleDemo", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{ name = "eagle", sprite = "UPSELL_EAGLE_BG", selectable = false, hanchor = "RIGHT", vanchor = "BOTTOM"},
			{ name = "upsellBlackBox", box = blackBoxSprites, hanchor = "LEFT", vanchor = "VCENTER"},
			{ name = "upsellTitle", sprite = "UPSELL_EAGLE_LOGO", hanchor = "HCENTER", vanchor = "VCENTER" },
			{ name = "upsellText", text = "TEXT_EAGLE_UPSELL", hanchor = "LEFT", vanchor = "TOP"},
			{ name = "upsellPayOnce", text = "TEXT_EAGLE_UPSELL2", hanchor = "LEFT", vanchor = "TOP"},
			--{ name = "attemptsText", text = "Attempts left : ", hanchor = "LEFT", vanchor = "TOP"},
			{ name = "buttonYes", sprite = "EAGLE_SHOPPING_CART_BUTTON", selectable = true, callFunction = goToMightyEaglePaymentPage }, --updateFunction = updateMenu, page = mightyEaglePaymentPage},
			{ name = "trailerButton", sprite = "BUTTON_UPSELL_TRAILER", selectable = true, callFunction = gotoMightyEagleTrailer },
			--{ name = "tryButton", sprite = "BUTTON_EAGLE_BUY", selectable = true, callFunction = reduceEagles },

			{ name = "buttonNo", sprite = "BUTTON_UPSELL_NO", selectable = true, callFunction = cancelMightyEaglePurchase },
		}
	}]]
	
	mightyEagleDemoPage = {
		name = "mightyEagleDemoPage",
		popup = true,
		back = nil,
		state = "READY",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundMightyEagleDemo", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{ name = "eagle", sprite = "UPSELL_EAGLE_BG", selectable = false, hanchor = "RIGHT", vanchor = "BOTTOM"},
			{ name = "upsellBlackBox", box = blackBoxSprites, hanchor = "LEFT", vanchor = "VCENTER"},
			{ name = "upsellTitle", sprite = "UPSELL_EAGLE_LOGO", hanchor = "HCENTER", vanchor = "VCENTER" },
			{ name = "upsellText", text = "TEXT_EAGLE_UPSELL", hanchor = "LEFT", vanchor = "TOP"},
			{ name = "upsellPayOnce", text = "TEXT_EAGLE_UPSELL2", hanchor = "LEFT", vanchor = "TOP"},
			{ name = "buttonYes", sprite = "EAGLE_SHOPPING_CART_BUTTON", selectable = true, callFunction = goToMightyEaglePaymentPage }, --updateFunction = updateMenu, page = mightyEaglePaymentPage},
			{ name = "trailerButton", sprite = "BUTTON_UPSELL_TRAILER", selectable = true, callFunction = gotoMightyEagleTrailer },
			
			{ name = "buttonNo", sprite = "BUTTON_UPSELL_NO", selectable = true, callFunction = cancelMightyEaglePurchase },
		}
	}
	
	if isBetaVersion then
		betaDisclaimerPage = {
			name = "betaDisclaimerPage",
			popup = true,
			back = nil,
			state = "READY",
			backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
			backgroundBox = { name = "backgroundDisclaimer", sprites = whiteBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
			items = {
				{name = "disclaimerText", text = "Angry Birds Lite Beta is an unfinished version of the application and may not reflect the final gameplay. Please report any issues you might encounter by using the bug button in the main menu. \n\n", font = fontBasic, selectable = false, hanchor = "HCENTER", vanchor = "VCENTER"},
				{name = "okButton", sheet = "", sprite = "TUTORIAL_OK", selectable = true, callFunction = closeBetaDisclaimerPage},
				{name = "hideArea1", callFunction = closeBetaDisclaimerPage, activateOnRelease = true },
				{name = "hideArea2", callFunction = closeBetaDisclaimerPage, activateOnRelease = true },
				{name = "hideArea3", callFunction = closeBetaDisclaimerPage, activateOnRelease = true },
				{name = "hideArea4", callFunction = closeBetaDisclaimerPage, activateOnRelease = true },
			}
		
		}
	end
	
	
	levelSelectionPagesBasic = {}
	
	local itemsPerPage = 21
	local levelCount = itemsPerPage
	local pages = 3
		
	if isLiteVersion then
		pages = 3
		itemsPerPage = 18
		levelCount = 18
	end
	
	if settings.currentLevelSelectionPages.basic > pages then
		settings.currentLevelSelectionPages.basic = 1
	end
		
	levelSelectionPagesBasic.currentPage = settings.currentLevelSelectionPages.basic
	levelSelectionPagesBasic.currentOffset = (levelSelectionPagesBasic.currentPage - 1) * -screenWidth
	levelSelectionPagesBasic.targetOffset = levelSelectionPagesBasic.currentOffset


	levelSelectionPagesBasic.name = "levelSelectionPagesBasic"
	levelSelectionPagesBasic.pageCount = pages
	levelSelectionPagesBasic.levelsPerPage = levelCount
	levelSelectionPagesBasic.levelCount = levelCount
	levelSelectionPagesBasic.themes = { 1, 2, 3 }
	levelSelectionPagesBasic.back = episodeSelectionPage
	levelSelectionPagesBasic.font = fontBasic
	levelSelectionPagesBasic.backgroundDrawFunction = drawLevelSelectionBackground
	levelSelectionPagesBasic.state = "READY"
	levelSelectionPagesBasic.sound = "menu_confirm"
	levelSelectionPagesBasic.items = { 	
			{ name = "left", sprite = "LS_THEME_1_LEFT", selectable = false },
			{ name = "right", sprite = "LS_THEME_1_RIGHT", selectable = false },
			{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back" },
			{ name = "text_1", text = "1", font = "FONT_LS_SMALL", visible = false },
			{ name = "text_2", text = "2", font = "FONT_LS_SMALL", visible = false },
			{ name = "text_3", text = "3", font = "FONT_LS_SMALL", visible = false },
			{ name = "dot1", sprite = "LS_DOT_WHITE", visible = false },
			{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
			{ name = "dot3", sprite = "LS_DOT_BLACK", visible = false },
		}
	
	if deviceModel == "n900" then
		_G.table.insert(levelSelectionPagesBasic.items, { name = "overlay", sprite = "DIM_BLOCK", x = 0, y = 0, shade = 0, visible = false })
		_G.table.insert(levelSelectionPagesBasic.items, { name = "button1", sheet = "", sprite = "AVAILABLE_ON_APP_STORE", callFunction = gotoOviStore, selectable = false, visible = false})
		_G.table.insert(levelSelectionPagesBasic.items, { name = "button2", sheet = "", sprite = "UPSELL_BUTTON", callFunction = gotoOviStore, selectable = false, visible = false })

		if settings.currentLevelSelectionPages.basic >= 2 then
			getItemByName(levelSelectionPagesBasic.items, "overlay").shade = 0.65
		end
	end
	
	levelSelectionPagesBasic.firstLevelIndex = #levelSelectionPagesBasic.items + 1
	
	local tmpIndex = pages
	if isLiteVersion then
		tmpIndex = pages - 2
	end
	
	local levelNumber = 0
	for currentPage = 1, tmpIndex do	
		local pageLevelIndex = 0	
		for i = 1, itemsPerPage do
			pageLevelIndex = pageLevelIndex + 1
			levelNumber = levelNumber + 1
			item = {
					levelIndex = levelNumber,
					pageLevelIndex = pageLevelIndex,
					pageIndex = currentPage,
					themeIndex = levelSelectionPagesBasic.themes[currentPage],
					worldNumber = currentPage,
					text =  "" .. pageLevelIndex,
					folder = levelPath .. "/pack" .. currentPage .. "/",
					filename = levelOrder[levelOrder.packs[currentPage]][pageLevelIndex],
					sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. currentPage,
					sheet = "LEVELSELECTION_SHEET_1",
					updateFunction = updateGame, 
					activateOnRelease = true,
				}
			item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds(item.sheet, item.sprite)
			_G.table.insert(levelSelectionPagesBasic.items, item)
			
			if isLiteVersion then
				item.folder = levelPath .. "/packLite/"
			end
		end
		
	end
		
	if isLiteVersion then
		local lastItemIndex = #levelSelectionPagesBasic.items
		
		if deviceModel == "s60" then
			levelSelectionPagesBasic.items[1].visible = false
			levelSelectionPagesBasic.items[lastItemIndex].sprite = "OVI_BUTTON_MEDIUM"
			levelSelectionPagesBasic.items[lastItemIndex].sheet = ""
			levelSelectionPagesBasic.items[lastItemIndex].levelIndex = nil
			levelSelectionPagesBasic.items[lastItemIndex].text = nil
			levelSelectionPagesBasic.items[lastItemIndex].updateFunction = updateMenu
			levelSelectionPagesBasic.items[lastItemIndex].page = upsellPage
			levelSelectionPagesBasic.back = mainMenu
			levelSelectionPagesBasic.items[3].page = mainMenu
		else
			-- levelSelectionPagesBasic.items[lastItemIndex].sprite = "LS_FULL_VERSION"
			-- levelSelectionPagesBasic.items[lastItemIndex].sheet = ""
			-- levelSelectionPagesBasic.items[lastItemIndex].levelIndex = nil
			-- levelSelectionPagesBasic.items[lastItemIndex].text = nil
			--levelSelectionPagesBasic.items[lastItemIndex].callFunction = gotoFullVersionInAppStore
			--levelSelectionPagesBasic.items[lastItemIndex].updateFunction = nil
			-- levelSelectionPagesBasic.items[lastItemIndex].page = upsellPage
			-- levelSelectionPagesBasic.items[lastItemIndex].updateFunction = updateMenu
			levelSelectionPagesBasic.back = mainMenu
			getItemByName(levelSelectionPagesBasic.items, "back").page = mainMenu
			
			local appStore = { 
								levelIndex = "dummy",
								name = "appStore",
								callFunction = gotoFullVersionInAppStore,
								--page = upsellPage,
								sheet = "",
								sprite = "MENU_APP_STORE",
								activateOnRelease = true,
					}
			appStore.spriteWidth, appStore.spriteHeight = _G.res.getSpriteBounds(appStore.sheet, appStore.sprite)
			_G.table.insert(levelSelectionPagesBasic.items, appStore)		
			
			local upsellABFull = {
						levelIndex = "dummy",
						name = "upsellABFull",
						callFunction = gotoSeasonsInAppStore,
						sprite = "UPSELL_HALLOWEEN",
						sheet = "",
						activateOnRelease = true,
					}
			upsellABFull.spriteWidth, upsellABFull.spriteHeight = _G.res.getSpriteBounds(upsellABFull.sheet, upsellABFull.sprite)
			_G.table.insert(levelSelectionPagesBasic.items, upsellABFull)
			
			local upsellABNews = {
						levelIndex = "dummy",
						name = "upsellABNews",
						callFunction = gotoNewsLetter,
						sprite = "SIGNUP_NEWSLETTER",
						sheet = "",
						activateOnRelease = true,
					}
			upsellABNews.spriteWidth, upsellABNews.spriteHeight = _G.res.getSpriteBounds(upsellABNews.sheet, upsellABNews.sprite)
			_G.table.insert(levelSelectionPagesBasic.items, upsellABNews)
			
			local upsellShop = { 

								 levelIndex = "dummy",
								 name = "upsellShop", 
								 callFunction = gotoABShop, 
								 sprite = "UPSELL_SHOP", 
								 sheet = "", 
								 activateOnRelease = true, 
					}
			upsellShop.spriteWidth, upsellShop.spriteHeight = _G.res.getSpriteBounds("", upsellShop.sprite)
			_G.table.insert(levelSelectionPagesBasic.items, upsellShop)
		
		end
	end
	
	if isLiteVersion then
		levelSelectionPagesBasic.bgColors = { { red = 41, green = 118, blue = 142 }, { red = 21, green = 68, blue = 92 }, { red = 21, green = 68, blue = 92 } }
	else
		levelSelectionPagesBasic.bgColors = { { red = 41, green = 118, blue = 142 }, { red = 14, green = 104, blue = 79 }, { red = 161, green = 98, blue = 60 } }
	end
	levelSelectionPagesBasic.bgColor = { red = 41, green = 118, blue = 142 }
	levelSelectionPagesBasic.items[levelSelectionPagesBasic.firstLevelIndex].updateFunction = updateMenu
	levelSelectionPagesBasic.items[levelSelectionPagesBasic.firstLevelIndex].page = gameStart
	levelSelectionPagesBasic.items[levelSelectionPagesBasic.firstLevelIndex].needLoadingScreen = true

	
	if not isLiteVersion then
		
		levelSelectionPagesExtra = {}
			
		local itemsPerPage = 21
		local levelCount = itemsPerPage
		local pages = 2
			
		if settings.currentLevelSelectionPages.extra > pages then
			settings.currentLevelSelectionPages.extra = 1
		end
			
		levelSelectionPagesExtra.currentPage = settings.currentLevelSelectionPages.extra
		levelSelectionPagesExtra.currentOffset = (levelSelectionPagesExtra.currentPage - 1) * -screenWidth
		levelSelectionPagesExtra.targetOffset = levelSelectionPagesExtra.currentOffset			
		
		levelSelectionPagesExtra.name = "levelSelectionPagesExtra"
		levelSelectionPagesExtra.pageCount = pages
		levelSelectionPagesExtra.levelsPerPage = levelCount
		levelSelectionPagesExtra.themes = { 4, 5 }
		levelSelectionPagesExtra.back = episodeSelectionPage
		levelSelectionPagesExtra.font = fontBasic
		levelSelectionPagesExtra.state = "READY"
		levelSelectionPagesExtra.sound = "menu_confirm"
		levelSelectionPagesExtra.items = { 	
				{ name = "left", sprite = "LS_THEME_4_LEFT", selectable = false },
				{ name = "right", sprite = "LS_THEME_4_RIGHT", selectable = false },
				{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back" },
				{ name = "text_4", text = "4", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_5", text = "5", font = "FONT_LS_SMALL", visible = false },
				{ name = "dot1", sprite = "LS_DOT_WHITE", visible = false },
				{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false }
			}
				
		levelSelectionPagesExtra.firstLevelIndex = #levelSelectionPagesExtra.items + 1
		levelSelectionPagesExtra.backgroundDrawFunction = drawLevelSelectionBackground
			
		local levelNumber = 0
		for currentPage = 1, pages do	
			local pageLevelIndex = 0
			for i = 1, itemsPerPage do
				pageLevelIndex = pageLevelIndex + 1
				levelNumber = levelNumber + 1
				item = {
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						pageIndex = currentPage,
						themeIndex = levelSelectionPagesExtra.themes[currentPage],
						worldNumber = currentPage + 3,
						text =  "" .. pageLevelIndex,
						folder = levelPath .. "/pack" .. currentPage + 3 .. "/",
						filename = levelOrder[levelOrder.packs[currentPage + 3]][pageLevelIndex],
						sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. currentPage,
						sheet = "LEVELSELECTION_SHEET_1",
						updateFunction = updateGame, 
						activateOnRelease = true,
					}
				item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds(item.sheet, item.sprite)
				_G.table.insert(levelSelectionPagesExtra.items, item)
			end
		end


		levelSelectionPagesExtra.bgColors = { { red = 105, green = 184, blue = 225 }, { red = 184, green = 152, blue = 91 } }
		levelSelectionPagesExtra.bgColor =  { red = 105, green = 184, blue = 225 }
		
		levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].updateFunction = updateMenu
		levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].page = theme4Start
		levelSelectionPagesExtra.items[levelSelectionPagesExtra.firstLevelIndex].needLoadingScreen = true
			
		levelSelectionPagesGoldenEggs = { {} }
		levelCount = 26
		
		-- golden eggs menu
		local pages = 2
		if settings.currentLevelSelectionPages.goldeneggs > pages then
			settings.currentLevelSelectionPages.goldeneggs = 1
		end
		levelSelectionPagesGoldenEggs[1].currentPage = 1
		levelSelectionPagesGoldenEggs[1].currentOffset = 0
		levelSelectionPagesGoldenEggs[1].targetOffset = 0
		levelSelectionPagesGoldenEggs[1].pageCount = 2
		levelSelectionPagesGoldenEggs[1].name = "levelSelectionPagesGoldenEggs" .. 1
		levelSelectionPagesGoldenEggs[1].pageNumber = 1
		levelSelectionPagesGoldenEggs[1].levelCount = levelCount
		levelSelectionPagesGoldenEggs[1].back = episodeSelectionPage
		levelSelectionPagesGoldenEggs[1].font = fontBasic
		levelSelectionPagesGoldenEggs[1].state = "READY"
		levelSelectionPagesGoldenEggs[1].sound = "menu_confirm"
		levelSelectionPagesGoldenEggs[1].themes = {1, 2}
		levelSelectionPagesGoldenEggs[1].items = {}
		levelSelectionPagesGoldenEggs[1].backgroundDrawFunction = drawLevelSelectionBackground
		levelSelectionPagesGoldenEggs[1].drawSpritesFirst = false
		levelSelectionPagesGoldenEggs[1].dragging = false
			
		
		
					
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{ name = "puzzledBird", sheet = puzzledBirdSheet, sprite = "GOLDEN_EGG_PUZZLED_BIRD"})		
				
		
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, { name = "text_1", text = "1", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="VCENTER", visible = false, })
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, { name = "text_2", text = "2", font = "FONT_LS_SMALL", hanchor="HCENTER", vanchor="VCENTER", visible = false })
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,	{ name = "dot1", sprite = "LS_DOT_WHITE", visible = false})
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, { name = "dot2", sprite = "LS_DOT_BLACK", visible = false})
				
		
			
		
	
		
		levelSelectionPagesGoldenEggs[1].firstLevelIndex = #levelSelectionPagesGoldenEggs[1].items + 1
		--[[
		geSprites = {"EGG_SILHOUETTE_2","EGG_SILHOUETTE_4","EGG_SILHOUETTE_1","EGG_SILHOUETTE_3",
					 "EGG_SILHOUETTE_5","EGG_SILHOUETTE_7","EGG_SILHOUETTE_6","GOLDEN_EGG_2", "GOLDEN_EGG_3",
					 "GOLDEN_EGG_3","GOLDEN_EGG_3", "GOLDEN_EGG_1", "GOLDEN_EGG_3","GOLDEN_EGG_1",
					 "GOLDEN_EGG_1","GOLDEN_EGG_1","GOLDEN_EGG_3","GOLDEN_EGG_1","GOLDEN_EGG_1",
					 "GOLDEN_EGG_1","GOLDEN_EGG_3","EGG_SUPER_BOWL",  
					 -- 1.6.0
					 "GOLDEN_EGG_1","GOLDEN_EGG_3","GOLDEN_EGG_3","GOLDEN_EGG_3"
					 
					 }
		geChildren = {
			 {{ sprite = "EGG_HINT_TUTORIAL", visible = false}, }, 
			 {{ sprite = "EGG_HINT_ROCKET", visible = false}, },
			 {{ sprite = "EGG_HINT_BEACH_BALL", visible = false}, },		
			 {{ sprite = "EGG_HINT_3STAR_EP1", visible = false}, },	
			 {{ sprite = "EGG_HINT_ABOUT", visible = false}, },
			 {{ sprite = "EGG_HINT_TREASURE_CHEST", visible = false}, },
			 {{ sprite = "EGG_HINT_3STAR_EP2", visible = false}, },
		}
		
		geFileNames = {
			levelOrder_goldenEggs[1], levelOrder_goldenEggs[2],levelOrder_goldenEggs[3], nil, levelOrder_goldenEggs[14],
			levelOrder_goldenEggs[15], nil,levelOrder_goldenEggs[4],levelOrder_goldenEggs[5],  levelOrder_goldenEggs[6],
			levelOrder_goldenEggs[7], nil,levelOrder_goldenEggs[8],levelOrder_goldenEggs[9],  levelOrder_goldenEggs[10],		
			levelOrder_goldenEggs[11], nil,levelOrder_goldenEggs[16],levelOrder_goldenEggs[17],  levelOrder_goldenEggs[18],		
			nil, levelOrder_goldenEggs[19],
			--1.6.0
			levelOrder_goldenEggs[20],levelOrder_goldenEggs[21], levelOrder_goldenEggs[22],levelOrder_goldenEggs[23],
			
		}
		
		
		for i = 1, levelCount do
			_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
				{
					pageLevelIndex = i,
					levelIndex = i,
					filename = geFileNames[i],
					
					folder = "levels/goldeneggs1/",
					updateFunction = updateGame, 
					page = levelSelectionPagesGoldenEggs[1],
					sprite = geSprites[i],
					children = geChildren[i],
					activateOnRelease = true,
					selectable = false,
					worldNumber = -1
				})		
				
				if(i == 4) then
					levelSelectionPagesGoldenEggs[1].items[i].soundboard = "SOUNDBOARD1"
					levelSelectionPagesGoldenEggs[1].items[i].updateFunction = updateSoundboard
					levelSelectionPagesGoldenEggs[1].items[i].folder = nil					
				end

				if(i == 7) then
					levelSelectionPagesGoldenEggs[1].items[i].soundboard = "RADIO"
					levelSelectionPagesGoldenEggs[1].items[i].updateFunction = updateSoundboard
					levelSelectionPagesGoldenEggs[1].items[i].folder = nil					
				end

				if(i == 12) then
					levelSelectionPagesGoldenEggs[1].items[i].soundboard = "KEYBOARD"
					levelSelectionPagesGoldenEggs[1].items[i].updateFunction = updateSoundboard
					levelSelectionPagesGoldenEggs[1].items[i].folder = nil					
				end				
				
				if(i == 17) then
					levelSelectionPagesGoldenEggs[1].items[i].soundboard = "SEQUENCER"
					levelSelectionPagesGoldenEggs[1].items[i].updateFunction = updateSoundboard
					levelSelectionPagesGoldenEggs[1].items[i].folder = nil					
				end

				if(i == 21) then
					levelSelectionPagesGoldenEggs[1].items[i].soundboard = "ACCORDION"
					levelSelectionPagesGoldenEggs[1].items[i].updateFunction = updateSoundboard
					levelSelectionPagesGoldenEggs[1].items[i].folder = nil					
				end
				
				

		end]]
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 1,
				levelIndex = 1,
				filename = levelOrder_goldenEggs[1],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame, 
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_2",
				children = { { sprite = "EGG_HINT_TUTORIAL", visible = false}, },
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 2,
				levelIndex = 2,
				filename = levelOrder_goldenEggs[2],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame, 
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_4",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_ROCKET", visible = false}, },
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 3,
				levelIndex = 3,
				filename = levelOrder_goldenEggs[3],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame,
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_1",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_BEACH_BALL", visible = false}, },
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 4,
				levelIndex = 4,
				updateFunction = updateGame, 
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_3",
				updateFunction = updateSoundboard,
				soundboard = "SOUNDBOARD1",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_3STAR_EP1", visible = false}, },
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				pageLevelIndex = 5,
				levelIndex = 5,
				filename = levelOrder_goldenEggs[14],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame,
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_5",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_ABOUT", visible = false}, },
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				pageLevelIndex = 6,
				levelIndex = 6,
				filename = levelOrder_goldenEggs[15],
				folder = "levels/goldeneggs1/",
				updateFunction = updateGame,
				page = levelSelectionPagesGoldenEggs[1],
				sprite = "EGG_SILHOUETTE_7",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_TREASURE_CHEST", visible = false}, },
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 7,
				levelIndex = 7,
				sprite = "EGG_SILHOUETTE_6",
				updateFunction = updateSoundboard,
				soundboard = "RADIO",
				activateOnRelease = true,
				children = { { sprite = "EGG_HINT_3STAR_EP2", visible = false}, },
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 8,
				levelIndex = 8,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[4],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_2",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 9,
				levelIndex = 9,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[5],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_3",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 10,
				levelIndex = 10,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[6],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_3",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 11,
				levelIndex = 11,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[7],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_3",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 12,
				levelIndex = 12,
				sprite = "GOLDEN_EGG_1",
				updateFunction = updateSoundboard,
				soundboard = "KEYBOARD",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 13,
				levelIndex = 13,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[8],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_3",
				selectable = false,
				worldNumber = -1
				
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 14,
				levelIndex = 14,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[9],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_1",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 15,
				levelIndex = 15,
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[10],
				folder = "levels/goldeneggs1/",
				sprite = "GOLDEN_EGG_1",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 16,
				levelIndex = 16,
				sprite = "GOLDEN_EGG_1",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[11],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 17,
				levelIndex = 17,
				sprite = "GOLDEN_EGG_3",
				updateFunction = updateSoundboard,
				soundboard = "SEQUENCER",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 18,
				levelIndex = 18,
				sprite = "GOLDEN_EGG_1",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[16],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 19,
				levelIndex = 19,
				sprite = "GOLDEN_EGG_1",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[17],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 20,
				levelIndex = 20,
				sprite = "GOLDEN_EGG_1",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[18],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 21,
				levelIndex = 21,
				sprite = "GOLDEN_EGG_3",
				updateFunction = updateSoundboard,
				soundboard = "ACCORDION",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 22,
				levelIndex = 22,
				sprite = "EGG_SUPER_BOWL",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[19],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})

		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 23,
				levelIndex = 23,
				sprite = "GOLDEN_EGG_3",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[20],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})

		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 24,
				levelIndex = 24,
				sprite = "GOLDEN_EGG_3",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[21],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 25,
				levelIndex = 25,
				sprite = "GOLDEN_EGG_3",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[22],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{
				page = levelSelectionPagesGoldenEggs[1],
				pageLevelIndex = 26,
				levelIndex = 26,
				sprite = "GOLDEN_EGG_1",
				updateFunction = updateGame, 
				filename = levelOrder_goldenEggs[23],
				folder = "levels/goldeneggs1/",
				activateOnRelease = true,
				selectable = false,
				worldNumber = -1
			})
			
			
		for i = 1, levelCount do
			if i == 22 then
				_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
				{ sprite = "EGG_SUPER_BOWL_STAR",
				  visible = false,
				  selectable = false,
				  levelIndex = i+1,
				})
			else
				_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
				{ sprite = "GOLDEN_EGG_CARVED_STAR",
				  visible = false,
				  selectable = false,
				  levelIndex = i+1,
				})
			end
		end
		
		if bingIsEnabled == true then
			local bingButton = {name = "bingButton", 
							  pageLevelIndex = 17,
							  levelIndex = 17,
							  callFunction = bingSearchGE,
							  callParam1 = "angry+birds+golden+egg",
							  sprite = "BING_EGG_BUTTON", 
							  sheet = "", 
							  activateOnRelease = true, 
							  selectable = true}
			bingButton.spriteWidth, bingButton.spriteHeight = _G.res.getSpriteBounds(bingButton.sheet, bingButton.sprite)
			_G.table.insert(levelSelectionPagesGoldenEggs[1].items, bingButton)
		end
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back" } )
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items, 
			{ name = "overlay", itemDrawFunction = goldenEggMenuDimDraw, sprite = "DIM_BLOCK", shade = 0, visible = false, fadeSpeed = 0, x = 0, y = 0 })
		
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{name = "tipBubble", sprite = "EGG_THOUGHT_BUBBLE_3", 
				children = { {sprite = "EGG_THOUGHT_BUBBLE_2"},
						     {sprite = "EGG_THOUGHT_BUBBLE_1"},
							}
			})	
			
		_G.table.insert(levelSelectionPagesGoldenEggs[1].items,
			{name = "tipContent", sprite = "EGG_HINT_TREASURE_CHEST", visible = false,
			})
		levelSelectionPagesGoldenEggs[1].bgColors = {{ red = 238, green = 176, blue = 66 }, { red = 238, green = 176, blue = 66 }}
		levelSelectionPagesGoldenEggs[1].bgColor = { red = 238, green = 176, blue = 66 }
		
		levelSelectionPagesPack3 = {}
			
		local itemsPerPage = 15
		local levelCount = itemsPerPage
		local pages = 3
			
		if settings.currentLevelSelectionPages.pack3 > pages then
			settings.currentLevelSelectionPages.pack3 = 1
		end
			
		levelSelectionPagesPack3.currentPage = settings.currentLevelSelectionPages.pack3
		levelSelectionPagesPack3.currentOffset = (levelSelectionPagesPack3.currentPage - 1) * -screenWidth
		levelSelectionPagesPack3.targetOffset = levelSelectionPagesPack3.currentOffset
			
			
		levelSelectionPagesPack3.name = "levelSelectionPagesPack3"
		levelSelectionPagesPack3.pageCount = pages
		levelSelectionPagesPack3.levelsPerPage = levelCount
		levelSelectionPagesPack3.themes = { 6, 7, 8 }
		levelSelectionPagesPack3.back = episodeSelectionPage
		levelSelectionPagesPack3.font = fontBasic
		levelSelectionPagesPack3.state = "READY"
		levelSelectionPagesPack3.sound = "menu_confirm"
		levelSelectionPagesPack3.items = { 	
				{ name = "left", sprite = "LS_THEME_6_LEFT", selectable = false },
				{ name = "right", sprite = "LS_THEME_6_RIGHT", selectable = false },
				{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back" },
				{ name = "text_6", text = "6", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_7", text = "7", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_8", text = "8", font = "FONT_LS_SMALL", visible = false },
				{ name = "dot1", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot3", sprite = "LS_DOT_BLACK", visible = false },
			}
				
			levelSelectionPagesPack3.firstLevelIndex = #levelSelectionPagesPack3.items + 1
			levelSelectionPagesPack3.backgroundDrawFunction = drawLevelSelectionBackground
			
		local levelNumber = 0
		for currentPage = 1, pages do
			local pageLevelIndex = 0
			for i = 1, itemsPerPage do
				pageLevelIndex = pageLevelIndex + 1
				levelNumber = levelNumber + 1
				item = {
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						pageIndex = currentPage,
						themeIndex = levelSelectionPagesPack3.themes[currentPage],
						worldNumber = currentPage + 5,
						text =  "" .. pageLevelIndex,
						folder = levelPath .. "/pack" .. currentPage + 5 .. "/",
						filename = levelOrder[levelOrder.packs[currentPage + 5]][pageLevelIndex],
						sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. levelSelectionPagesPack3.themes[currentPage],
						updateFunction = updateGame, 
						activateOnRelease = true,
					}
				item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds("", item.sprite)
				_G.table.insert(levelSelectionPagesPack3.items, item)
					
			end	
			if currentPage == 3 then
				--golden egg
				_G.table.insert(levelSelectionPagesPack3.items, 
					{
					name = "goldenEgg",
					sprite = "GOLDEN_EGG_5",
					callFunction = episode3LevelSelectionEggAchieved
					})
			end
		end
				
		levelSelectionPagesPack3.bgColors = { { red = 82, green = 103, blue = 43 }, { red = 21, green = 31, blue = 63 }, { red = 190, green = 219, blue = 229 } }
		levelSelectionPagesPack3.bgColor = { red = 82, green = 103, blue = 43 }
		
		levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].updateFunction = updateMenu
		levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].page = theme6Start
		levelSelectionPagesPack3.items[levelSelectionPagesPack3.firstLevelIndex].needLoadingScreen = true

		
		levelSelectionPagesPack4 = {}
			
		local itemsPerPage = 15
		local levelCount = itemsPerPage
		local pages = 3
		
		if settings.currentLevelSelectionPages.pack4 > pages then
			settings.currentLevelSelectionPages.pack4 = 1
		end
			
		levelSelectionPagesPack4.currentPage = settings.currentLevelSelectionPages.pack4
		levelSelectionPagesPack4.currentOffset = (levelSelectionPagesPack4.currentPage - 1) * -screenWidth
		levelSelectionPagesPack4.targetOffset = levelSelectionPagesPack4.currentOffset
		
		
		levelSelectionPagesPack4.name = "levelSelectionPagesPack4"
		levelSelectionPagesPack4.pageCount = pages
		levelSelectionPagesPack4.levelsPerPage = levelCount
		levelSelectionPagesPack4.themes = { 9, 10, 11}
		levelSelectionPagesPack4.back = episodeSelectionPage
		levelSelectionPagesPack4.font = fontBasic
		levelSelectionPagesPack4.state = "READY"
		levelSelectionPagesPack4.sound = "menu_confirm"
		levelSelectionPagesPack4.items = { 	
				{ name = "left", sprite = "LS_THEME_9_LEFT", selectable = false },
				{ name = "right", sprite = "LS_THEME_9_RIGHT", selectable = false },
				{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back" },
				{ name = "text_9", text = "9", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_10", text = "10", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_11", text = "11", font = "FONT_LS_SMALL", visible = false },
				{ name = "dot1", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot3", sprite = "LS_DOT_BLACK", visible = false },
			}
				
			levelSelectionPagesPack4.firstLevelIndex = #levelSelectionPagesPack4.items + 1
			levelSelectionPagesPack4.backgroundDrawFunction = drawLevelSelectionBackground
		
		local levelNumber = 0
		for currentPage = 1, pages do
			local pageLevelIndex = 0
			for i = 1, itemsPerPage do
				pageLevelIndex = pageLevelIndex + 1
				levelNumber = levelNumber + 1
				item = {
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						pageIndex = currentPage,
						themeIndex = levelSelectionPagesPack4.themes[currentPage],
						worldNumber = currentPage + 8,
						text =  "" .. pageLevelIndex,
						folder = levelPath .. "/pack" .. currentPage + 8 .. "/",
						filename = levelOrder[levelOrder.packs[currentPage + 8]][pageLevelIndex],
						sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. levelSelectionPagesBasic.themes[currentPage], -- uses buttons from episode 1
						sheet = "LEVELSELECTION_SHEET_1",
						updateFunction = updateGame, 
						activateOnRelease = true,
					}
				item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds(item.sheet, item.sprite)
				_G.table.insert(levelSelectionPagesPack4.items, item)
			end
		end
					
		levelSelectionPagesPack4.bgColors = { { red = 41, green = 118, blue = 142 }, { red = 105, green = 184, blue = 225 }, { red = 82, green = 103, blue = 43 } }
		levelSelectionPagesPack4.bgColor = { red = 41, green = 118, blue = 142 }
		
		levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].updateFunction = updateMenu
		levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].page = theme9Start
		levelSelectionPagesPack4.items[levelSelectionPagesPack4.firstLevelIndex].needLoadingScreen = true
	
		levelSelectionPagesPack5 = {}
			
		local itemsPerPage = 15
		local levelCount = itemsPerPage
		local pages = 4
		
		if settings.currentLevelSelectionPages.pack5 > pages then
			settings.currentLevelSelectionPages.pack5 = 1
		end
			
		levelSelectionPagesPack5.currentPage = settings.currentLevelSelectionPages.pack5
		levelSelectionPagesPack5.currentOffset = (levelSelectionPagesPack5.currentPage - 1) * -screenWidth
		levelSelectionPagesPack5.targetOffset = levelSelectionPagesPack5.currentOffset
		
		
		levelSelectionPagesPack5.name = "levelSelectionPagesPack5"
		
		levelSelectionPagesPack5.pageCount = pages
		
		if applyChinaRestictions then
			levelSelectionPagesPack5.pageCount = pages - 1
		end
		
		levelSelectionPagesPack5.levelsPerPage = levelCount
		levelSelectionPagesPack5.themes = {12, 13, 14, 14}
		levelSelectionPagesPack5.back = episodeSelectionPage
		levelSelectionPagesPack5.font = fontBasic
		levelSelectionPagesPack5.state = "READY"
		levelSelectionPagesPack5.sound = "menu_confirm"
		levelSelectionPagesPack5.items = { 	
				{ name = "left", sprite = "LS_THEME_1_LEFT", selectable = false },
				{ name = "right", sprite = "LS_THEME_12_RIGHT", selectable = false },
				{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back" },
				{ name = "text_12", text = "12", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_13", text = "13", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_14", text = "14", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_14B", text = "|", font = "FONT_LS_SMALL", visible = false },
				{ name = "dot1", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot3", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot4", sprite = "LS_DOT_BLACK", visible = false },
			}
				
			levelSelectionPagesPack5.firstLevelIndex = #levelSelectionPagesPack5.items + 1
			levelSelectionPagesPack5.backgroundDrawFunction = drawLevelSelectionBackground
		
		
		
		
		local levelNumber = 0
		for currentPage = 1, pages -1 do
			local pageLevelIndex = 0
			for i = 1, itemsPerPage do
				pageLevelIndex = pageLevelIndex + 1
				levelNumber = levelNumber + 1
				item = {
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						pageIndex = currentPage,
						themeIndex = levelSelectionPagesPack5.themes[currentPage],
						worldNumber = currentPage + 11,
						text =  "" .. pageLevelIndex,
						folder = levelPath .. "/pack" .. currentPage + 11 .. "/",
						filename = levelOrder[levelOrder.packs[currentPage + 11]][pageLevelIndex],
						sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. levelSelectionPagesBasic.themes[currentPage], -- uses buttons from episode 1
						sheet = "LEVELSELECTION_SHEET_1",
						updateFunction = updateGame, 
						activateOnRelease = true,
					}

				item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds(item.sheet, item.sprite)
				_G.table.insert(levelSelectionPagesPack5.items, item)
			end
		end
		
		if not applyChinaRestictions then
			local pageLevelIndex = 15
			local currentPage = 3
			for i = 1, 3 do
				pageLevelIndex = pageLevelIndex + 1
				levelNumber = levelNumber + 1
				item = {
						name = "extraLevel"..i,
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						pageIndex = currentPage,
						themeIndex = levelSelectionPagesPack5.themes[currentPage],
						worldNumber = currentPage + 11,
						text =  "" .. pageLevelIndex,
						folder = levelPath .. "/pack" .. currentPage + 11 .. "/",
						filename = levelOrder[levelOrder.packs[currentPage + 11]][pageLevelIndex],
						sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. levelSelectionPagesBasic.themes[currentPage], -- uses buttons from episode 1
						sheet = "LEVELSELECTION_SHEET_1",
						updateFunction = updateGame, 
						activateOnRelease = true,
					}

				item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds(item.sheet, item.sprite)
				_G.table.insert(levelSelectionPagesPack5.items, item)
			end
			local fbButton = {name = "fbButton", 
							  pageLevelIndex = 17,
							  levelIndex = 17,
							  updateFunction = gotoABFBConnect, 
							  sprite = "FB_LIKE_BUTTON", 
							  sheet = "", 
							  activateOnRelease = true, 
							  selectable = true}
			fbButton.spriteWidth, fbButton.spriteHeight = _G.res.getSpriteBounds(fbButton.sheet, fbButton.sprite)
			_G.table.insert(levelSelectionPagesPack5.items, fbButton)
		end
		levelSelectionPagesPack5.bgColors = { { red = 126, green = 113, blue = 89 }, { red = 99, green = 142, blue = 160 }, { red = 67, green = 82, blue = 62 }, { red = 67, green = 82, blue = 62 }}
		levelSelectionPagesPack5.bgColor = { red = 126, green = 113, blue = 89 }
		
		levelSelectionPagesPack5.items[levelSelectionPagesPack5.firstLevelIndex].updateFunction = updateMenu
		levelSelectionPagesPack5.items[levelSelectionPagesPack5.firstLevelIndex].page = theme12Start
		levelSelectionPagesPack5.items[levelSelectionPagesPack5.firstLevelIndex].needLoadingScreen = true
	
		-- ADDED
		levelSelectionPagesPack6 = {}
			
		local itemsPerPage = 15
		local levelCount = itemsPerPage
		-- TODO: change
		local pages = 3
		
		if settings.currentLevelSelectionPages.pack6 > pages then
			settings.currentLevelSelectionPages.pack6 = 1
		end
			
		levelSelectionPagesPack6.currentPage = settings.currentLevelSelectionPages.pack6
		levelSelectionPagesPack6.currentOffset = (levelSelectionPagesPack6.currentPage - 1) * -screenWidth
		levelSelectionPagesPack6.targetOffset = levelSelectionPagesPack6.currentOffset
		
		
		levelSelectionPagesPack6.name = "levelSelectionPagesPack6"
		levelSelectionPagesPack6.pageCount = pages
		levelSelectionPagesPack6.levelsPerPage = levelCount
		levelSelectionPagesPack6.themes = { 15, 16, 17}
		--levelSelectionPagesPack6.themes = { 15, 16, 17}
		levelSelectionPagesPack6.back = episodeSelectionPage
		levelSelectionPagesPack6.font = fontBasic
		levelSelectionPagesPack6.state = "READY"
		levelSelectionPagesPack6.sound = "menu_confirm"
		levelSelectionPagesPack6.items = { 	
				{ name = "left", sprite = "LS_THEME_15_LEFT", selectable = false },
				{ name = "right", sprite = "LS_THEME_15_RIGHT", selectable = false },
				{ name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = episodeSelectionPage, sound = "menu_back" },
				{ name = "text_15", text = "15", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_16", text = "16", font = "FONT_LS_SMALL", visible = false },
				{ name = "text_17", text = "17", font = "FONT_LS_SMALL", visible = false },
				{ name = "dot1", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
				{ name = "dot3", sprite = "LS_DOT_BLACK", visible = false },
			}
				
			levelSelectionPagesPack6.firstLevelIndex = #levelSelectionPagesPack6.items + 1
			levelSelectionPagesPack6.backgroundDrawFunction = drawLevelSelectionBackground
		
		local levelNumber = 0
		for currentPage = 1, pages do
			local pageLevelIndex = 0
			for i = 1, itemsPerPage do
				pageLevelIndex = pageLevelIndex + 1
				levelNumber = levelNumber + 1
				
				--if(currentPage == 1) then
					item = {
						levelIndex = levelNumber,
						pageLevelIndex = pageLevelIndex,
						pageIndex = currentPage,
						themeIndex = levelSelectionPagesPack4.themes[currentPage], -- TODO: CHANGE!
						worldNumber = currentPage + 14,
						text =  "" .. pageLevelIndex,
						folder = levelPath .. "/pack" .. currentPage + 14 .. "/",
						filename = levelOrder[levelOrder.packs[currentPage + 14]][pageLevelIndex],
						sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. levelSelectionPagesBasic.themes[currentPage], -- uses buttons from episode 1
						sheet = "LEVELSELECTION_SHEET_1",
						updateFunction = updateGame, 
						activateOnRelease = true,
				}
				
								
				item.spriteWidth, item.spriteHeight = _G.res.getSpriteBounds(item.sheet, item.sprite)
				_G.table.insert(levelSelectionPagesPack6.items, item)
			end
		end

		if(LP6_PAGE2_LOCKED == true) then
			item = {
				levelIndex = levelNumber,
				pageLevelIndex = pageLevelIndex,
				name = "comingSoon2",
				sprite = "LS_COMING_SOON",
				sheet = "",
--				relativeX = 0,
--				currentOffset = 0
			}		
			_G.table.insert(levelSelectionPagesPack6.items, item)
		end
		
		if(LP6_PAGE3_LOCKED == true) then
		
			item = {
				levelIndex = levelNumber,
				pageLevelIndex = pageLevelIndex,
				name = "comingSoon3",
				sprite = "LS_COMING_SOON",
				sheet = "",
--				relativeX = 0,
--				currentOffset = 0
			}		
			_G.table.insert(levelSelectionPagesPack6.items, item)
		end
		

		
		levelSelectionPagesPack6.bgColors = { { red = 41, green = 118, blue = 142 }, { red = 105, green = 184, blue = 225 }, { red = 82, green = 103, blue = 43 } }
		levelSelectionPagesPack6.bgColor = { red = 41, green = 118, blue = 142 }
		
		levelSelectionPagesPack6.items[levelSelectionPagesPack6.firstLevelIndex].updateFunction = updateMenu
																						
		levelSelectionPagesPack6.items[levelSelectionPagesPack6.firstLevelIndex].page = theme15Start
		levelSelectionPagesPack6.items[levelSelectionPagesPack6.firstLevelIndex].needLoadingScreen = true	
	
	end

	
	
	if showEditor then
		levelSelectionEdit = {}
		
		local currentLevel = 0
		for i = 1, 50 do			
			levelSelectionEdit[i], currentLevel = makeEditLevelPack(i, currentLevel)
			currentLevel = i * 21
			levelSelectionEdit[i].back = mainMenu
			
			if i > 0 then
				_G.table.insert(levelSelectionEdit[i].items,
					{sprite = "LS_BACK_BUTTON", x = 0, y = screenHeight, updateFunction = updateMenu, page = levelSelectionEdit[i-1], sound = "menu_back" } )
					if i == 1 then
						levelSelectionEdit[i].items[#levelSelectionEdit[i].items].back = mainMenu
						levelSelectionEdit[i].items[#levelSelectionEdit[i].items].page = mainMenu
					end
			end
			
			if i-1 > 0 then
				_G.table.insert(levelSelectionEdit[i-1].items,
					{sprite = "LS_BACK_BUTTON", x = screenWidth - 100, y = screenHeight, updateFunction = updateMenu, page = levelSelectionEdit[i], sound = "menu_back" } )
			end
		end
	end
	
	settingsBGw, settingsBGh = _G.res.getSpriteBounds("", "SETTINGS_BG")
	levelFinishBGw, levelFinishBGh = _G.res.getSpriteBounds("", "LEVEL_FINISH_BG")	
	levelFailedBGw, levelFailedBGh = _G.res.getSpriteBounds("", "LEVEL_FAILED_BG")
	
	pauseButtonW, pauseButtonH = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "MENU_BUTTON")
	eagleButtonW, eagleButtonH = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "BUTTON_USE_EAGLE")
	if deviceModel == "iphone4" then
		pauseButtonW, pauseButtonH = pauseButtonW * 2, pauseButtonH * 1.7
		eagleButtonW, eagleButtonH = eagleButtonW * 2, eagleButtonH * 2
	end
		
	overlayMenuPage = {
		name = "overlayMenuPage",
		back = nil,
		title = { text = "" },
		state = "READY",
		sound = "menu_confirm",
		items = {
		}
	}
	
	if deviceModel == "n900" then
		_G.table.insert(overlayMenuPage.items, {name = "taskSwitcher", sprite = "BUTTON_TASK_SWITCHER", x = 0, y = 0, callFunction = goToTaskSwitcherLua } )
		_G.table.insert(overlayMenuPage.items, {name = "close", sprite = "BUTTON_CLOSE", x = screenWidth, y = 0, callFunction = requestExit} )
	elseif deviceModel == "s60" then
		_G.table.insert(overlayMenuPage.items, {name = "close", sprite = "BUTTON_CLOSE", x = screenWidth, y = 0, callFunction = requestExit} )
	elseif deviceModel == "android" and isBetaVersion then
		_G.table.insert(overlayMenuPage.items, {name = "betaUp", sprite = "BETA_UP_LEFT", selectable = false})
	end
	
	local scoreSpriteName = _G.res.getString("TEXTS_BASIC", "TEXT_SCORE_SPRITE")
	
	local textY = 30
	local scoreBox = {topLeft = "SCORE_TOP_LEFT", left = "SCORE_LEFT", bottomLeft = "SCORE_BOTTOM_LEFT", bottomMiddle = "SCORE_BOTTOM_MIDDLE",
					  bottomRight = "SCORE_BOTTOM_RIGHT", right = "SCORE_RIGHT", topRight = "SCORE_TOP_RIGHT", topMiddle = "SCORE_TOP_MIDDLE",
					  center = "SCORE_CENTER"}

	local featherBox = {topLeft = "", left = "EPISODE1_LEFT", bottomLeft = "EPISODE1_BOTTOM_LEFT", bottomMiddle = "EPISODE1_BOTTOM_MIDDLE",
					  bottomRight = "EPISODE1_BOTTOM_RIGHT", right = "EPISODE1_RIGHT", topRight = "", topMiddle = "",
					  center = "EPISODE1_CENTER"}
	
	episodeSelectionPage.name = "episodeSelectionPage"
	episodeSelectionPage.back = mainMenu
	episodeSelectionPage.backgroundDrawFunction = drawLevelSelectionBackground
	episodeSelectionPage.state = "READY"
	episodeSelectionPage.sound = "menu_confirm"
	episodeSelectionPage.bgColor = { red = 11, green = 101, blue = 76 }
	
	-- CHANGE FOR NEW EPISODE
	episodeSelectionPage.numEpisodes = 9
	episodeSelectionPage.items = {
	
		{name = "left", sprite = "LS_MAIN_LEFT", selectable = false },
		{name = "right", sprite = "LS_MAIN_RIGHT", selectable = false },
		{name = "dot1", sprite = "LS_DOT_WHITE", visible = false },
		{name = "dot2", sprite = "LS_DOT_BLACK", visible = false },
		{name = "dot3", sprite = "LS_DOT_BLACK", visible = false },
		{name = "dot4", sprite = "LS_DOT_BLACK", visible = false },
		{name = "dot5", sprite = "LS_DOT_BLACK", visible = false },
		{name = "dot6", sprite = "LS_DOT_BLACK", visible = false },
		{name = "dot7", sprite = "LS_DOT_BLACK", visible = false },
		{name = "dot8", sprite = "LS_DOT_BLACK", visible = false },
		{name = "dot9", sprite = "LS_DOT_BLACK", visible = false },
		{name = "back", sprite = "LS_BACK_BUTTON", updateFunction = updateMenu, page = mainMenu, sound = "menu_back" },	
	}
	createEpisodeBox(1)
	createEpisodeBox(2)
	createEpisodeBox(3)
	createEpisodeBox(4)
	createEpisodeBox(5)
	createEpisodeBox(6)
		
	_G.table.insert(episodeSelectionPage.items, 7, 
		{
			name = "episodeG", updateFunction = gotoLevelSelectionGoldenEggs, box = { topLeft = "EPISODEG_TOP_LEFT", left = "EPISODEG_LEFT", 
												   bottomLeft = "EPISODEG_BOTTOM_LEFT", bottomMiddle = "EPISODEG_BOTTOM_MIDDLE",
												   bottomRight = "EPISODEG_BOTTOM_RIGHT", right = "EPISODEG_RIGHT",
												   topRight = "EPISODEG_TOP_RIGHT", topMiddle = "EPISODEG_TOP_MIDDLE",
												   center = "EPISODEG_CENTER"}, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER",
			children = {{name = "epGYellowLine", box = {topMiddle = "EPISODE_YELLOW_LINE"}, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "TOP"},
						{name = "epGSprite", sprite = "EPISODEG_ICON"}, 
						{name = "epGScoreBox", box = scoreBox, hanchor = "HCENTER", vanchor = "BOTTOM"},
						{name = "epGStar", sprite = "EPISODEG_STAR"},
						{name = "epGEpisodeText", text = "Golden Eggs", vanchor = "BASELINE", hanchor = "HCENTER", font = fontBasic},
						{name = "epGEggLeft", sprite = "EPISODEG_EGG", hanchor = "LEFT"},
						{name = "epGEggRight", sprite = "EPISODEG_EGG", hanchor = "RIGHT"},
												
						{ name = "epGStarText", text = "", hanchor="HCENTER", vanchor="VCENTER", font = "FONT_LS_SMALL"} }
		})
		
		-- AB Shop button
		
		local upsellShop = { 	 levelIndex = "dummy",
								 name = "upsellShop", 
								 updateFunction = gotoABShop, 
								 sprite = "UPSELL_SHOP", 
								 sheet = "", 
								 activateOnRelease = true, 
					}
		upsellShop.spriteWidth, upsellShop.spriteHeight = _G.res.getSpriteBounds("", upsellShop.sprite)
		_G.table.insert(episodeSelectionPage.items, 8, upsellShop)
		
		-- Halloween upsell and newsletter links
		local halloweenItem = nil

		if isSeasonsAvailable then
			halloweenItem = {
			  name = "upsellHalloween", sprite = "UPSELL_HALLOWEEN", updateFunction = gotoHalloweenInAppStore, selectable = true, activateOnRelease = true, hanchor = "HCENTER", vanchor = "VCENTER", selectableChildren = true,
			  children = {{name = "newsletter", sprite = "SIGNUP_NEWSLETTER", updateFunction = gotoNewsletter, selectable = true, activateOnRelease = true, vanchor = "VCENTER", hanchor = "HCENTER"}}			
			}
			_G.table.insert(episodeSelectionPage.items, 9, halloweenItem)
		else
			news = {
			  name = "newsletter", sprite = "SIGNUP_NEWSLETTER", updateFunction = gotoNewsletter, selectable = true, activateOnRelease = true, hanchor = "HCENTER", vanchor = "VCENTER"
			  --children = {{name = "newsletter", sprite = "SIGNUP_NEWSLETTER", updateFunction = gotoNewsletter, selectable = true, activateOnRelease = true, vanchor = "VCENTER", hanchor = "HCENTER"}}			
			}
			_G.table.insert(episodeSelectionPage.items, 9, news)
		
		end
		
		
		if deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad" or (deviceModel == "android" and isHDVersion) then
			local giftButton = { 	 levelIndex = "dummy",
									 name = "giftButton", 
									 updateFunction = gotoAppleGiftPurchase, 
									 sprite = "BUTTON_GIFT_APP", 
									 sheet = "", 
									 
						}
			giftButton.spriteWidth, giftButton.spriteHeight = _G.res.getSpriteBounds("", giftButton.sprite)
			_G.table.insert(episodeSelectionPage.items, 10, giftButton)
		end
	
	-- <GameCenter>
	-- Global rank meters for episodes
	if gameCenterSupported then
	
		local episodeAmount = 0
		-- getting true amount of episodes based on names in episodeselectionpage.
		for i = episodeSelectionPage.numEpisodes, 1, -1 do
			if getItemByName(episodeSelectionPage.items, "episode" .. i) then
				episodeAmount = i
				break
			end
		end
	
		for i = 1, episodeAmount do
			_G.table.insert(episodeSelectionPage.items[i].children, {name = "ep" .. i .. "MeterBG", sprite = "GLOBAL_METER_BG", visible = false})
			_G.table.insert(episodeSelectionPage.items[i].children, {name = "ep" .. i .. "MeterIndicator", sprite = "GLOBAL_METER_INDICATOR", visible = false})
		end		
	end
	
	episodeSelectionPage.goldenEggHitBox = {}
	
	if deviceModel == "n900" then
		_G.table.insert(episodeSelectionPage.items[1].children, 
		{ name = "pack1buy", sheet = "", sprite = "LS_LEVEL_PACK1_BUY",
		  visible = false, callFunction = gotoOviStore, selectable = false })
	end
			
	for i = 1, episodeSelectionPage.numEpisodes do
		episodeSelectionPage.items[i].activateOnRelease = true
	end

	if settings.selectedEpisode > episodeSelectionPage.numEpisodes then
		settings.selectedEpisode = 1
	end
	
	moreGamesPage = {
		name = "moreGamesPage",
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		popup = true,
		back = nil,
		state = "READY",
		sound = "menu_confirm",
		items = {
			{x = 0, y = 0, w = screenWidth, h = screenHeight, updateFunction = removePopupMenu },
			{sprite = "LEVEL_FAILED_BG", x = screenWidth * 0.5, y = screenHeight * 0.5 },
			{text = "Get More on Ovi", x = screenWidth * 0.5, y = screenHeight * 0.5 - 10 },
			{sprite = "BUTTON_MENU", x = screenWidth * 0.5 - 80, y = screenHeight * 0.5 + 80, updateFunction = removePopupMenu },
			{sprite = "BUTTON_NEXTLEVEL", x = screenWidth * 0.5 + 80, y = screenHeight * 0.5 + 80, callFunction = gotoMoreOnOviStore },
		}
	}
	
	local sliderBox = {topLeft = "MENU_SLIDER_BG_TOP_LEFT", left = "MENU_SLIDER_BG_LEFT", bottomLeft = "MENU_SLIDER_BG_BOTTOM_LEFT", bottomMiddle = "MENU_SLIDER_BG_BOTTOM_MIDDLE",
					  bottomRight = "MENU_SLIDER_BG_BOTTOM_RIGHT", right = "MENU_SLIDER_BG_RIGHT", topRight = "MENU_SLIDER_BG_TOP_RIGHT", topMiddle = "MENU_SLIDER_BG_TOP_MIDDLE",
					  center = "MENU_SLIDER_BG_CENTER"}
	
	
	local playSpriteName = _G.res.getString("TEXTS_BASIC", "TEXT_PLAY_SPRITE")
	mainMenu.name = "mainMenu"
	mainMenu.back = nil
	mainMenu.bgColor = { red = 11, green = 101, blue = 76 }
	mainMenu.state = "READY"
	mainMenu.sound = "menu_confirm"
	mainMenu.items = {
			{name = "playBG", box = playBoxSprites, hanchor = "HCENTER", vanchor = "VCENTER", visible = true},
			{name = "play", sprite = playSpriteName, updateFunction = updateMenu, page = episodeSelectionPage, activateOnRelease = true, hanchor="HCENTER", vanchor="VCENTER" } , 
			{name = "sliderBGRight", box = sliderBox, hanchor = "HCENTER", vanchor = "BOTTOM", visible = false},
			{name = "sliderBGLeft", box = sliderBox, hanchor = "HCENTER", vanchor = "BOTTOM", visible = false},
			{name = "sfx", sprite = "BUTTON_SOUNDS_SMALL", callFunction = changeAudio, hanchor="HCENTER", vanchor="VCENTER", selectable = false } ,
			{name = "credits", sprite = "BUTTON_ABOUT_SMALL", callFunction = showLeftMenu, hanchor="HCENTER", vanchor="VCENTER", selectable = false } ,
			{name = "trailer", sprite = "BUTTON_TRAILER_SMALL", callFunction = gotoAngryBirdsTrailer, selectable = false, visible = false },
			{name = "buttonOff", sprite = "BUTTON_SOUNDS_OFF_SMALL", selectable = false } ,
			{name = "menuOvi", sprite = "MENU_OVI", callFunction = gotoOviStore, visible = false },
			{name = "menuLogo", sprite = "MENU_LOGO", selectable = false, visible = true },
			{name = "logoLite", sprite = "LOGO_LITE", selectable = false, visible = false },
			{name = "appStore", sprite = "MENU_APP_STORE", visible = false, callFunction = gotoFullVersionInAppStore },
			{name = "facebook", sprite = "BUTTON_FACEBOOK_SMALL", visible = false, callFunction = gotoFacebook, selectable = false },
			{name = "twitter", sprite = "BUTTON_TWITTER_SMALL", visible = false, callFunction = gotoTwitter, selectable = false },
			{name = "resetMightyEagle", text = "Reset Mighty Eagle", updateFunction = resetMightyEagleFeature, activateOnRelease = true, hanchor = "LEFT", vanchor = "TOP" },
			{name = "lockLevels", text = "Lock levels", updateFunction = lockLevels, activateOnRelease = true, hanchor = "RIGHT", vanchor = "TOP" },
			{name = "unlockLevels", text = "Unlock levels", updateFunction = unlockLevels, activateOnRelease = true, hanchor = "RIGHT", vanchor = "TOP" },
			{name = "leaderboards", sprite = "BUTTON_LEADERBOARDS", visible = false, callFunction = showLeaderboards },
			{name = "achievements", sprite = "BUTTON_ACHIEVEMENTS", visible = false, callFunction = showAchievements },--updateFunction = updateMenu, page = achievementsPage},			
			{name = "loaderLB", sprite = "GC_LOADING", visible = false },
			{name = "loaderAC", sprite = "GC_LOADING", visible = false },
			--{name = "buyEagle", sprite = "BUTTON_EAGLE_BUY", updateFunction = updateMenu, page = mightyEagleDemoPage },
			{name = "buyEagle", sprite = "BUTTON_EAGLE_BUY", callFunction = showEagleBuyFromMain},
		}
		
	if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
		_G.table.insert(mainMenu.items, {name = "crystal", sprite = "BUTTON_CRYSTAL_SMALL", callFunction = startCrystal, hanchor="HCENTER", vanchor="VCENTER", visible = false, selectable = false } )
		if settings.mightyEagleEnabled then
			_G.table.insert(mainMenu.items, {name = "trailerEagle", sprite = "BUTTON_MEVIDEO", callFunction = gotoMightyEagleTrailer, selectable = false, visible = false })
		end
	end
	
	if deviceModel == "android" and not isHDVersion then
		_G.table.insert(mainMenu.items, {name = "gfxQualityButton", sprite = "BUTTON_LQ", callFunction = changeGFXQuality, hanchor="HCENTER", vanchor="VCENTER", visible = false, selectable = false } )
		_G.table.insert(mainMenu.items, {name = "gfxQualityButtonOff", sprite = "BUTTON_LQ_X", visible = false, selectable = false } )
	end

	if deviceModel == "s60" then
		if isLiteVersion then
			_G.table.insert(mainMenu.items, {name = "oviButton", sprite = "OVI_BUTTON", updateFunction = updateMenu, page = upsellPage } )
		else
			_G.table.insert(mainMenu.items, {name = "oviButton", sprite = "OVI_BUTTON", updateFunction = updateMenu, page = moreGamesPage } )
			_G.table.insert(mainMenu.items, {name = "mightyEagleButton", sprite = "OVI_BUTTON", updateFunction = updateMenu, page = moreGamesPage } )
			_G.table.insert(mainMenu.items, {name = "updateButton", sprite = "BUTTON_UPDATE", callFunction = gotoS60UpdatePage, visible = true })
		end
	end
	if isBetaVersion and deviceModel == "android" then
		local menuAndroid = getItemByName(mainMenu.items, "menuOvi")
		menuAndroid.callFunction = gotoAndroidMarket
		menuAndroid.sprite = "MENU_FULL_VERSION"
		menuAndroid.visible = true
		_G.table.insert(mainMenu.items, {name = "reportBug", sprite = "BUTTON_BUG_SMALL", callFunction = gotoReportBug})
	end
	
	if showEditor then
		_G.table.insert(mainMenu.items, {name = "editor", text = "MI_EDIT", updateFunction = updateMenu, page = levelSelectionEdit[1] } )
	end
	
	if deviceModel == "android" and not isHDVersion then
		_G.table.insert( mainMenu.items, {name = "buttonSliderBGOptions", sprite = "BUTTON_EMPTY", visible = true, 
		callFunction = changeOptionSliderStatus, state = "closed", elements = {{name = "sfx", sprite = "BUTTON_SOUNDS_SMALL"},
		{ name = "credits", sprite = "BUTTON_ABOUT_SMALL"}, { name = "gfxQualityButton", sprite = "BUTTON_LQ"}}})
	else
		_G.table.insert( mainMenu.items, {name = "buttonSliderBGOptions", sprite = "BUTTON_EMPTY", visible = true, 
		callFunction = changeOptionSliderStatus, state = "closed", elements = {{name = "sfx", sprite = "BUTTON_SOUNDS_SMALL"},
		{ name = "credits", sprite = "BUTTON_ABOUT_SMALL"}}})
	end
	
	_G.table.insert( mainMenu.items, {name = "buttonSliderOptions", sprite = "BUTTON_OPTIONS", 
	visible = true, itemDrawFunction = buttonSliderOptionsDraw, angle = 0, selectable = false })
	
	if( deviceModel == "iphone") or ( deviceModel == "iphone4") or deviceModel == "ipad" then
		if settings.mightyEagleEnabled then
			_G.table.insert( mainMenu.items, {name = "buttonSliderBG", sprite = "BUTTON_EMPTY", visible = true, 
			callFunction = changeSliderStatus, state = "closed", elements = {{name = "crystal", sprite = "BUTTON_CRYSTAL_SMALL"},
			{ name = "twitter", sprite = "BUTTON_TWITTER_SMALL"}, { name = "facebook", sprite = "BUTTON_FACEBOOK_SMALL"}, 
			{ name = "trailerEagle", sprite = "BUTTON_TRAILER_SMALL"}, { name = "trailer", sprite = "BUTTON_TRAILER_SMALL"}}})
		else
			_G.table.insert( mainMenu.items, {name = "buttonSliderBG", sprite = "BUTTON_EMPTY", visible = true, 
			callFunction = changeSliderStatus, state = "closed", elements = {{name = "crystal", sprite = "BUTTON_CRYSTAL_SMALL"},
			{ name = "twitter", sprite = "BUTTON_TWITTER_SMALL"}, { name = "facebook", sprite = "BUTTON_FACEBOOK_SMALL"}, 
			{ name = "trailer", sprite = "BUTTON_TRAILER_SMALL"}}})
		end
		
	elseif ( deviceModel == "android") and isBetaVersion then
		_G.table.insert( mainMenu.items, {name = "buttonSliderBG", sprite = "BUTTON_EMPTY", visible = true, 
		callFunction = changeSliderStatus, state = "closed", elements = {{name = "reportBug", sprite = "BUTTON_BUG_SMALL"},
		{ name = "twitter", sprite = "BUTTON_TWITTER_SMALL"}, { name = "facebook", sprite = "BUTTON_FACEBOOK_SMALL"}, 
		{ name = "trailer", sprite = "BUTTON_TRAILER_SMALL"}}})
	else
		_G.table.insert( mainMenu.items, {name = "buttonSliderBG", sprite = "BUTTON_EMPTY", visible = true, 
		callFunction = changeSliderStatus, state = "closed", elements = {{ name = "twitter", sprite = "BUTTON_TWITTER_SMALL"}, { name = "facebook", sprite = "BUTTON_FACEBOOK_SMALL"}, 
		{ name = "trailer", sprite = "BUTTON_TRAILER_SMALL"}}})
	end
	
	_G.table.insert( mainMenu.items, {name = "buttonSlider", sprite = "BUTTON_SLIDER", 
	visible = true, itemDrawFunction = buttonSliderDraw, angle = 0, selectable = false })
	
	about = {
		name = "about",
		back = mainMenu,
		-- about text overlay 0,0
		sound = "menu_confirm",		
		backgroundBox = { name = "aboutbg", sprites = {  right = "MAIN_SETTINGS_LEFT", center = "MAIN_CENTER" }, sheet = "POPUPS_SHEET_1", hanchor = "LEFT", vanchor = "TOP"},
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		state = "READY",
		font = fontBasic,
		scrollStart = 1,
		scrollEnd = 8,
		items = {
			{name = "birds1", sprite = "ABOUT_BIRDS_1" },
			{name = "textAbout", text = "TEXT_ABOUT", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "privacyButton", sprite = "BUTTON_PRIVACY", selectable = true, hanchor="HCENTER", vanchor="VCENTER", callFunction = gotoPrivacyPolicy, activateOnRelease = true },
			
			{name = "textAboutRovio", text = "", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "birds2", sprite = "ABOUT_BIRDS_2", selectable = false },
			{name = "textCredits", text = "TEXT_CREDITS", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "textAdditionalCredits", sprite = "", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "goldenEgg", sprite = "GOLDEN_EGG_5", callFunction = aboutGoldenEggAchieved },
			{name = "arrow", sprite = "ARROW_LEFT", callFunction = hideLeftMenu, visible = false },
			{name = "hideArea", callFunction = hideLeftMenu, activateOnRelease = false, visible = false} ,
		}
	}
	if(iOS ~= true) then
		_G.table.insert(about.items,4,
			{name = "eulaButton", sprite = "BUTTON_EULA", selectable = true, hanchor="HCENTER", vanchor="VCENTER", callFunction = gotoEula, activateOnRelease = true }
		)
		
		about.scrollEnd = 9
	end
	
	local textAbout = getItemByName(about.items, "textAbout")
	local textAdditionalCredits = getItemByName(about.items, "textAdditionalCredits")
	if deviceModel == "iphone" or deviceModel == "iphone4" then
		if isLiteVersion then
			textAbout.text = "TEXT_ABOUT_CLICKGAMER_LITE"
		else
			textAbout.text = "TEXT_ABOUT_CLICKGAMER"
		end
	elseif deviceModel == "s60" then
		textAbout.text = "TEXT_ABOUT_S60"
		
		if applyChinaRestictions then
			textAdditionalCredits.sprite = "TOM_CREDITS_S60"
		end	
	elseif deviceModel == "palm" then
		if isLiteVersion then
			textAbout.text = "TEXT_ABOUT_PALM_LITE"
		else
			textAbout.text = "TEXT_ABOUT_PALM"
		end
	elseif deviceModel == "android" then
		if isBetaVersion then
			textAbout.text = "TEXT_ABOUT_ANDROID_BETA"
		elseif isHDVersion then
			textAbout.text = "TEXT_ABOUT_ANDROID_HD"
		else
			textAbout.text = "TEXT_ABOUT_ANDROID"
		end
	elseif deviceModel == "ipad" then
		textAbout.text = "TEXT_ABOUT_CHILLINGO"
	end
	
	upsellPage.name = "upsellPage"
	upsellPage.popup = true
	upsellPage.back = mainMenu
	upsellPage.state = "READY"
	upsellPage.sound = "menu_confirm"
	upsellPage.bgColor = { red = 0, green = 0, blue = 0 }
	
	if deviceModel == "n900" then
		upsellPage.backgroundSprite = { name = "UPSELL", x = 0, y = 0 }
		upsellPage.items = {
			{sprite = "BUTTON_MENU", x = 60, y = screenHeight - 70, selectable = true, updateFunction = updateMenu, page = levelSelectionPagesBasic },
			{sprite = "UPSELL_BUTTON", x = screenWidth*0.5, y = screenHeight, selectable = true, callFunction = gotoOviStore },
		}
	elseif deviceModel == "s60" then
		upsellPage.backgroundSprite = { name = "UPSELL_BG", x = 0, y = 0 }
		upsellPage.items = {
			{text = "TEXT_UPSELL", x = screenWidth*0.5, y = 9, vanchor = "TOP", hanchor = "HCENTER" },
			{sprite = "BUTTON_MENU", x = 40, y = screenHeight - 40, selectable = true, updateFunction = removePopupMenu },
			{sprite = "UPSELL_BUTTON", x = screenWidth*0.5, y = 266, selectable = true, callFunction = gotoOviStore },
			{text = "TEXT_UPSELL_BUTTON_2", x = screenWidth*0.5, y = screenHeight-3, vanchor = "BOTTOM", hanchor = "HCENTER" },
		}
	elseif deviceModel == "android" then
		upsellPage.backgroundSprite = { name = "UPSELL_BG", x = 0, y = 0 }
		upsellPage.items = {
			{name = "back", sprite = "LS_BACK_BUTTON",  selectable = true, updateFunction = removePopupMenu },
			{name = "button", sprite = "UPSELL_BUTTON", selectable = true, callFunction = gotoAndroidMarket },
		}
	else
		upsellPage.backgroundSprite = { name = "UPSELL_BG", x = 0, y = 0 }
		upsellPage.items = {
		--	{name = "background", sprite = "UPSELL_BG", selectable = false},
			{name = "back", sprite = "LS_BACK_BUTTON",  selectable = true, updateFunction = updateMenu, page = mainMenu },
			{name = "button", sprite = "UPSELL_BUTTON", selectable = true, callFunction = gotoFullVersionInAppStore },
		}
	end

	
	pauseBGw = 0
	pausePage = {
		name = "pause",
		back = "goToLevelSelection",
		backgroundBox = { name = "pausebg", sprites = { left = "MAIN_ABOUT_RIGHT", right = "MAIN_SETTINGS_LEFT", center = "MAIN_CENTER" }, sheet = "POPUPS_SHEET_1", hanchor = "LEFT", vanchor = "TOP"},
		backgroundDrawFunction = drawGame,
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		state = "READY",
		sound = "menu_confirm",
		font = fontMenu,
		items = {
			{name = "buttonSfx", sprite = "BUTTON_SFX", selectable = true, callFunction = changeAudio } ,
			{name = "buttonOff", sprite = "BUTTON_OFF_SMALL", selectable = false } ,
			{name = "buttonMenu", sprite = "BUTTON_MENU", selectable = true, updateFunction = updateMenu, page = nil } ,
			{name = "buttonRestart", sprite = "BUTTON_RESTART",  selectable = true, updateFunction = updateGame, restartLevel = true } ,
			{name = "buttonResume", sprite = "BUTTON_RESUME", updateFunction = hidePauseMenu, activateOnRelease = true } ,
			{name = "hideArea", updateFunction = hidePauseMenu, activateOnRelease = true } ,
			{name = "levelText", text = "", selectable = false } ,
			{name = "buttonTutorials", sprite = "MENU_TUTORIALS", selectable = true, updateFunction = showTutorials } ,
		}
	}
	
	if deviceModel == "n900" or deviceModel == "s60" then
		_G.table.insert(pausePage.items, {name = "taskSwitcher", sprite = "BUTTON_TASK_SWITCHER", callFunction = goToTaskSwitcherLua } )
	end
	
	if deviceModel == "s60" and isLiteVersion then
		_G.table.insert(pausePage.items, {name = "buttonOvi", sprite = "OVI_BUTTON", updateFunction = updateMenu, page = upsellPage } )	
	end	
	
	tutorials = {
		name = "tutorials",
		back = nil,
		backgroundBox = { name = "tutorialBg", sprites = {left = "TUTORIAL_LEFT", bottomLeft = "TUTORIAL_BOTTOM_LEFT", 
						  bottomMiddle = "TUTORIAL_BOTTOM_MIDDLE", bottomRight = "TUTORIAL_BOTTOM_RIGHT", right = "TUTORIAL_RIGHT", 
						  topRight = "TUTORIAL_TOP_RIGHT", topMiddle = "TUTORIAL_TOP_MIDDLE", topLeft = "TUTORIAL_TOP_LEFT", 
						  center = "TUTORIAL_CENTER" }, hanchor = "HCENTER", vanchor = "VCENTER"},
		items = { 
				{ name = "TUTORIAL_1", sprite = "TUTORIAL_RED", selectable = false }, --red
				{ name = "TUTORIAL_2", sprite = "TUTORIAL_BLUE", selectable = false }, --blue
				{ name = "TUTORIAL_3", sprite = "TUTORIAL_YELLOW", selectable = false }, --yellow
				{ name = "TUTORIAL_4", sprite = "TUTORIAL_BLACK", selectable = false }, --black
				{ name = "TUTORIAL_5", sprite = "TUTORIAL_WHITE", selectable = false }, --white
				{ name = "TUTORIAL_6", sprite = "TUTORIAL_BOOMERANG", selectable = false }, --boomerang
				{ name = "TUTORIAL_7", sprite = "TUTORIAL_BIG_BROTHER", selectable = false }, --bigbrother
				{ name = "TUTORIAL_8", sprite = "TUTORIAL_MIGHTYEAGLE", selectable = false }, --mightyeagle
				}
		}
				
	if deviceModel == "s60" or deviceModel == "n900" or deviceModel == "android" then
		areYouSurePage = {
			name = "areYouSure",
			state = "READY",
			back = nil,
			popup = true,
			backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
			backgroundBox = { name = "backgroundAreYouSure", 
							  sprites = {topLeft = "POPUP_TOP_LEFT", left = "POPUP_LEFT", 
										 bottomLeft = "POPUP_BOTTOM_LEFT", bottomMiddle = "POPUP_BOTTOM_MIDDLE", 
										 bottomRight = "POPUP_BOTTOM_RIGHT", right = "POPUP_RIGHT", topRight = "POPUP_TOP_RIGHT", 
										 topMiddle = "POPUP_TOP_MIDDLE", center = "POPUP_CENTER"}, 
							  sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
			items = {
				{name = "areYouSureText", text = "TEXT_EXIT_CONFIRM", font = fontBasic, hanchor = "HCENTER", vanchor = "BASELINE"},
				{name = "buttonNo", sprite = "MENU_NO", selectable = true, callFunction = closeBetaDisclaimerPage},
				{name = "buttonYes", sprite = "MENU_YES", selectable = true, callFunction = requestExit},
			}
		
		}
	end
	
	systemPopup = {
		name = "systemPopup",	
		back = nil,
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true, shade = 0.65 },
		state = "READY",
		sound = "menu_confirm",
		popup = true,
		nextPage = nil,	
		backgroundBox = { name = "bgSystemPopup", 
							  sprites = {topLeft = "POPUP_TOP_LEFT", left = "POPUP_LEFT", 
										 bottomLeft = "POPUP_BOTTOM_LEFT", bottomMiddle = "POPUP_BOTTOM_MIDDLE", 
										 bottomRight = "POPUP_BOTTOM_RIGHT", right = "POPUP_RIGHT", topRight = "POPUP_TOP_RIGHT", 
										 topMiddle = "POPUP_TOP_MIDDLE", center = "POPUP_CENTER"}, 
							  sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{name = "title", text = "", selectable = false, hanchor="HCENTER", vanchor="VCENTER" } ,
			{name = "message", text = "", selectable = false, hanchor="HCENTER", vanchor="VCENTER" } ,
			{name = "icon", sprite = "", hanchor="HCENTER", vanchor="BOTTOM" },
			{name = "buttonYes", sprite = "TUTORIAL_OK", selectable = true, callFunction = hideSystemPopup, activateOnRelease = true },
		}
	}
	
	loadingPage = {
		name = "loading",	
		back = nil,
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true, shade = 0 },
		--backgroundDrawFunction = drawMenu,
		state = "READY",
		sound = "menu_confirm",
		nextPage = nil,		
		items = {
			{name = "loadingText", text = "MI_LOADING", selectable = false, hanchor="HCENTER", vanchor="VCENTER" } ,
		}
	}
	
	-- this is not used
	clearSaveConfirm = {
		name = "clearSaveConfirm",
		popup = true,
		back = nil,
		title = { text = "" },
		state = "READY",
		sound = "menu_confirm",
		itemBackgroundSprite = "BUTTON_BG",
		itemBackgroundSpriteSelected = "BUTTON_BG_HOVER",
		items = {
			{text = "MI_VIBRA", x = screenWidth*0.5, y = screenHeight*0.5 - 90, selectable = false },
			{text = "MI_VIBRA", x = screenWidth*0.5, y = screenHeight*0.5 - 15, selectable = false },
			{text = "SK_YES", updateFunction = clearSaveFunction, x = screenWidth*0.5 - 50, y = screenHeight*0.5 + 70, selectable = true } , 
			{text = "SK_NO", updateFunction = removePopupMenu, x = screenWidth*0.5 + 50, y = screenHeight*0.5 + 70, selectable = true } , 
		}
	}	
	
	settingsPage = {
		name = "settingsPage",
		back = nil,
		--title = { text = "MT_SETTINGS",	x = screenWidth - 108, y = 36 },
		sound = "menu_confirm",		
		backgroundSprite = { name = "SETTINGS_BG", x = screenWidth, y = 0 },
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		state = "READY",
		items = {
			-- {sprite = "BUTTON_SFX", x = screenWidth - 64, y = 178, selectable = true, callFunction = changeAudio } ,
			-- {sprite = "BUTTON_OFF", x = screenWidth - 64, y = 178, selectable = false } ,
			-- {sprite = "BUTTON_MUSIC", x = screenWidth - 160, y = 178, selectable = true, updateFunction = changeMusic } ,
			-- {sprite = "BUTTON_OFF", x = screenWidth - 160, y = 178, selectable = false } ,
			-- {sprite = "FLAG_TEMPLATE", x = screenWidth - 111 , y = 245, selectable = true, updateFunction = changeLanguage, visible = false } ,
			-- {sprite = "SETTINGS_LANGUAGE_BORDERS", x = screenWidth - 111 , y = 245, selectable = false, visible = false } ,
			-- {sprite = "ARROW_RIGHT", x = screenWidth - settingsBGw + 22, y = screenHeight - 30, updateFunction = hideRightMenu } ,
			-- {x = 0, y = 0, w = screenWidth - settingsBGw, h = screenHeight, updateFunction = hideLeftMenu, activateOnRelease = true } ,
			--old data
			--{text = "MI_AUDIO", x = 130, y = 120, selectable = false } ,
			--{text = "MI_VIBRA", x = 130, y = 220, selectable = false } ,
			--{sprite = "BUTTON_BIG", x = 335, y = 120, selectable = true, updateFunction = updateMenu, page = clearSaveConfirm } ,
			--{text = "ITEM_ERASE_DATA", x = 335, y = 120, selectable = false } ,
			--{sprite = "BUTTON_SQUARE", x = 335, y = 235, selectable = true, updateFunction = changeLanguage } ,
			--{text = "TITLE_CHOOSE_LANGUAGE", x = 335, y = 210, selectable = false } ,
			--{sprite = "SETTINGS_LANGUAGE_BORDERS", x = 335, y = 250, selectable = false } ,
		}
	}
		
	gameStart.name = "gameStart"
	gameStart.back = nil
	gameStart.sound = "menu_confirm"
	gameStart.state = "READY"
	gameStart.animationState = "SCROLL"
	gameStart.timer = 0
	gameStart.bgColor = { red = 0, green = 0, blue = 0 }
	gameStart.items = { {name = "storyBegin1", sprite = "STORY_BEGIN_BG_1", updateFunction = gotoFirstLevel, isBackground = true },
						{name = "storyBegin2", sprite = "STORY_BEGIN_BG_2", updateFunction = gotoFirstLevel, isBackground = true },
						{name = "storyBeginGroup", sprite = "STORY_BEGIN_PIG_GROUP_1", selectable = false },
						}
	
	theme1Complete = {
		name = "theme1Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_1", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
		}
	}

	theme2Complete = {
		name = "theme2Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_2", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
		}
	}
	

	gameComplete = {
		name = "gameComplete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyEnd1", sprite = "STORY_END_1_1", selectable = false, isBackground = true },
			{name = "storyEnd2", sprite = "STORY_END_1_2", selectable = false, isBackground = true },
			{name = "storyEndEyeNormal", sprite = "STORY_END_KING_EYE_NORMAL",selectable = false, visible = false },
			{name = "storyEndEyePeek", sprite = "STORY_END_KING_EYE_PEEK", selectable = false, visible = false },
			{name = "storyEndEyeWink", sprite = "STORY_END_KING_EYE_WINK", selectable = false, visible = false },
		}
	}	

	
	theme4Start.name = "theme4Start"
	theme4Start.back = nil
	theme4Start.sound = "menu_confirm"
	theme4Start.state = "READY"
	theme4Start.animationState = "SCROLL"
	theme4Start.timer = 0
	theme4Start.bgColor = { red = 0, green = 0, blue = 0 }
	theme4Start.items = {
			{name = "storyBg", sprite = "STORY_BEGIN_BG_1", updateFunction = gotoFirstLevelLP2, isBackground = true },
			{name = "storyBegin1", sprite = "STORY_BEGIN_BG_2", updateFunction = gotoFirstLevelLP2, isBackground = true },
			{name = "storyFakeEggs", sprite = "STORY_BEGIN_FAKE_EGGS", selectable = false },
			{name = "storyGroup", sprite = "STORY_BEGIN_PIG_GROUP_2", selectable = false },
		}
	
	theme4Complete = {
		name = "theme4Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_4", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
		}
	}
	
	theme5Complete = {
		name = "theme5Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_4", selectable = false, visible = false },
			{name = "storyTongue", sprite = "STORY_END_2_TONGUE", selectable = false, visible = false },
			{name = "storyEggs", sprite = "STORY_END_2_EGGS", selectable = false, visible = false },
			{name = "storyKing", sprite = "STORY_END_2_HIDING_KING", selectable = false, visible = false },
			{name = "storyEyeOpen", sprite = "STORY_END_2_EYE_OPEN", selectable = false, visible = false },
			{name = "storyEyePeek", sprite = "STORY_END_2_EYE_PEEK", selectable = false, visible = false },
			{name = "storyEyeWink", sprite = "STORY_END_2_EYE_WINK", selectable = false, visible = false },
			{name = "storySmile", sprite = "STORY_END_2_SMILE", selectable = false, visible = false },
		}
	}	
	
	theme6Start.name = "theme6Start"
	theme6Start.back = nil
	theme6Start.sound = "menu_confirm"
	theme6Start.state = "READY"
	theme6Start.animationState = "SCROLL"
	theme6Start.timer = 0
	theme6Start.offsetY = 0
	theme6Start.bgColor = { red = 61, green = 163, blue = 204 }
	theme6Start.items = {
			{name = "storyBg", sprite = "STORY_BEGIN_BG_1", updateFunction = gotoFirstLevelLP3 },
			{name = "storyBg2", sprite = "STORY_BEGIN_BG_2", updateFunction = gotoFirstLevelLP3 },
			{name = "storyHideHoof", sprite = "STORY_HIDE_HOOF_1", selectable = false },
			{name = "storyFade", sprite = "STORY_BEGIN_FADE", selectable = false },
			{name = "storyFade2", sprite = "STORY_BEGIN_FADE_2", selectable = false },
			{name = "storyCloud4", sprite = "STORY_CLOUD_4", selectable = false },
			{name = "storyCloud3", sprite = "STORY_CLOUD_3", selectable = false },
			{name = "storyCloud2", sprite = "STORY_CLOUD_2", selectable = false },
			{name = "storyCloud1", sprite = "STORY_CLOUD_1", selectable = false },
			{name = "storyPigs3", sprite = "STORY_FLYING_PIGS_3", selectable = false },
			{name = "storyPigs2", sprite = "STORY_FLYING_PIGS_2", selectable = false },
			{name = "storyPigs1", sprite = "STORY_FLYING_PIGS_1", selectable = false },
			{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_2", selectable = false },
			{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_3", selectable = false },
			{name = "storyHideAllHoofs", sprite = "HIDE_ALL_HOOF", selectable = false },
			{name = "storyYellow", sprite = "STORY_ANGRY_YELLOW_BIRD", selectable = false },
		}

	
	theme6Complete = {
		name = "theme6Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyHoof", sprite = "STORY_HIDE_HOOF_2", selectable = false },
			{name = "storyBalloon", sprite = "STORY_BOSS_FLATTENED_BALLOON",  selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_1", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING_2",  selectable = false },
		}
	}	
	
	theme7Complete = {
		name = "theme7Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyHoof", sprite = "STORY_HIDE_HOOF_2", selectable = false },
			{name = "storyBalloon", sprite = "STORY_BOSS_FLATTENED_BALLOON_2", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_2", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING_3", selectable = false },
		}
	}	
	
	theme8Complete = {
		name = "theme8Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyHoof", sprite = "STORY_HIDE_HOOF_2", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING_4", selectable = false },
			{name = "storyCarpet", sprite = "STORY_BOSS_CARPET", selectable = false },
			{name = "storyEye", sprite = "STORY_BOSS_KING_ESCAPING_4_EYE_2", selectable = false, visible = false },
			{name = "storyWink", sprite = "STORY_BOSS_KING_ESCAPING_4_EYE_WINK", selectable = false, visible = false },
		}
	}

	theme9Start.name = "theme9Start"
	theme9Start.back = nil
	theme9Start.sound = "menu_confirm"
	theme9Start.state = "READY"
	theme9Start.animationState = "SCROLL"
	theme9Start.timer = 0
	theme9Start.bgColor = { red = 0, green = 0, blue = 0 }
	theme9Start.items = {
			{name = "storyBg1", sprite = "STORY_BEGIN_BG_1", updateFunction = gotoFirstLevelLP4, isBackground = true  },
			{name = "storyBg2", sprite = "STORY_BEGIN_BG_2", updateFunction = gotoFirstLevelLP4, isBackground = true  },
			{name = "storyHideBirds1", sprite = "STORY_HIDE_BIRDS_1", selectable = false },
			{name = "storyHideBirds2", sprite = "STORY_HIDE_BIRDS_2", selectable = false },
			{name = "storyHideBirds3", sprite = "STORY_HIDE_BIRDS_3", selectable = false },
			{name = "storyYard", sprite = "STORY_CONSTRUCTION_YARD", selectable = false },
			{name = "bg_extension", sprite = "STORY_BEGIN_BG_EXTENSION", selectable = false },
			{name = "storyBigBrother", sprite = "STORY_EP4_START_BIG_BROTHER", selectable = false },
		}	
		
	theme9Complete = {
		name = "theme9Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_1", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_4", selectable = false },
			{name = "storyBigBrother", sprite = "STORY_BIG_BROTHER_2", selectable = false },
			{name = "storyHelmet", sprite = "STORY_BOSS_1_HELMET", selectable = false },
		}
	}	
	
	theme10Complete = {
		name = "theme10Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyBoss", sprite = "STORY_BOSS_THEME_2", selectable = false },
			{name = "storyEscape", sprite = "STORY_BOSS_KING_ESCAPING", selectable = false },
			{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_4", selectable = false },
			{name = "storyBigBrother", sprite = "STORY_BIG_BROTHER_2", selectable = false },
			{name = "storyHelmet", sprite = "STORY_BOSS_2_HELMET", selectable = false },
		}
	}
	
	theme11Complete = {
		name = "theme11Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyBg", sprite = "STORY_BOSS_BG", selectable = false },
			{name = "storyHoof", sprite = "STORY_HIDE_HOOF_2", selectable = false },
			{name = "storyHideBirds", sprite = "STORY_HIDE_BIRDS_4", selectable = false },
			{name = "storyEnd", sprite = "STORY_EP4_END", selectable = false },
			{name = "storyBigBrother", sprite = "STORY_BIG_BROTHER_2", selectable = false },
			{name = "storyHelmet", sprite = "STORY_BIG_BROTHER_HELMET", selectable = false },
			{name = "storyKingPeak", sprite = "STORY_EP4_KING_PEAK", selectable = false, visible = false },
			{name = "storyKingWink", sprite = "STORY_EP4_KING_WINK", selectable = false, visible = true },
		}
	}
	
	theme12Start.name = "theme12Start"
	theme12Start.back = nil
	theme12Start.sound = "menu_confirm"
	theme12Start.state = "READY"
	theme12Start.animationState = "SCROLL"
	theme12Start.timer = 0
	theme12Start.offsetY = 0
	theme12Start.bgColor = { red = 0, green = 0, blue = 0 }
	theme12Start.items = {
			{name = "storyWesternBegin", sprite = "STORY_WESTERN_BEGIN", isCompoSprite = true, selectable = false},
		}
		
	theme12Complete = {
		name = "theme12Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyWesternEndOne", sprite = "STORY_WESTERN_MIDDLE_1", isCompoSprite = true, selectable = false},
		}
	}
	
	theme13Complete = {
		name = "theme13Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyWesternEndTwo", sprite = "STORY_WESTERN_MIDDLE_2", isCompoSprite = true, selectable = false},
		}
	}
	
	theme14Complete = {
		name = "theme14Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyWesternEndFinal", sprite = "STORY_WESTERN_END", isCompoSprite = true, selectable = false},
			{name = "kingEyeOpen", sprite = "STORY_WEST_KING_EYE_OPEN", visible = false },
			{name = "kingEyePeak", sprite = "STORY_WEST_KING_EYE_PEAK", visible = false },
			{name = "kingEyeBlink", sprite = "STORY_WEST_KING_EYE_WINK", visible = false },
		}
	}
	
	-- ADDED
	theme15Complete = {
		name = "theme15Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyCaveEndOne", sprite = "STORY_CAVE_MIDDLE_1", isCompoSprite = true, selectable = false},
		}
	}

	
	
	
	theme15Start.name = "theme15Start"
	theme15Start.back = nil
	theme15Start.sound = "menu_confirm"
	theme15Start.state = "READY"
	theme15Start.animationState = "SCROLL"
	theme15Start.timer = 0
	theme15Start.bgColor = { red = 0, green = 0, blue = 0 }
	theme15Start.items = {
				{name = "storyCaveBegin", sprite = "STORY_CAVE_BEGIN", isCompoSprite = true, selectable = false},
	}	

	
	-- ADDED
	theme16Complete = {
		name = "theme16Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyCaveEndTwo", sprite = "STORY_CAVE_MIDDLE_2", isCompoSprite = true, selectable = false},
		}
	}

	-- ADDED
	theme17Complete = {
		name = "theme17Complete",
		back = nil,
		sound = "menu_confirm",		
		state = "READY",
		animationState = "SCROLL",
		timer = 0,
		bgColor = { red = 0, green = 0, blue = 0 },
		items = {
			{name = "storyCaveEndThree", sprite = "STORY_CAVE_END", isCompoSprite = true, selectable = false},
		}
	}
	
	
	levelComplete = {
		name = "levelComplete",
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundBox = { name = "backgroundTop", sprites = completeBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "BOTTOM"},
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		font = fontBasic,
		items = {
			{name = "background", box = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
			{name = "levelNumber", text = "LEVEL_NUMBER_PLACEHOLDER", selectable = false, font = "FONT_BIG_NUMBERS", hanchor="LEFT", vanchor="VCENTER" },
			{name = "levelComplete", text = "MT_LEVEL_COMPLETE", font = fontBasic, selectable = false, hanchor="LEFT", vanchor="TOP" },
			{name = "score", text = "MI_SCORE", selectable = false, hanchor="LEFT", vanchor="VCENTER" } ,
			{name = "scoreNumber", text = "MI_SCORE_AMOUNT_PLACEHOLDER", selectable = false, hanchor="LEFT", vanchor="VCENTER" } ,
			{name = "highScoreText", text = "MI_HIGH_SCORE", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "highScoreNumber", text = "MI_HIGH_SCORE_PLACEHOLDER", selectable = false, hanchor="RIGHT", vanchor="VCENTER" } ,
			{name = "starEffect", sprite = "EAGLE_METER_EFFECT", selectable = false, itemDrawFunction = starEffectItemDraw},
			{name = "buttonMenu", sprite = "BUTTON_MENU", updateFunction = updateMenu, page = levelSelectionPagesBasic[1] },
			{name = "buttonRestart", sprite = "BUTTON_RESTART", updateFunction = updateGame, restartLevel = true },
			{name = "buttonNextLevel", sprite = "BUTTON_NEXTLEVEL", callFunction = loadNextLevel },
			{name = "newHighScore", sprite = "NEW_HIGHSCORE_BG", selectable = false, hanchor="HCENTER", vanchor="VCENTER" } ,
			{name = "buttonCutscene1", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme1Complete, needLoadingScreen = true  },
			{name = "buttonCutscene2", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme2Complete, needLoadingScreen = true  },
			{name = "buttonCutscene3", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = gameComplete, needLoadingScreen = true  },
			{name = "stars", sprite = "", selectable = false },
			{name = "starsCurrent", sprite = "", selectable = false },
			{name = "buttonCutscene4", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme4Complete, needLoadingScreen = true  },
			{name = "buttonCutscene5", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme5Complete, needLoadingScreen = true  },
			{name = "buttonCutscene6", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme6Complete, needLoadingScreen = true  },
			{name = "buttonCutscene7", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme7Complete, needLoadingScreen = true  },
			{name = "buttonCutscene8", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme8Complete, needLoadingScreen = true  },
			{name = "buttonCutscene9", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme9Complete, needLoadingScreen = true  },
			{name = "buttonCutscene10", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme10Complete, needLoadingScreen = true  },
			{name = "buttonCutscene11", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme11Complete, needLoadingScreen = true  },
			{name = "buttonCutscene12", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme12Complete, needLoadingScreen = true  },
			{name = "buttonCutscene13", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme13Complete, needLoadingScreen = true  },
			{name = "buttonCutscene14", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme14Complete, needLoadingScreen = true  },
			{name = "buttonCutscene15", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme15Complete, needLoadingScreen = true  },
			{name = "buttonCutscene16", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme16Complete, needLoadingScreen = true  },
			{name = "buttonCutscene17", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme17Complete, needLoadingScreen = true  },
			{name = "eagleFeatherEmpty", sprite = "EAGLE_METER_EMPTY", selectable = false } ,
			{name = "ingameFeatherEmpty", sprite = "RESULT_ME_FEATHER_OFF", selectable = false } ,
			{name = "ingameFeatherFull", sprite = "RESULT_ME_FEATHER_ON", selectable = false } ,
			
			{name = "eagleFeatherFull", sprite = "EAGLE_METER_FULL", selectable = false } ,
			{name = "totalDestruction", text = "TEXT_EAGLE_TOTAL_DESTRUCTION", selectable = false, hanchor="HCENTER", vanchor="TOP" } ,
			{name = "eagleScoreNumber", text = "50%", selectable = false, hanchor="RIGHT", vanchor="TOP" } ,
			{name = "eagleFeatherFill", sprite = "EAGLE_METER_FILL", selectable = false, itemDrawFunction = eagleFeatherFillDraw } ,
			{name = "eagleHighScoreNumber", text = "", selectable = false, hanchor="RIGHT", vanchor="VCENTER" } ,
			{name = "eagleHighScoreFeatherEmpty", sprite = "EAGLE_FEATHER_EMPTY", selectable = false } ,
			{name = "eagleHighScoreFeatherFull", sprite = "EAGLE_FEATHER_FULL", selectable = false } ,
			{name = "eagleHighScoreText", text = "TEXT_EAGLE_HIGHSCORE", selectable = false, hanchor="RIGHT", vanchor="VCENTER" }, 
			{name = "rioButton", sprite = "BUTTON_RIO_ONLINE", updateFunction = gotoRioContest },
		}
	}
	
	levelFailed = {
		name = "levelFailed",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundBox = { name = "backgroundTop", sprites = completeBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "BOTTOM"},
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		font = fontBasic,
		
		items = {
			{name = "background", box = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
			{name = "levelNumber", text = "LEVEL_NUMBER_PLACEHOLDER", selectable = false, font = "FONT_BIG_NUMBERS", hanchor="LEFT", vanchor="VCENTER" },
			{name = "levelFailed", text = "MT_LEVEL_FAILED", font = fontBasic, selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "highScoreText", text = "MI_HIGH_SCORE", selectable = false, hanchor="HCENTER", vanchor="VCENTER" },
			{name = "highScoreNumber", text = "MI_HIGH_SCORE_PLACEHOLDER", selectable = false, hanchor="RIGHT", vanchor="VCENTER" } ,
			{name = "buttonMenu", sprite = "BUTTON_MENU", updateFunction = updateMenu, page = levelSelectionPagesBasic[1] },
			{name = "buttonRestart", sprite = "BUTTON_RESTART", updateFunction = updateGame, restartLevel = true },
			{name = "stars", sprite = "RESULT_STARS_0", selectable = false },			
			{name = "buttonEagle", sprite = "BUTTON_EAGLE", updateFunction = launchEagleBait, activateOnRelease = true },
			{name = "buttonEagleLost", sprite = "BUTTON_EAGLE_LOST", selectable = true, callFunction = showEagleTimeLeft },
			{name = "buttonNextLevel", sprite = "BUTTON_NEXTLEVEL", updateFunction = loadNextLevel, visible = false },
			{name = "buttonCutscene1", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme1Complete, needLoadingScreen = true  },
			{name = "buttonCutscene2", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme2Complete, needLoadingScreen = true  },
			{name = "buttonCutscene3", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = gameComplete, needLoadingScreen = true  },
			{name = "buttonCutscene4", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme4Complete, needLoadingScreen = true  },
			{name = "buttonCutscene5", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme5Complete, needLoadingScreen = true  },
			{name = "buttonCutscene6", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme6Complete, needLoadingScreen = true  },
			{name = "buttonCutscene7", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme7Complete, needLoadingScreen = true  },
			{name = "buttonCutscene8", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme8Complete, needLoadingScreen = true  },
			{name = "buttonCutscene9", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme9Complete, needLoadingScreen = true  },
			{name = "buttonCutscene10", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme10Complete, needLoadingScreen = true  },
			{name = "buttonCutscene11", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme11Complete, needLoadingScreen = true  },
			{name = "buttonCutscene12", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme12Complete, needLoadingScreen = true  },
			{name = "buttonCutscene13", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme13Complete, needLoadingScreen = true  },
			{name = "buttonCutscene14", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme14Complete, needLoadingScreen = true  },
			{name = "buttonCutscene15", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme15Complete, needLoadingScreen = true  },
			{name = "buttonCutscene16", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme16Complete, needLoadingScreen = true  },
			{name = "buttonCutscene17", sprite = "MENU_CUTSCENE", updateFunction = updateMenu, page = theme17Complete, needLoadingScreen = true  },
			--{name = "buttonEagleBuy", sprite = "BUTTON_EAGLE", updateFunction = updateMenu, page = mightyEagleDemoPage},
			--{name = "sign", sprite = "EAGLE_SELL_SIGN_1", selectable = false},
			{name = "ingameFeatherEmpty", sprite = "RESULT_ME_FEATHER_OFF", selectable = false } ,
			{name = "ingameFeatherFull", sprite = "RESULT_ME_FEATHER_ON", selectable = false } ,	
			{name = "buttonEagleBuy", sprite = "BUTTON_EAGLE", callFunction = showEagleBuyFromFailed},
			{name = "eagleTimeLeft", text = "MI_HIGH_SCORE_PLACEHOLDER", selectable = false, hanchor="HCENTER", vanchor="VCENTER" }
		}
	}
	
	if bingIsEnabled == true then
		_G.table.insert(levelFailed.items, {name = "bingButton", sprite = "BUTTON_BING", callFunction = bingSearchGE, callParam1 = "angry+birds+walkthrough" })
		_G.table.insert(levelFailed.items, {name = "bingSign", sprite = "BING_SIGN", angle = 1.57, itemDrawFunction = bingSignDraw, currentState = 1})
	end
	
	if ( deviceModel ~= "s60") then
		local buttonEagleBuy = getItemByName(levelFailed.items, "buttonEagleBuy")
		buttonEagleBuy.visible = false
	end
	
	gameFinished = {
		name = "gameFinished",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, selectable = true },
			{sprite = "REWARD_1"},
			{text = "TEXT_COMPLETE", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_1", selectable = false, hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	
	
	gameFinishedLP2 = {
		name = "gameFinishedLP2",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, selectable = true },
			{sprite = "REWARD_2" },
			{text = "TEXT_COMPLETE", selectable = false,  hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_2", selectable = false,  hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	gameFinishedLP3 = {
		name = "gameFinishedLP3",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0,  itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete,  selectable = true },
			{sprite = "REWARD_3"},
			{text = "TEXT_COMPLETE", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_3", selectable = false,  hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	
	gameFinishedLP4 = {
		name = "gameFinishedLP4",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete,  selectable = true },
			{sprite = "REWARD_4", },
			{text = "TEXT_COMPLETE", selectable = false,  hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_4", selectable = false,  hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	gameFinishedLP5 = {
		name = "gameFinishedLP5",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete,  selectable = true },
			{sprite = "REWARD_5", },
			{text = "TEXT_COMPLETE", selectable = false,  hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_5", selectable = false,  hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
		
	gameFinishedThreeStars = {
		name = "gameFinishedThreeStars",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, selectable = true },
			{sprite = "REWARD_1_STAR"},
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_1", selectable = false, hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	gameFinishedThreeStarsLP2 = {
		name = "gameFinishedThreeStarsLP2",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		font = fontBasic,
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, selectable = true },
			{sprite = "REWARD_2_STAR", },
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_2", selectable = false, hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	gameFinishedThreeStarsLP3 = {
		name = "gameFinishedThreeStarsLP3",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0, itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, selectable = true },
			{sprite = "REWARD_3_STAR", },
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_3", selectable = false, hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	gameFinishedThreeStarsLP4 = {
		name = "gameFinishedThreeStarsLP4",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0,itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, selectable = true },
			{sprite = "REWARD_4_STAR"},
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_4", selectable = false,hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
	gameFinishedThreeStarsLP5 = {
		name = "gameFinishedThreeStarsLP5",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0,itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, selectable = true },
			{sprite = "REWARD_5_STAR"},
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_5", selectable = false,hanchor="LEFT", vanchor="BASELINE" },
		}
	}	

	gameFinishedThreeStarsLP6 = {
		name = "gameFinishedThreeStarsLP6",	
		back = nil,
		state = "READY",
		sound = "menu_confirm",		
		backgroundDrawFunction = drawGame, 
		backgroundOverlay = { sprite = "DIM_BLOCK", visible = true },
		backgroundBox = { name = "backgroundTop", sprites = popupBoxSprites, sheet = "POPUPS_SHEET_1", hanchor = "HCENTER", vanchor = "VCENTER"},
		font = fontBasic,
		items = {
			{sprite = "GOLDEN_EGG_STAR_EFFECT", selectable = false, angle = 0,itemDrawFunction = starEffectItemDraw},
			{name = "buttonYes", sprite = "MENU_YES", updateFunction = updateMenu, page = levelComplete, selectable = true },
			{sprite = "REWARD_6_STAR"},
			{text = "TEXT_PERFECT", selectable = false, hanchor="LEFT", vanchor="VCENTER" },
			{text = "TEXT_LP_NAME_6", selectable = false,hanchor="LEFT", vanchor="BASELINE" },
		}
	}	
	
		
	tutorialGoldenEggPosition = { }
	
	

	prepareMenuPage(mainMenu)
	prepareMenuPage(about)
	prepareMenuPage(settingsPage)
	prepareMenuPage(loadingPage)
	--prepareMenuPage(pausePage)
	
	if gameCenterEnabled and gameCenter and gameCenter.leaderboards then
		postTotalHighScores()
	end
end

function showEagleBuyFromFailed()

	if(settings.mightyEagleEnabled ~= true) then
		setGameMode(updateMenu)
		--setActivePopupPage(mightyEagleIngamePage, nil, "level failed")
		setActivePopupPage(mightyEagleDemoPage, nil, "level failed")
		setActiveMenuPage(levelFailed)
		print("(1.5.4) ME demo page opened from failed\n")	
	end

end

function showEagleBuyFromMain()
	setGameMode(updateMenu)
	setActivePopupPage(mightyEagleDemoPage, nil, "main menu")
	setActiveMenuPage(mainMenu)
	print("(1.5.4) ME demo page opened from main\n")
end
--, page = mightyEagleDemoPage 
--{name = "buttonEagleBuy", sprite = "BUTTON_EAGLE", callFunction = showEagleBuy, page = mightyEagleDemoPage },


function updateMenu(dt, time)
	
	
	
	if (currentMenuPage == levelSelectionPagesBasic or currentMenuPage == levelSelectionPagesExtra or currentMenuPage == levelSelectionPagesPack3 -- ADDED
	or currentMenuPage == levelSelectionPagesPack4 or currentMenuPage == levelSelectionPagesPack5  or currentMenuPage == levelSelectionPagesPack6 or currentMenuPage == levelSelectionPagesGoldenEggs[1]) 
	and rovioNewsIsShown then
		rovioNews:hide()
		rovioNewsIsShown = false
	end
	rovioNewsShowWhenLoaded = false
	
	selectedMenuItem = -1
	if oldScreenWidth ~= screenWidth or oldScreenHeight ~= screenHeight then
		--oldScreenWidth = screenWidth
		--oldScreenHeight = screenHeight
		--createMenuPages()
		--initializeMenu()
	
		if currentMenuPage == about or currentMenuPage == mainMenu then
			prepareMenuPage(mainMenu,nil,true)
			hideLeftMenu(dt)
			prepareMenuPage(about,nil,true)
		else
			prepareMenuPage(currentMenuPage,nil,true)
		end
		if popupPage then
			if popupPage == achievementPopUpPage then
				-- reset the layout of gamecenter achievement popup except the animation
				local tempAnimationState = popupPage.animationState
				local tempAnimationTimer = popupPage.animationTimer
				prepareMenuPage(achievementPopUpPage,nil,true)
				popupPage.animationState = tempAnimationState 
				popupPage.animationTimer = tempAnimationTimer 
			else
				prepareMenuPage(popupPage,nil,true)
			end
		end		
	end
	
	if settings.eagleUsedTime ~= nil and (currentMenuPage == levelFailed or currentMenuPage == levelSelectionPages) then
		if timeDiff(currentTime(), settings.eagleUsedTime) >= eagleLockedTime then 
			print("Mighty eagle available again!\n")
			getItemByName(levelFailed.items, "buttonEagle").visible = true
			getItemByName(levelFailed.items, "buttonEagleLost").visible = false
			getItemByName(levelFailed.items, "eagleTimeLeft").visible = false
			oldEagleButtonStatusDisabled = false
			if currentMenuPage == levelFailed then
				_G.res.playAudio("goldenegg", 1, false)
			end
			
			eagleInfoTimer = nil
			settings.eagleUsedTime = nil
			
			if settings.eaglesUsedIn ~= nil and #settings.eaglesUsedIn > 0 then
				settings.eaglesUsedIn = {}
				dontStopMusic = true
				local musicPlaying = _G.res.isAudioPlaying(currentMainMenuSong)
				prepareMenuPage(levelSelectionPages)
				if musicPlaying ~= true then
					_G.res.stopAudio(currentMainMenuSong)
				end
				dontStopMusic = nil
			end
		end
	end
	
	
	if audioRampVolume then
		audioRampVolume = audioRampVolume + (dt / audioRampLength)
		
		if audioRampVolume <= 0 then
			_G.res.stopAudioOutput()
			audioRampVolume = nil
		elseif audioRampVolume > 1 then
			audioRampVolume = nil
		else
			-- Use squared volume because it gives more linear response
			setMusicVolume( audioRampVolume * audioRampVolume )
			setEffectsVolume( audioRampVolume * audioRampVolume )
		end
	end
	if currentMenuPage == mainMenu or currentMenuPage == about then
		menuSunsetAngle = menuSunsetAngle + 0.125 * dt
		if menuSunsetAngle > _G.math.pi then
			menuSunsetAngle = menuSunsetAngle - 2 * _G.math.pi
		end
		animateBirds(dt)
	end
		
	goldenEggsStarEffectAngle = goldenEggsStarEffectAngle + 0.6 * dt
	if goldenEggsStarEffectAngle > _G.math.pi then
		goldenEggsStarEffectAngle = goldenEggsStarEffectAngle - 2 * _G.math.pi
	end
	
	if currentMenuPage.bgColor ~= nil then
		setBGColor( currentMenuPage.bgColor.red, currentMenuPage.bgColor.green, currentMenuPage.bgColor.blue)
	end
	
	-- handle dragging
	if menuDrag ~= nil then
		menuDrag = nil
	end
	if keyPressed["LBUTTON"] then
		menuDragStart = { x = cursor.x, y = cursor.y, time = time, page = currentMenuPage}
	elseif menuDragStart ~= nil and keyReleased["LBUTTON"] then
		if menuDragStart.page == currentMenuPage then
			dist = distance(menuDragStart.x, menuDragStart.y, cursor.x, cursor.y)
			menuDrag = { startX = menuDragStart.x, startY = menuDragStart.y, endX = cursor.x, endY = cursor.y, speed = dist / (time - menuDragStart.time) }
		end
		menuDragStart = nil
	end
		
	if ((currentMenuPage == mainMenu and mainMenu.back == nil and popupPage == nil) or
		(currentMenuPage == mainMenu and popupPage == areYouSurePage))
		and (keyPressed["ESCAPE"] or keyPressed["KEY_BACK"]) then

		requestExit()
		return
	end
	
	if (currentMenuPage == mainMenu) then
		-- Right Slider
		local buttonSliderBG = getItemByName(mainMenu.items, "buttonSliderBG")
		local buttonSlider = getItemByName(mainMenu.items, "buttonSlider")
		local speed = 600*displayScale
		
		if buttonSliderBG.state == "closed" then
			for i = 1, #buttonSliderBG.elements do
				getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).visible = false
			end
		end
		
		if buttonSliderBG.state == "opening" then
			local sliderBGRight = getItemByName(mainMenu.items, "sliderBGRight")
			
			if buttonSlider.angle < 3.14 then
				buttonSlider.angle = buttonSlider.angle + 20 * dt
			else
				buttonSlider.angle = 3.14
			end

			if sliderBGRight.height < sliderBGRight.maxHeight then
				for i = 1, #buttonSliderBG.elements do
					
					if getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y > buttonSliderBG.elements[i].yPos then
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y - speed*dt
					else
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = buttonSliderBG.elements[i].yPos
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).visible = true
					end
				end
				sliderBGRight.height = sliderBGRight.height + speed*dt
				if sliderBGRight.height >= sliderBGRight.maxHeight then
					sliderBGRight.height = sliderBGRight.maxHeight
					for i = 1, #buttonSliderBG.elements do
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).selectable = true
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = buttonSliderBG.elements[i].yPos
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).visible = true
						
					end
					buttonSliderBG.state = "open"
				end
			end
		elseif buttonSliderBG.state == "closing" then
			local sliderBGRight = getItemByName(mainMenu.items, "sliderBGRight")
			
			if buttonSlider.angle > 0 then
				buttonSlider.angle = buttonSlider.angle - 20 * dt
			else
				buttonSlider.angle = 0
			end
			
			if sliderBGRight.height > 0 then
				for i = 1, #buttonSliderBG.elements do
					getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).selectable = false
					if getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y < (buttonSliderBG.y - speed*dt) then
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y + speed*dt
					else
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).y = buttonSliderBG.y
						getItemByName(mainMenu.items, buttonSliderBG.elements[i].name).visible = false
					end
				end
				sliderBGRight.height = sliderBGRight.height - speed*dt
			else
				sliderBGRight.height = 0
				sliderBGRight.visible = false
				buttonSliderBG.state = "closed"
			end
		
		end
		
		-- Left Slider
		local buttonSliderBGOptions = getItemByName(mainMenu.items, "buttonSliderBGOptions")
		local buttonSliderOptions = getItemByName(mainMenu.items, "buttonSliderOptions")
		local speed = 600*displayScale
		local buttonOff = getItemByName(mainMenu.items, "buttonOff")
		local gfxQualityButtonOff = getItemByName(mainMenu.items, "gfxQualityButtonOff")
		
		if buttonSliderBGOptions.state == "closed" then
			for i = 1, #buttonSliderBGOptions.elements do
				getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).visible = false
				buttonOff.visible = false
			end
		end
		
		if buttonSliderBGOptions.state == "opening" then
			local sliderBGLeft = getItemByName(mainMenu.items, "sliderBGLeft")
			
			if buttonSliderOptions.angle < 3.14 then
				buttonSliderOptions.angle = buttonSliderOptions.angle + 20 * dt
			else
				buttonSliderOptions.angle = 3.14
			end
			
			if sliderBGLeft.height < sliderBGLeft.maxHeight then
				for i = 1, #buttonSliderBGOptions.elements do
					
					if getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y >= (buttonSliderBGOptions.elements[i].yPos + speed*dt) then
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y - speed*dt
						if buttonSliderBGOptions.elements[i].name == "sfx" then
							buttonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
						end
						
						if buttonSliderBGOptions.elements[i].name == "gfxQualityButton" then
							gfxQualityButtonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
						end
					else
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = buttonSliderBGOptions.elements[i].yPos
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).visible = true
						if buttonSliderBGOptions.elements[i].name == "sfx" then
							buttonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
							if settings.audioEnabled ~= false then
								buttonOff.visible = false
							else
								buttonOff.visible = true
							end
						end
						
						if buttonSliderBGOptions.elements[i].name == "gfxQualityButton" then
							gfxQualityButtonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
							if settings.gfxLowQuality == false then
								gfxQualityButtonOff.visible = false
							elseif settings.gfxLowQuality == true then
								gfxQualityButtonOff.visible = true
							end
						end
					end
				end
				
				sliderBGLeft.height = sliderBGLeft.height + speed*dt
				
				if sliderBGLeft.height >= sliderBGLeft.maxHeight then
					sliderBGLeft.height = sliderBGLeft.maxHeight
					for i = 1, #buttonSliderBGOptions.elements do
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).selectable = true
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = buttonSliderBGOptions.elements[i].yPos
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).visible = true
						if settings.audioEnabled ~= false then
							buttonOff.visible = false
						else
							buttonOff.visible = true
						end
						
						if settings.gfxLowQuality == false then
							gfxQualityButtonOff.visible = false
						elseif settings.gfxLowQuality == true then
							gfxQualityButtonOff.visible = true
						end
						
					end
					buttonSliderBGOptions.state = "open"
				end
			end
		elseif buttonSliderBGOptions.state == "closing" then
			local sliderBGLeft = getItemByName(mainMenu.items, "sliderBGLeft")
			
			if buttonSliderOptions.angle > 0 then
				buttonSliderOptions.angle = buttonSliderOptions.angle - 20 * dt
			else
				buttonSliderOptions.angle = 0
			end
			
			if sliderBGLeft.height > 0 then
				for i = 1, #buttonSliderBGOptions.elements do
					getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).selectable = false
					if getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y < (buttonSliderBGOptions.y - speed*dt)  then
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y + speed*dt
						if buttonSliderBGOptions.elements[i].name == "sfx" then
							buttonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
						end
						
						if buttonSliderBGOptions.elements[i].name == "gfxQualityButton" then
							gfxQualityButtonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
						end
					else
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y = buttonSliderBGOptions.y
						getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).visible = false
						if buttonSliderBGOptions.elements[i].name == "sfx" then
							buttonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
							--buttonOff.visible = false
						end
						
						if buttonSliderBGOptions.elements[i].name == "gfxQualityButton" then
							gfxQualityButtonOff.y = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name).y
						end
					end
				end
				sliderBGLeft.height = sliderBGLeft.height - speed*dt
			else
				sliderBGLeft.height = 0
				sliderBGLeft.visible = false
				buttonSliderBGOptions.state = "closed"
			end
		
		end
	end
	
	
	if popupPage == nil then
		updateMenuPage(currentMenuPage, dt)
	elseif popupPage == achievementPopUpPage then
		updateMenuPage(currentMenuPage, dt)
		local page = achievementPopUpPage
		
		page.animationTimer = page.animationTimer - dt
		local bgBox = getItemByName(page.items, "achievementBox")
		local boxOffset = 190
		if deviceModel == "ipad" then
			boxOffset = 280
		end
		if page.animationTimer > 2.4 then
			bgBox.y = screenHeight - boxOffset * (2.7 - page.animationTimer)
		elseif page.animationTimer > 0.4 and page.animationTimer <= 2.4 then
			bgBox.y = screenHeight - boxOffset * 0.3
		elseif page.animationTimer > 0 and page.animationTimer <= 0.4 then
			bgBox.y = screenHeight - boxOffset * (page.animationTimer - 0.1)
		elseif page.animationTimer <= 0 then
			popupPage = nil
		end
	else
		updateMenuPage(popupPage, dt)
	end
	
	if (deviceModel == "n900" or deviceModel == "s60") and currentMenuPage.animationState == nil and currentMenuPage ~= upsellPage then
		updateMenuPage(overlayMenuPage, dt)
	end
	
	
	local sw, _  = _G.res.getSpriteBounds("", getItemByName(mainMenu.items, "credits").sprite)
	local sideBorderOffset = sw / 4

	updateAnimations(dt)
	about.offsetX = elementAnimations["aboutPageScroll"].percentage / 100 * (about.backgroundBox.width - sideBorderOffset) - about.backgroundBox.width - sideBorderOffset
	about.backgroundOverlay.shade = elementAnimations["aboutPageScroll"].percentage / 100 * 0.6
	-- do not fade background if tutorials are going to be shown next
	if birdTutorialPopups == nil or #birdTutorialPopups == 0 then
		pausePage.backgroundOverlay.shade = elementAnimations["ingamePausePageScroll"].percentage / 100 * 0.65
	else
		pausePage.backgroundOverlay.shade = 0
	end
	pausePage.offsetX = elementAnimations["ingamePausePageScroll"].percentage / 100 * pauseBGw - pauseBGw
	drawMenu(dt)
end

-- uses page offset values to offset current coordinates
function offsetCoordinates(page, x, y)
	if page.offsetX ~= nil then
		x = x + page.offsetX
	end
	if page.offsetY ~= nil then
		y = y + page.offsetY
	end

	return x, y
end

function updateMenuPage(page, dt)
	
	if page == nil then
		return
	end
	
	
	
	updateGameMenuPage(page, dt)
	
	-- if page is not ready for input
	if page.state ~= "READY" then
		return
	end
	
	-- Handle menu items
	-- update items and select one that is under the cursor
	if keyPressed["LBUTTON"] or keyReleased["LBUTTON"] then
		local i = #page.items
		local j = 0
		local distanceToSelected = 10000
		local hasChildren = false
		local selectedMenuItemChildren = -1
		while i >= 1 or j >= 1 do
			local ci = page.items[i]
			local parent = nil			
			if ci.selectableChildren == true and hasChildren == true then
				parent = ci
				ci = page.items[i].children[j]
			end
			
			-- is menu item visible
			if ci.visible ~= false and ci.selectable ~= false then
				if ci.activateOnRelease ~= true and keyPressed["LBUTTON"] or ci.activateOnRelease == true and keyReleased["LBUTTON"] then
					local selectionCandidate = nil
					local selectionCandidateChildren = nil
					local x = ci.x and ci.x or 0
					local y = ci.y and ci.y or 0
					if parent ~= nil then
						x = x + parent.x
						y = y + parent.y
					end
					
					x, y = offsetCoordinates(page, x, y)
					-- menu item is text
					if ci.text ~= nil then
						x = screenWidth/2
						y = screenHeight/(#page.items + 1) * i
						x = ci.x and ci.x or x
						y = ci.y and ci.y or y
						x, y = offsetCoordinates(page, x, y)

						if ci.font ~= nil then
							--use item default
							setFont(ci.font)
						elseif page.font ~= nil then
							--use page override
							setFont(page.font)
						else
							--use menu default
							setFont(defaultMenuFont)
						end

						if checkTextBounds("TEXTS_BASIC", ci.text, ci.hanchor, ci.vanchor, x, y, cursor.x, cursor.y) then
							selectionCandidate = i
							selectionCandidateChildren = j
						end
					end

					-- menu item is image
					if ci.sprite ~= nil then
						if checkSpriteBounds("", ci.sprite, x, y, cursor.x, cursor.y) then
							selectionCandidate = i
							selectionCandidateChildren = j
						end
					end

					-- menu item is just touch area
					if ci.w ~= nil and ci.h ~= nil then
						if checkBounds(x, y, ci.w, ci.h, cursor.x, cursor.y) then
							selectionCandidate = i
							selectionCandidateChildren = j
						end
					end
					
					if ci.box ~= nil and ci.width ~= nil and ci.height ~= nil then
						if checkBounds(x, y, ci.width, ci.height, cursor.x, cursor.y, nil, ci.hanchor, ci.vanchor) then
							selectionCandidate = i
							selectionCandidateChildren = j
						end
					end
					
					if selectionCandidate ~= nil and page.items[selectionCandidate].disableSelection ~= true then
						local dist = distance(x, y, cursor.x, cursor.y)
						if dist < distanceToSelected then
							selectedMenuItem = selectionCandidate
							if hasChildren == true then
								selectedMenuItemChildren = selectionCandidateChildren
							end
							distanceToSelected = dist
						end
					end
				end
			end
			
			if (parent == nil and (ci.selectableChildren ~= true or ci.children == nil)) or j == 1 then
				i = i - 1
				hasChildren = false
				j = 0
			else
				hasChildren = true
				if j == 0 then
					j = #page.items[i].children
				else
					j = j - 1
				end
			end
		end

		if selectedMenuItem > -1 then
			local selectedItem = page.items[selectedMenuItem]
			if selectedMenuItemChildren > -1 then
				selectedItem = page.items[selectedMenuItem].children[selectedMenuItemChildren]
			end
			-- do not change game mode if update function is not available
			if selectedItem.updateFunction ~= nil and page.items[selectedMenuItem].disableUpdateFunctionChange ~= true then
				
				if(selectedItem.name ~= nil) then
					if(selectedItem.name == "extraLevel1" or selectedItem.name == "extraLevel2" or selectedItem.name == "extraLevel3") then
						print("(1.5.4) Facebook level clicked!"..(selectedItem.name).."\n")
						logFlurryEvent("Facebook level clicked "..(selectedItem.name))
					end
				end
				
				setGameMode(selectedItem.updateFunction)
				if currentGameMode == updateMenu then
					if selectedItem.page.popup == true then
						setActivePopupPage(selectedItem.page)
					else
						if selectedItem.needLoadingScreen == true then
							setGameMode(updateLoadingEx)
							loadingPage.nextPage = selectedItem.page
						else
							setActiveMenuPage(selectedItem.page)
							popupPage = nil
						end
					end
				end
				if currentGameMode == addPopupMenu then
					setGameMode(updateMenu)
					setActivePopupPage(selectedItem.page)
				end
				if currentGameMode == removePopupMenu then
					setGameMode(updateMenu)
					popupPage = nil
				end			
				handleGameModeChange(page, selectedMenuItem)
				
				-- Item selection sound
				local sound = page.sound
				if selectedItem.sound ~= nil then
					sound = selectedItem.sound
				end
				if sound ~= nil then
					_G.res.playAudio(sound, 1, false)
				end
			end
			
			if selectedItem.callFunction ~= nil then
				selectedItem.callFunction( selectedItem.callParam1 )
			end
			
			selectedMenuItem = -1
		end		
	end
	
	if deviceModel == "n900" and hasLevelPack1() == false and page == episodeSelectionPage 
	 and keyReleased["LBUTTON"] and page.items[1].disableUpdateFunctionChange ~= true then
		local itm = getItemByName(page.items, "pack1buy")
		if checkSpriteBounds(itm.sheet, itm.sprite, page.items[1].x + itm.x, page.items[1].y + itm.y - 10, cursor.x, cursor.y) then
			itm.callFunction(dt)
		end
	end
	
	if (keyPressed["ESCAPE"] or keyPressed["KEY_BACK"]) and page.back ~= nil then
		if currentMenuPage == about and page.back == mainMenu then
			hideLeftMenu(dt)
		elseif page.back == "goToLevelSelection" then
			if startedFromEditor then
				setGameMode(hidePauseMenu)
			else
				setGameMode(updateMenu)
				setActiveMenuPage(levelSelectionPages)
			end
		elseif page.back.popup then
			setActivePopupPage(page.back)
		else
			setActiveMenuPage(page.back)
		end
		if page.popup then
			popupPage = nil
		end
	end
	
	
	if (keyPressed["KEY_MENU"]) and page.menuButton then
		
		if page.menuButton == about then
			showLeftMenu()
		elseif page.menuButton == mainMenu then
			hideLeftMenu(dt)
		elseif page.menuButton == "goToGame" then
			setGameMode(hidePauseMenu)
		else
			setActiveMenuPage(page.menuButton)
		end
		if page.popup then
			popupPage = nil
		end
	end

end

function setSelectedEpisode(item)
	settings.selectedEpisode = item
end

-- Game specific menu update logic
function updateGameMenuPage(page, dt)
	
	if page.backgroundOverlay ~= nil then
		if page.backgroundOverlay.sprite ~= nil and page.backgroundOverlay.visible ~= false then
			if page.backgroundOverlay.sprite == "DIM_BLOCK" then
				if page.backgroundOverlay.shade == nil then
					page.backgroundOverlay.shade = 0
				end
				page.backgroundOverlay.shade = page.backgroundOverlay.shade + dt * 2.7
				if page.backgroundOverlay.shade > 0.65 then
					page.backgroundOverlay.shade = 0.65
				end
			end
		end
	end

	if page == mainMenu then
		if _G.res.isAudioPlaying(currentMainMenuSong) == false then
			_G.res.playAudio(currentMainMenuSong, 0.8, true, 7)
		end
	end
	
	if page == pausePage then
		if _G.res.isAudioPlaying(currentMusic) == false then
			_G.res.playAudio(currentMusic, 1, true,7)
		end
		
		if currentMenuPage ~= mightyEaglePaymentPage and rovioNewsIsLoaded and not rovioNewsIsShown and elementAnimations["ingamePausePageScroll"].state == "VISIBLE" then
			hideAd()
			rovioNews:show()
			rovioNewsIsShown = true
		end
		rovioNewsShowWhenLoaded = false
		
	end
	
	if page == levelFailed and deviceModel ~= "iphone" and deviceModel ~= "ipad" and deviceModel ~= "iphone4" and bingIsEnabled then
		if getItemByName(levelFailed.items, "bingSign").currentState == 1 then
			if getItemByName(levelFailed.items, "bingSign").angle - 8 * dt > -0.35 then
				getItemByName(levelFailed.items, "bingSign").angle = getItemByName(levelFailed.items, "bingSign").angle - 8 * dt
			else
				getItemByName(levelFailed.items, "bingSign").angle = -0.35
				getItemByName(levelFailed.items, "bingSign").currentState = 2
			end
		elseif getItemByName(levelFailed.items, "bingSign").currentState == 2 then
			if getItemByName(levelFailed.items, "bingSign").angle + 6 * dt < 0.17 then
				getItemByName(levelFailed.items, "bingSign").angle = getItemByName(levelFailed.items, "bingSign").angle + 6 * dt
			else
				getItemByName(levelFailed.items, "bingSign").angle = 0.17
				getItemByName(levelFailed.items, "bingSign").currentState = 3
			end
		elseif getItemByName(levelFailed.items, "bingSign").currentState == 3 then
			if getItemByName(levelFailed.items, "bingSign").angle - 5 * dt > -0.1 then
				getItemByName(levelFailed.items, "bingSign").angle = getItemByName(levelFailed.items, "bingSign").angle - 5 * dt
			else
				getItemByName(levelFailed.items, "bingSign").angle = -0.1
				getItemByName(levelFailed.items, "bingSign").currentState = 4
			end
		elseif getItemByName(levelFailed.items, "bingSign").currentState == 4 then
			if getItemByName(levelFailed.items, "bingSign").angle + 4 * dt < 0 then
				getItemByName(levelFailed.items, "bingSign").angle = getItemByName(levelFailed.items, "bingSign").angle + 4 * dt
			else
				getItemByName(levelFailed.items, "bingSign").angle = 0
			end
		end
	end
	
	if page == episodeSelectionPage then
		for i = 1, page.numEpisodes do
			if page.items[i].x < - page.items[i].width / 1.5 or  page.items[i].x > screenWidth + page.items[i].width / 1.5 then
				page.items[i].visible = false
				--print("item: "..page.items[i].name.." not visible, x: "..page.items[i].x)
			else
				page.items[i].visible = true
				--print("item: "..page.items[i].name.." visible, x: "..page.items[i].x)
			end
		end
		
		
		if dragSpeed == nil then
			dragSpeed = 0
		end
		
		local minDragSpeed = 500 * (screenWidth + 480) / 960
	
		if doubleClick and cursor.x >= page.goldenEggHitBox.xMin and cursor.x < page.goldenEggHitBox.xMax
		   and cursor.y >= page.goldenEggHitBox.yMin and cursor.y < page.goldenEggHitBox.yMax then
			goldenEggAchieved("Level8")
		end
			
		if episodeMenuDragStart == nil then
			for i = 1, page.numEpisodes do
				page.items[i].disableSelection = true
			end
		end
			
		if keyPressed["LBUTTON"] then
			
			episodeMenuDragStart = { x = cursor.x, y = cursor.y, time = time }
			episodeMenuDragStart.itemsx = {}
			for i = 1, page.numEpisodes do
				_G.table.insert(episodeMenuDragStart.itemsx, page.items[i].x)
				page.items[i].disableSelection = false
			end
				
		elseif keyReleased["LBUTTON"] and episodeMenuDragStart ~= nil then
			
			local dragLength = distance( episodeMenuDragStart.x, episodeMenuDragStart.y, cursor.x, cursor.y )
			dragSpeed = dragLength / (time - episodeMenuDragStart.time)
			local xdrag = _G.math.abs( episodeMenuDragStart.x - cursor.x)
			local left = cursor.x < episodeMenuDragStart.x
				
			for i = 1, page.numEpisodes do
				page.items[i].disableUpdateFunctionChange = true
				if i ~= settings.selectedEpisode then
					page.items[i].callFunction = setSelectedEpisode
					page.items[i].callParam1 = i
				else
					page.items[i].callFunction = nil	
				end					
			end
			
			if dragLength > (0.65 * screenWidth) then
				local dist = screenWidth
				local closest
				for i = 1, page.numEpisodes do
					if _G.math.abs(page.items[i].x - (screenWidth / 2)) < dist then
						closest = i
						dist = _G.math.abs(page.items[i].x - (screenWidth / 2))
					end
				end
				centerItem = closest
			
			elseif dragSpeed > 200 and dragLength > 40 then
				-- change the center item if a fast sweep was made
				if left then
					if settings.selectedEpisode < page.numEpisodes then
						settings.selectedEpisode = settings.selectedEpisode + 1
					elseif dragSpeed > minDragSpeed then
						dragSpeed = minDragSpeed
					end
				else
					if settings.selectedEpisode > 1 then
						settings.selectedEpisode = settings.selectedEpisode - 1
					elseif dragSpeed > minDragSpeed then
						dragSpeed = minDragSpeed
					end
				end
			elseif dragLength <= 40 then
				-- set the center item to the one that's closest to the center
				for i = 1, page.numEpisodes do
					if page.items[i].x > screenWidth * 0.25 and page.items[i].x <= screenWidth * 0.75 then
						settings.selectedEpisode = i
					end
				end
				-- check if episode is not locked and enable updatefunction
				if settings.selectedEpisode == page.numEpisodes or settings.selectedEpisode == page.numEpisodes - 2 or settings.selectedEpisode == page.numEpisodes - 1 or getItemByName(page.items[settings.selectedEpisode].children, "lock").visible ~= true then
					page.items[settings.selectedEpisode].disableUpdateFunctionChange = false
				end
			end
			if dragSpeed < minDragSpeed then
				dragSpeed = minDragSpeed
			end
									
		elseif keyHold["LBUTTON"] and episodeMenuDragStart ~= nil then
			
			local horizontalDrag = cursor.x - episodeMenuDragStart.x
			
			if page.items[1].x > screenWidth / 2 then
				if episodeMenuDragStart.itemsx[1] < screenWidth / 2 then
					horizontalDrag = horizontalDrag - 0.5 * (horizontalDrag - (screenWidth / 2 - episodeMenuDragStart.itemsx[1]))
				else
					horizontalDrag = horizontalDrag * 0.5
				end
			elseif page.items[page.numEpisodes].x < screenWidth / 2 then
				if episodeMenuDragStart.itemsx[page.numEpisodes] > screenWidth / 2 then
					horizontalDrag = horizontalDrag + 0.5 * (horizontalDrag * -1 - (episodeMenuDragStart.itemsx[page.numEpisodes] - screenWidth / 2))
				else
					horizontalDrag = horizontalDrag * 0.5
				end
			end
				
			for i = 1, page.numEpisodes do
				page.items[i].x = episodeMenuDragStart.itemsx[i] + horizontalDrag
			end
				
		else
			
			if centerItem ~= nil then
				settings.selectedEpisode = centerItem
				centerItem = nil
			end
			
			-- move items to their places
			local distToRest = page.items[settings.selectedEpisode].x - screenWidth / 2
			if _G.math.abs(distToRest) < 1 then
				for i = 1, page.numEpisodes do
					page.items[i].x = (i - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2
				end
				-- check if episode is not locked and enable updatefunction
				if settings.selectedEpisode == page.numEpisodes - 2 or settings.selectedEpisode == page.numEpisodes - 1 or settings.selectedEpisode == page.numEpisodes or getItemByName(page.items[settings.selectedEpisode].children, "lock").visible ~= true then
					page.items[settings.selectedEpisode].disableUpdateFunctionChange = false
				end
				
				for i = 1, page.numEpisodes do
					getItemByName(page.items, "dot" .. i).sprite = "LS_DOT_BLACK"
				end
				getItemByName(page.items, "dot" .. settings.selectedEpisode).sprite = "LS_DOT_WHITE"
							
			else
				if _G.math.abs(distToRest) < dragSpeed * dt * 3 then
					dragSpeed = dragSpeed * 0.7
				end
				dragSpeed = _G.math.max(dragSpeed, 10)
				add = _G.math.min(dragSpeed * dt, _G.math.abs(distToRest))
				if distToRest > 0 then
					add = add * -1
				end
				for i = 1, page.numEpisodes do
					page.items[i].x = page.items[i].x + add
				end
			end
		end
	
	end
	-- handle dragging
	if page == levelSelectionPagesBasic or page == levelSelectionPagesExtra or page == levelSelectionPagesPack3 or page == levelSelectionPagesPack4 or page == levelSelectionPagesPack5 or (levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1])
	-- ADDED
	or page == levelSelectionPagesPack6 then 
		--if not isLiteVersion then
			if menuDrag ~= nil then
				if (_G.math.abs(menuDrag.endX - menuDrag.startX) > 30 and menuDrag.speed > 100) or 
				   (_G.math.abs(menuDrag.endX - menuDrag.startX) > 90 and menuDrag.speed > 20) then
					if levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1] then
						if menuDrag.endX > menuDrag.startX then
							if page.currentPage > 1 and page.currentOffset > -(page.currentPage - 1) * screenWidth then
								page.currentPage = page.currentPage - 1
							end
						elseif page.currentPage < page.pageCount and page.currentOffset < -(page.currentPage - 1) * screenWidth and isGEPage2Unlocked() then
							if page.currentPage < page.pageCount then
								page.currentPage = page.currentPage + 1
							end
						end
						levelSelectionDragSpeed = _G.math.max(menuDrag.speed, 500)
					else
						if menuDrag.endX > menuDrag.startX then
							if page.currentPage > 1 and page.currentOffset > -(page.currentPage - 1) * screenWidth then
								page.currentPage = page.currentPage - 1
							end
						elseif page.currentPage < page.pageCount and page.currentOffset < -(page.currentPage - 1) * screenWidth then
							if page.currentPage < page.pageCount then
								page.currentPage = page.currentPage + 1
							end
						end
						levelSelectionDragSpeed = _G.math.max(menuDrag.speed, 500)
					end
				end -- set current page
				if page == levelSelectionPagesBasic then
					settings.currentLevelSelectionPages.basic = page.currentPage
				elseif page == levelSelectionPagesExtra then
					settings.currentLevelSelectionPages.extra = page.currentPage
				elseif page == levelSelectionPagesPack3 then
					settings.currentLevelSelectionPages.pack3 = page.currentPage
				elseif page == levelSelectionPagesPack4 then
					settings.currentLevelSelectionPages.pack4 = page.currentPage
				elseif page == levelSelectionPagesPack5 then
					settings.currentLevelSelectionPages.pack5 = page.currentPage
				elseif page == levelSelectionPagesPack6 then
					settings.currentLevelSelectionPages.pack6 = page.currentPage
				elseif levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1] then
					--settings.currentLevelSelectionPages.goldeneggs = page.currentPage
					if (_G.math.abs(menuDrag.endX - menuDrag.startX) > 30 and menuDrag.speed > 100) or 
				   (_G.math.abs(menuDrag.endX - menuDrag.startX) > 60 and menuDrag.speed > 20) then
						for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do
							page.items[i].selectable = false
						end
						page.dragging = true
					elseif not(helpAreaPressed) then
						for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do				
							page.items[i].selectable = true
						end
						page.dragging = false
					end
				end
			end
			
			page.targetOffset = -(page.currentPage - 1) * screenWidth
			
			if keyPressed["LBUTTON"] then
				levelSelectionPagesDragStartOffset = page.currentOffset
				levelSelectionPagesPressed = true
				if levelSelectionPagesGoldenEggs == nil or page ~= levelSelectionPagesGoldenEggs[1] then
					for i = page.firstLevelIndex, #page.items do
						page.items[i].disableSelection = false
					end
				elseif helpAreaPressed ~= true then
					for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do				
						page.items[i].selectable = true
					end
				end
			elseif keyHold["LBUTTON"] == true then
				if levelSelectionPagesDragStartOffset == nil then
					levelSelectionPagesDragStartOffset = 0
				end	
				
				if page.currentOffset > 0 or page.currentOffset < (page.pageCount - 1) * -screenWidth then
					if page.currentOffset > 0 and levelSelectionPagesDragStartOffset < 0 then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset
						levelSelectionPagesDragStartOffset = 0
					elseif page.currentOffset < (page.pageCount - 1) * -screenWidth and levelSelectionPagesDragStartOffset > (page.pageCount - 1) * -screenWidth  then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset + (page.pageCount - 1) * -screenWidth
						levelSelectionPagesDragStartOffset = (page.pageCount - 1) * -screenWidth
					end
						page.currentOffset = levelSelectionPagesDragStartOffset + (cursor.x - menuDragStart.x) / 2
					if page.currentOffset > screenWidth then
						page.currentOffset = screenWidth
					elseif page.currentOffset < page.pageCount * -screenWidth then
						page.currentOffset = page.pageCount * -screenWidth
					end
				else
					if levelSelectionPagesDragStartOffset > 0 then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset * 2
						levelSelectionPagesDragStartOffset = 0
					elseif levelSelectionPagesDragStartOffset < (page.pageCount - 1) * -screenWidth  then
						menuDragStart.x = menuDragStart.x - levelSelectionPagesDragStartOffset * 2 + (page.pageCount - 1) * -screenWidth * 2
						levelSelectionPagesDragStartOffset = (page.pageCount - 1) * -screenWidth
					end
					if ( menuDragStart ~= nil) then
						page.currentOffset = levelSelectionPagesDragStartOffset + (cursor.x - menuDragStart.x)
					end
					
				end
			else
				if levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0 then
					local speed = 1000
					if levelSelectionDragSpeed ~= nil then
						if _G.math.abs(page.targetOffset - page.currentOffset) < levelSelectionDragSpeed * dt * 3 then
							levelSelectionDragSpeed = levelSelectionDragSpeed * 0.7
						end
						speed = _G.math.max(levelSelectionDragSpeed, 100)
					end
					if page.currentOffset > page.targetOffset then
						page.currentOffset = page.currentOffset - dt * speed
						if page.currentOffset <= page.targetOffset then
							page.currentOffset = page.targetOffset
						end
					elseif page.currentOffset < page.targetOffset then
						page.currentOffset = page.currentOffset + dt * speed
						if page.currentOffset >= page.targetOffset then
							page.currentOffset = page.targetOffset
						end
					end
				else
					levelSelectionScrollStartTimer = levelSelectionScrollStartTimer - dt
				end
			end
			
			if page.currentOffset == page.targetOffset then
				local _, textIndex = getItemByName(page.items, "text_" .. page.themes[1])
				for i = 1, page.pageCount do
					page.items[i + textIndex - 1].visible = page.currentPage == i
				end
				local _, dotIndex = getItemByName(page.items, "dot1")
				for i = dotIndex, dotIndex + page.pageCount - 1 do
					page.items[i].sprite = "LS_DOT_BLACK"
				end
				page.items[dotIndex + page.currentPage - 1].sprite = "LS_DOT_WHITE"				
			end
		
			for i = page.firstLevelIndex, #page.items do
				if page.items[i].levelIndex ~= nil then
--					if(page.items[i].name ~= nil) then
	--					print(page.items[i].name.."\n")
		--			end
					page.items[i].x = page.items[i].relativeX + page.currentOffset
					if levelSelectionPagesPressed and (levelSelectionPagesGoldenEggs == nil or (levelSelectionPagesGoldenEggs and page ~= levelSelectionPagesGoldenEggs[1])) then
						page.items[i].disableSelection = page.currentOffset ~= page.targetOffset
					end
				end
			end
					
			if page == levelSelectionPagesPack3 then
				-- move golden egg
					local goldenEgg = getItemByName(page.items, "goldenEgg")
					goldenEgg.x = goldenEgg.relativeX + page.currentOffset
								
					local w, _ = _G.res.getSpriteBounds("", goldenEgg.sprite)
					local px, _ = _G.res.getSpritePivot("", goldenEgg.sprite)
					if goldenEgg.x + (w - px) <= screenWidth then
						episode3LevelSelectionEggAchieved()
					end
			end
		--else
			-- if keyPressed["LBUTTON"] and levelSelectionPagesPressed == false then
				-- levelSelectionPagesPressed = true
				-- if levelSelectionPagesGoldenEggs == nil or (levelSelectionPagesGoldenEggs and page ~= levelSelectionPagesGoldenEggs[1]) then
					-- for i = page.firstLevelIndex, #page.items do
						-- page.items[i].disableSelection = false
					-- end
				-- end
			-- end
		-- end
			
		bgColorPhase = _G.math.max(1, _G.math.min(page.pageCount, -(page.currentOffset / screenWidth - 1)))
		if bgColorPhase == page.pageCount then
			page.bgColor = { red = page.bgColors[page.pageCount].red, green = page.bgColors[page.pageCount].green, blue = page.bgColors[page.pageCount].blue}
		else
			leftColor = page.bgColors[_G.math.floor(bgColorPhase)]
			rightColor = page.bgColors[_G.math.floor(bgColorPhase) + 1]
			_, rightWeight = _G.math.modf(bgColorPhase)
			leftWeight = 1 - rightWeight
			red = leftColor.red * leftWeight + rightColor.red * rightWeight
			green = leftColor.green * leftWeight + rightColor.green * rightWeight
			blue = leftColor.blue * leftWeight + rightColor.blue * rightWeight
			page.bgColor = { red = red, green = green, blue = blue}
		end
			
		-- move Ovistore buttons
		if deviceModel == "n900" and page == levelSelectionPagesBasic and getItemByName(page.items, "overlay").visible then
			getItemByName(page.items, "overlay").shade = _G.math.max(0, _G.math.min(0.65, (page.currentOffset / -screenWidth)))  	
			if page.currentOffset < -screenWidth then
				getItemByName(page.items, "button1").x = screenWidth / 2
				getItemByName(page.items, "button2").x = screenWidth / 2
			else
				getItemByName(page.items, "button1").x = getItemByName(page.items, "button1").relativeX + page.currentOffset
				getItemByName(page.items, "button2").x = getItemByName(page.items, "button2").relativeX + page.currentOffset
			end
		end
		
	end
		
	if levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1] and levelSelectionPagesPressed then

		if getItemByName(page.items, "overlay") ~= nil then
			if getItemByName(page.items, "overlay").shade == nil then
				getItemByName(page.items, "overlay").shade = 0
			end
			
			if getItemByName(page.items, "overlay").fadeSpeed > 0 then
				getItemByName(page.items, "overlay").shade = getItemByName(page.items, "overlay").shade + dt * getItemByName(page.items, "overlay").fadeSpeed
				if getItemByName(page.items, "overlay").shade > 0.65 then
					getItemByName(page.items, "overlay").shade = 0.65
					getItemByName(page.items, "overlay").fadeSpeed = 0
				end
			elseif getItemByName(page.items, "overlay").fadeSpeed < 0 then
				getItemByName(page.items, "overlay").shade = getItemByName(page.items, "overlay").shade + dt * getItemByName(page.items, "overlay").fadeSpeed
				if getItemByName(page.items, "overlay").shade < 0 then
					getItemByName(page.items, "overlay").shade = 0
					getItemByName(page.items, "overlay").fadeSpeed = 0
					getItemByName(page.items, "overlay").visible = false
				end
			end
		end
	
		-- help text bubble

		
		if page == levelSelectionPagesGoldenEggs[1] and keyReleased["LBUTTON"] then
				helpAreaPressed = false
				for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do
					if page.items[i].visible ~= false and page.items[i].disableSelection and not(page.dragging) then 
						local w, h = _G.res.getSpriteBounds("", page.items[i].sprite)
						local px, py = _G.res.getSpritePivot("", page.items[i].sprite)
						if cursor.x > page.items[i].x - px and cursor.x < page.items[i].x + (w - px) and
						   cursor.y > page.items[i].y - py and cursor.y < page.items[i].y + (h - py) then
							getItemByName(page.items, "tipContent").sprite = page.items[i].children[1].sprite
							helpAreaPressed = true
						end
					end
				end
				
				if helpAreaPressed and getItemByName(page.items, "tipBubble").visible ~= true then 
					getItemByName(page.items, "tipBubble").visible = true
					getItemByName(page.items, "overlay").visible = true
					getItemByName(page.items, "overlay").shade = 0
					getItemByName(page.items, "overlay").fadeSpeed = 2.7
					getItemByName(page.items, "tipContent").visible = true

					-- disable egg buttons until the help text is dismissed
					for i = page.firstLevelIndex, page.firstLevelIndex + page.levelCount do
						page.items[i].selectable = false
					end
				else
					getItemByName(page.items, "tipBubble").visible = false	
					getItemByName(page.items, "tipContent").visible = false
					getItemByName(page.items, "overlay").fadeSpeed = -2.7
				end
		end
	end
	
	if page == about then
		about.scrollTimer = about.scrollTimer - dt
		local scrollSpeed = 35
				
		if keyPressed["LBUTTON"] and cursor.x < page.backgroundBox.width then
			aboutDragStart = { x = cursor.x, y = cursor.y }
			scrollSpeed = 0
		elseif keyReleased["LBUTTON"] and aboutDragStart ~= nil then
			scrollSpeed = 35
			aboutDragStart = nil
		elseif keyHold["LBUTTON"] and aboutDragStart ~= nil then
			scrollSpeed = 0
			dragSpeed = cursor.y - aboutDragStart.y
			aboutDragStart = { x = cursor.x, y = cursor.y }
		end
		
		if about.scrollTimer < 0 then
			for i = about.scrollStart, about.scrollEnd do
				about.items[i].y = about.items[i].y - dt * scrollSpeed
			end
		end
		for i = about.scrollStart, about.scrollEnd do
			about.items[i].y = about.items[i].y + dragSpeed
		end
			
		if about.items[about.scrollEnd].y < -about.items[about.scrollEnd].h * 0.5 then
			--local increment = about.items[1].h + about.items[2].h + about.items[3].h + about.items[4].h + about.items[5].h + about.items[6].h + about.items[7].h + about.items[8].h + screenHeight + 4 * 30
			local increment = 0			
			for i = 1, about.scrollEnd do
				increment = increment + about.items[i].h
			end			
			increment = increment + 120 + screenHeight
			
			for i = about.scrollStart, about.scrollEnd do
				about.items[i].y = about.items[i].y + increment + 120
			end
		elseif about.items[1].y > about.items[1].h + screenHeight + 10 then
			--local increment = about.items[1].h + about.items[2].h + about.items[3].h + about.items[4].h + about.items[5].h + about.items[6].h + about.items[7].h + about.items[8].h + screenHeight + 4 * 30
			local increment = 0			
			for i = 1, about.scrollEnd do
				increment = increment + about.items[i].h
			end			
			increment = increment + 120 + screenHeight
			
			
			for i = about.scrollStart, about.scrollEnd do
				about.items[i].y = about.items[i].y - increment - 200
			end 
		end
		
		dragSpeed = dragSpeed * _G.math.pow(0.002, dt)
		if _G.math.abs(dragSpeed) < 0.1 then
			dragSpeed = 0
		end
	end
	
	if page == goldenEggAchievedPage then -- or page == mightyEagleAvailablePage then
		page.timer = page.timer - dt
		local _, eggHeight = _G.res.getSpriteBounds("", page.items[1].sprite)
		page.items[1].angle = page.items[1].angle + 1.6 * dt
		
		if page.animationState == "FADEIN" then
			page.backgroundOverlay.shade = (page.fadeInLength - page.timer) / page.fadeInLength * page.fullyShaded
			page.items[1].visible = true
			page.items[1].y = (screenHeight*0.5) + _G.math.pow(page.timer / page.fadeInLength, 2) * ((screenHeight*0.5) + eggHeight)
			if page.timer < 0 then
				page.timer = page.fadedLength
				page.animationState = "FADED"
			end
		end
		
		if page.animationState == "FADED" then
			page.backgroundOverlay.shade = page.fullyShaded
			page.items[1].y = screenHeight*0.5
			if page.timer < 0 then
				page.timer = page.fadeOutLength
				page.animationState = "FADEOUT"
			end
		end
		
		if page.animationState == "FADEOUT" then
			page.backgroundOverlay.shade = (page.timer / page.fadeOutLength) * page.fullyShaded
			page.items[1].y = (screenHeight*0.5) - _G.math.pow((page.fadeInLength - page.timer) / page.fadeInLength, 2) * ((screenHeight*0.5) + eggHeight)
			if page.timer < 0 then
				if page.enablePhysicsWhenDone then
					setPhysicsEnabled(true)
				end
				popupPage = nil
				if deviceModel == "iphone4" and currentGameMode ~= updateMenu then
					changeResolution = true
					wantedResolution = "FULL"
					resolutionChanged = true
				end
				
				if currentMenuPage == levelSelectionPagesGoldenEggs[1] then
					prepareMenuPage(currentMenuPage)
				end
			end
		end
	end
	
	-- effects in levelcomplete when mighty eagle is used 
	if page == levelComplete then
		if eagleBaitLaunched == true then
			local starEffect = getItemByName(levelComplete.items, "starEffect")
			starEffect.angle = starEffect.angle + 1.6 * dt
			
			local eagleFeatherFill = getItemByName(levelComplete.items, "eagleFeatherFill")
			local eagleScoreNumber = getItemByName(levelComplete.items, "eagleScoreNumber")
			local eagleHighScoreNumber = getItemByName(levelComplete.items, "eagleHighScoreNumber")
			
			-- some little delay before starting filling the feather
			if starEffect.angle > 0.8 then
				eagleFeatherFill.fill = eagleFeatherFill.fill + 50 * dt 
				if eagleFeatherFill.fill > mightyEagleScore then
					eagleFeatherFill.fill = mightyEagleScore
				end
				eagleScoreNumber.text = _G.string.format("%d", eagleFeatherFill.fill) .. "%"
				eagleHighScoreNumber.text = _G.string.format("%d", _G.math.max(eagleHighScoreNumber.number, eagleFeatherFill.fill)) .. "%"
				prepareTextItem(page, eagleScoreNumber)
				prepareTextItem(page, eagleHighScoreNumber)
			end
			
			local totalDestruction = getItemByName(levelComplete.items, "totalDestruction")
			local eagleFeatherFull = getItemByName(levelComplete.items, "eagleFeatherFull")
			local eagleFeatherEmpty = getItemByName(levelComplete.items, "eagleFeatherEmpty")
			local eagleHighScoreFeatherEmpty = getItemByName(levelComplete.items, "eagleHighScoreFeatherEmpty")
			local eagleHighScoreFeatherFull = getItemByName(levelComplete.items, "eagleHighScoreFeatherFull")
			
			
			if eagleHighScoreNumber.number >= 100 then
				eagleHighScoreFeatherEmpty.visible = false
				eagleHighScoreFeatherFull.visible = true 
			end
			
			if eagleFeatherFill.fill >= 100 then
				eagleScoreNumber.visible = false
				totalDestruction.visible = true
				eagleFeatherFull.visible = true
				eagleFeatherFill.visible = false
				eagleFeatherEmpty.visible = false
				starEffect.visible = true
				eagleHighScoreFeatherEmpty.visible = false
				eagleHighScoreFeatherFull.visible = true 
			end
		end
	end
	
	if page == goldenEggStarAchievedPage then
		page.timer = page.timer - dt
		local _, eggHeight = _G.res.getSpriteBounds("", page.items[1].sprite)
		page.items[1].angle = page.items[1].angle + 1.6 * dt
		
		if page.animationState == "FADEIN" then
			page.backgroundOverlay.shade = (page.fadeInLength - page.timer) / page.fadeInLength * page.fullyShaded
			page.items[1].visible = true
			page.items[1].y = (screenHeight*0.5) + _G.math.pow(page.timer / page.fadeInLength, 2) * ((screenHeight*0.5) + eggHeight)
			if page.timer < 0 then
				page.timer = page.fadedLength
				page.animationState = "FADED"
			end
		end
		
		if page.animationState == "FADED" then
			page.backgroundOverlay.shade = page.fullyShaded
			page.items[1].y = screenHeight*0.5

			if page.timer < 0 then
				page.timer = page.fadeOutLength
				page.animationState = "FADEOUT"
			end
		end
		
		if page.animationState == "FADEOUT" then
			page.backgroundOverlay.shade = (page.timer / page.fadeOutLength) * page.fullyShaded
			page.items[1].y = (screenHeight*0.5) - _G.math.pow((page.fadeInLength - page.timer) / page.fadeInLength, 2) * ((screenHeight*0.5) + eggHeight)
			if page.timer < 0 then
				if page.enablePhysicsWhenDone then
					setPhysicsEnabled(true)
				end
				popupPage = nil
			end
		end
	end
	
	if page == mightyEaglePaymentPage then
		local progress = getItemByName(page.items, "progress")
		progress.timer = progress.timer + dt
		if(progress.timer > 0.1) then -- and (progress.angle <= 1080) then
			progress.angle = progress.angle + _G.math.pi / 6
			progress.timer = 0
		end
		--[[if (progress.angle == 1080) then
			progress.angle = progress.angle + _G.math.pi / 4
			
			page.items[2].visible = false
			page.items[4].visible = true
			page.items[5].visible = true
			enableMightyEagleFeature()		
		end]]
	end
	
	if page == boomerangBirdAchievedPage then
		page.timer = page.timer - dt
		local _, birdHeight = _G.res.getSpriteBounds("", page.items[1].sprite)
		page.items[1].angle = page.items[1].angle + 1.6 * dt
		
		if page.animationState == "FADEIN" then
			page.backgroundOverlay.shade = (page.fadeInLength - page.timer) / page.fadeInLength * page.fullyShaded
			page.items[1].visible = true
			page.items[1].y = (screenHeight*0.5) + _G.math.pow(page.timer / page.fadeInLength, 2) * ((screenHeight*0.5) + birdHeight)
			if page.timer < 0 then
				page.timer = page.fadedLength
				page.animationState = "FADED"
			end
		end
		
		if page.animationState == "FADED" then
			page.backgroundOverlay.shade = page.fullyShaded
			page.items[1].y = screenHeight*0.5
			if page.timer < 0 then
				page.timer = page.fadeOutLength
				page.animationState = "FADEOUT"
			end
		end
		
		if page.animationState == "FADEOUT" then
			page.backgroundOverlay.shade = (page.timer / page.fadeOutLength) * page.fullyShaded
			page.items[1].y = (screenHeight*0.5) - _G.math.pow((page.fadeInLength - page.timer) / page.fadeInLength, 2) * ((screenHeight*0.5) + birdHeight)
			if page.timer < 0 then
				setPhysicsEnabled(true)
				popupPage = nil
				if deviceModel == "iphone4" and currentGameMode ~= updateMenu then
					changeResolution = true
					wantedResolution = "FULL"
					resolutionChanged = true
				end
				
				if currentMenuPage == levelComplete then
					prepareMenuPage(currentMenuPage)
				end
			end
		end
	end
	
	if page == gameComplete then

		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX  + screenWidth
					end
					page.timer = 1
					page.animationState = "STATE1"
					return
				end
			end
			
			if page.animationState == "STATE1" then
				page.items[3].visible = true
				page.timer = 0.5
				page.animationState = "STATE2"
				return
			end

			if page.animationState == "STATE2" then
				page.items[3].visible = false
				page.items[4].visible = true
				page.timer = 1
				page.animationState = "STATE3"
				return
			end

			if page.animationState == "STATE3" then
				page.items[4].visible = false
				page.items[3].visible = true
				page.timer = 1.3
				page.animationState = "STATE4"
				return
			end
			
			if page.animationState == "STATE4" then
				page.items[3].visible = false
				page.items[4].visible = false
				page.items[5].visible = true
				page.timer = 0.15
				page.animationState = "STATE5"
				return
			end

			if page.animationState == "STATE5" then
				page.items[5].visible = false
				page.items[3].visible = true
				_G.res.playAudio("piglette_oink_story", 1, false, 0)
				page.timer = 2
				page.animationState = "END"
				return
			end
						
			if page.animationState == "END" then
				setGameMode(gotoAbout)
			end
		end
	end
	
	if page == theme5Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX  + screenWidth
					end
					page.timer = 1
					page.animationState = "STATE1"
					return
				end
			end
			
			if page.animationState == "STATE1" then
				page.timer = 0.5
				page.animationState = "STATE2"
				return
			end

			if page.animationState == "STATE2" then
				page.items[6].visible = false
				page.items[7].visible = true
				page.timer = 1
				page.animationState = "STATE3"
				return
			end

			if page.animationState == "STATE3" then
				page.items[7].visible = false
				page.items[6].visible = true
				page.timer = 1.3
				page.animationState = "STATE4"
				return
			end
			
			if page.animationState == "STATE4" then
				page.items[6].visible = false
				page.items[7].visible = false
				page.items[8].visible = true
				page.timer = 0.15
				page.animationState = "STATE5"
				return
			end

			if page.animationState == "STATE5" then
				page.items[8].visible = false
				page.items[6].visible = true
				page.timer = 1.0
				page.animationState = "STATE6"
				return
			end
			
			if page.animationState == "STATE6" then
				_G.res.playAudio("piglette_oink_story", 1, false, 0)
				page.items[6].visible = false
				page.items[9].visible = true
				page.timer = 2.0
				page.animationState = "END"
				return
			end
						
			if page.animationState == "END" then
				setGameMode(gotoAbout)
			end
		end
	end
	
	if page == gameStart then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX  + screenWidth
					end
					page.timer = 0
					page.animationState = "STATE1"
					return
				end
			end

			if page.animationState == "STATE1" then
				page.timer = 2.5
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoFirstLevel)
				settings.gameStarted = true
			end
		end
	end
	
	if page == theme1Complete then
		
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
				
			end
									
			if page.animationState == "END" then
				if not hasLevelPack1() then
					if isLiteVersion then
						setActiveMenuPage(mainMenu, false)
						setActivePopupPage(upsellPage)
						playVideo( "videos/lite_iPhone.m4v" )
					else
						setGameMode(gotoLevelSelection)
						setActiveMenuPage(levelSelectionPagesBasic)
						settings.currentLevelSelectionPages.basic = settings.currentLevelSelectionPages.basic + 1
					end
				else
					setGameMode(gotoLevelSelection)
					settings.currentLevelSelectionPages.basic = settings.currentLevelSelectionPages.basic + 1
				end
			end
		end
	end
	
	if page == theme2Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelection)
				settings.currentLevelSelectionPages.basic = settings.currentLevelSelectionPages.basic + 1
			end
		end
	end

	if page == theme4Start then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX  + screenWidth
					end
					page.timer = 0
					page.animationState = "STATE1"
					return
				end
			end

			if page.animationState == "STATE1" then
				page.timer = 2.5
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoFirstLevelLP2)
				settings.lp2Started = true
			end
		end
	end
	
	if page == theme4Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelectionExtra)
				settings.currentLevelSelectionPages.extra = settings.currentLevelSelectionPages.extra + 1				
			end
		end
	end
	
	if page == theme6Start then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local ys = page.ys or 1
				if not page.dontScroll then
					page.offsetY = page.offsetY + dt * page.scrollSpeed
				end
				
				--page.offsetY = page.offsetY + dt * (page.maxOffsetY / 6)
				page.tuneTimer = page.tuneTimer - dt
				--if page.offsetY >= page.maxOffsetY then
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetY >= page.backgroundHeight * page.ys) then
					if not page.dontScroll then
						page.offsetY = page.maxOffsetY 
					end
					page.animationState = "END"
					page.timer = 4.0
				end
			elseif page.animationState == "END" then
				setGameMode(gotoFirstLevelLP3)
				settings.lp3Started = true
			end
		end
		
		if settings.lp3Started == true and keyPressed["LBUTTON"] then
			gotoFirstLevelLP3()
		end
	end
	
	if page == theme6Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelectionPack3)
				settings.currentLevelSelectionPages.pack3 = settings.currentLevelSelectionPages.pack3 + 1
			end
		end
	end
	
	if page == theme7Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelectionPack3)
				settings.currentLevelSelectionPages.pack3 = settings.currentLevelSelectionPages.pack3 + 1
			end
		end
	end
	
	if page == theme8Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX + screenWidth
					end
					page.timer = 1.5
					page.animationState = "STATE1"
					return
				end
			end
			if page.animationState == "STATE1" then
				page.items[5].visible = true
				page.timer = 1
				page.animationState = "STATE2"
				return
			end
			
			if page.animationState == "STATE2" then
				page.items[5].visible = false
				page.timer = 1.3
				page.animationState = "STATE3"
				return
			end
			
			if page.animationState == "STATE3" then
				page.items[6].visible = true
				page.timer = 0.15
				page.animationState = "STATE4"
				return
			end

			if page.animationState == "STATE4" then
				_G.res.playAudio("piglette_oink_story", 1, false, 0)
				page.items[6].visible = false
				page.timer = 2.0
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoAbout)
			end
		end
	end
	
	if page == theme9Start then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX  + screenWidth
					end
					page.timer = 0
					page.animationState = "STATE1"
					return
				end
			end

			if page.animationState == "STATE1" then
				page.timer = 2.3 
				page.animationState = "SCROLL_FORWARD"
				local sw2, _ = _G.res.getSpriteBounds("", getItemByName(page.items, "bg_extension").sprite)
				local scaleX = page.xs or 1
				page.tuneTimer = 1.73075
				page.dontScroll = true
				if (page.backgroundWidth + sw2) * scaleX > screenWidth then
					page.dontScroll = false
				end
				page.scrollSpeed = sw2 * scaleX / page.tuneTimer
				return
			end
			
			if page.animationState == "SCROLL_FORWARD" then
				local sw2, _ = _G.res.getSpriteBounds("", getItemByName(page.items, "bg_extension").sprite)
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -(page.backgroundWidth + sw2) * scaleX  + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -(page.backgroundWidth + sw2) * scaleX  + screenWidth
					end
					page.timer = 0
					page.animationState = "STATE2"
					return
				end
			end
			
			if page.animationState == "STATE2" then
				_G.res.stopAllAudio()
				_G.res.playAudio("big_brother_awakens", 1, false, 7)
				page.timer = 2.2
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoFirstLevelLP4)
				settings.lp4Started = true
			end
		end
	end
	
	if page == theme12Start then
		if keyPressed["LBUTTON"] and settings.lp5Started and settings.lp5Started == true then
			gotoFirstLevelLP5()
		end

		page.timer = page.timer - dt
		if page.timer <= 0 then
			if page.animationState == "SCROLL" then
				--page.timer = 2.3
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and (page.offsetX < (screenWidth - page.backgroundWidth))) then
					page.animationState = "STATE1"
				end
			end
			
			if page.animationState == "STATE1" then
				page.timer = 3
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoFirstLevelLP5)
				settings.lp5Started = true
			end
		end	
	end
	
	if page == theme12Complete then
		page.timer = page.timer - dt
		if page.timer <= 0 then
			if page.animationState == "SCROLL" then
				--page.timer = 2.3
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and (page.offsetX < (screenWidth - page.backgroundWidth))) then
					page.animationState = "STATE1"
				end
			end
			
			if page.animationState == "STATE1" then
				page.timer = 3
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				--setGameMode(gotoAbout)
				setGameMode(gotoLevelSelectionPack5)
				settings.currentLevelSelectionPages.pack5 = settings.currentLevelSelectionPages.pack5 + 1
			end
		end	
	end
	
	if page == theme13Complete then
		page.timer = page.timer - dt
		if page.timer <= 0 then
			if page.animationState == "SCROLL" then
				--page.timer = 2.3
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and (page.offsetX < (screenWidth - page.backgroundWidth))) then
					page.animationState = "STATE1"
				end
			end
			
			if page.animationState == "STATE1" then
				page.timer = 3
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				--setGameMode(gotoAbout)
				setGameMode(gotoLevelSelectionPack5)
				settings.currentLevelSelectionPages.pack5 = settings.currentLevelSelectionPages.pack5 + 1
			end
		end	
	end
		
	if page == theme9Complete or page == theme10Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX + screenWidth
					end
					page.timer = 2.5
					page.animationState = "END"
					return
				end
			end
									
			if page.animationState == "END" then
				setGameMode(gotoLevelSelectionPack4)
				settings.currentLevelSelectionPages.pack4 = settings.currentLevelSelectionPages.pack4 + 1
			end
		end
	end
	
	-- ADDED --------------------------------------
	if page == theme15Start then
		if keyPressed["LBUTTON"] and settings.lp6Started and settings.lp6Started == true then
			gotoFirstLevelLP6()
		end

		page.timer = page.timer - dt
		if page.timer <= 0 then
			if page.animationState == "SCROLL" then
				--page.timer = 2.3
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and (page.offsetX < (screenWidth - page.backgroundWidth))) then
					page.animationState = "STATE1"
				end
			end
			
			if page.animationState == "STATE1" then
				page.timer = 3
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				setGameMode(gotoFirstLevelLP6)
				settings.lp6Started = true
			end
		end	
	end
	
	if page == theme15Complete or page == theme16Complete or page == theme17Complete then
		page.timer = page.timer - dt
		if page.timer <= 0 then
			if page.animationState == "SCROLL" then
				--page.timer = 2.3
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and (page.offsetX < (screenWidth - page.backgroundWidth))) then
					page.animationState = "STATE1"
				end
			end
			
			if page.animationState == "STATE1" then
				page.timer = 3
				page.animationState = "END"
				return
			end
			
			if page.animationState == "END" then
				--setGameMode(gotoAbout)
				setGameMode(gotoLevelSelectionPack6)
				if(page ~= theme17Complete) then
					settings.currentLevelSelectionPages.pack6 = settings.currentLevelSelectionPages.pack6 + 1
				end
			end
		end	
	end
	
	
	
	----------------------------------------------
	
	if page == theme11Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth  * scaleX + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth * scaleX + screenWidth
					end
					page.timer = 3.0
					page.animationState = "STATE1"
					return
				end
			end
			
			local storyKingPeak = getItemByName(page.items, "storyKingPeak")
			local storyKingWink = getItemByName(page.items, "storyKingWink")
			if page.animationState == "STATE1" then
				storyKingWink.visible = false
				page.timer = 1
				page.animationState = "STATE2"
				return
			end
			
			if page.animationState == "STATE2" then
				storyKingPeak.visible = true
				page.timer = 1.0
				page.animationState = "STATE3"
				return
			end
			
			if page.animationState == "STATE3" then
				storyKingPeak.visible = false
				page.timer = 1.0
				page.animationState = "STATE4"
				return
			end

			if page.animationState == "STATE4" then
				_G.res.playAudio("piglette_oink_story", 1, false, 0)
				storyKingWink.visible = true
				page.timer = 0.2
				page.animationState = "STATE5"
				return
			end
			
			if page.animationState == "STATE5" then
				storyKingWink.visible = false
				page.timer = 1.5
				page.animationState = "END"
				return
			end
			if page.animationState == "END" then
				setGameMode(gotoAbout)
			end
		end
	end
	
	if page == theme14Complete then
		page.timer = page.timer - dt
		if page.timer < 0 then
			if page.animationState == "SCROLL" then
				local scaleX = page.xs or 1
				if not page.dontScroll then
					page.offsetX = page.offsetX - dt * page.scrollSpeed
				end
				page.tuneTimer = page.tuneTimer - dt
				if page.tuneTimer <= 0 or (page.dontScroll ~= true and page.offsetX <= -page.backgroundWidth + screenWidth) then
					if not page.dontScroll then
						page.offsetX = -page.backgroundWidth + screenWidth
					end
					page.timer = 3.0
					page.animationState = "STATE1"
					return
				end
			end
			
			local storyKingPeak = getItemByName(page.items, "kingEyePeak")
			local storyKingWink = getItemByName(page.items, "kingEyeBlink")
			local storyKingOpen = getItemByName(page.items, "kingEyeOpen")
			if page.animationState == "STATE1" then
				storyKingWink.visible = false
				storyKingOpen.visible = true
				page.timer = 1
				page.animationState = "STATE2"
				return
			end
			
			if page.animationState == "STATE2" then
				storyKingPeak.visible = true
				storyKingOpen.visible = false
				page.timer = 1.0
				page.animationState = "STATE3"
				return
			end
			
			if page.animationState == "STATE3" then
				storyKingPeak.visible = false
				storyKingOpen.visible = true
				page.timer = 1.0
				page.animationState = "STATE4"
				return
			end

			if page.animationState == "STATE4" then
				_G.res.playAudio("piglette_oink_story", 1, false, 0)
				storyKingWink.visible = true
				page.timer = 0.2
				page.animationState = "STATE5"
				return
			end
			
			if page.animationState == "STATE5" then
				storyKingWink.visible = false
				storyKingOpen.visible = true
				page.timer = 1.5
				page.animationState = "END"
				return
			end
			if page.animationState == "END" then
				setGameMode(gotoAbout)
			end
		end
	end
	
	if page == gameFinished or page == gameFinishedThreeStars or
	   page == gameFinishedLP2 or page == gameFinishedThreeStarsLP2 or 
	   page == gameFinishedLP3 or page == gameFinishedThreeStarsLP3 or
	   page == gameFinishedLP4 or page == gameFinishedThreeStarsLP4 or 
	   page == gameFinishedLP5 or page == gameFinishedThreeStarsLP5 or
	   page == gameFinishedLP6 or page == gameFinishedThreeStarsLP6 then
		page.items[1].angle = page.items[1].angle + 0.8 * dt
	end
end

function prepareTextItem(page, ci)
	if ci.text ~= nil then
		local textBoxSize = ci.textBoxSize and ci.textBoxSize or screenWidth
		local group = ci.group and ci.group or "TEXTS_BASIC"
		
		--check font
		if ci.font == nil then
			-- use default
			ci.font = defaultMenuFont
			--use page default if it exists
			if page.font ~= nil then
				ci.font = page.font
			end
		end
		setFont(ci.font)
		clipText(group, ci.text, textBoxSize)
		local fh = _G.res.getFontLeading()
		local textHeight = #clippedText.lines * fh
		ci.h = textHeight
		ci.w = clippedText.widestLine
		ci.lines = {}
		
		local k = 1
		while  k <= #clippedText.lines do
			ci.lines[k] = clippedText.lines[k]
			--print("Calculated new lines: " .. ci.lines[k] .. "\n")
			k = k + 1
		end
	end
end

function calculateTotalScoreAndStars(levelTable)

	local totalScore = 0
	local gainedStars = 0
	local totalStars = 0
	
	for k = 1, #levelTable do
		local pageTable = levelTable[k]
		totalStars = totalStars + #pageTable*3
		for i = 1, #pageTable do
		
			if highscores[pageTable[i]] ~= nil and highscores[pageTable[i]].completed == true then
				totalScore = totalScore + highscores[pageTable[i]].score
				
				if highscores[pageTable[i]].score >= starTable[pageTable[i]].goldScore then
					gainedStars = gainedStars + 3
				elseif highscores[pageTable[i]].score >= starTable[pageTable[i]].silverScore then
					gainedStars = gainedStars + 2
				elseif highscores[pageTable[i]].score > 0 then
					gainedStars = gainedStars + 1
				end
			end
			
		end
	end
	
	return totalScore, gainedStars, totalStars
end

function getEagleScore(levelName)
	-- Check that this is actually availabe
	if(levelName == nil or highscores[levelName] == nil or highscores[levelName].eagleScore == nil) then
		return -1;
	end
	
	local eagleScore = 0

	if(highscores[levelName].eagleScore ~= nil) then
		eagleScore = highscores[levelName].eagleScore
	end		
	print("---------- Returning score : "..eagleScore.."\n")
	return eagleScore
end


function calculateFeathers(levelTable)
	local totalFeathers = 0
	local gainedFeathers = 0
	
	for k = 1, #levelTable do
		local pageTable = levelTable[k]
		totalFeathers = totalFeathers + #pageTable
		for i = 1, #pageTable do
			--local eagleScore = highscores[pageTable[i]].eagleScore or  highscores[pageTable[i]].trialEagleScore
			if highscores[pageTable[i]] ~= nil and getEagleScore(pageTable[i]) >= 100 then
				gainedFeathers = gainedFeathers + 1
			end
		end
	end
	
	return gainedFeathers, totalFeathers
end

function calculateTotalLevelsCompleted(levelTable)
	local totalLevelsCompleted = 0
	
	for k = 1, #levelTable do
		local pageTable = levelTable[k]
		for i = 1, #pageTable do
		
			if highscores[pageTable[i]] ~= nil then
				totalLevelsCompleted = totalLevelsCompleted + 1
			end
		end
	end
	return totalLevelsCompleted
end

function checkLastOpenLevel(levelTable)
	local lastLevel = 1
	local pageInc = 0
	
	for k = 1, #levelTable do
		local pageTable = levelTable[k]
		for i = 1, #pageTable do
			if highscores[pageTable[i]] ~= nil and lastLevel <= i + pageInc then
				lastLevel = i + pageInc + 1
			end
		end
		pageInc = pageInc + #pageTable
	end
	return lastLevel
end

function checkEagleStatusFromHighscores(levelTable)
	
	local eagleEnabled = false
	
	for k = 1, #levelTable do
		local pageTable = levelTable[k]
		for i = 1, #pageTable do
			if highscores[pageTable[i] ] ~= nil and highscores[pageTable[i] ].eagleScore ~= nil and highscores[pageTable[i] ].eagleScore > 0 and highscores[pageTable[i] ].freeEagle ~= true then
				eagleEnabled = true 
				break
			end
		end
	end
	return eagleEnabled
end


function calculateStarsFromGoldenEggLevels()
	stars = 0
	_G.table.foreach( settings.openGoldenEggLevels, function(k,v) if v == 2 then stars = stars + 1 end end)
	return stars
end

function calculateOpenGoldenEggLevels()
	count = 0
	_G.table.foreach( settings.openGoldenEggLevels, function(k,v) count = count + 1 end)
	return count
end
--[[
function prepareFeatherScoreBox(episode)
		-- XXX: FINISH
		------------- Feather box
		local ep1FeathersBox = getItemByName(page.items, "ep"..epiode.."FeathersBox")
		ep1FeathersBox.width, ep1FeathersBox.height = _G.math.min(episode1.width / 2.25, (episode1.width / 2.25) - (ep1ScoreBox1.width - (episode1.width / 2.25))), fh 
		ep1FeathersBox.x, ep1FeathersBox.y = 0, episode1.height * 0.50 + ep1FeathersBox.height * 0.95

		-------------- Feather score	
		local topPieceW, topPieceH = _G.res.getSpriteBounds("EPISODE1_TOP_MIDDLE")
		local episode1FeatherScore = getItemByName(page.items, "episode"..episode.."FeatherScore")
		setFont(episode1FeatherScore.font)

		local scoreFeathers, maxFeathers = getEpisodeFeathers(1)
		
		episode1FeatherScore.text = scoreFeathers.."/"..maxFeathers 
		episode1FeatherScore.x, episode1FeatherScore.y = 0, ep1FeathersBox.y + (ep1FeathersBox.height + topPieceH) * 0.95 * 0.5		
		--------------- 
		-- Feather Sprite
		local ep1FeatherSprite = getItemByName(page.items, "ep1FeatherSprite")
		ep1FeatherSprite.x, ep1FeatherSprite.y = 0, ep1FeathersBox.y + (ep1FeathersBox.height + topPieceH) * 0.95 * 0.5				
		----------------

end]]

-- prepare current menu page when it is set as active page
function prepareMenuPage(page, resume, noprint)
	
	if page == nil then
		return
	end
	--print("Preparing menu page: " .. page.name .. "\n")
	
	if levelSelectionEdit ~= nil and page == levelSelectionEdit[1] then
		startedFromEditor = true
	end
	
	if page.backgroundOverlay ~= nil and page ~= loadingPage then
		page.backgroundOverlay.shade = 0
	end
	
	if page == systemPopup then
		local bgBox = page.backgroundBox
		local title = getItemByName(page.items, "title")
		prepareTextItem(page, title)
		bgBox.x, bgBox.y = screenWidth / 2, screenHeight / 2
		bgBox.width, bgBox.height = title.w * 2, title.h * 4
		
		local message = getItemByName(page.items, "message")
		
		message.textBoxSize = screenWidth * 0.5
		prepareTextItem(page, message)
		
		if message.w < message.textBoxSize then
			message.textBoxSize = message.w * 1.1
		end
		
		local fontH = _G.res.getFontLeading(message.font)
		
		bgBox.width, bgBox.height = message.textBoxSize * 1.1, (title.h * 2 + message.h) * 1.1 + fontH
		
		title.x, title.y = screenWidth / 2, bgBox.y - bgBox.height / 2.25
		message.x, message.y = screenWidth / 2, title.y + title.h * 1.5 + message.h / 2
		
		local icon = getItemByName(page.items, "icon")
		if icon ~= nil then
			icon.x, icon.y = bgBox.x + bgBox.width * 0.35, bgBox.y - bgBox.height / 2 - 53
		end
		
		local buttonYes = getItemByName(page.items, "buttonYes")
		buttonYes.x, buttonYes.y = bgBox.x + bgBox.width * 0.35, bgBox.y + bgBox.height * 0.6
	end
	
	if page == loadingPage then
		local loadingText = getItemByName(page.items, "loadingText")
		loadingText.x, loadingText.y = screenWidth / 2, screenHeight / 2
	end
	
	-- page specific controls
	
	if page == mainMenu then
		
		if not noprint then
			print("(1.5.4) main menu entered..\n")
			logFlurryEvent("Main menu entered")
		end
		mainMenu.menuButton = about
		
		--[[bats = {{x = _G.math.random(- screenWidth / 2, 1.5 * screenWidth), y = screenHeight + 50, animationSteps = 100, currentAnimFrame = _G.math.random(1, 3), timerAnim = 0, timerWings = _G.math.random() * 0.025 + 0.06 }, 
		{x = _G.math.random(- screenWidth / 2, 1.5 * screenWidth), y = screenHeight + 150, animationSteps = 200, currentAnimFrame = _G.math.random(1, 3), timerAnim = 0, timerWings = _G.math.random() * 0.025 + 0.06 }, 
		{x = _G.math.random(- screenWidth / 2, 1.5 * screenWidth), y = screenHeight + 250, animationSteps = 300, currentAnimFrame = _G.math.random(1, 3), timerAnim = 0, timerWings = _G.math.random() * 0.025 + 0.06 },
		{x = _G.math.random(- screenWidth / 2, 1.5 * screenWidth), y = screenHeight + 350, animationSteps = 350, currentAnimFrame = _G.math.random(1, 3), timerAnim = 0, timerWings = _G.math.random() * 0.025 + 0.06 },
		}
		
		maxDistanceToMoon = _G.math.floor(_G.math.sqrt(_G.math.pow(screenWidth / 2, 2) +  _G.math.pow(screenHeight / 2, 2)))
		]]
		getItemByName(page.items, "menuLogo").sprite = "MENU_LOGO"
			
		if settings.currentMainMenuTheme and settings.currentZoomLevelMainMenu then
			currentMainMenuTheme = settings.currentMainMenuTheme
			currentZoomLevelMainMenu = settings.currentZoomLevelMainMenu
		else
			currentMainMenuTheme = "theme1"
			currentZoomLevelMainMenu = 1.83
		end
		
		if isLiteVersion then
			currentMainMenuTheme = "theme1"
		end	
			
		mainMenu.state = "READY"
		
		local sw, sh = _G.res.getSpriteBounds("", getItemByName(page.items, "credits").sprite)
		local smallSw, smallSh = _G.res.getSpriteBounds("", getItemByName(page.items, "facebook").sprite)
		
		
		
		local play = getItemByName(page.items, "play")
		local playBG = getItemByName(page.items, "playBG")
		
		local playSpriteName = _G.res.getString("TEXTS_BASIC", "TEXT_PLAY_SPRITE")
		local playW, playH = _G.res.getSpriteBounds("", playSpriteName)
		
		play.sprite = playSpriteName
		play.x, play.y = screenWidth * 0.5, screenHeight * 0.555
		playBG.x, playBG.y = play.x, play.y
		playBG.width, playBG.height = playW, playH * 1.7
		playBG.visible = true

		local buttonSliderBG = getItemByName(page.items, "buttonSliderBG")
		local bsW, bsH = _G.res.getSpriteBounds("", buttonSliderBG.sprite)
		buttonSliderBG.x, buttonSliderBG.y = _G.math.floor(screenWidth - bsW * 0.55), _G.math.floor(screenHeight - bsH * 0.55)
		
		local buttonSlider = getItemByName(page.items, "buttonSlider")
		buttonSlider.x, buttonSlider.y = buttonSliderBG.x, buttonSliderBG.y
		
		local buttonSliderBGOptions = getItemByName(page.items, "buttonSliderBGOptions")
		local bsOW, bsOH = _G.res.getSpriteBounds("", buttonSliderBGOptions.sprite)
		buttonSliderBGOptions.x, buttonSliderBGOptions.y = _G.math.floor(bsOW * 0.55), buttonSliderBG.y
		
		local buttonSliderOptions = getItemByName(page.items, "buttonSliderOptions")
		buttonSliderOptions.x, buttonSliderOptions.y = buttonSliderBGOptions.x, _G.math.floor(buttonSliderBGOptions.y * 1.005)
		
		local sliderBGRight = getItemByName(page.items, "sliderBGRight")
		sliderBGRight.x, sliderBGRight.y = buttonSliderBG.x, buttonSliderBG.y
		sliderBGRight.visible = false
		sliderBGRight.width, sliderBGRight.height = bsW * 0.5, 0
		sliderBGRight.maxHeight = bsH / 4
		
		local sliderBGLeft = getItemByName(page.items, "sliderBGLeft")
		sliderBGLeft.x, sliderBGLeft.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		sliderBGLeft.visible = false
		sliderBGLeft.width, sliderBGLeft.height = bsW * 0.5, 0
		sliderBGLeft.maxHeight = bsOH / 4
		
		for i = 1, #buttonSliderBG.elements do
			sw, sh = _G.res.getSpriteBounds("", buttonSliderBG.elements[i].sprite)
			sliderBGRight.maxHeight = sliderBGRight.maxHeight + sh
			buttonSliderBG.elements[i].yPos = buttonSliderBG.y - sliderBGRight.maxHeight
		end
		
		for i = 1, #buttonSliderBGOptions.elements do
			sw, sh = _G.res.getSpriteBounds("", buttonSliderBGOptions.elements[i].sprite)
			sliderBGLeft.maxHeight = sliderBGLeft.maxHeight + sh
			buttonSliderBGOptions.elements[i].yPos = buttonSliderBGOptions.y - sliderBGLeft.maxHeight
		end
		
		sliderBGRight.maxHeight = sliderBGRight.maxHeight + sh / 2
		sliderBGLeft.maxHeight = sliderBGLeft.maxHeight + sh / 2
		
		local credits = getItemByName(page.items, "credits")
		credits.x, credits.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		
		local sfx = getItemByName(page.items, "sfx")
		sfx.x, sfx.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		
		local buttonOff = getItemByName(page.items, "buttonOff")
		buttonOff.x, buttonOff.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		
		local menuOvi = getItemByName(page.items, "menuOvi")
		menuOvi.x, menuOvi.y = buttonSliderBG.x, buttonSliderBG.y
		
		local menuLogo = getItemByName(page.items, "menuLogo")
		menuLogo.x, menuLogo.y = screenWidth * 0.5, screenHeight * 0.021875
		
		local lite = getItemByName(page.items, "logoLite")
		lite.x, lite.y = menuLogo.x, menuLogo.y
		if isBetaVersion and deviceModel == "android" then
			lite.sprite = "LITE_LOGO"
		end
		
		local trailer = getItemByName(page.items, "trailer")
		trailer.x, trailer.y = buttonSliderBG.x, buttonSliderBG.y
		
		local facebook = getItemByName(page.items, "facebook")
		facebook.x, facebook.y = buttonSliderBG.x, buttonSliderBG.y
		
		local twitter = getItemByName(page.items, "twitter")
		twitter.x, twitter.y = buttonSliderBG.x, buttonSliderBG.y
		
		if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
			local crystal = getItemByName(page.items, "crystal")
			crystal.x, crystal.y = buttonSliderBG.x, buttonSliderBG.y
			if settings.mightyEagleEnabled then
				local trailerEagle = getItemByName(page.items, "trailerEagle")
				trailerEagle.x, trailerEagle.y = buttonSliderBG.x, buttonSliderBG.y
			end
		end
		
		if deviceModel == "android" and not isHDVersion then
			local gfxQualityButton = getItemByName(page.items, "gfxQualityButton")
			gfxQualityButton.x, gfxQualityButton.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
			
			local gfxQualityButtonOff = getItemByName(page.items, "gfxQualityButtonOff")
			gfxQualityButtonOff.x, gfxQualityButtonOff.y = buttonSliderBGOptions.x, buttonSliderBGOptions.y
		end
		
		if deviceModel == "android" or deviceModel == "palm" then
			if isBetaVersion then
				local reportBug = getItemByName(page.items, "reportBug")
				reportBug.x, reportBug.y = buttonSliderBG.x, buttonSliderBG.y
			end
		end
		
		if buttonSliderBG.state == "open" then
			for i = 1, #buttonSliderBG.elements do
				local item = getItemByName(mainMenu.items, buttonSliderBG.elements[i].name) 
				item.y, item.visible = buttonSliderBG.elements[i].yPos, true
			end
			sliderBGRight.height = sliderBGRight.maxHeight
			sliderBGRight.visible = true
		end
		
		if buttonSliderBGOptions.state == "open" then
			for i = 1, #buttonSliderBGOptions.elements do
				local item = getItemByName(mainMenu.items, buttonSliderBGOptions.elements[i].name) 
				item.y, item.visible, item.selectable = buttonSliderBGOptions.elements[i].yPos, true, true
				if item.name == "sfx" then
					buttonOff.y = item.y
				end
				
				if deviceModel == "android" and not isHDVersion then
					local gfxQualityButtonOff = getItemByName(page.items, "gfxQualityButtonOff")
					if item.name == "gfxQualityButton" then
						gfxQualityButtonOff.y = item.y
					end
				end
			end
			sliderBGLeft.height = sliderBGLeft.maxHeight
			sliderBGLeft.visible = true
		elseif buttonSliderBGOptions.state == "opening" then
			sliderBGLeft.visible = true
		end
		
		local appStore = getItemByName(page.items, "appStore")
		appStore.x, appStore.y = screenWidth / 2, buttonSliderBG.y
	
		local buyEagle = getItemByName(page.items, "buyEagle")
		if iapEnabled ~= true or settings.mightyEagleEnabled == true then
			buyEagle.visible = false
		else
			buyEagle.visible = true
		end
	
		if gameCenterSupported then
			local loaderLB = getItemByName(page.items, "loaderLB")
			local loaderAC = getItemByName(page.items, "loaderAC")
			loaderLB.visible = false
			loaderAC.visible = false

			local leaderboards = getItemByName(page.items, "leaderboards")
			local achievements = getItemByName(page.items, "achievements")
					
			if iapEnabled ~= true or settings.mightyEagleEnabled == true then 
				leaderboards.x, leaderboards.y = screenWidth / 2 - bsOW / 2, buttonSliderBG.y
				achievements.x, achievements.y = screenWidth / 2 + bsOW / 2, buttonSliderBG.y
			else
				leaderboards.x, leaderboards.y = screenWidth / 2 - bsOW , buttonSliderBG.y
				achievements.x, achievements.y = screenWidth / 2, buttonSliderBG.y
				buyEagle.x, buyEagle.y = screenWidth / 2 + bsOW, buttonSliderBG.y
			end
			leaderboards.visible = true
			achievements.visible = true
			
			appStore.x, appStore.y = screenWidth / 2, buttonSliderBG.y - bsOH
			
			if isLiteVersion then
				play.x, play.y = screenWidth * 0.5, screenHeight * 0.5
				playBG.x, playBG.y = play.x, play.y
			end
			
			
			if gameCenterEnabled then
				if not loaderLB.show and not loaderAC.show then
					leaderboards.callFunction = showLoadingLeaderboards
					achievements.callFunction = showLoadingAchievements
				else
					leaderboards.callFunction = nil
					achievements.callFunction = nil
				end
			else
				if gameCenter and gameCenter.isAuthenticating then
					leaderboards.callFunction = nil
					achievements.callFunction = nil
				else
					leaderboards.callFunction = showLoadingInitGameCenter
					achievements.callFunction = showLoadingInitGameCenter
				end
			end
		else
			buyEagle.x, buyEagle.y = screenWidth / 2, buttonSliderBG.y
		end	
		
		if deviceModel == "n900" then
			menuOvi.visible = true
		else
			if isLiteVersion then
				--settings.currentLevelSelectionPages.basic = 1
				play.updateFunction = gotoLevelSelection
				--play.page = levelSelectionPagesBasic
				lite.visible = true
				if deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad" then
					appStore.visible = true
				end
			end
		end
		
		local unlockLevels = getItemByName(page.items, "unlockLevels")
		unlockLevels.x, unlockLevels.y = screenWidth, screenHeight * 0.1
		local lockLevels = getItemByName(page.items, "lockLevels")
		lockLevels.x, lockLevels.y = screenWidth, screenHeight * 0.1
				
		local resetMightyEagle = getItemByName(page.items, "resetMightyEagle")
		resetMightyEagle.x, resetMightyEagle.y = 0, 0
		if settings.mightyEagleEnabled == true then
			resetMightyEagle.visible = true
		else
			resetMightyEagle.visible = false
		end
		
		if showEditor then
			local editor = getItemByName(page.items, "editor")
			editor.x, editor.y = screenWidth * 0.75, screenHeight * 0.75
			if showEditor then
				editor.visible = true
			else 
				editor.visible = false
			end
		end
		
		-- The Youtube trailer and other links have to be removed in China
		if applyChinaRestictions then
			local sliderBGRight = getItemByName(mainMenu.items, "sliderBGRight")
			local buttonSlider = getItemByName(mainMenu.items, "buttonSlider")
			buttonSliderBG.visible = false
			buttonSliderBG.selectable = false
			sliderBGRight.visible = false
			sliderBGRight.selectable = false
			buttonSlider.visible = false
			buttonSlider.selectable = false
			-- move the update button to replace the unused link button
			local updateButton = getItemByName(page.items, "updateButton")
			if updateButton ~= nil then
				updateButton.x, updateButton.y = buttonSlider.x, buttonSlider.y
			end
		end	
			
		if deviceModel == "s60" then
			local sw, sh = _G.res.getSpriteBounds("", buttonSliderBG.sprite)

			local updateButton = getItemByName(page.items, "updateButton")
			if updateButton ~= nil and not applyChinaRestictions then
				updateButton.x, updateButton.y = buttonSliderBG.x - sw, buttonSliderBG.y
			end
			
			local oviButton = getItemByName(page.items, "oviButton")
			oviButton.x, oviButton.y = trailer.x - sw, trailer.y
			local unlockLevels = getItemByName(page.items, "unlockLevels")
			unlockLevels.x, unlockLevels.y = screenWidth, screenHeight * 0.1
			local lockLevels = getItemByName(page.items, "lockLevels")
			lockLevels.x, lockLevels.y = screenWidth, screenHeight * 0.1
			if releaseBuild == true then
				unlockLevels.visible = true
				lockLevels.visible = false
			else
				unlockLevels.visible = false
				lockLevels.visible = true
			end
		else
			unlockLevels.visible = false
			lockLevels.visible = false
			resetMightyEagle.visible = false
		end
		if lockLevelsButtonVisible ~= true then
			unlockLevels.visible = false
			lockLevels.visible = false
		end
		
		
		birdSprites = {}
		if settings.tutorials ~= nil then
			for k, v in _G.pairs(settings.tutorials) do
				if k == "BAIT_SARDINE" then
					_G.table.insert(birdSprites, { sprite = k , sheet = "", reward = 1 })
				else
					_G.table.insert(birdSprites, { sprite = k , sheet = "INGAME_BIRDS_1", reward = 0 })
				end
			end
		end
		
		if #birdSprites == 0 then
			_G.table.insert(birdSprites, { sprite = "BIRD_RED", sheet = "INGAME_BIRDS_1", reward = 0 })
		end
		
		if settings.gameCompleted then
			if not isLiteVersion then
				if settings.threeStars then
					_G.table.insert(birdSprites, { sprite = "REWARD_1_STAR", sheet = "MENU_ELEMENTS_1", reward = 1})
					_G.table.insert(birdSprites, { sprite = "REWARD_1_STAR", sheet = "MENU_ELEMENTS_1", reward = 1})
				else
					_G.table.insert(birdSprites, { sprite = "REWARD_1", sheet = "MENU_ELEMENTS_1", reward = 1})
					_G.table.insert(birdSprites, { sprite = "REWARD_1", sheet = "MENU_ELEMENTS_1", reward = 1})
				end
			end
		end
		
		if settings.theme5Completed then
			if settings.threeStarsLP2 then
				_G.table.insert(birdSprites, { sprite = "REWARD_2_STAR", sheet = "MENU_ELEMENTS_1", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_2_STAR", sheet = "MENU_ELEMENTS_1", reward = 1})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_2", sheet = "MENU_ELEMENTS_1", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_2", sheet = "MENU_ELEMENTS_1", reward = 1})
			end
		end
		
		if settings.theme8Completed then
			if settings.threeStarsLP3 then
				_G.table.insert(birdSprites, { sprite = "REWARD_3_STAR", sheet = "MENU_ELEMENTS_1", reward = 2})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_3", sheet = "MENU_ELEMENTS_1", reward = 2})
			end
		end
		
		if settings.theme11Completed then
			if settings.threeStarsLP4 then
				_G.table.insert(birdSprites, { sprite = "REWARD_4_STAR", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_4_STAR", sheet = "", reward = 1})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_4", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_4", sheet = "", reward = 1})
			end
		end
		
		if settings.theme14Completed then
			if settings.threeStarsLP5 then
				_G.table.insert(birdSprites, { sprite = "REWARD_5_STAR", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_5_STAR", sheet = "", reward = 1})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_5", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_5", sheet = "", reward = 1})
			end
		end
		
		if settings.theme17Completed then
			if settings.threeStarsLP6 then
				_G.table.insert(birdSprites, { sprite = "REWARD_6_STAR", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_6_STAR", sheet = "", reward = 1})
			else
				_G.table.insert(birdSprites, { sprite = "REWARD_6", sheet = "", reward = 1})
				_G.table.insert(birdSprites, { sprite = "REWARD_6", sheet = "", reward = 1})
			end
		end
		
		local feathers, maxFeathers = calculateFeathers(levelOrder_allLevels)
		-- same amount of feathers that is required for Feather Gatherer achievement
		if feathers >= 200 then
			_G.table.insert(birdSprites, { sprite = "REWARD_EAGLE", sheet = "", reward = 1})
			_G.table.insert(birdSprites, { sprite = "REWARD_EAGLE", sheet = "", reward = 1})
		end
		
		if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
			checkForAchievements()
		end
		
	--[[	if settings.crystalSplashShown ~= true then
			showCrystalSplash()
			checkForCrystalEnabled = true
			settings.crystalSplashShown = true
		end ]]
		
		if deviceModel == "n900" or deviceModel == "s60" or deviceModel == "android" then
			mainMenu.back = areYouSurePage
		end
		
		birdSpriteSoundMapping = { BIRD_RED = "bird_01_flying", BIRD_BLUE = "bird_02_flying", 
								   BIRD_YELLOW = "bird_03_flying", BIRD_GREY = "bird_04_flying",
								   BIRD_GREEN = "bird_05_flying", BIRD_BIG_BROTHER = "big_brother_flying",
								   BIRD_BOOMERANG = "bird_06_flying"
								 }
		
	end
	
	if page == betaDisclaimerPage then
		local bg = page.backgroundBox
		bg.x, bg.y = screenWidth / 2, screenHeight / 2
		local disclaimerText = getItemByName(page.items, "disclaimerText")
		disclaimerText.textBoxSize = screenWidth / 2
		prepareTextItem(page, disclaimerText)
		local fl = _G.res.getFontLeading()
		bg.width, bg.height = screenWidth / 2, (#clippedText.lines + 1) * fl
		disclaimerText.x, disclaimerText.y = screenWidth / 2, screenHeight / 2
		
		local okButton = getItemByName(page.items, "okButton")
		local sw, sh = _G.res.getSpriteBounds("", okButton.sprite)
		okButton.x, okButton.y = bg.x + bg.width / 2 - sw / 2, bg.y + bg.height / 2 + sh / 4
		
		local hideArea1 = getItemByName(page.items, "hideArea1")
		hideArea1.x, hideArea1.y = 0, 0
		hideArea1.w, hideArea1.h = (screenWidth - bg.width) / 2, screenHeight
		
		local hideArea2 = getItemByName(page.items, "hideArea2")
		hideArea2.x, hideArea2.y = 0, 0
		hideArea2.w, hideArea2.h = screenWidth, (screenHeight - bg.height) / 2
		
		local hideArea3 = getItemByName(page.items, "hideArea3")
		hideArea3.x, hideArea3.y = screenWidth - hideArea1.w, 0
		hideArea3.w, hideArea3.h = hideArea1.w, screenHeight
		
		local hideArea4 = getItemByName(page.items, "hideArea4")
		hideArea4.x, hideArea4.y = 0, screenHeight - hideArea2.h
		hideArea4.w, hideArea4.h = screenWidth, hideArea2.h
	end	
	
	if page == areYouSurePage then
		local bg = page.backgroundBox
		bg.x, bg.y = screenWidth / 2, screenHeight / 2
		local fl = _G.res.getFontLeading()
		local areYouSureText = getItemByName(page.items, "areYouSureText")
		areYouSureText.x, areYouSureText.y = screenWidth / 2, screenHeight / 2 - fl / 6
		setFont(areYouSureText.font)
		areYouSureText.textBoxSize = screenWidth * 0.7
		prepareTextItem(page, areYouSureText)
		
		local okButton = getItemByName(page.items, "buttonYes")
		local sw, sh = _G.res.getSpriteBounds("", okButton.sprite)
		
		bg.width, bg.height = areYouSureText.w, _G.math.max(#areYouSureText.lines * fl, sw) 
		if bg.width < sw * 3 then
			bg.width = sw * 3
		end
		
		okButton.x, okButton.y = (screenWidth / 2) - bg.width / 2 + sw / 1.5, screenHeight / 2 + bg.height / 2 + sh / 6
		local noButton = getItemByName(page.items, "buttonNo")
		noButton.x, noButton.y = (screenWidth / 2) + bg.width / 2 - sw / 1.5 , screenHeight / 2 + bg.height / 2 + sh / 6
	end
	
	if page == mightyEaglePurchasePage then
		local whiteBackground = page.backgroundBox
		
		whiteBackground.x, whiteBackground.y = screenWidth / 2, screenHeight / 2
		whiteBackground.width, whiteBackground.height = 0.47 * screenWidth, 0.83 * screenHeight
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = screenWidth / 2, screenHeight / 2
		end
	end
	
	if page == mightyEagleDemoPage then
		inGamePressed = nil
		setPhysicsEnabled(false)
		local demoBackground = page.backgroundBox
		local buttonYes = getItemByName(page.items, "buttonYes")
		local buttonNo = getItemByName(page.items, "buttonNo")
		local wButton, hButton = _G.res.getSpriteBounds("", buttonYes.sprite)
		local eagle = getItemByName(page.items, "eagle")
		local eWidth, eHeight = _G.res.getSpriteBounds("",eagle.sprite)
		local blackBox = getItemByName(page.items, "upsellBlackBox")
		local title = getItemByName(page.items, "upsellTitle")
		local titleW, titleH = _G.res.getSpriteBounds("",title.sprite)
		local upsellText = getItemByName(page.items, "upsellText")
		local trailerButton = getItemByName(page.items, "trailerButton")
		local payOnceText = getItemByName(page.items, "upsellPayOnce")
		local blackBoxW = 0
		
		if(deviceModel == "ipad") then
			blackBoxW = titleW * 1.50
		else
			blackBoxW = titleW * 1.30
		end

		upsellText.textBoxSize = blackBoxW
		prepareTextItem(page, upsellText)

		
		payOnceText.textBoxSize = blackBoxW
		prepareTextItem(page, payOnceText)
		--title.y + titleH + upsellText.h / 2
		--, blackBox.y - blackBox.height / 2.25
		
		local fontH = _G.res.getFontLeading(payOnceText.font)
		
		if deviceModel == "ipad" then
			eHeight = _G.math.max(eHeight, upsellText.h + payOnceText.h + fontH * 4  + titleH)
			demoBackground.x, demoBackground.y = screenWidth / 2, screenHeight * 0.45
			
			demoBackground.width, demoBackground.height = eWidth * 1.75, eHeight 
			blackBox.width, blackBox.height = blackBoxW, demoBackground.height / 1.2
			blackBox.x, blackBox.y = demoBackground.x - demoBackground.width / 2, demoBackground.y
			eagle.x, eagle.y = demoBackground.x + demoBackground.width / 2 , demoBackground.y + demoBackground.height / 2
			title.x, title.y = blackBox.x + (blackBox.width - titleW) / 2, blackBox.y - blackBox.height / 2.25
		else
			demoBackground.x, demoBackground.y = screenWidth / 2, screenHeight * 0.5 		
			demoBackground.width, demoBackground.height = eWidth * 1.3, eHeight 
			blackBox.width, blackBox.height = blackBoxW, demoBackground.height
			blackBox.x, blackBox.y = demoBackground.x - demoBackground.width / 2, demoBackground.y
			eagle.x, eagle.y = demoBackground.x + demoBackground.width / 1.92 , demoBackground.y + demoBackground.height / 1.92
			title.x, title.y = blackBox.x + (blackBox.width - titleW) / 2, blackBox.y - blackBox.height / 2
		end
		
		
		buttonYes.x, buttonYes.y = screenWidth / 2 + 0.4 * demoBackground.width, demoBackground.y + demoBackground.height / 2 + hButton / 6
		trailerButton.x, trailerButton.y = buttonYes.x - 1.2 * wButton, buttonYes.y
		buttonNo.x, buttonNo.y = screenWidth / 2 - 0.4 * demoBackground.width, buttonYes.y
		
		upsellText.x, upsellText.y = blackBox.x, title.y + titleH + upsellText.h / 2

		payOnceText.x, payOnceText.y = upsellText.x, upsellText.y + upsellText.h / 2 + fontH + payOnceText.h / 2 

		
	end
	---- 	
	--[[
	if page == mightyEagleIngamePage then
		inGamePressed = nil
		setPhysicsEnabled(false)
		local demoBackground = page.backgroundBox
		local buttonYes = getItemByName(page.items, "buttonYes")
		local buttonNo = getItemByName(page.items, "buttonNo")
		local tryButton = getItemByName(page.items, "tryButton")
		local wButton, hButton = _G.res.getSpriteBounds("", buttonYes.sprite)
		local eagle = getItemByName(page.items, "eagle")
		local eWidth, eHeight = _G.res.getSpriteBounds("",eagle.sprite)
		local blackBox = getItemByName(page.items, "upsellBlackBox")
		local title = getItemByName(page.items, "upsellTitle")
		local titleW, titleH = _G.res.getSpriteBounds("",title.sprite)
		local upsellText = getItemByName(page.items, "upsellText")
		local payOnceText = getItemByName(page.items, "upsellPayOnce")
		local trailerButton = getItemByName(page.items, "trailerButton")
		
		
		--		local sign = getItemByName(page.items, "sign")		
		--local attemptsText = getItemByName(page.items, "attemptsText")
		
		--settings.tryoutEagles = settings.tryoutEagles or 3
		--attemptsText.text = "Tries Left : "..settings.tryoutEagles
--		local attemptsW = _G.res.getStringWidth(attemptsText.text)
		
				
		if deviceModel == "ipad" then
			demoBackground.x, demoBackground.y = screenWidth / 2, screenHeight * 0.45
			
			--demoBackground.width, demoBackground.height = screenWidth * 0.75, screenHeight * 0.75
			demoBackground.width, demoBackground.height = eWidth * 1.75, eHeight
			
			
			blackBox.width, blackBox.height = titleW * 1.35, demoBackground.height / 1.2
			blackBox.x, blackBox.y = demoBackground.x - demoBackground.width / 2, demoBackground.y
			eagle.x, eagle.y = demoBackground.x + demoBackground.width / 2 , demoBackground.y + demoBackground.height / 2
			title.x, title.y = blackBox.x + (blackBox.width - titleW) / 2, blackBox.y - blackBox.height / 2.25			
			--attemptsText.x, attemptsText.y = demoBackground.x - demoBackground.width * 0.49, demoBackground.y + demoBackground.height * 0.35			

		else
			demoBackground.x, demoBackground.y = screenWidth / 2, screenHeight * 0.5
			demoBackground.width, demoBackground.height = eWidth * 1.3, eHeight * 0.9
			blackBox.width, blackBox.height = titleW * 1.14, demoBackground.height
			blackBox.x, blackBox.y = demoBackground.x - demoBackground.width / 2, demoBackground.y
			eagle.x, eagle.y = demoBackground.x + demoBackground.width / 1.92 , demoBackground.y + demoBackground.height / 1.92
			title.x, title.y = blackBox.x + (blackBox.width - titleW) / 2, blackBox.y - blackBox.height / 2
		end
		
		--sign.x, sign.y = demoBackground.x + demoBackground.width * 0.60, demoBackground.y + demoBackground.height * 0.60;
		--sign.visible = true
		buttonYes.x, buttonYes.y = screenWidth / 2 + 0.4 * demoBackground.width, demoBackground.y + demoBackground.height / 2 + hButton / 6
		trailerButton.x, trailerButton.y = buttonYes.x - 1.2 * wButton, buttonYes.y
		--tryButton.x, tryButton.y = buttonYes.x - 1.2 * wButton, buttonYes.y
		buttonNo.x, buttonNo.y = screenWidth / 2 - 0.4 * demoBackground.width, buttonYes.y
		--[ [
		--if(settings.tryoutEagles and settings.tryoutEagles <= 0) then
		--	tryButton.visible = false
		--else
		--	tryButton.visible = true		
		--end] ]
		
		upsellText.textBoxSize = blackBox.width
		prepareTextItem(page, upsellText)
		upsellText.x, upsellText.y = blackBox.x, title.y + titleH + upsellText.h / 2
		prepareTextItem(page, payOnceText)
		payOnceText.x, payOnceText.y = upsellText.x, upsellText.y + upsellText.h / 2 + payOnceText.h 
	end]]
	
	
	if page == mightyEaglePaymentPage then
		--if settings.mightyEagleEnabled ~= true then
		--	purchaseMightyEagle()
		--end
				
		page.items[1].angle = 0
		
		for i = 1, #page.items do
			if page.items[i].name == "confirming" then
				page.items[i].x, page.items[i].y = screenWidth / 2, screenHeight / 2 + 0.06 * screenHeight
			else
				page.items[i].x, page.items[i].y = screenWidth / 2, screenHeight / 2
			end
		end
	end
	
	if page == levelComplete then
		
		local background = getItemByName(page.items, "background")
		local _, bh = _G.res.getSpriteBounds(background.sheet, background.box.topMiddle)
		local _, bottomH = _G.res.getSpriteBounds(background.sheet, background.box.bottomMiddle)
		local bw, _ = _G.res.getSpriteBounds(background.sheet, background.box.left)
		local _, bottomBorderH = _G.res.getSpriteBounds(background.sheet, background.box.bottomMiddle)
		local buttonMenu = getItemByName(page.items, "buttonMenu")
		local buttonW, buttonH = _G.res.getSpriteBounds("", buttonMenu.sprite)
		local levelComplete = getItemByName(page.items, "levelComplete")
		local score = getItemByName(page.items, "score")
		prepareTextItem(page, score)
		local scoreNumber = getItemByName(page.items, "scoreNumber")
		prepareTextItem(page, scoreNumber)
		local newHighScore = getItemByName(page.items, "newHighScore")
		local newHighScoreW, newHighScoreH = _G.res.getSpriteBounds("", newHighScore.sprite)
		local newHighScoreTextW, newHighScoreTextH = _G.res.getSpriteBounds("", _G.res.getString("TEXTS_BASIC", "TEXT_HIGHSCORE_SPRITE"))
		
		local levelNumber = getItemByName(page.items, "levelNumber")
		prepareTextItem(page, levelNumber)
		local highScoreNumber = getItemByName(page.items, "highScoreNumber")
		local highScoreText = getItemByName(page.items, "highScoreText")
		local eagleHighScoreText = getItemByName(page.items, "eagleHighScoreText")
		
		
		local ingameFeatherFull = getItemByName(page.items, "ingameFeatherFull")
		local ingameFeatherEmpty = getItemByName(page.items, "ingameFeatherEmpty")
		
		prepareTextItem(page, eagleHighScoreText)
		
		prepareTextItem(page, highScoreNumber)
		prepareTextItem(page, highScoreText)
		background.width = buttonW * 3.8
		
		if background.width < newHighScoreW * 2.8 and not inExtraWorld then
			background.width = newHighScoreW * 2.8
		end
		
		levelComplete.textBoxSize = background.width * 0.55
		prepareTextItem(page, levelComplete)
		
		if #levelComplete.lines >= 2 and levelComplete.w < screenWidth * 0.8 then
			levelComplete.textBoxSize = background.width * 0.8
		else
			levelComplete.textBoxSize = background.width * 0.55
		end
		
		if adReady == true or isShowingAd == true and (deviceModel == "android" and not isHDVersion)  then
			background.x, background.y = screenWidth * 0.5, screenHeight * 0.58 + highScoreText.h
			background.height = levelComplete.h + score.h * 0.2 + scoreNumber.h + buttonH * 0.2
		else
			background.x, background.y = screenWidth * 0.5, screenHeight * 0.53 + highScoreText.h
			background.height = levelComplete.h + score.h * 0.2 + scoreNumber.h + buttonH * 0.7
		end

		if background.width < newHighScoreTextW + levelComplete.textBoxSize then
			background.width = (newHighScoreTextW + levelComplete.textBoxSize)
			newHighScore.x, newHighScore.y = background.x + background.width * 0.5 - newHighScoreTextW * 0.45, background.y - buttonH * 0.15
		else
			newHighScore.x, newHighScore.y = background.x + background.width * 0.5 - newHighScoreW * 0.5 - buttonH * 0.1, background.y - buttonH * 0.15
		end
		
		if background.height < newHighScoreH + buttonH * 0.4  then
			if adReady == true or isShowingAd == true or inExtraWorld and (deviceModel == "android" and not isHDVersion) then
				background.height = newHighScoreH + buttonH * 0.2
			else
				background.height = newHighScoreH + buttonH * 0.4
			end
		end
						
		local highScoreNumber = getItemByName(page.items, "highScoreNumber")
		local highScoreText = getItemByName(page.items, "highScoreText")
		prepareTextItem(page, highScoreNumber)
		prepareTextItem(page, highScoreText)
		
		local backgroundTop = page.backgroundBox
		local btw, bth = _G.res.getSpriteBounds(background.sheet, backgroundTop.sprites.topMiddle)
		backgroundTop.x, backgroundTop.y = background.x, background.y - background.height * 0.5
		backgroundTop.width, backgroundTop.height = background.width - bw * 0.5, bh * 0.7 + highScoreText.h * 3 - bth 
		
		levelNumber.x, levelNumber.y = backgroundTop.x - backgroundTop.width * 0.5 + buttonW * 0.1, backgroundTop.y - bh * 0.7 - (backgroundTop.height - bh * 0.7 + bth) * 0.5			
		
		ingameFeatherFull.visible = false			
		ingameFeatherEmpty.visible = false			
		
		if(mightyEagleSupported == true and inExtraWorld ~= true) then
			if(getEagleScore(levelName) >= 100) then
				ingameFeatherEmpty.visible = false
				ingameFeatherFull.visible = true
			else
				ingameFeatherEmpty.visible = true
				ingameFeatherFull.visible = false			
			end				
			
			if(eagleBaitLaunched == true) then
				ingameFeatherFull.visible = false			
				ingameFeatherEmpty.visible = false			
			end			
		end
		
		
		score.x, score.y = levelNumber.x, background.y - buttonH * 0.15
		
		if #levelComplete.lines >= 2 then
			levelComplete.x, levelComplete.y = score.x, score.y - levelComplete.h / 2 - score.h * 1.2
		else
			levelComplete.x, levelComplete.y = score.x, score.y - levelComplete.h - score.h * 1.2
		end
		prepareTextItem(page, scoreNumber)
		scoreNumber.x, scoreNumber.y = score.x, score.y + scoreNumber.h * 1.1
		
		
		
		
		local starsCurrent = getItemByName(page.items, "starsCurrent")
		starsCurrent.x, starsCurrent.y = scoreNumber.x + scoreNumber.w, scoreNumber.y
		
		
		buttonMenu.x, buttonMenu.y = background.x - background.width * 0.5 + buttonW * 0.5 , background.y + background.height * 0.5 + bottomBorderH * 0.5
		
		
		local buttonNextLevel = getItemByName(page.items, "buttonNextLevel")
		buttonNextLevel.x, buttonNextLevel.y = background.x + background.width * 0.5 - buttonW * 0.5, buttonMenu.y
		
		
		
		local stars = getItemByName(page.items, "stars")
		local starsW, starsH = _G.res.getSpriteBounds("", stars.sprite)

		--local stringw = _G.res.getStringWidth(levelNumber.text)
		local xdiff = (newHighScore.x - newHighScoreW / 2) - (levelNumber.x + levelNumber.w / 2)
		
		local hscoreX = levelNumber.x + levelNumber.w + xdiff / 2 
		
		
		
		local scoreStringW = _G.res.getStringWidth(highScoreNumber.text)
		local starsW = _G.res.getSpriteBounds(stars.sprite)
		local xdiff = (buttonNextLevel.x - _G.res.getSpriteBounds(buttonNextLevel.sprite) / 2) - (levelNumber.x + levelNumber.w / 2)		
		local hscoreX = levelNumber.x + levelNumber.w + xdiff / 2  - (starsW - scoreStringW) 		

		if(hscoreX > levelNumber.x + levelNumber.w + xdiff / 2) then
			hscoreX = levelNumber.x + levelNumber.w + xdiff / 2
		end
		
		if(mightyEagleSupported == true and inExtraWorld ~= true) then
			local hsTextX = (hscoreX + (-scoreStringW + starsW) / 2)
			highScoreNumber.x,highScoreNumber.y = hscoreX,  levelNumber.y + highScoreText.h * 0.5
			hScoreX = highScoreNumber.x + highScoreNumber.w
			highScoreText.x, highScoreText.y = hsTextX, highScoreNumber.y - highScoreNumber.h * 1.1			
		else
			highScoreNumber.x, highScoreNumber.y = backgroundTop.x + backgroundTop.width * 0.5 - starsW - buttonW * 0.1, levelNumber.y + highScoreText.h * 0.5
			highScoreText.x, highScoreText.y = highScoreNumber.x + starsW - (starsW + highScoreNumber.w) * 0.5, highScoreNumber.y - highScoreNumber.h * 1.1		
		end
		
		
		
		
		
		
		--[[
		
		if(mightyEagleSupported == true and inExtraWorld ~= true) then
			highScoreNumber.x,highScoreNumber.y = hscoreX,  levelNumber.y + highScoreText.h * 0.5
			hScoreX = highScoreNumber.x + highScoreNumber.w
			highScoreText.x, highScoreText.y = hscoreX, highScoreNumber.y - highScoreNumber.h * 1.1
		else
			highScoreNumber.x, highScoreNumber.y = backgroundTop.x + backgroundTop.width * 0.5 - starsW - buttonW * 0.1, levelNumber.y + highScoreText.h * 0.5
			highScoreText.x, highScoreText.y = highScoreNumber.x + starsW - (starsW + highScoreNumber.w) * 0.5, highScoreNumber.y - highScoreNumber.h * 1.1		
		end]]
		
		stars.x, stars.y = highScoreNumber.x, highScoreNumber.y		
		eagleHighScoreText.x, eagleHighScoreText.y = backgroundTop.x + backgroundTop.width * 0.5, highScoreText.y
		
		prepareTextItem(page, highScoreText)
		local highScoreTextRightSide = highScoreText.x + highScoreText.w * 0.5
		
		
		if highScoreTextRightSide > background.x + background.width * 0.5 then
			local move = highScoreTextRightSide - (background.x + background.width * 0.5)
			highScoreNumber.x = highScoreNumber.x - move
			highScoreText.x = highScoreText.x - move
			stars.x = stars.x - move
		end
		
		
		local buttonRestart = getItemByName(page.items, "buttonRestart")
		buttonRestart.x, buttonRestart.y = background.x , buttonMenu.y
		
		
		local rioButton = getItemByName(page.items, "rioButton")
		rioButton.x, rioButton.y = background.x + background.width * 0.5 - buttonW * 0.5, buttonMenu.y
		if inExtraWorld and currentLevelNumberInTheme == 22 and not applyChinaRestictions then
			rioButton.visible = true
		else
			rioButton.visible = false
		end
		
		-- each cutscene has it's own button
		for i = 1, 17 do
			local tempButton = getItemByName(page.items, "buttonCutscene" .. i)
			tempButton.x, tempButton.y = buttonNextLevel.x, buttonNextLevel.y
			--print("SETTING X TO "..(tempButton.x).."\n")
			--print("SETTING Y TO "..(tempButton.y).."\n")
		end
		
		--local eagleBadge = getItemByName(page.items, "eagleBadge")
		--eagleBadge.x, eagleBadge.y = background.x, background.y - buttonH * 0.15
		
		local totalDestruction = getItemByName(page.items, "totalDestruction")
		totalDestruction.x, totalDestruction.y = background.x, background.y - background.height * 0.5
		
		local eagleScoreNumber = getItemByName(page.items, "eagleScoreNumber")
		prepareTextItem(page, eagleScoreNumber)
		eagleScoreNumber.x, eagleScoreNumber.y = totalDestruction.x + eagleScoreNumber.w * 0.5, totalDestruction.y
		eagleScoreNumber.Text = "0%"
		
		local eagleFeatherEmpty = getItemByName(page.items, "eagleFeatherEmpty")
		eagleFeatherEmpty.x, eagleFeatherEmpty.y = background.x, background.y + buttonH * 0.1
		local eagleFeatherFill = getItemByName(page.items, "eagleFeatherFill")
		eagleFeatherFill.x, eagleFeatherFill.y = eagleFeatherEmpty.x, eagleFeatherEmpty.y
		if not resume then
			eagleFeatherFill.fill = 0
		end
		local eagleFeatherFull = getItemByName(page.items, "eagleFeatherFull")
		eagleFeatherFull.x, eagleFeatherFull.y = eagleFeatherEmpty.x, eagleFeatherEmpty.y
		
		local starEffect = getItemByName(page.items, "starEffect")
		starEffect.x, starEffect.y = eagleFeatherEmpty.x, eagleFeatherEmpty.y
		starEffect.angle = 0
		
		local eagleHighScoreFeatherEmpty = getItemByName(page.items, "eagleHighScoreFeatherEmpty")
		local eagleHighScoreFeatherFull = getItemByName(page.items, "eagleHighScoreFeatherFull")
		local eagleHighScoreNumber = getItemByName(page.items, "eagleHighScoreNumber")
		eagleHighScoreNumber.x, eagleHighScoreNumber.y = eagleHighScoreText.x - eagleHighScoreText.w * 0.5 - buttonW * 0.1, levelNumber.y + eagleHighScoreText.h * 0.5
		eagleHighScoreFeatherEmpty.x, eagleHighScoreFeatherEmpty.y = eagleHighScoreNumber.x + buttonW * 0.1, stars.y
		eagleHighScoreFeatherFull.x, eagleHighScoreFeatherFull.y = eagleHighScoreFeatherEmpty.x, eagleHighScoreFeatherEmpty.y
		
		if inExtraWorld then
			highScoreNumber.x = highScoreNumber.x + starsW * 0.5
			prepareTextItem(page, highScoreNumber)
		end						
		
		local stringw1 = levelNumber.w
		local stringw2 = highScoreText.w
		
		local xdiff = highScoreText.x - levelNumber.x 
		local spritew, spriteh = _G.res.getSpriteBounds(ingameFeatherEmpty.sprite)
		--local stringw = _G.res.getStringWidth(levelNumber.text)
		--local stringw = _G.res.getStringWidth(highScoreText.text)
		--local featherX = (stars.x + _G.res.getSpriteBounds(stars.sprite)) + spritew / 2
		local featherX = buttonNextLevel.x + spritew
		ingameFeatherEmpty.x = featherX
		ingameFeatherEmpty.y = levelNumber.y
		ingameFeatherFull.x = featherX
		ingameFeatherFull.y = levelNumber.y
		
	end
	
	if page == levelFailed then
	
		local background = getItemByName(page.items, "background")
		local _, bh = _G.res.getSpriteBounds(background.sheet, background.box.topMiddle)
		local bw, _ = _G.res.getSpriteBounds(background.sheet, background.box.left)
		local _, bottomBorderH = _G.res.getSpriteBounds(background.sheet, background.box.bottomMiddle)
		local buttonMenu = getItemByName(page.items, "buttonMenu")
		local buttonW, buttonH = _G.res.getSpriteBounds("", buttonMenu.sprite)
		local levelFailed = getItemByName(page.items, "levelFailed")
		local ingameFeatherFull = getItemByName(page.items, "ingameFeatherFull")
		local ingameFeatherEmpty = getItemByName(page.items, "ingameFeatherEmpty")

		background.width = buttonW * 3.7
		levelFailed.textBoxSize = background.width
		prepareTextItem(page, levelFailed)
		background.x, background.y = screenWidth * 0.5, screenHeight * 0.6
		
		
		
		
		if adReady == true or isShowingAd == true then
			background.height = levelFailed.h + buttonH * 0.5
		else
			background.height = levelFailed.h + buttonH * 0.8
		end

--		local sign = getItemByName(page.items, "sign")
		--[[
		if(sign ~= nil) then
			
			sign.x = background.x + background.width * 0.50
			sign.y = background.y + background.height * 0.50 + bottomBorderH * 0.50
		end]]
		--[[
		if(iapEnabled == true) then
			if(settings.mightyEagleEnabled == true) then
				sign.visible = false
			else
				sign.visible = true		
			end		
		else
			sign.visible = false		
		end]]
		
		
		levelFailed.x, levelFailed.y = background.x, background.y - buttonH * 0.1

		
		local levelNumber = getItemByName(page.items, "levelNumber")
		prepareTextItem(page, levelNumber)
		local backgroundTop = page.backgroundBox
		local btw, bth = _G.res.getSpriteBounds(background.sheet, backgroundTop.sprites.topMiddle)
		local highScoreNumber = getItemByName(page.items, "highScoreNumber")
		local highScoreText = getItemByName(page.items, "highScoreText")
		prepareTextItem(page, highScoreText)
		prepareTextItem(page, highScoreNumber)
		
		backgroundTop.x, backgroundTop.y = background.x, background.y - background.height * 0.5
		backgroundTop.width, backgroundTop.height = background.width - bw * 0.5, bh * 0.7 + highScoreText.h * 3 - bth 
			
		levelNumber.x, levelNumber.y = backgroundTop.x - backgroundTop.width * 0.5 + buttonW * 0.1, backgroundTop.y - bh * 0.7 - (backgroundTop.height - bh * 0.7 + bth) * 0.5
		
		local stars = getItemByName(page.items, "stars")
		local starsW, starsH = _G.res.getSpriteBounds("", "RESULT_STARS_0")
		--highScoreNumber.x, highScoreNumber.y = backgroundTop.x + backgroundTop.width * 0.5 - starsW - buttonW * 0.1, levelNumber.y + highScoreText.h * 0.5
		
		
		--highScoreText.x, highScoreText.y = highScoreNumber.x + starsW - (starsW + highScoreNumber.w) * 0.5, highScoreNumber.y - highScoreNumber.h * 1.1
		prepareTextItem(page, highScoreText)
		
		buttonMenu.x, buttonMenu.y = background.x - background.width * 0.5 + buttonW * 0.5, background.y + background.height * 0.5 + bottomBorderH * 0.5		
		local buttonNextLevel = getItemByName(page.items, "buttonNextLevel")
		buttonNextLevel.x, buttonNextLevel.y = background.x + background.width * 0.5 - buttonW * 0.5, buttonMenu.y
		
		
		
		local scoreStringW = _G.res.getStringWidth(highScoreNumber.text)
		local starsW = _G.res.getSpriteBounds(stars.sprite)
		local xdiff = (buttonNextLevel.x - _G.res.getSpriteBounds(buttonNextLevel.sprite) / 2) - (levelNumber.x + levelNumber.w / 2)		
		local hscoreX = levelNumber.x + levelNumber.w + xdiff / 2  - (starsW - scoreStringW) 		

		if(hscoreX > levelNumber.x + levelNumber.w + xdiff / 2) then
			hscoreX = levelNumber.x + levelNumber.w + xdiff / 2
		end
		
		if(mightyEagleSupported == true and inExtraWorld ~= true) then
			local hsTextX = (hscoreX + (-scoreStringW + starsW) / 2)
			highScoreNumber.x,highScoreNumber.y = hscoreX,  levelNumber.y + highScoreText.h * 0.5
			hScoreX = highScoreNumber.x + highScoreNumber.w
			highScoreText.x, highScoreText.y = hsTextX, highScoreNumber.y - highScoreNumber.h * 1.1			
		else
			highScoreNumber.x, highScoreNumber.y = backgroundTop.x + backgroundTop.width * 0.5 - starsW - buttonW * 0.1, levelNumber.y + highScoreText.h * 0.5
			highScoreText.x, highScoreText.y = highScoreNumber.x + starsW - (starsW + highScoreNumber.w) * 0.5, highScoreNumber.y - highScoreNumber.h * 1.1		
		end
		
		stars.x, stars.y = highScoreNumber.x, highScoreNumber.y

		
		local highScoreTextRightSide = highScoreText.x + highScoreText.w * 0.5
		
		
		if highScoreTextRightSide > background.x + background.width * 0.5 then
			local move = highScoreTextRightSide - (background.x + background.width * 0.5)
			highScoreNumber.x = highScoreNumber.x - move
			highScoreText.x = highScoreText.x - move
			stars.x = stars.x - move
		end
		
		
		local buttonRestart = getItemByName(page.items, "buttonRestart")
		buttonRestart.x, buttonRestart.y = background.x , buttonMenu.y
		
		

		
		if bingIsEnabled == true then
			local bingButton = getItemByName(page.items, "bingButton")
			bingButton.x, bingButton.y = background.x + background.width * 0.5 - buttonW * 0.5, buttonMenu.y
			
			local bbW, bbH = _G.res.getSpriteBounds("", bingButton.sprite)
			local bingSign = getItemByName(page.items, "bingSign")
			bingSign.x, bingSign.y, bingSign.angle, bingSign.currentState = bingButton.x + bbW * 1.3, screenHeight, 1.57, 1
		end
		
		local buttonEagle = getItemByName(page.items, "buttonEagle")
		buttonEagle.x, buttonEagle.y = buttonNextLevel.x, buttonNextLevel.y
		
		local buttonEagleLost = getItemByName(page.items, "buttonEagleLost")
		buttonEagleLost.x, buttonEagleLost.y = buttonNextLevel.x, buttonNextLevel.y
		
		local buttonEagleBuy = getItemByName(page.items, "buttonEagleBuy")
		buttonEagleBuy.x, buttonEagleBuy.y = buttonNextLevel.x, buttonNextLevel.y
		
		local eagleTimeLeft = getItemByName(page.items, "eagleTimeLeft")
		eagleTimeLeft.x, eagleTimeLeft.y = buttonNextLevel.x, _G.math.floor(buttonNextLevel.y + buttonH * 0.55)
		eagleTimeLeft.visible = false
			
		-- each cutscene has it's own button
		for i = 1, #page.items do
			if _G.string.sub(page.items[i].name, 1, 14) == "buttonCutscene" then
				page.items[i].x, page.items[i].y = buttonNextLevel.x, buttonNextLevel.y
			end
		end
		
		if inExtraWorld then
			highScoreNumber.x = highScoreNumber.x + starsW * 0.5
			prepareTextItem(page, highScoreNumber)
		end								

		ingameFeatherFull.visible = false			
		ingameFeatherEmpty.visible = false			
		
		if(mightyEagleSupported == true and inExtraWorld ~= true) then
			if(getEagleScore(levelName) >= 100) then
				ingameFeatherEmpty.visible = false
				ingameFeatherFull.visible = true
			else
				ingameFeatherEmpty.visible = true
				ingameFeatherFull.visible = false			
			end				
			
			if(eagleBaitLaunched == true) then
				ingameFeatherFull.visible = false			
				ingameFeatherEmpty.visible = false			
			end			
		end

		local featherX = buttonNextLevel.x + _G.res.getSpriteBounds(ingameFeatherEmpty.sprite)
		ingameFeatherEmpty.x = featherX
		ingameFeatherEmpty.y = levelNumber.y
		ingameFeatherFull.x = featherX
		ingameFeatherFull.y = levelNumber.y
		
		
		
		-- hide eagle refresh time is it was clicked from in game
		eagleInfoTimer = nil
	end
	
	if page == episodeSelectionPage then
		if not noprint then
			print("(1.5.4) Episode selection entered..\n")
			logFlurryEvent("Episode selection entered")
		end
	
		startedFromEditor = false
		
		episodeMenuDragStart = nil
		
		for i = 1, page.numEpisodes do
			getItemByName(page.items, "dot" .. i).sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot" .. i).visible = true
		end
		getItemByName(page.items, "dot" .. settings.selectedEpisode).sprite = "LS_DOT_WHITE"
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		back.x, back.y = 0, screenHeight
		
		local lsDotY = 10*displayScale --yes, i made sure
		local lsDotSpacing = 20*displayScale
		
		page.goldenEggHitBox.xMin, page.goldenEggHitBox.xMax = 0.44 * screenWidth, 0.56 * screenWidth
		page.goldenEggHitBox.yMin, page.goldenEggHitBox.yMax = 0.87 * screenHeight, 0.95 * screenHeight
		
	
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = (screenWidth / 2) - 5.25 * (lsDotSpacing / 2), screenHeight - lsDotY
		
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = (screenWidth / 2) - 3.75 *(lsDotSpacing / 2), screenHeight - lsDotY
	
		local dot3 = getItemByName(page.items, "dot3")
		dot3.x, dot3.y = screenWidth / 2 - 2.25 *(lsDotSpacing / 2), screenHeight - lsDotY
		
		local dot4 = getItemByName(page.items, "dot4")
		dot4.x, dot4.y = (screenWidth / 2) - 0.75 *(lsDotSpacing / 2), screenHeight - lsDotY
		
		local dot5 = getItemByName(page.items, "dot5")
		dot5.x, dot5.y = (screenWidth / 2) + 0.75 * (lsDotSpacing / 2), screenHeight - lsDotY
		
		local dot6 = getItemByName(page.items, "dot6")
		dot6.x, dot6.y = (screenWidth / 2) + 2.25 * (lsDotSpacing / 2), screenHeight - lsDotY
		
		local dot7 = getItemByName(page.items, "dot7")
		dot7.x, dot7.y = (screenWidth / 2) + 3.75 * (lsDotSpacing / 2), screenHeight - lsDotY
		
		local dot8 = getItemByName(page.items, "dot8")
		dot8.x, dot8.y = (screenWidth / 2) + 5.25 * (lsDotSpacing / 2), screenHeight - lsDotY

		local dot9 = getItemByName(page.items, "dot9")
		dot9.x, dot9.y = (screenWidth / 2) + 6.75 * (lsDotSpacing / 2), screenHeight - lsDotY
		
		
		local biggestSpriteW, biggestSpriteH = 0, 0
		local longestString = 0
		-- -1 is because of halloween upsell and newsletter page
		for i = 1, episodeSelectionPage.numEpisodes - 1 do
			local index = i
			if i == episodeSelectionPage.numEpisodes - 1 then
				index = "G"
			end
			local spriteItem = getItemByName(page.items, "ep" .. index .. "Sprite")
			if spriteItem then
				local width, height = _G.res.getSpriteBounds("", spriteItem.sprite)
				
				if width > biggestSpriteW then
					biggestSpriteW = width
				end
				if height > biggestSpriteH then
					biggestSpriteH = height
				end
			end
			local stringItem = getItemByName(page.items, "episode" .. index .. "Text")
			if stringItem then
				setFont(stringItem.font)
				local stringWidth = _G.res.getStringWidth(stringItem.text)
				if stringWidth > longestString then
					longestString = stringWidth
				end
			end
		end
		
		local scoreSpriteName = _G.res.getString("TEXTS_BASIC", "TEXT_SCORE_SPRITE")
		
		--ep1
		local ep1Sprite = getItemByName(page.items, "ep1Sprite")
		ep1Sprite.x, ep1Sprite.y = 0, 0
		
		setFont(fontBasic)
		local fh = _G.res.getFontHeight()
		local _, sh2 = _G.res.getSpriteBounds("", "EPISODE1_TOP_MIDDLE")
		
		local episode1 = getItemByName(page.items, "episode1")
		episode1.x, episode1.y = (1 - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2, screenHeight / 2
		
		local episode1Text = getItemByName(page.items, "episode1Text")
		episode1.width, episode1.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		episode1Text.x, episode1Text.y = 0, -episode1.height * 0.44
		
		local episode1YellowLine = getItemByName(page.items, "episode1YellowLine")
		episode1YellowLine.x, episode1YellowLine.y = 0, episode1Text.y + fh * 0.4
		episode1YellowLine.width, episode1YellowLine.height = episode1.width, 1
		
		local episode1Score = getItemByName(page.items, "episode1Score")
		setFont(episode1Score.font)
		fh = _G.res.getFontHeight()
		
		local ep1ScoreBox1 = getItemByName(page.items, "ep1ScoreBox1")
		local sw, sh = _G.res.getSpriteBounds("", getItemByName(page.items, "episode1ScoreText").sprite)
		local starW, starH = _G.res.getSpriteBounds("", "LS_STAR_GOLD")
		ep1ScoreBox1.width, ep1ScoreBox1.height = _G.math.max(episode1.width / 2.25, sw), fh + starH
		ep1ScoreBox1.x, ep1ScoreBox1.y = -episode1.width / 2, episode1.height / 2 + sh2 / 6
		
		local ep1ScoreBox2 = getItemByName(page.items, "ep1ScoreBox2")
		ep1ScoreBox2.width, ep1ScoreBox2.height = _G.math.min(episode1.width / 2.25, (episode1.width / 2.25) - (ep1ScoreBox1.width - (episode1.width / 2.25))), fh + starH
		ep1ScoreBox2.x, ep1ScoreBox2.y = episode1.width / 2, episode1.height / 2 + sh2 / 6

		
		episode1Score.x, episode1Score.y = -episode1.width / 2 + ep1ScoreBox1.width / 2, ep1ScoreBox1.y 
		local episode1ScoreText = getItemByName(page.items, "episode1ScoreText")
		episode1ScoreText.sprite = scoreSpriteName
		episode1ScoreText.x, episode1ScoreText.y = ep1ScoreBox1.x + ep1ScoreBox1.width / 2, ep1ScoreBox1.y - 0.8 * ep1ScoreBox1.height

		local episode1Stars = getItemByName(page.items, "episode1Stars")
		episode1Stars.x, episode1Stars.y = episode1.width / 2 - ep1ScoreBox2.width / 2, ep1ScoreBox2.y
		
		local sw, sh = _G.res.getSpriteBounds("", "LS_STAR_GOLD")
		local ep1StarSprite = getItemByName(page.items, "ep1StarSprite")
		ep1StarSprite.x, ep1StarSprite.y = ep1ScoreBox2.x - ep1ScoreBox2.width / 2, ep1ScoreBox1.y - 0.8 * ep1ScoreBox1.height
		
		local lock = getItemByName(page.items[1].children, "lock")
		lock.x, lock.y = 0, 0
		
		if gameCenterSupported then
			local ep1MeterBG = getItemByName(page.items[1].children, "ep1MeterBG")
			local ep1MeterIndicator = getItemByName(page.items[1].children, "ep1MeterIndicator")
			local meterW, meterH = _G.res.getSpriteBounds("" ,ep1MeterBG.sprite)
			local meterPx, meterPy = _G.res.getSpritePivot("", ep1MeterBG.sprite)
			local ep1BorderW, _ = _G.res.getSpriteBounds("", "EPISODE1_TOP_LEFT")
			ep1MeterBG.x, ep1MeterBG.y = -episode1.width / 2 - (ep1BorderW * 0.6), meterPy - meterH / 2
			ep1MeterIndicator.x, ep1MeterIndicator.y = ep1MeterBG.x, ep1MeterIndicator.y or ep1MeterBG.y 
			if gameCenterEnabled then
				ep1MeterBG.visible = true
				ep1MeterIndicator.visible = true
			else
				ep1MeterBG.visible = false
				ep1MeterIndicator.visible = false
			end
			
			
		end
		createFeatherBox(1, page)
		
		--ep2
		local ep2Sprite = getItemByName(page.items, "ep2Sprite")
		ep2Sprite.x, ep2Sprite.y = 0, 0
		
		setFont(fontBasic)
		fh = _G.res.getFontHeight()
		_, sh2 = _G.res.getSpriteBounds("", "EPISODE2_TOP_MIDDLE")
		
		local episode2 = getItemByName(page.items, "episode2")
		episode2.x, episode2.y = (2 - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2, screenHeight / 2
		
		local episode2Text = getItemByName(page.items, "episode2Text")
		episode2.width, episode2.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		episode2Text.x, episode2Text.y = episode1Text.x, episode1Text.y
		
		local episode2YellowLine = getItemByName(page.items, "episode2YellowLine")
		episode2YellowLine.x, episode2YellowLine.y = episode1YellowLine.x, episode1YellowLine.y
		episode2YellowLine.width, episode2YellowLine.height = episode2.width, 1
		
		local episode2Score = getItemByName(page.items, "episode2Score")
		setFont(episode2Score.font)
		fh = _G.res.getFontHeight()
		
		local ep2ScoreBox1 = getItemByName(page.items, "ep2ScoreBox1")
		ep2ScoreBox1.width, ep2ScoreBox1.height = ep1ScoreBox1.width, ep1ScoreBox1.height
		ep2ScoreBox1.x, ep2ScoreBox1.y = -episode2.width / 2, episode2.height / 2 + sh2 / 6
		
		local ep2ScoreBox2 = getItemByName(page.items, "ep2ScoreBox2")
		ep2ScoreBox2.width, ep2ScoreBox2.height = ep1ScoreBox2.width, ep1ScoreBox2.height
		ep2ScoreBox2.x, ep2ScoreBox2.y = episode2.width / 2, episode2.height / 2 + sh2 / 6
		
		episode2Score.x, episode2Score.y = -episode2.width / 2 + ep2ScoreBox2.width / 2, ep2ScoreBox1.y
		
		local episode2ScoreText = getItemByName(page.items, "episode2ScoreText")
		episode2ScoreText.sprite = scoreSpriteName
		episode2ScoreText.x, episode2ScoreText.y = ep2ScoreBox1.x + ep2ScoreBox1.width / 2, ep2ScoreBox1.y - 0.8 * ep2ScoreBox1.height

		local episode2Stars = getItemByName(page.items, "episode2Stars")
		episode2Stars.x, episode2Stars.y = episode2.width / 2 - ep2ScoreBox2.width / 2, ep2ScoreBox2.y
		
		local ep2StarSprite = getItemByName(page.items, "ep2StarSprite")
		ep2StarSprite.x, ep2StarSprite.y = ep2ScoreBox2.x - ep2ScoreBox2.width / 2, ep2ScoreBox1.y - 0.8 * ep2ScoreBox1.height
		
		local lock = getItemByName(page.items[2].children, "lock")
		lock.x, lock.y = 0, 0
		
		local appStore = getItemByName(page.items[2].children, "appStore")
		appStore.x, appStore.y = 0, 0
		
		if gameCenterSupported then
			local ep2MeterBG = getItemByName(page.items[2].children, "ep2MeterBG")
			local ep2MeterIndicator = getItemByName(page.items[2].children, "ep2MeterIndicator")
			local meterW, meterH = _G.res.getSpriteBounds("", ep2MeterBG.sprite)
			local meterPx, meterPy = _G.res.getSpritePivot("", ep2MeterBG.sprite)
			local ep2BorderW, _ = _G.res.getSpriteBounds("", "EPISODE2_TOP_LEFT")			
			ep2MeterBG.x, ep2MeterBG.y = -episode2.width / 2 - (ep2BorderW * 0.6), meterPy - meterH / 2
			
			ep2MeterIndicator.x, ep2MeterIndicator.y = ep2MeterBG.x, ep2MeterIndicator.y or ep2MeterBG.y
			if gameCenterEnabled then
				ep2MeterBG.visible = true
				ep2MeterIndicator.visible = true
			else
				ep2MeterBG.visible = false
				ep2MeterIndicator.visible = false
			end
		end
		createFeatherBox(2, page)
		--ep3
		local ep3Sprite = getItemByName(page.items, "ep3Sprite")
		ep3Sprite.x, ep3Sprite.y = 0, 0
		
		setFont(fontBasic)
		fh = _G.res.getFontHeight()
		_, sh2 = _G.res.getSpriteBounds("", "EPISODE3_TOP_MIDDLE")
		
		local episode3 = getItemByName(page.items, "episode3")
		episode3.x, episode3.y = ((3 - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2) , screenHeight / 2
		
		local episode3Text = getItemByName(page.items, "episode3Text")
		episode3.width, episode3.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		episode3Text.x, episode3Text.y = episode1Text.x, episode1Text.y
		
		local episode3YellowLine = getItemByName(page.items, "episode3YellowLine")
		episode3YellowLine.x, episode3YellowLine.y = episode1YellowLine.x, episode1YellowLine.y
		episode3YellowLine.width, episode3YellowLine.height = episode3.width, 1
		
		local episode3Score = getItemByName(page.items, "episode3Score")
		setFont(episode3Score.font)
		fh = _G.res.getFontHeight()
		
		local ep3ScoreBox1 = getItemByName(page.items, "ep3ScoreBox1")
		ep3ScoreBox1.width, ep3ScoreBox1.height = ep1ScoreBox1.width, ep1ScoreBox1.height
		ep3ScoreBox1.x, ep3ScoreBox1.y = -episode3.width / 2, episode3.height / 2 + sh2 / 6
		
		local ep3ScoreBox2 = getItemByName(page.items, "ep3ScoreBox2")
		ep3ScoreBox2.width, ep3ScoreBox2.height = ep1ScoreBox2.width, ep1ScoreBox2.height
		ep3ScoreBox2.x, ep3ScoreBox2.y = episode3.width / 2, episode3.height / 2 + sh2 / 6
		
		episode3Score.x, episode3Score.y = -episode3.width / 2 + ep3ScoreBox2.width / 2, ep3ScoreBox1.y
		
		local episode3ScoreText = getItemByName(page.items, "episode3ScoreText")
		episode3ScoreText.sprite = scoreSpriteName
		episode3ScoreText.x, episode3ScoreText.y = ep3ScoreBox1.x + ep3ScoreBox1.width / 2, ep3ScoreBox1.y - 0.8 * ep3ScoreBox1.height

		local episode3Stars = getItemByName(page.items, "episode3Stars")
		episode3Stars.x, episode3Stars.y = episode3.width / 2 - ep3ScoreBox2.width / 2, ep3ScoreBox2.y
		
		local ep3StarSprite = getItemByName(page.items, "ep3StarSprite")
		ep3StarSprite.x, ep3StarSprite.y = ep3ScoreBox2.x - ep3ScoreBox2.width / 2, ep3ScoreBox1.y - 0.8 * ep3ScoreBox1.height
		
		local lock = getItemByName(page.items[3].children, "lock")
		lock.x, lock.y = 0, 0
		
		local appStore = getItemByName(page.items[3].children, "appStore")
		appStore.x, appStore.y = 0, 0
		
		if gameCenterSupported then
			local ep3MeterBG = getItemByName(page.items[3].children, "ep3MeterBG")
			local ep3MeterIndicator = getItemByName(page.items[3].children, "ep3MeterIndicator")
			local meterW, meterH = _G.res.getSpriteBounds("", ep3MeterBG.sprite)
			
			local meterPx, meterPy = _G.res.getSpritePivot("", ep3MeterBG.sprite)
			local ep3BorderW, _ = _G.res.getSpriteBounds("", "EPISODE3_TOP_LEFT")			
			ep3MeterBG.x, ep3MeterBG.y = -episode3.width / 2 - (ep3BorderW * 0.6), meterPy - meterH / 2
			
			--ep3MeterBG.x, ep3MeterBG.y = -episode3.width / 2 - meterW * 1.1, episode3.height / 2 - meterH / 7
			ep3MeterIndicator.x, ep3MeterIndicator.y = ep3MeterBG.x, ep3MeterIndicator.y or ep3MeterBG.y
			if gameCenterEnabled then
				ep3MeterBG.visible = true
				ep3MeterIndicator.visible = true
			else
				ep3MeterBG.visible = false
				ep3MeterIndicator.visible = false
			end
		end
		createFeatherBox(3, page)

		local episode4
		local ep4Sprite
		local episode4Text
		local episode4YellowLine
		local episode4Score
		local ep4ScoreBox1
		local ep4ScoreBox2
		local episode4ScoreText
		local episode4Stars
		local ep4StarSprite
		--ep4
		
			ep4Sprite = getItemByName(page.items, "ep4Sprite")
			ep4Sprite.x, ep4Sprite.y = 0, 0
			
			setFont(fontBasic)
			fh = _G.res.getFontHeight()
			_, sh2 = _G.res.getSpriteBounds("", "EPISODE4_TOP_MIDDLE")
			
			episode4 = getItemByName(page.items, "episode4")
			episode4.x, episode4.y = ((4 - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2), screenHeight / 2
			
			episode4Text = getItemByName(page.items, "episode4Text")
			episode4.width, episode4.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
			episode4Text.x, episode4Text.y = episode1Text.x, episode1Text.y
			
			episode4YellowLine = getItemByName(page.items, "episode4YellowLine")
			episode4YellowLine.x, episode4YellowLine.y = episode1YellowLine.x, episode1YellowLine.y
			episode4YellowLine.width, episode4YellowLine.height = episode4.width, 1
			
			episode4Score = getItemByName(page.items, "episode4Score")
			setFont(episode4Score.font)
			fh = _G.res.getFontHeight()
			
			ep4ScoreBox1 = getItemByName(page.items, "ep4ScoreBox1")
			ep4ScoreBox1.width, ep4ScoreBox1.height = ep1ScoreBox1.width, ep1ScoreBox1.height
			ep4ScoreBox1.x, ep4ScoreBox1.y = -episode4.width / 2, episode4.height / 2 + sh2 / 6
			
			ep4ScoreBox2 = getItemByName(page.items, "ep4ScoreBox2")
			ep4ScoreBox2.width, ep4ScoreBox2.height = ep1ScoreBox2.width, ep1ScoreBox2.height
			ep4ScoreBox2.x, ep4ScoreBox2.y = episode4.width / 2, episode4.height / 2 + sh2 / 6
			
			episode4Score.x, episode4Score.y = -episode4.width / 2 + ep4ScoreBox2.width / 2, ep4ScoreBox1.y
			
			episode4ScoreText = getItemByName(page.items, "episode4ScoreText")
			episode4ScoreText.sprite = scoreSpriteName
			episode4ScoreText.x, episode4ScoreText.y = ep4ScoreBox1.x + ep4ScoreBox1.width / 2, ep4ScoreBox1.y - 0.8 * ep4ScoreBox1.height

			episode4Stars = getItemByName(page.items, "episode4Stars")
			episode4Stars.x, episode4Stars.y = episode4.width / 2 - ep4ScoreBox2.width / 2, ep4ScoreBox2.y
			
			ep4StarSprite = getItemByName(page.items, "ep4StarSprite")
			ep4StarSprite.x, ep4StarSprite.y = ep4ScoreBox2.x - ep4ScoreBox2.width / 2, ep4ScoreBox1.y - 0.8 * ep4ScoreBox1.height
			
			local lock = getItemByName(page.items[4].children, "lock")
			lock.x, lock.y = 0, 0
			
			local appStore = getItemByName(page.items[4].children, "appStore")
			appStore.x, appStore.y = 0, 0
			
			if gameCenterSupported then
				local ep4MeterBG = getItemByName(page.items[4].children, "ep4MeterBG")
				local ep4MeterIndicator = getItemByName(page.items[4].children, "ep4MeterIndicator")
				local meterW, meterH = _G.res.getSpriteBounds("", ep4MeterBG.sprite)
				
				local meterPx, meterPy = _G.res.getSpritePivot("", ep4MeterBG.sprite)
				local ep4BorderW, _ = _G.res.getSpriteBounds("", "EPISODE4_TOP_LEFT")			
				ep4MeterBG.x, ep4MeterBG.y = -episode4.width / 2 - (ep4BorderW * 0.6), meterPy - meterH / 2
				
				--ep4MeterBG.x, ep4MeterBG.y = -episode4.width / 2 - meterW * 1.1, episode4.height / 2 - meterH / 7
				ep4MeterIndicator.x, ep4MeterIndicator.y = ep4MeterBG.x, ep4MeterIndicator.y or ep4MeterBG.y
				if gameCenterEnabled then
					ep4MeterBG.visible = true
					ep4MeterIndicator.visible = true
				else
					ep4MeterBG.visible = false
					ep4MeterIndicator.visible = false
				end
			end
		
		createFeatherBox(4, page)

		local episode5
		local ep5Sprite
		local episode5Text
		local episode5YellowLine
		local episode5Score
		local ep5ScoreBox1
		local ep5ScoreBox2
		local episode5ScoreText
		local episode5Stars
		local ep5StarSprite
		
		--ep5
	
		ep5Sprite = getItemByName(page.items, "ep5Sprite")
		ep5Sprite.x, ep5Sprite.y = 0, 0
		
		setFont(fontBasic)
		fh = _G.res.getFontHeight()
		_, sh2 = _G.res.getSpriteBounds("", "EPISODE5_TOP_MIDDLE")
		
		episode5 = getItemByName(page.items, "episode5")
		episode5.x, episode5.y = ((5 - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2), screenHeight / 2
		
		episode5Text = getItemByName(page.items, "episode5Text")
		episode5.width, episode5.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		episode5Text.x, episode5Text.y = episode1Text.x, episode1Text.y
		
		episode5YellowLine = getItemByName(page.items, "episode5YellowLine")
		episode5YellowLine.x, episode5YellowLine.y = episode1YellowLine.x, episode1YellowLine.y
		episode5YellowLine.width, episode5YellowLine.height = episode5.width, 1
		
		episode5Score = getItemByName(page.items, "episode5Score")
		setFont(episode5Score.font)
		fh = _G.res.getFontHeight()
		
		ep5ScoreBox1 = getItemByName(page.items, "ep5ScoreBox1")
		ep5ScoreBox1.width, ep5ScoreBox1.height = ep1ScoreBox1.width, ep1ScoreBox1.height
		ep5ScoreBox1.x, ep5ScoreBox1.y = -episode5.width / 2, episode5.height / 2 + sh2 / 6
		
		ep5ScoreBox2 = getItemByName(page.items, "ep5ScoreBox2")
		ep5ScoreBox2.width, ep5ScoreBox2.height = ep1ScoreBox2.width, ep1ScoreBox2.height
		ep5ScoreBox2.x, ep5ScoreBox2.y = episode5.width / 2, episode5.height / 2 + sh2 / 6
		
		episode5Score.x, episode5Score.y = -episode5.width / 2 + ep5ScoreBox2.width / 2, ep5ScoreBox1.y
		
		episode5ScoreText = getItemByName(page.items, "episode5ScoreText")
		episode5ScoreText.sprite = scoreSpriteName
		episode5ScoreText.x, episode5ScoreText.y = ep5ScoreBox1.x + ep5ScoreBox1.width / 2, ep5ScoreBox1.y - 0.8 * ep5ScoreBox1.height

		episode5Stars = getItemByName(page.items, "episode5Stars")
		episode5Stars.x, episode5Stars.y = episode5.width / 2 - ep5ScoreBox2.width / 2, ep5ScoreBox2.y
		
		ep5StarSprite = getItemByName(page.items, "ep5StarSprite")
		ep5StarSprite.x, ep5StarSprite.y = ep5ScoreBox2.x - ep5ScoreBox2.width / 2, ep5ScoreBox1.y - 0.8 * ep5ScoreBox1.height
		
		local lock = getItemByName(page.items[5].children, "lock")
		lock.x, lock.y = 0, 0
		
		local appStore = getItemByName(page.items[5].children, "appStore")
		appStore.x, appStore.y = 0, 0
		
		if gameCenterSupported then
			local ep5MeterBG = getItemByName(page.items[5].children, "ep5MeterBG")
			local ep5MeterIndicator = getItemByName(page.items[5].children, "ep5MeterIndicator")
			local meterW, meterH = _G.res.getSpriteBounds("", ep5MeterBG.sprite)

			local meterPx, meterPy = _G.res.getSpritePivot("", ep5MeterBG.sprite)
			local ep5BorderW, _ = _G.res.getSpriteBounds("", "EPISODE5_TOP_LEFT")			
			ep5MeterBG.x, ep5MeterBG.y = -episode5.width / 2 - (ep5BorderW * 0.6), meterPy - meterH / 2
			
		--	ep5MeterBG.x, ep5MeterBG.y = -episode5.width / 2 - meterW * 1.1, episode5.height / 2 - meterH / 7
			ep5MeterIndicator.x, ep5MeterIndicator.y = ep5MeterBG.x, ep5MeterIndicator.y or ep5MeterBG.y
			if gameCenterEnabled then
				ep5MeterBG.visible = true
				ep5MeterIndicator.visible = true
			else
				ep5MeterBG.visible = false
				ep5MeterIndicator.visible = false
			end
		end
		createFeatherBox(5, page)
		
		local episode6
		local ep6Sprite
		local episode6Text
		local episode6YellowLine
		local episode6Score
		local ep6ScoreBox1
		local ep6ScoreBox2
		local episode6ScoreText
		local episode6Stars
		local ep6StarSprite
		--ep6 --ADDED
		
		ep6Sprite = getItemByName(page.items, "ep6Sprite")
		ep6Sprite.x, ep6Sprite.y = 0, 0
			
		setFont(fontBasic)
		fh = _G.res.getFontHeight()  -- TODO: CHANGE NUM 
		_, sh2 = _G.res.getSpriteBounds("", "EPISODE5_TOP_MIDDLE")
			
		episode6 = getItemByName(page.items, "episode6")
		episode6.x, episode6.y = ((6 - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2), screenHeight / 2
			
		episode6Text = getItemByName(page.items, "episode6Text")
		episode6.width, episode6.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		episode6Text.x, episode6Text.y = episode1Text.x, episode1Text.y
			
		episode6YellowLine = getItemByName(page.items, "episode6YellowLine")
		episode6YellowLine.x, episode6YellowLine.y = episode1YellowLine.x, episode1YellowLine.y
		episode6YellowLine.width, episode6YellowLine.height = episode6.width, 1
			
		episode6Score = getItemByName(page.items, "episode6Score")
		setFont(episode6Score.font)
		fh = _G.res.getFontHeight()
			
		ep6ScoreBox1 = getItemByName(page.items, "ep6ScoreBox1")
		ep6ScoreBox1.width, ep6ScoreBox1.height = ep1ScoreBox1.width, ep1ScoreBox1.height
		ep6ScoreBox1.x, ep6ScoreBox1.y = -episode6.width / 2, episode6.height / 2 + sh2 / 6
			
		ep6ScoreBox2 = getItemByName(page.items, "ep6ScoreBox2")
		ep6ScoreBox2.width, ep6ScoreBox2.height = ep1ScoreBox2.width, ep1ScoreBox2.height
		ep6ScoreBox2.x, ep6ScoreBox2.y = episode6.width / 2, episode6.height / 2 + sh2 / 6
			
		episode6Score.x, episode6Score.y = -episode6.width / 2 + ep6ScoreBox2.width / 2, ep6ScoreBox1.y
			
		episode6ScoreText = getItemByName(page.items, "episode6ScoreText")
		episode6ScoreText.sprite = scoreSpriteName
		episode6ScoreText.x, episode6ScoreText.y = ep6ScoreBox1.x + ep6ScoreBox1.width / 2, ep6ScoreBox1.y - 0.8 * ep6ScoreBox1.height

		episode6Stars = getItemByName(page.items, "episode6Stars")
		episode6Stars.x, episode6Stars.y = episode6.width / 2 - ep6ScoreBox2.width / 2, ep6ScoreBox2.y
			
		ep6StarSprite = getItemByName(page.items, "ep6StarSprite")
		ep6StarSprite.x, ep6StarSprite.y = ep6ScoreBox2.x - ep6ScoreBox2.width / 2, ep6ScoreBox1.y - 0.8 * ep6ScoreBox1.height
			
		local lock = getItemByName(page.items[6].children, "lock")
		lock.x, lock.y = 0, 0
			
		local appStore = getItemByName(page.items[6].children, "appStore")
		appStore.x, appStore.y = 0, 0
			
		if gameCenterSupported then
			local ep6MeterBG = getItemByName(page.items[6].children, "ep6MeterBG")
			local ep6MeterIndicator = getItemByName(page.items[6].children, "ep6MeterIndicator")
			local meterW, meterH = _G.res.getSpriteBounds("", ep6MeterBG.sprite)
				
			local meterPx, meterPy = _G.res.getSpritePivot("", ep6MeterBG.sprite)
			-- TODO: CHANGE EP NUM
			local ep6BorderW, _ = _G.res.getSpriteBounds("", "EPISODE4_TOP_LEFT")			
				ep6MeterBG.x, ep6MeterBG.y = -episode6.width / 2 - (ep6BorderW * 0.6), meterPy - meterH / 2
				
			--ep4MeterBG.x, ep4MeterBG.y = -episode4.width / 2 - meterW * 1.1, episode4.height / 2 - meterH / 7
			ep6MeterIndicator.x, ep6MeterIndicator.y = ep6MeterBG.x, ep6MeterIndicator.y or ep6MeterBG.y
			if gameCenterEnabled then
				ep6MeterBG.visible = true
				ep6MeterIndicator.visible = true
			else
				ep6MeterBG.visible = false
				ep6MeterIndicator.visible = false
			end
		end
			
			
		createFeatherBox(6, page)
			
		if gameCenterEnabled then
			setIndicatorPositions()
			gameCenter.safeToRefresh = true
		end
		
		local episodeG = getItemByName(page.items, "episodeG")
		episodeG.x, episodeG.y = ((page.numEpisodes - 2 - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2), screenHeight / 2
		episodeG.width, episodeG.height = _G.math.max(longestString * 0.8, biggestSpriteW * 0.95), biggestSpriteH * 1.7
		
		local epGSprite = getItemByName(page.items, "epGSprite")
		epGSprite.x, epGSprite.y = 0, -episodeG.height * 0.05
				
		local epGEggLeft = getItemByName(page.items, "epGEggLeft")
		epGEggLeft.x, epGEggLeft.y = -episodeG.width / 2.1 , -episodeG.height / 2.05
		
		local epGEggRight = getItemByName(page.items, "epGEggRight")
		epGEggRight.x, epGEggRight.y = episodeG.width / 2.1 , -episodeG.height / 2.05
		
		local epGStarText = getItemByName(page.items, "epGStarText")
		local goldenEggStars = calculateStarsFromGoldenEggLevels()
		if goldenEggStars > 0 then
			epGStarText.text = "" .. goldenEggStars
		end
		
		local epGScoreBox = getItemByName(page.items, "epGScoreBox")
		epGScoreBox.x, epGScoreBox.y = 0, episodeG.height / 2 + sh2 / 6
		epGScoreBox.width, epGScoreBox.height = ep1ScoreBox1.width / 2, ep1ScoreBox1.height 
		
		epGStarText.x, epGStarText.y = epGScoreBox.x , epGScoreBox.y - epGScoreBox.height / 2 - fh / 8
		
		local epGYellowLine = getItemByName(page.items, "epGYellowLine")
		epGYellowLine.x, epGYellowLine.y = episode1YellowLine.x, episode1YellowLine.y
		epGYellowLine.width, epGYellowLine.height = episodeG.width, 1
		
		local sw, sh = _G.res.getSpriteBounds("", "SCORE_BOTTOM_MIDDLE")
	
		local epGStar = getItemByName(page.items, "epGStar")
		epGStar.x, epGStar.y = 0, epGScoreBox.y - epGScoreBox.height / 2.3 - sh / 2
		
		local epGEpisodeText = getItemByName(page.items, "epGEpisodeText")
		epGEpisodeText.x, epGEpisodeText.y = episode1Text.x, episode1Text.y
		
		local upsellShop = getItemByName(page.items, "upsellShop")
		upsellShop.x, upsellShop.y = ((page.numEpisodes - 1 - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2), screenHeight / 2
		upsellShop.width, upsellShop.height = _G.res.getSpriteBounds("", getItemByName(page.items, "upsellShop").sprite)
		
		if isSeasonsAvailable then
			local upsellHalloween = getItemByName(page.items, "upsellHalloween")
			upsellHalloween.x, upsellHalloween.y = ((page.numEpisodes - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2), screenHeight / 3
			upsellHalloween.width, upsellHalloween.height = _G.res.getSpriteBounds("", getItemByName(page.items, "upsellHalloween").sprite)
		
			local newsletter = getItemByName(page.items, "newsletter")
			newsletter.x, newsletter.y = 0, upsellHalloween.height
			newsletter.width, newsletter.height = _G.res.getSpriteBounds("", getItemByName(page.items, "newsletter").sprite)		
		else
			local newsletter = getItemByName(page.items, "newsletter")
			newsletter.x, newsletter.y = ((page.numEpisodes - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2), screenHeight / 2
			newsletter.width, newsletter.height = _G.res.getSpriteBounds("", getItemByName(page.items, "newsletter").sprite)		
		
		end
		
		if deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad" then
			local giftButton = getItemByName(page.items, "giftButton")
			local gbW, gbH = _G.res.getSpriteBounds("", giftButton.sprite)
			giftButton.x, giftButton.y = screenWidth - gbW / 2, gbH / 2
		elseif deviceModel == "android" and isHDVersion then
			local giftButton = getItemByName(page.items, "giftButton")
			giftButton.sprite = "BTN_ADFREE"
			giftButton.updateFunction = gotoLenovoNoAdsVersion
			local gbW, gbH = _G.res.getSpriteBounds("", giftButton.sprite)
			giftButton.x, giftButton.y = screenWidth - gbW / 2, gbH / 2

			if isPremium then
				giftButton.visible = false
			end
		end
		
		if deviceModel == "n900" then
			local pack1buy = getItemByName(page.items, "pack1buy")
			pack1buy.x, pack1buy.y = 0, -10
			if not hasLevelPack1() then
				pack1buy.visible = true
				pack1buy.selectable = true
			else
				pack1buy.visible = false
				pack1buy.selectable = false
			end
		end
		
		
		-- Prepare base game icon if available
		local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
		getItemByName(page.items[1].children, "episode1Score").text = _G.string.format("%d", score)
		getItemByName(page.items[1].children, "episode1Stars").text = gainedStars .. "/" .. totalStars
		getItemByName(page.items[1].children, "episode1ScoreText").visible = true
		getItemByName(page.items[2].children, "episode2ScoreText").visible = true
		getItemByName(page.items[3].children, "episode3ScoreText").visible = true

		
		getItemByName(page.items[4].children, "episode4ScoreText").visible = true
		

		getItemByName(page.items[1].children, "lock").visible = false
		
		-- Prepare Level Pack 2 icon if available
		if hasLevelPack2() == true then
			
			local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packOne)
			
			episode2.selectable = true
			episode2.updateFunction = gotoLevelSelectionExtra
			episode2Text.visible = true
			episode2Score.text = _G.string.format("%d", score)
			episode2Score.visible = true
			episode2Stars.text = gainedStars .. "/" .. totalStars
			episode2Stars.visible = true
			episode2ScoreText.visible = true
			getItemByName(page.items[2].children, "appStore").visible = false
			
			if deviceModel == "n900" or score > 0 or settings.gameCompleted then 
				getItemByName(page.items[2].children, "lock").visible = false
			else
				getItemByName(page.items[2].children, "lock").visible = true
			end
		else
			getItemByName(page.items, "episode2").selectable = true
			if deviceModel == "n900" or deviceModel == "s60" then
				episode2.updateFunction = gotoOviStore
			else
				episode2.callFunction = gotoFullVersionInAppStore
				episode2.updateFunction = nil
			end
			if deviceModel == "n900" then
				episode2.box = {left = "EPISODE_LOCKED_LEFT", bottomLeft = "EPISODE_LOCKED_BOTTOM_LEFT",
								bottomMiddle = "EPISODE_LOCKED_BOTTOM_MIDDLE", bottomRight = "EPISODE_LOCKED_BOTTOM_RIGHT",
								right = "EPISODE_LOCKED_RIGHT", topRight = "EPISODE_LOCKED_TOP_RIGHT",
								topMiddle = "EPISODE_LOCKED_TOP_MIDDLE", topLeft = "EPISODE_LOCKED_TOP_LEFT",
								center = "EPISODE_LOCKED_CENTER"}
			end
			
			ep2Sprite.visible = false
			episode2Text.visible = true
			episode2Score.visible = false
			episode2Stars.visible = false
			episode2ScoreText.visible = true
			getItemByName(page.items[2].children, "lock").visible = false
			getItemByName(page.items[2].children, "appStore").visible = true

		end
		
		if hasLevelPack3() == true then
		
			local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packThree)
			episode3.selectable = true
			episode3.updateFunction = gotoLevelSelectionPack3
			episode3.callFunction = nil
			ep3Sprite.visible = true
			episode3Text.visible = true
			episode3Score.visible = true
			episode3Score.text = _G.string.format("%d", score)
			episode3Stars.visible = true
			episode3Stars.text = gainedStars .. "/" .. totalStars
			episode3ScoreText.visible = true
			getItemByName(page.items[3].children, "appStore").visible = false
			
			if deviceModel == "n900" or settings.gameCompleted or score > 0 then
				getItemByName(page.items[3].children, "lock").visible = false
			else
				getItemByName(page.items[3].children, "lock").visible = true
			end
		else
			getItemByName(page.items, "episode3").selectable = true
			
			if deviceModel == "n900" or deviceModel == "s60" then
				episode3.updateFunction = gotoOviStore
			else
				episode3.callFunction = gotoFullVersionInAppStore
				episode3.updateFunction = nil
			end
			
			if deviceModel == "n900" then
				episode3.box = {left = "EPISODE_LOCKED_LEFT", bottomLeft = "EPISODE_LOCKED_BOTTOM_LEFT",
								bottomMiddle = "EPISODE_LOCKED_BOTTOM_MIDDLE", bottomRight = "EPISODE_LOCKED_BOTTOM_RIGHT",
								right = "EPISODE_LOCKED_RIGHT", topRight = "EPISODE_LOCKED_TOP_RIGHT",
								topMiddle = "EPISODE_LOCKED_TOP_MIDDLE", topLeft = "EPISODE_LOCKED_TOP_LEFT",
								center = "EPISODE_LOCKED_CENTER"}
			end
				
			ep3Sprite.visible = false
			episode3Text.visible = true
			episode3Score.visible = false
			episode3Stars.visible = false
			episode3ScoreText.visible = true
			getItemByName(page.items[3].children, "lock").visible = false
			getItemByName(page.items[3].children, "appStore").visible = true

		end
		
		
		if hasLevelPack4() == true then
		
			local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packFour)
			episode4.selectable = true
			episode4.updateFunction = gotoLevelSelectionPack4
			episode4.callFunction = nil
			ep4Sprite.visible = true
			episode4Text.visible = true
			episode4Score.visible = true
			episode4Score.text = _G.string.format("%d", score)
			episode4Stars.visible = true
			episode4Stars.text = gainedStars .. "/" .. totalStars
			episode4ScoreText.visible = true
			getItemByName(page.items[4].children, "appStore").visible = false
			
			if settings.gameCompleted or score > 0 then
				getItemByName(page.items[4].children, "lock").visible = false	
			else
				getItemByName(page.items[4].children, "lock").visible = true
			end
		else
			episode4.selectable = true
			-- if deviceModel == "n900" or deviceModel == "s60" then
				-- episode4.updateFunction = gotoOviStore
			-- else
				-- episode4.callFunction = gotoFullVersionInAppStore
				-- episode4.updateFunction = nil
			-- end
			
			if deviceModel == "n900" then
			episode4.box = {left = "EPISODE_LOCKED_LEFT", bottomLeft = "EPISODE_LOCKED_BOTTOM_LEFT",
							bottomMiddle = "EPISODE_LOCKED_BOTTOM_MIDDLE", bottomRight = "EPISODE_LOCKED_BOTTOM_RIGHT",
							right = "EPISODE_LOCKED_RIGHT", topRight = "EPISODE_LOCKED_TOP_RIGHT",
							topMiddle = "EPISODE_LOCKED_TOP_MIDDLE", topLeft = "EPISODE_LOCKED_TOP_LEFT",
							center = "EPISODE_LOCKED_CENTER"}
			end
				
			ep4Sprite.visible = false
			episode4Text.visible = true
			episode4Score.visible = false
			episode4Stars.visible = false
			episode4ScoreText.visible = true
			getItemByName(page.items[4].children, "lock").visible = false
			getItemByName(page.items[4].children, "appStore").visible = true

		end
		
		
		if hasLevelPack5() == true then
		
			local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packFive)
			episode5.selectable = true
			episode5.updateFunction = gotoLevelSelectionPack5
			episode5.callFunction = nil
			ep5Sprite.visible = true
			episode5Text.visible = true
			episode5Score.visible = true
			episode5Score.text = _G.string.format("%d", score)
			episode5Stars.visible = true
			episode5Stars.text = gainedStars .. "/" .. totalStars
			episode5ScoreText.visible = true
			getItemByName(page.items[5].children, "appStore").visible = false
			
			if settings.gameCompleted or score > 0 then
				getItemByName(page.items[5].children, "lock").visible = false	
			else
				getItemByName(page.items[5].children, "lock").visible = true
			end
		else
			episode5.selectable = true
			if deviceModel == "n900" or deviceModel == "s60" then
				episode5.updateFunction = gotoOviStore
			else
				episode5.callFunction = gotoFullVersionInAppStore
				episode5.updateFunction = nil
			end
			
			if deviceModel == "n900" then
			episode5.box = {left = "EPISODE_LOCKED_LEFT", bottomLeft = "EPISODE_LOCKED_BOTTOM_LEFT",
							bottomMiddle = "EPISODE_LOCKED_BOTTOM_MIDDLE", bottomRight = "EPISODE_LOCKED_BOTTOM_RIGHT",
							right = "EPISODE_LOCKED_RIGHT", topRight = "EPISODE_LOCKED_TOP_RIGHT",
							topMiddle = "EPISODE_LOCKED_TOP_MIDDLE", topLeft = "EPISODE_LOCKED_TOP_LEFT",
							center = "EPISODE_LOCKED_CENTER"}
			end
				
			ep5Sprite.visible = false
			episode5Text.visible = true
			episode5Score.visible = false
			episode5Stars.visible = false
			episode5ScoreText.visible = true
			getItemByName(page.items[5].children, "lock").visible = false
			getItemByName(page.items[5].children, "appStore").visible = true

		end
		
			if hasLevelPack6() == true then
		
			local score, gainedStars, totalStars = calculateTotalScoreAndStars(levelOrder_packSix)
			episode6.selectable = true
			episode6.updateFunction = gotoLevelSelectionPack6
			episode6.callFunction = nil
			ep6Sprite.visible = true
			episode6Text.visible = true
			episode6Score.visible = true
			episode6Score.text = _G.string.format("%d", score)
			episode6Stars.visible = true
			episode6Stars.text = gainedStars .. "/" .. totalStars
			episode6ScoreText.visible = true
			getItemByName(page.items[6].children, "appStore").visible = false
			
			if settings.gameCompleted or score > 0 then
				getItemByName(page.items[6].children, "lock").visible = false	
			else
				getItemByName(page.items[6].children, "lock").visible = true
			end
		else
			episode6.selectable = true
			
			if deviceModel == "n900" then
			episode6.box = {left = "EPISODE_LOCKED_LEFT", bottomLeft = "EPISODE_LOCKED_BOTTOM_LEFT",
							bottomMiddle = "EPISODE_LOCKED_BOTTOM_MIDDLE", bottomRight = "EPISODE_LOCKED_BOTTOM_RIGHT",
							right = "EPISODE_LOCKED_RIGHT", topRight = "EPISODE_LOCKED_TOP_RIGHT",
							topMiddle = "EPISODE_LOCKED_TOP_MIDDLE", topLeft = "EPISODE_LOCKED_TOP_LEFT",
							center = "EPISODE_LOCKED_CENTER"}
			end
				
			ep6Sprite.visible = false
			episode6Text.visible = true
			episode6Score.visible = false
			episode6Stars.visible = false
			episode6ScoreText.visible = true
			getItemByName(page.items[6].children, "lock").visible = false
			getItemByName(page.items[6].children, "appStore").visible = true

		end
	end
	

	
	if page == about then
		
		page.menuButton = mainMenu
		aboutDragStart = nil	
		dragSpeed = 0
		about.scrollTimer = 1.5
		
		local birds2 = getItemByName(page.items, "birds2")
		local sw, _ = _G.res.getSpriteBounds("", birds2.sprite)
		
		local textAbout = getItemByName(page.items, "textAbout")
		textAbout.textBoxSize = _G.math.max(sw, 200 * (screenWidth / 480))
		prepareTextItem(page, textAbout)
		
		local textCredits = getItemByName(page.items, "textCredits")
		textCredits.textBoxSize =  screenWidth * 0.8
		prepareTextItem(page, textCredits)
		
		local textAdditionalCredits = getItemByName(page.items, "textAdditionalCredits")
		textAdditionalCredits.textBoxSize = textCredits.w
		prepareTextItem(page, textAdditionalCredits)
		
		local privacyButton = getItemByName(page.items, "privacyButton")
		
		
		local textAboutRovio = getItemByName(page.items, "textAboutRovio")
		textAboutRovio.textBoxSize =  textAbout.textBoxSize
		prepareTextItem(page, textAboutRovio)
		
		page.backgroundBox.x, page.backgroundBox.y = 0, 0
		page.backgroundBox.width, page.backgroundBox.height = textAbout.w * 1.6, screenHeight + 1
		if page.backgroundBox.width < textCredits.w * 1.1 then
			page.backgroundBox.width = textCredits.w * 1.1
			textAbout.textBoxSize = textCredits.w
			prepareTextItem(page, textAbout)
		end
		--textCredits.textBoxSize =  page.backgroundBox.width
		--prepareTextItem(page, textCredits)
		local aboutTextXPos = page.backgroundBox.width * 0.53
		
		textAbout.x, textAbout.y = aboutTextXPos, 240
		birds2.x, birds2.y = aboutTextXPos, 480
		
		textCredits.x, textCredits.y = aboutTextXPos, 480
		textAdditionalCredits.x, textAdditionalCredits.y = aboutTextXPos, 480
		
		
		privacyButton.x, privacyButton.y = aboutTextXPos, 480

		local eulaButton = getItemByName(page.items, "eulaButton")
		if(eulaButton ~= nil) then
			eulaButton.x, eulaButton.y = aboutTextXPos, 480			
			eulaButton.visible = true		
		end
		
		textAboutRovio.x, textAboutRovio.y = aboutTextXPos, 480
		
		local birds1 = getItemByName(page.items, "birds1")
		birds1.x, birds1.y = aboutTextXPos, 480
			
		local goldenEgg = getItemByName(page.items, "goldenEgg")
		goldenEgg.x, goldenEgg.y = aboutTextXPos, 480
		
		local borderSw, _ = _G.res.getSpriteBounds("", "MAIN_SETTINGS_LEFT")
		local arrow = getItemByName(page.items, "arrow")
		arrow.x, arrow.y = page.backgroundBox.width + borderSw / 2, screenHeight - 30* screenHeight / 320
		
		local hideArea = getItemByName(page.items, "hideArea")
		hideArea.x, hideArea.y = page.backgroundBox.width, 0
		hideArea.w, hideArea.h = screenWidth - page.backgroundBox.width, screenHeight
		
		setFont(fontBasic)
		local fh = _G.res.getFontLeading()
		local fontHeight = _G.res.getFontHeight()

		local margin = 30
		local currentHeight = 55 * screenHeight / 320
		
		
		for i = page.scrollStart, page.scrollEnd do
			if about.items[i].text ~= nil then
				clipText("TEXTS_BASIC", about.items[i].text, about.items[i].textBoxSize)
				local textHeight = #clippedText.lines * fh
				about.items[i].h = textHeight
				about.items[i].y = textHeight * 0.5 + currentHeight
				currentHeight = currentHeight + textHeight + margin
			end
			
			if about.items[i].sprite ~= nil then	
				local w, h = _G.res.getSpriteBounds("", about.items[i].sprite)
				about.items[i].h = h
				about.items[i].y = h * 0.5 + currentHeight
				currentHeight = currentHeight + h + margin				
			end				
		end
		
	end
	
	if page == settingsPage then
		-- if settings.audioEnabled == false then
			-- page.items[2].visible = true
		-- else
			-- page.items[2].visible = false
		-- end
		-- if settings.musicEnabled == false then
			-- page.items[4].visible = true
		-- else
			-- page.items[4].visible = false
		-- end
		--[[
		if settings.lastOpenLevel == 1 then
			page.items[7].sprite = "BUTTON_BIG_DISABLED"
		else
			page.items[7].sprite = "BUTTON_BIG"
		end
		--]]
		--page.items[5].sprite = languageSprites[currentLanguage]
	end
	
	if page == pausePage then
		if currentMainMenuSong ~= nil and _G.res.isAudioPlaying(currentMainMenuSong) == true then
			_G.res.stopAudio(currentMainMenuSong)
		end
		pausePage.menuButton = "goToGame"
		local buttonSfx = getItemByName(page.items, "buttonSfx")
		local sw, sh = _G.res.getSpriteBounds("", buttonSfx.sprite)
		
		page.backgroundBox.x, page.backgroundBox.y = 0, 0
		
		page.backgroundBox.width = sw * 2.5
		buttonSfx.x, buttonSfx.y = page.backgroundBox.width / 2 - sw * 0.54, screenHeight - sh * 0.66
		
		local buttonOff = getItemByName(page.items, "buttonOff")
		buttonOff.x, buttonOff.y = page.backgroundBox.width / 2 - sw * 0.54, screenHeight - sh * 0.66
		
		local buttonTutorials = getItemByName(page.items, "buttonTutorials")
		buttonTutorials.x, buttonTutorials.y = page.backgroundBox.width / 2 + sw * 0.54, screenHeight - sh * 0.66
		
		if deviceModel == "s60" and isLiteVersion then
			local buttonOvi = getItemByName(page.items, "buttonOvi")
			buttonOvi.visible = false
		end
		page.backgroundBox.height = screenHeight + 1
			
		local buttonMenu = getItemByName(page.items, "buttonMenu")
		buttonMenu.x, buttonMenu.y = page.backgroundBox.width / 2, screenHeight / 2 + (sh * 0.7)
		
		local buttonRestart = getItemByName(page.items, "buttonRestart")
		buttonRestart.x, buttonRestart.y = page.backgroundBox.width / 2, screenHeight / 2 - (sh * 0.7)
		
		local borderSw, _ = _G.res.getSpriteBounds("", "MAIN_SETTINGS_LEFT")
		local buttonResume = getItemByName(page.items, "buttonResume")
		buttonResume.x, buttonResume.y = page.backgroundBox.width + borderSw / 2, screenHeight/2
		
		local buttonResumeW, _ = _G.res.getSpriteBounds("", buttonResume.sprite)
		pauseBGw = page.backgroundBox.width + buttonResumeW
		
		local hideArea = getItemByName(page.items, "hideArea")
		hideArea.x, hideArea.y = pauseBGw, 0
		hideArea.w, hideArea.h = screenWidth, screenHeight
		
		local levelText = getItemByName(page.items, "levelText")
		levelText.x, levelText.y = page.backgroundBox.width / 2, sh * 0.65	
		
		if deviceModel == "n900" or deviceModel == "s60" then
			local taskSwitcher = getItemByName(page.items, "taskSwitcher")
			taskSwitcher.x, taskSwitcher.y = 0, 0
		end	
		
		if settings.audioEnabled == false then
			getItemByName(page.items, "buttonOff").visible = true
		else
			getItemByName(page.items, "buttonOff").visible = false
		end

		if inExtraWorld == true then
			getItemByName(page.items, "buttonMenu").page = levelSelectionPagesGoldenEggs[settings.currentLevelSelectionPages.goldeneggs]
			if currentLevelNumberInTheme == 22 then
				getItemByName(page.items, "levelText").text = "*"
			else
				getItemByName(page.items, "levelText").text = "^-" .. currentLevelNumberInTheme
			end
		else
			if currentWorldNumber <= 3 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesBasic
			elseif currentWorldNumber <= 5 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesExtra
			elseif currentWorldNumber <= 8 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack3
			elseif currentWorldNumber <= 11 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack4
			elseif currentWorldNumber <= 14 then
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack5
			elseif currentWorldNumber <= 17 then				-- ADDED
				getItemByName(page.items, "buttonMenu").page = levelSelectionPagesPack6	
			end
			if currentWorldNumber == 14 and currentLevelNumberInTheme > 15 then
				getItemByName(page.items, "levelText").text = "|-"..currentLevelNumberInTheme - 15
			else
				getItemByName(page.items, "levelText").text = currentWorldNumber .. "-" .. currentLevelNumberInTheme
			end
		end
	end
	
	if page == levelSelectionPagesBasic then

		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = {red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue =  page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesBasic.firstLevelIndex, #levelSelectionPagesBasic.items do
			levelSelectionPagesBasic.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.basic = levelSelectionPagesBasic.currentPage

		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		local textY = 0.03 * screenHeight + 12
		local yDividerMultiplier = 1.16
		
		local contentAreaWidth = screenWidth * 0.83
		if isLiteVersion then
			contentAreaWidth = screenWidth * 0.7
			yDividerMultiplier = 1.3
		end
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		back.x, back.y = 0, screenHeight
		
		local text1 = getItemByName(page.items, "text_1")
		text1.x, text1.y = screenWidth / 2 - lsDotSpacing, screenHeight - textY
		local text2 = getItemByName(page.items, "text_2")
		text2.x, text2.y = screenWidth / 2, screenHeight - textY
		local text3 = getItemByName(page.items, "text_3")
		text3.x, text3.y = screenWidth / 2 + lsDotSpacing, screenHeight - textY
		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = screenWidth / 2 - lsDotSpacing, screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = screenWidth / 2, screenHeight - lsDotY
		local dot3 = getItemByName(page.items, "dot3")
		dot3.x, dot3.y = screenWidth / 2 + lsDotSpacing, screenHeight - lsDotY
		
		if isLiteVersion then
			
			local upsellShop = getItemByName(page.items, "upsellShop")
			upsellShop.x, upsellShop.y, upsellShop.relativeX = 0, screenHeight / 2.5, screenWidth * 1.5
			
			local upsellABFull = getItemByName(page.items, "upsellABFull")
			upsellABFull.x, upsellABFull.y, upsellABFull.relativeX = 0, screenHeight / 4, screenWidth * 2.5
			
			local upsellABNews = getItemByName(page.items, "upsellABNews")
			upsellABNews.x, upsellABNews.y, upsellABNews.relativeX = 0, screenHeight / 1.75, screenWidth * 2.5
		
			local appStore = getItemByName(page.items, "appStore")
			appStore.x, appStore.y, appStore.relativeX = screenWidth / 2, screenHeight * 0.78, screenWidth * 0.5
		end
		
		local itemsPerPage = 21
		local itemsPerLine = 7
		local linesPerPage = 3
		local pages = 3
		
		if isLiteVersion then
			linesPerPage = 4
			pages = 1
			itemsPerPage = 18
			itemsPerLine = 6
		end
		
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		local offset = 0
		
		for k = 0, pages - 1 do
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				local tempX = offset + contentAreaStart + (indexInLine - 1) * contentItemStep + levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX =  offset + tempX - levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = screenHeight * yDivider + ySpaceAdd
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX + levelSelectionPagesBasic.currentOffset
			end
			
			-- ovistore item positions
			if deviceModel == "n900" and k == 1 then
				local itm = getItemByName(levelSelectionPagesBasic.items, "button1")
				itm.x = offset * 2 + screenWidth / 2 + levelSelectionPagesBasic.currentOffset
				itm.relativeX = screenWidth / 2 + offset * 2
				itm.y = screenHeight / 2
				itm = getItemByName(levelSelectionPagesBasic.items, "button2")
				itm.x = offset * 2 + screenWidth / 2 + levelSelectionPagesBasic.currentOffset
				itm.relativeX = screenWidth / 2 + offset * 2
				itm.y = screenHeight * 0.83333
			end
			
			offset = offset + screenWidth / 2
		end
		
		
		-- check if player has theme 2 and 3 for n900
		if deviceModel == "n900" then
			if not hasLevelPack1() then 
				getItemByName(page.items, "overlay").visible = true
				local itm = getItemByName(page.items, "button1")
				itm.visible, itm.selectable = true, true
				itm = getItemByName(page.items, "button2")
				itm.visible, itm.selectable = true, true
				
			else
				getItemByName(page.items, "overlay").visible = false
				local itm = getItemByName(page.items, "button1")
				itm.visible, itm.selectable = false, false
				itm = getItemByName(page.items, "button2")
				itm.visible, itm.selectable = false, false
			end
		end	
		
		if not limitLevels then
			for i = 1, #page.items do
				if page.items[i].levelIndex ~= nil and page.items[i].levelIndex ~= "dummy" then
					themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
					if (deviceModel == "n900" and (getItemByName(page.items, "overlay").visible == false or themeIndex < 2)) 
					 or (deviceModel ~= "n900" and (settings.lastOpenLevel >= page.items[i].levelIndex)) 
					 or highscores[page.items[i].filename] ~= nil then
						page.items[i].text = "" .. page.items[i].pageLevelIndex
						page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. page.themes[themeIndex]
						page.items[i].selectable = true
					else
						page.items[i].text = nil
						page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
						page.items[i].selectable = false
					end
				else
					if isLiteVersion then
						page.items[i].selectable = true
						page.items[i].visible = true
					end
				end
			end
		else
			for i = 1, #page.items do
				if page.items[i].levelIndex ~= nil and page.items[i].levelIndex ~= "dummy" then
					page.items[i].text = ""
					page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					page.items[i].selectable = false
				
					for j = 1, #openDemoLevels do
						if page.items[i].levelIndex == openDemoLevels[j] then
							page.items[i].text = "" .. page.items[i].pageLevelIndex
							page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. page.themes[page.currentPage]
							page.items[i].selectable = true
						end
					end
				end
			end		
		end
		
		if levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0 then

			getItemByName(page.items, "text_1").visible = page.currentPage == 1
			getItemByName(page.items, "text_2").visible = page.currentPage == 2
			getItemByName(page.items, "text_3").visible = page.currentPage == 3
		
			
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot3").sprite = "LS_DOT_BLACK"

			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true
			getItemByName(page.items, "dot3").visible = true

		end
		
		if isLiteVersion then
			--levelSelectionPagesBasic.items[#levelSelectionPagesBasic.items].x = screenWidth*0.5
			--levelSelectionPagesBasic.items[#levelSelectionPagesBasic.items].y = levelSelectionPagesBasic.items[#levelSelectionPagesBasic.items].y + 16
		end
		
		if oldMenuPage ~= mainMenu and 
			oldMenuPage ~= episodeSelectionPage and
			dontStopMusic ~= true then
			_G.res.stopAllAudio()
		end
		if _G.res.isAudioPlaying(currentMainMenuSong) == false then
			_G.res.playAudio(currentMainMenuSong, 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
	end	
	
	if page == levelSelectionPagesExtra then
		
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesExtra.firstLevelIndex, #levelSelectionPagesExtra.items do
			levelSelectionPagesExtra.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.extra = page.currentPage		
		
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		local textY = 0.03 * screenHeight + 12
		local yDividerMultiplier = 1.16
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		back.x, back.y = 0, screenHeight
		
		local text1 = getItemByName(page.items, "text_4")
		text1.x, text1.y = screenWidth / 2 - lsDotSpacing / 2, screenHeight - textY
		local text2 = getItemByName(page.items, "text_5")
		text2.x, text2.y = screenWidth / 2 + lsDotSpacing / 2, screenHeight - textY

		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = screenWidth / 2 - lsDotSpacing / 2, screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = screenWidth / 2 + lsDotSpacing / 2, screenHeight - lsDotY
		
		
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 0.023 * screenWidth
		local lsDotY = 0.03 * screenHeight
		local textY = 0.03 * screenHeight + 15
		local yDividerMultiplier = 1.16
			
		local contentAreaWidth = screenWidth * 0.83
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		
		local itemsPerPage = 21
		local itemsPerLine = 7
		local linesPerPage = 3
		local pages = 2
		
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		
		local offset = 0
		for k = 0, pages - 1 do
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				local tempX = offset + contentAreaStart + (indexInLine - 1) * contentItemStep + levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX =  offset + tempX - levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = screenHeight * yDivider + ySpaceAdd
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX + levelSelectionPagesBasic.currentOffset
			end
				
			offset = offset + screenWidth / 2
		end
		
		
		for i = 1, #page.items do
			if page.items[i].levelIndex ~= nil then
				themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
				if settings.lastOpenLevelLP2 >= page.items[i].levelIndex or highscores[page.items[i].filename] ~= nil then
					page.items[i].text = "" .. page.items[i].pageLevelIndex
					page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. page.themes[themeIndex]
					page.items[i].selectable = true
				else
					page.items[i].text = nil
					page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					page.items[i].selectable = false
				end
			end
		end
		
		if not isLiteVersion and (levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0) then
			getItemByName(page.items, "text_4").visible = page.currentPage == 1
			getItemByName(page.items, "text_5").visible = page.currentPage == 2
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true	
		end
		
		if oldMenuPage ~= mainMenu and 
			oldMenuPage ~= episodeSelectionPage and 
			dontStopMusic ~= true then			
			_G.res.stopAllAudio()
		end
		if _G.res.isAudioPlaying(currentMainMenuSong) == false then
			_G.res.playAudio(currentMainMenuSong, 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
	end	
	
	if levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1] then
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		levelSelectionPagesPressed = false
		
		local lsDotSpacing = 15
		local lsDotY = 10
		local puzzledBird = getItemByName(page.items, "puzzledBird")
		local pbx, pby = _G.res.getSpritePivot("","GOLDEN_EGG_PUZZLED_BIRD")
		local pbw, pbh = _G.res.getSpriteBounds("","GOLDEN_EGG_PUZZLED_BIRD")
		local textY = 0.03 * screenHeight + 12
		
		if isGEPage2Unlocked() then
			page.pageCount = 2
		else
			page.pageCount = 1
		end
		
		local goldenEggPositions = {{x = 0.33 * screenWidth, y = 0.21 * screenHeight}, 
									{x = 0.68 * screenWidth, y = 0.21 * screenHeight},
									{x = 0.1 * screenWidth, y = 0.45 * screenHeight}, 
									{x = 0.5 *  screenWidth, y = 0.48 * screenHeight},
									{x = 0.81 * screenWidth, y = 0.53 * screenHeight}, 
									{x = 0.29 * screenWidth, y = 0.82 * screenHeight},
									{x = 0.58 * screenWidth, y = 0.84 * screenHeight}, 
									{x = 0.32 * screenWidth, y = 0.53 * screenHeight},
									{x = 0.8 * screenWidth, y = 0.83 * screenHeight}, 
									{x = 0.91 * screenWidth, y = 0.16 * screenHeight},
									{x = 0.12 * screenWidth, y = 0.17 * screenHeight}, 
									{x = 0.5 * screenWidth, y = 0.19 * screenHeight},
									{x = 0.10 * screenWidth, y = 0.72 * screenHeight},
									{x = 0.66 * screenWidth, y = 0.52 * screenHeight},
									{x = 0.44 * screenWidth, y = 0.75 * screenHeight},
									{x = 1.44 * screenWidth, y = 0.75 * screenHeight},
									{x = 1.5 *  screenWidth, y = 0.48 * screenHeight},
									{x = 1.1 * screenWidth, y = 0.45 * screenHeight},
									{x = 1.81 * screenWidth, y = 0.53 * screenHeight}, 
									{x = 1.31 * screenWidth, y = 0.13 * screenHeight}, 
									{x = 1.70 * screenWidth, y = 0.83 * screenHeight}, 
									{x = 1.20 * screenWidth, y = 0.73 * screenHeight}, 

									{x = 1.90 * screenWidth, y = 0.13 * screenHeight}, 
									{x = 1.70 * screenWidth, y = 0.16 * screenHeight}, 
									{x = 1.60 * screenWidth, y = 0.63 * screenHeight}, 
									{x = 1.30 * screenWidth, y = 0.50 * screenHeight}, 
								 }
		
		local tipBubblePositions = {{x = screenWidth - 3.5 * pbw, y = screenHeight - 1.5 * pbh}, 
									{x = 1.5 * pbw, y = 0.75 * pbh}, 
									{x = 2 * pbw, y = pbh}}
		
		if currentGameMode ~= updateSoundboard then
			
			if oldMenuPage ~= mainMenu and 
				oldMenuPage ~= episodeSelectionPage and
				dontStopMusic ~= true then			
				_G.res.stopAllAudio()
			end
			if _G.res.isAudioPlaying(currentMainMenuSong) == false then
				_G.res.playAudio(currentMainMenuSong, 0.8, true, 7)
			end
		
		end
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		-- set puzzled bird and back button position
		
		page.items[1].x, page.items[1].y = screenWidth, screenHeight
		getItemByName(page.items, "back").x, getItemByName(page.items, "back").y = 0, screenHeight
		
		-- set golden egg positions
		
		for i = 0, page.levelCount - 1 do
			page.items[page.firstLevelIndex + i].x, page.items[page.firstLevelIndex + i].y = goldenEggPositions[i+1].x, goldenEggPositions[i+1].y
			page.items[page.firstLevelIndex + i].relativeX = goldenEggPositions[i+1].x
			page.items[page.firstLevelIndex + i].selectable = false
			if i < 7 then
				page.items[page.firstLevelIndex + i].children[1].x, page.items[page.firstLevelIndex + i].children[1].y = screenWidth / 2 - goldenEggPositions[i+1].x, screenHeight / 2 - goldenEggPositions[i+1].y
			end
			
			-- set stars positions
			page.items[page.firstLevelIndex + page.levelCount + i].x = goldenEggPositions[i+1].x
			page.items[page.firstLevelIndex + page.levelCount + i].y = goldenEggPositions[i+1].y
			page.items[page.firstLevelIndex + page.levelCount + i].relativeX = goldenEggPositions[i+1].x	
		end
		
		if settings.openGoldenEggLevels["Level1"] ~= nil or highscores[goldenEggLevelMapping["Level1"]] ~= nil then
			page.items[page.firstLevelIndex].sprite = "GOLDEN_EGG_3"
			page.items[page.firstLevelIndex].disableSelection = false
			page.items[page.firstLevelIndex].updateFunction = updateGame
		else
			page.items[page.firstLevelIndex].sprite = "EGG_SILHOUETTE_2"
			page.items[page.firstLevelIndex].disableSelection = true
			page.items[page.firstLevelIndex].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level2"] ~= nil or highscores[goldenEggLevelMapping["Level2"]] ~= nil then
			page.items[page.firstLevelIndex + 1].sprite = "GOLDEN_EGG_2"
			page.items[page.firstLevelIndex + 1].disableSelection = false
			page.items[page.firstLevelIndex + 1].updateFunction = updateGame
		else
			page.items[page.firstLevelIndex + 1].sprite = "EGG_SILHOUETTE_4"
			page.items[page.firstLevelIndex + 1].disableSelection = true
			page.items[page.firstLevelIndex + 1].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level3"] ~= nil or highscores[goldenEggLevelMapping["Level3"]] ~= nil then
			page.items[page.firstLevelIndex + 2].sprite = "GOLDEN_EGG_1"
			page.items[page.firstLevelIndex + 2].disableSelection = false
			page.items[page.firstLevelIndex + 2].updateFunction = updateGame
		else
			page.items[page.firstLevelIndex + 2].sprite = "EGG_SILHOUETTE_1"
			page.items[page.firstLevelIndex + 2].disableSelection = true
			page.items[page.firstLevelIndex + 2].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level4"] ~= nil or highscores[goldenEggLevelMapping["Level4"]] ~= nil then
			page.items[page.firstLevelIndex + 3].sprite = "GOLDEN_EGG_5"
			page.items[page.firstLevelIndex + 3].disableSelection = false
			page.items[page.firstLevelIndex + 3].updateFunction = updateSoundboard
		else
			page.items[page.firstLevelIndex + 3].sprite = "EGG_SILHOUETTE_3"
			page.items[page.firstLevelIndex + 3].disableSelection = true
			page.items[page.firstLevelIndex + 3].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level5"] ~= nil or highscores[goldenEggLevelMapping["Level5"]] ~= nil then
			if not(highscores[goldenEggLevelMapping["Level5"]]) and settings.openGoldenEggLevels["Level5"] == 0 then
				settings.openGoldenEggLevels["Level5"] = 0
			end
			
			page.items[page.firstLevelIndex + 4].sprite = "GOLDEN_EGG_3"
			page.items[page.firstLevelIndex + 4].disableSelection = false
			page.items[page.firstLevelIndex + 4].updateFunction = updateGame
		else
			page.items[page.firstLevelIndex + 4].sprite = "EGG_SILHOUETTE_5"
			page.items[page.firstLevelIndex + 4].disableSelection = true
			page.items[page.firstLevelIndex + 4].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level6"] ~= nil or highscores[goldenEggLevelMapping["Level6"]] ~= nil then
			if not(highscores[goldenEggLevelMapping["Level6"]]) and settings.openGoldenEggLevels["Level6"] == 0 then
				settings.openGoldenEggLevels["Level6"] = 0
			end
			
			page.items[page.firstLevelIndex + 5].sprite = "GOLDEN_EGG_2"
			page.items[page.firstLevelIndex + 5].disableSelection = false
			page.items[page.firstLevelIndex + 5].updateFunction = updateGame
		else
			page.items[page.firstLevelIndex + 5].sprite = "EGG_SILHOUETTE_7"
			page.items[page.firstLevelIndex + 5].disableSelection = true
			page.items[page.firstLevelIndex + 5].updateFunction = nil
		end
		if settings.openGoldenEggLevels["Level7"] ~= nil or highscores[goldenEggLevelMapping["Level7"]] ~= nil then
			page.items[page.firstLevelIndex + 6].sprite = "GOLDEN_EGG_4"
			page.items[page.firstLevelIndex + 6].disableSelection = false
			page.items[page.firstLevelIndex + 6].updateFunction = updateSoundboard
		else
			page.items[page.firstLevelIndex + 6].sprite = "EGG_SILHOUETTE_6"
			page.items[page.firstLevelIndex + 6].disableSelection = true
			page.items[page.firstLevelIndex + 6].updateFunction = nil
		end
		
		page.items[page.firstLevelIndex + 7].visible = settings.openGoldenEggLevels["Level8"] ~= nil or highscores[goldenEggLevelMapping["Level8"]] ~= nil
		page.items[page.firstLevelIndex + 8].visible = settings.openGoldenEggLevels["Level9"] ~= nil or highscores[goldenEggLevelMapping["Level9"]] ~= nil
		page.items[page.firstLevelIndex + 9].visible = settings.openGoldenEggLevels["Level10"] ~= nil or highscores[goldenEggLevelMapping["Level10"]] ~= nil
		page.items[page.firstLevelIndex + 10].visible = settings.openGoldenEggLevels["Level11"] ~= nil or highscores[goldenEggLevelMapping["Level11"]] ~= nil
		page.items[page.firstLevelIndex + 11].visible = settings.openGoldenEggLevels["Level12"] ~= nil or highscores[goldenEggLevelMapping["Level12"]] ~= nil
		page.items[page.firstLevelIndex + 12].visible = settings.openGoldenEggLevels["Level13"] ~= nil or highscores[goldenEggLevelMapping["Level13"]] ~= nil
		page.items[page.firstLevelIndex + 13].visible = settings.openGoldenEggLevels["Level14"] ~= nil or highscores[goldenEggLevelMapping["Level14"]] ~= nil
		page.items[page.firstLevelIndex + 14].visible = settings.openGoldenEggLevels["Level15"] ~= nil or highscores[goldenEggLevelMapping["Level15"]] ~= nil
		page.items[page.firstLevelIndex + 15].visible = settings.openGoldenEggLevels["Level16"] ~= nil or highscores[goldenEggLevelMapping["Level16"]] ~= nil
		page.items[page.firstLevelIndex + 16].visible = settings.openGoldenEggLevels["Level17"] ~= nil or highscores[goldenEggLevelMapping["Level17"]] ~= nil
		page.items[page.firstLevelIndex + 17].visible = settings.openGoldenEggLevels["Level18"] ~= nil or highscores[goldenEggLevelMapping["Level18"]] ~= nil
		page.items[page.firstLevelIndex + 18].visible = settings.openGoldenEggLevels["Level19"] ~= nil or highscores[goldenEggLevelMapping["Level19"]] ~= nil
		page.items[page.firstLevelIndex + 19].visible = settings.openGoldenEggLevels["Level20"] ~= nil or highscores[goldenEggLevelMapping["Level20"]] ~= nil
		page.items[page.firstLevelIndex + 20].visible = settings.openGoldenEggLevels["Level21"] ~= nil or highscores[goldenEggLevelMapping["Level21"]] ~= nil
		page.items[page.firstLevelIndex + 21].visible = settings.openGoldenEggLevels["Level22"] ~= nil or highscores[goldenEggLevelMapping["Level22"]] ~= nil
		page.items[page.firstLevelIndex + 22].visible = settings.openGoldenEggLevels["Level23"] ~= nil or highscores[goldenEggLevelMapping["Level23"]] ~= nil
		page.items[page.firstLevelIndex + 23].visible = settings.openGoldenEggLevels["Level24"] ~= nil or highscores[goldenEggLevelMapping["Level24"]] ~= nil
		page.items[page.firstLevelIndex + 24].visible = settings.openGoldenEggLevels["Level25"] ~= nil or highscores[goldenEggLevelMapping["Level25"]] ~= nil
		page.items[page.firstLevelIndex + 25].visible = settings.openGoldenEggLevels["Level26"] ~= nil or highscores[goldenEggLevelMapping["Level26"]] ~= nil
		
		-- stars on eggs
		
		for i = 1, page.levelCount do
			page.items[page.firstLevelIndex + page.levelCount + i - 1].visible = settings.openGoldenEggLevels["Level" .. i] == 2
			if highscores[goldenEggLevelMapping[i]] ~= nil and highscores[goldenEggLevelMapping[i]].completed then
	
				page.items[page.firstLevelIndex + page.levelCount + i - 1].visible = true
			end
		end
				
		local tipItem = getItemByName(page.items, "tipBubble")
		tipItem.visible = false
		tipItem.x, tipItem.y = tipBubblePositions[1].x, tipBubblePositions[1].y
		tipItem.children[1].x, tipItem.children[1].y = tipBubblePositions[2].x, tipBubblePositions[2].y
		tipItem.children[2].x, tipItem.children[2].y = tipBubblePositions[3].x, tipBubblePositions[3].y
		
		local tipContent = getItemByName(page.items, "tipContent")
		tipContent.x, tipContent.y, tipContent.visible = tipBubblePositions[1].x, tipBubblePositions[1].y, false
		
		if bingIsEnabled == true then
			local bingButton = getItemByName(page.items, "bingButton")
			bingButton.x, bingButton.y, bingButton.relativeX  = 0, 0.2 * screenHeight, screenWidth * 1.75
		end
		if settings.threeStars  == true then
			goldenEggAchieved("Level4")
		end
		
		if settings.threeStarsLP2 == true then
			goldenEggAchieved("Level7")
		end
		
		if settings.threeStarsLP3 == true then
			goldenEggAchieved("Level12")
		end
		
		if settings.threeStarsLP4 == true then
			goldenEggAchieved("Level17")
		end
		
		if settings.threeStarsLP5 == true then
			goldenEggAchieved("Level21")
		end

		if settings.threeStarsLP6 == true then
			goldenEggAchieved("Level25")
		end

		
		getItemByName(page.items, "overlay").shade = 0
		getItemByName(page.items, "overlay").visible = false
		
		if not isLiteVersion and (levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0) then
			
			if not isGEPage2Unlocked() then
				page.items[2].visible = page.currentPage == 1
				page.items[2].x, page.items[2].y = screenWidth / 2 , screenHeight - textY
				page.items[4].sprite = "LS_DOT_WHITE"
				page.items[4].x, page.items[4].y = (screenWidth / 2), screenHeight - lsDotY
				page.items[4].visible = true
				page.items[5].visible = false
			else
				page.items[2].visible = page.currentPage == 1
				page.items[2].x, page.items[2].y = screenWidth / 2 - (lsDotSpacing / 2), screenHeight -  textY
				page.items[3].visible = page.currentPage == 2
				page.items[3].x, page.items[3].y = screenWidth / 2 + (lsDotSpacing / 2), screenHeight - textY
				page.items[4].sprite = "LS_DOT_BLACK"
				page.items[4].x, page.items[4].y = (screenWidth / 2) - (lsDotSpacing / 2), screenHeight - lsDotY
				page.items[5].sprite = "LS_DOT_BLACK"
				page.items[5].x, page.items[5].y = (screenWidth / 2) +  (lsDotSpacing / 2), screenHeight - lsDotY
				page.items[3 + page.currentPage].sprite = "LS_DOT_WHITE"
				page.items[4].visible = true
				page.items[5].visible = true
			end
		end
		page.currentOffset = page.targetOffset
	end
	
	if page == levelSelectionPagesPack3 then
	
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesPack3.firstLevelIndex, #levelSelectionPagesPack3.items do
			levelSelectionPagesPack3.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.pack3 = page.currentPage
			
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		local textY = 0.03 * screenHeight + 12
		local yDividerMultiplier = 1.16
		
	
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		back.x, back.y = 0, screenHeight
		
		local text6 = getItemByName(page.items, "text_6")
		text6.x, text6.y = screenWidth / 2 - lsDotSpacing, screenHeight - textY
		local text7 = getItemByName(page.items, "text_7")
		text7.x, text7.y = screenWidth / 2, screenHeight - textY
		local text8 = getItemByName(page.items, "text_8")
		text8.x, text8.y = screenWidth / 2 + lsDotSpacing, screenHeight - textY
		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = screenWidth / 2 - lsDotSpacing, screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = screenWidth / 2, screenHeight - lsDotY
		local dot3 = getItemByName(page.items, "dot3")
		dot3.x, dot3.y = screenWidth / 2 + lsDotSpacing, screenHeight - lsDotY

		local itemsPerPage = 15
		local itemsPerLine = 5
		local linesPerPage = 3
		local pages = 3
		local contentAreaWidth = screenWidth * 0.74	
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		local offset = 0
		for k = 0, pages - 1 do
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				local tempX = offset + contentAreaStart + (indexInLine - 1) * contentItemStep + levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX =  offset + tempX - levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = screenHeight * yDivider + ySpaceAdd
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX + levelSelectionPagesBasic.currentOffset
			end	
			if k == pages - 1 then
				local goldenEgg = getItemByName(page.items, "goldenEgg")
				goldenEgg.x = offset * 2 + screenWidth + 170 + levelSelectionPagesPack3.currentOffset
				goldenEgg.relativeX = offset * 2 + screenWidth + 170
				goldenEgg.y = screenHeight / 2
			end
			offset = offset + screenWidth / 2
		end
		
		
		for i = 1, #page.items do
			if page.items[i].levelIndex ~= nil then
				themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
				if settings.lastOpenLevelLP3 >= page.items[i].levelIndex or highscores[page.items[i].filename] ~= nil then
					page.items[i].text = "" .. page.items[i].pageLevelIndex
					page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_" .. page.themes[themeIndex]
					page.items[i].selectable = true
				else
					page.items[i].text = nil
					page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					page.items[i].selectable = false
				end
			end
		end
				
		if levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0 then	
			getItemByName(page.items, "text_6").visible = page.currentPage == 1
			getItemByName(page.items, "text_7").visible = page.currentPage == 2
			getItemByName(page.items, "text_8").visible = page.currentPage == 3
	
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot3").sprite = "LS_DOT_BLACK"
			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true
			getItemByName(page.items, "dot3").visible = true
			
		end
		
		if oldMenuPage ~= mainMenu and 
			oldMenuPage ~= episodeSelectionPage and
			dontStopMusic ~= true then			
			_G.res.stopAllAudio()
		end
		if _G.res.isAudioPlaying(currentMainMenuSong) == false then
			_G.res.playAudio(currentMainMenuSong, 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
		getItemByName(page.items, "goldenEgg").visible = settings.openGoldenEggLevels["Level11"] == nil
	
	end
	
	if page == levelSelectionPagesPack4 then
	
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesPack4.firstLevelIndex, #levelSelectionPagesPack4.items do
			levelSelectionPagesPack4.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.pack4 = page.currentPage
		
		
		
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		local textY = 0.03 * screenHeight + 12
		local yDividerMultiplier = 1.16
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		back.x, back.y = 0, screenHeight
		
		local text9 = getItemByName(page.items, "text_9")
		text9.x, text9.y = screenWidth / 2 - lsDotSpacing, screenHeight - textY
		local text10 = getItemByName(page.items, "text_10")
		text10.x, text10.y = screenWidth / 2, screenHeight - textY
		local text11 = getItemByName(page.items, "text_11")
		text11.x, text11.y = screenWidth / 2 + lsDotSpacing, screenHeight - textY
		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = screenWidth / 2 - lsDotSpacing, screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = screenWidth / 2, screenHeight - lsDotY
		local dot3 = getItemByName(page.items, "dot3")
		dot3.x, dot3.y = screenWidth / 2 + lsDotSpacing, screenHeight - lsDotY
		
		local itemsPerPage = 15
		local itemsPerLine = 5
		local linesPerPage = 3
		local pages = 3
		local contentAreaWidth = screenWidth * 0.74
			
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		local offset = 0
		for k = 0, pages - 1 do
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				local tempX = offset + contentAreaStart + (indexInLine - 1) * contentItemStep + levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX =  offset + tempX - levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = screenHeight * yDivider + ySpaceAdd
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX + levelSelectionPagesBasic.currentOffset
			end	
			offset = offset + screenWidth / 2
		end
		
		for i = 1, #page.items do
			if page.items[i].levelIndex ~= nil then
				themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
				if settings.lastOpenLevelLP4 >= page.items[i].levelIndex or highscores[page.items[i].filename] ~= nil then
					page.items[i].text = "" .. page.items[i].pageLevelIndex
					if themeIndex == 1 then
						page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_6" 
					elseif themeIndex == 2 then
						page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_5" 
					else
						page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_2"
					end
					page.items[i].selectable = true
				else
					page.items[i].text = nil
					page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					page.items[i].selectable = false
				end
			end
		end
				
		if levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0 then
			getItemByName(page.items, "text_9").visible = page.currentPage == 1
			getItemByName(page.items, "text_10").visible = page.currentPage == 2
			getItemByName(page.items, "text_11").visible = page.currentPage == 3
	
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot3").sprite = "LS_DOT_BLACK"
			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true
			getItemByName(page.items, "dot3").visible = true
		end
		
		if oldMenuPage ~= mainMenu and 
			oldMenuPage ~= episodeSelectionPage and
			dontStopMusic ~= true then
			_G.res.stopAllAudio()
		end
		if _G.res.isAudioPlaying(currentMainMenuSong) == false then
			_G.res.playAudio(currentMainMenuSong, 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
	end
	
	if page == levelSelectionPagesPack5 then
	
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesPack5.firstLevelIndex, #levelSelectionPagesPack5.items do
			levelSelectionPagesPack5.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.pack5 = page.currentPage
		
		
		
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		local textY = 0.03 * screenHeight + 12
		local yDividerMultiplier = 1.16
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		back.x, back.y = 0, screenHeight
		
		local text12 = getItemByName(page.items, "text_12")
		text12.x, text12.y = screenWidth / 2 - 1.5 * lsDotSpacing, screenHeight - textY
		local text13 = getItemByName(page.items, "text_13")
		text13.x, text13.y = screenWidth / 2 - 0.5 * lsDotSpacing, screenHeight - textY
		local text14 = getItemByName(page.items, "text_14")
		text14.x, text14.y = screenWidth / 2 + 0.5 * lsDotSpacing, screenHeight - textY
		local text14B = getItemByName(page.items, "text_14B")
		text14B.x, text14B.y = screenWidth / 2 + 1.5 * lsDotSpacing, screenHeight - textY
		
		if applyChinaRestictions then
			print("wtf")
			text12.x, text13.x, text14.x = screenWidth / 2 - lsDotSpacing, screenWidth / 2, screenWidth / 2 + lsDotSpacing
		end
		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = text12.x , screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = text13.x , screenHeight - lsDotY
		local dot3 = getItemByName(page.items, "dot3")
		dot3.x, dot3.y = text14.x , screenHeight - lsDotY
		local dot4 = getItemByName(page.items, "dot4")
		dot4.x, dot4.y = text14B.x , screenHeight - lsDotY
		
		
		local itemsPerPage = 15
		local itemsPerLine = 5
		local linesPerPage = 3
		local pages = 4
		local contentAreaWidth = screenWidth * 0.74
			
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		local offset = 0
		for k = 0, pages - 2 do
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				local tempX = offset + contentAreaStart + (indexInLine - 1) * contentItemStep + levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX =  offset + tempX - levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = screenHeight * yDivider + ySpaceAdd
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX + levelSelectionPagesBasic.currentOffset
			end	
			offset = offset + screenWidth / 2
		end
		
		if not applyChinaRestictions then
			for i = 1, 3 do
				local fbButton = getItemByName(page.items, "fbButton")
				local fbW, fbH = _G.res.getSpriteBounds("", fbButton.sprite)
				fbButton.x, fbButton.y, fbButton.relativeX = 0, screenHeight / 2.75, screenWidth * 3.5
				
				local elW, elH = _G.res.getSpriteBounds("", getItemByName(page.items, "extraLevel1").sprite)
				
				for i = 1, 3 do
					getItemByName(page.items, "extraLevel"..i).x = screenWidth * 3.5
					getItemByName(page.items, "extraLevel"..i).y = fbButton.y + fbH / 2.28 + elH / 2
				end	
				
				getItemByName(page.items, "extraLevel1").relativeX =  screenWidth * 3.5 - 1.5 * elW
				getItemByName(page.items, "extraLevel2").relativeX =  screenWidth * 3.5
				getItemByName(page.items, "extraLevel3").relativeX =  screenWidth * 3.5 + 1.5 * elW

				if settings.fbPageLiked == nil then
					for i = 1, 3 do
						getItemByName(page.items, "extraLevel"..i).text = nil
						getItemByName(page.items, "extraLevel"..i).sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
						getItemByName(page.items, "extraLevel"..i).callFunction = showFBLikePopup
						getItemByName(page.items, "extraLevel"..i).updateFunction = nil
					end
				else
					for i = 1, 3 do
						getItemByName(page.items, "extraLevel"..i).text = "" .. getItemByName(page.items, "extraLevel"..i).pageLevelIndex - 15
						getItemByName(page.items, "extraLevel"..i).sprite = "LS_LEVEL_BG_NORMAL_OPEN_5"
						getItemByName(page.items, "extraLevel"..i).callFunction = nil
						getItemByName(page.items, "extraLevel"..i).updateFunction = updateGame
					end
				end
			end
		end
		
		for i = 1, #page.items do
			if page.items[i].levelIndex ~= nil and page.items[i].name == nil then
				themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
				if settings.lastOpenLevelLP5 >= page.items[i].levelIndex or highscores[page.items[i].filename] ~= nil then
					page.items[i].selectable = true
					if themeIndex == 1 then
						page.items[i].text = "" .. page.items[i].pageLevelIndex
						page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_7" 
					elseif themeIndex == 2 then
						if LP5_PAGE2_LOCKED == true then
							page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
							page.items[i].folder = nil
							page.items[i].filename = nil
							page.items[i].text = nil
							page.items[i].selectable = false
						else
							page.items[i].text = "" .. page.items[i].pageLevelIndex
							page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_8" 
						end
					elseif themeIndex == 3 then
						if LP5_PAGE3_LOCKED == true then
							page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
							page.items[i].folder = nil
							page.items[i].filename = nil
							page.items[i].text = nil
							page.items[i].selectable = false
						else
							page.items[i].text = "" .. page.items[i].pageLevelIndex
							page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_3" 
						end
					end
				else
					page.items[i].text = nil
					if page.items[i].sprite ~= "LS_COMING_SOON" then
						page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					end
					page.items[i].selectable = false
				end
			end
		end
		
		--getItemByName(page.items, "comingSoon2").x, getItemByName(page.items, "comingSoon2").y, getItemByName(page.items, "comingSoon2").relativeX = 0, screenHeight / 2, screenWidth * 1.5
		--getItemByName(page.items, "comingSoon3").x, getItemByName(page.items, "comingSoon3").y, getItemByName(page.items, "comingSoon3").relativeX = 0, screenHeight / 2, screenWidth * 2.5
		--getItemByName(page.items, "comingSoon2").sprite, getItemByName(page.items, "comingSoon3").sprite = "LS_COMING_SOON", "LS_COMING_SOON"
		--[[
		if LP5_PAGE2_LOCKED == true then
			getItemByName(page.items, "comingSoon2").visible = true
		else
			getItemByName(page.items, "comingSoon2").visible = false
		end
		
		if LP5_PAGE3_LOCKED == true then
			getItemByName(page.items, "comingSoon3").visible = true
		else
			getItemByName(page.items, "comingSoon3").visible = false
		end]]
		
		
		if levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0 then
			getItemByName(page.items, "text_12").visible = page.currentPage == 1
			getItemByName(page.items, "text_13").visible = page.currentPage == 2
			getItemByName(page.items, "text_14").visible = page.currentPage == 3
			getItemByName(page.items, "text_14B").visible = page.currentPage == 4
	
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true
			getItemByName(page.items, "dot3").visible = true
			getItemByName(page.items, "dot4").visible = true
			
			if applyChinaRestictions then
				getItemByName(page.items, "dot4").visible = false
			end
		end
		
		if oldMenuPage ~= mainMenu and 
			oldMenuPage ~= episodeSelectionPage and
			dontStopMusic ~= true then			
			_G.res.stopAllAudio()
		end
		if _G.res.isAudioPlaying(currentMainMenuSong) == false then
			_G.res.playAudio(currentMainMenuSong, 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
	end
	--ADDED
	if page == levelSelectionPagesPack6 then
	
		levelRestartedFrom = nil
		levelSelectionDragSpeed = nil
		
		page.bgColor = { red = page.bgColors[page.currentPage].red, green = page.bgColors[page.currentPage].green, blue = page.bgColors[page.currentPage].blue}
		
		levelSelectionPagesPressed = false
		for i = levelSelectionPagesPack6.firstLevelIndex, #levelSelectionPagesPack6.items do
			levelSelectionPagesPack6.items[i].disableSelection = true
		end
		
		settings.currentLevelSelectionPages.pack6 = page.currentPage
		
		
		
		local ySpaceAdd = -0.08 * screenHeight
		local lsDotSpacing = 15
		local lsDotY = 10
		local textY = 0.03 * screenHeight + 12
		local yDividerMultiplier = 1.16
		
		local left = getItemByName(page.items, "left")
		left.x, left.y = 0, screenHeight
		local right = getItemByName(page.items, "right")
		right.x, right.y = screenWidth, screenHeight
		
		local back = getItemByName(page.items, "back")
		back.x, back.y = 0, screenHeight
		
		local text15 = getItemByName(page.items, "text_15")
		text15.x, text15.y = screenWidth / 2 - lsDotSpacing, screenHeight - textY
		local text16 = getItemByName(page.items, "text_16")
		text16.x, text16.y = screenWidth / 2, screenHeight - textY
		local text17 = getItemByName(page.items, "text_17")
		text17.x, text17.y = screenWidth / 2 + lsDotSpacing, screenHeight - textY
		
		local dot1 = getItemByName(page.items, "dot1")
		dot1.x, dot1.y = screenWidth / 2 - lsDotSpacing, screenHeight - lsDotY
		local dot2 = getItemByName(page.items, "dot2")
		dot2.x, dot2.y = screenWidth / 2, screenHeight - lsDotY
		local dot3 = getItemByName(page.items, "dot3")
		dot3.x, dot3.y = screenWidth / 2 + lsDotSpacing, screenHeight - lsDotY
		
		local itemsPerPage = 15
		local itemsPerLine = 5
		local linesPerPage = 3
		
		local pages = 3
		
		local contentAreaWidth = screenWidth * 0.74
			
		local contentAreaStart = (screenWidth / 2) - (contentAreaWidth / 2)
		local contentItemStep = 0
		if itemsPerLine > 1 then
			contentItemStep = contentAreaWidth / (itemsPerLine-1)
		end
		
		local offset = 0
		for k = 0, pages - 1 do
			for i = 1, itemsPerPage do
				local line = _G.math.ceil(i / itemsPerLine)
				local indexInLine = _G.math.fmod((i - 1), itemsPerLine) + 1
				local yDivider = line / (linesPerPage + 2) * yDividerMultiplier
				local tempX = offset + contentAreaStart + (indexInLine - 1) * contentItemStep + levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX =  offset + tempX - levelSelectionPagesBasic.currentOffset
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].y = screenHeight * yDivider + ySpaceAdd
				page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].x = page.items[page.firstLevelIndex - 1 + i + k * itemsPerPage].relativeX + levelSelectionPagesBasic.currentOffset
			end	
			offset = offset + screenWidth / 2
		end
		
		for i = 1, #page.items do
			if page.items[i].levelIndex ~= nil then
				themeIndex = _G.math.ceil(page.items[i].levelIndex / page.levelsPerPage)
				if settings.lastOpenLevelLP6 >= page.items[i].levelIndex or highscores[page.items[i].filename] ~= nil then
	
					page.items[i].selectable = true
					
					if themeIndex == 1 then
						page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_6" 
						page.items[i].text = "" .. page.items[i].pageLevelIndex
					elseif themeIndex == 2 then
						if(LP6_PAGE2_LOCKED ~= true) then
							page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_5" 
							page.items[i].text = "" .. page.items[i].pageLevelIndex						
						else
						
							setLevelButtonLocked(page, i)
						end
					else
						if(LP6_PAGE3_LOCKED ~= true) then
							page.items[i].sprite = "LS_LEVEL_BG_NORMAL_OPEN_2"
							page.items[i].text = "" .. page.items[i].pageLevelIndex
						else
							setLevelButtonLocked(page, i)							
						end
							
					end
				else
					page.items[i].text = nil
					page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
					page.items[i].selectable = false
				end
			end
		end
		
		if(LP6_PAGE2_LOCKED == true) then
			getItemByName(page.items, "comingSoon2").sprite = "LS_COMING_SOON"		
			getItemByName(page.items, "comingSoon2").x, getItemByName(page.items, "comingSoon2").y, getItemByName(page.items, "comingSoon2").relativeX = 0, screenHeight / 2, screenWidth * 1.5
		end
		
		if(LP6_PAGE3_LOCKED == true) then
			getItemByName(page.items, "comingSoon3").x, getItemByName(page.items, "comingSoon3").y, getItemByName(page.items, "comingSoon3").relativeX = 0, screenHeight / 2, screenWidth * 2.5
			getItemByName(page.items, "comingSoon3").sprite =  "LS_COMING_SOON"						
		
		end

		
		if levelSelectionScrollStartTimer == nil or levelSelectionScrollStartTimer <= 0 then
			getItemByName(page.items, "text_15").visible = page.currentPage == 1
			getItemByName(page.items, "text_16").visible = page.currentPage == 2
			getItemByName(page.items, "text_17").visible = page.currentPage == 3
	
			local dot1, dot1Index = getItemByName(page.items, "dot1") 
			dot1.sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot2").sprite = "LS_DOT_BLACK"
			getItemByName(page.items, "dot3").sprite = "LS_DOT_BLACK"
			page.items[dot1Index - 1 + page.currentPage].sprite = "LS_DOT_WHITE"
			getItemByName(page.items, "dot1").visible = true
			getItemByName(page.items, "dot2").visible = true
			getItemByName(page.items, "dot3").visible = true
		end
		
		if oldMenuPage ~= mainMenu and 
			oldMenuPage ~= episodeSelectionPage and
			dontStopMusic ~= true then
			_G.res.stopAllAudio()
		end
		if _G.res.isAudioPlaying(currentMainMenuSong) == false then
			_G.res.playAudio(currentMainMenuSong, 0.8, true, 7)
		end
		
		page.currentOffset = page.targetOffset
		
	end	
	
	
	--prepare levelselectionpages for faster drawing																																				-- ADDED
	if page == levelSelectionPagesBasic or page == levelSelectionPagesExtra or page == levelSelectionPagesPack3 or page == levelSelectionPagesPack4 or page == levelSelectionPagesPack5 or page == levelSelectionPagesPack6 then
		levelSelectionButtonIndeces = {}
		for k, v in _G.pairs(page.items) do
			if v.filename then
				local eagle = false
				for k2, v2 in _G.pairs(settings.eaglesUsedIn) do
					if v2.world == v.worldNumber and v2.level == v.pageLevelIndex then
						eagle = true
					end
				end
				_G.table.insert(levelSelectionButtonIndeces, {index = k, stars = 0, eagleUsed = eagle })
			end
		end
				
		for i = 1, #levelSelectionButtonIndeces do
			local ci = page.items[levelSelectionButtonIndeces[i].index]
			if highscores[ci.filename] ~= nil then
				if highscores[ci.filename].score > 0 then
					levelSelectionButtonIndeces[i].starSprite = "LS_STARS_1"
				end
				if starTable[ci.filename] ~= nil then
					if highscores[ci.filename].score >= starTable[ci.filename].silverScore then
						levelSelectionButtonIndeces[i].starSprite = "LS_STARS_2"
					end
					if highscores[ci.filename].score >= starTable[ci.filename].goldScore then
						levelSelectionButtonIndeces[i].starSprite = "LS_STARS_3"
					end
					
					--[[
					local eagleScore = nil
					
					if(highscores[ci.filename] ~= nil) then
						eagleScore = highscores[ci.filename].eagleScore-- or highscores[ci.filename].trialEagleScore
					end
					]]
					
					--if settings.mightyEagleEnabled == true and eagleScore ~= nil and 
					if getEagleScore(ci.filename) >= 100 then
						levelSelectionButtonIndeces[i].featherSprite = "LS_EAGLE_FEATHER"
					else
						levelSelectionButtonIndeces[i].featherSprite = nil
					end
				end
			end
		end		
	end
	
	if page == upsellPage then
		if deviceModel == "n900" then
		
		elseif deviceModel == "s60" then
		
		else
			local backgroundWidth, backgroundHeight = _G.res.getSpriteBounds("", "UPSELL_BG")
			page.backgroundSprite.x, page.backgroundSprite.y = 0, 0
				
			if screenHeight ~= backgroundHeight then
				page.backgroundSprite.scale = true
				page.backgroundSprite.ys = screenHeight / backgroundHeight
				page.backgroundSprite.xs = screenHeight / backgroundHeight
				local newWidth = backgroundWidth * page.backgroundSprite.xs
				if newWidth < screenWidth then
					page.backgroundSprite.x = (screenWidth - newWidth) / 2
				else
					page.backgroundSprite.ys = screenWidth / backgroundWidth
					page.backgroundSprite.xs = screenWidth / backgroundWidth
					local newHeight = backgroundHeight * page.backgroundSprite.ys
					if newHeight < screenHeight then
						page.backgroundSprite.y = (screenHeight - newHeight) / 2
					end
				end
			elseif screenWidth ~= backgroundWidth then
				page.backgroundSprite.x = (screenWidth - backgroundWidth) / 2
			end
			
			local back = getItemByName(page.items, "back")
			back.x, back.y = 0, screenHeight
			
			local button = getItemByName(page.items, "button")
			button.x, button.y = screenWidth * 0.5, screenHeight * 0.5
			
		end
	end
	
	if page == tutorials then
		
		local maxW, maxH = 0, 0
		for i = 1, #tutorials.items do
			local itm = tutorials.items[i]
			itm.x, itm.y = screenWidth / 2, screenHeight / 2
			local x1, y1, x2, y2 = _G.res.getCompoSpriteBounds("", itm.sprite)
			if x2 - x1 > maxW then
				maxW = x2 - x1
			end
			if y2 - y1 > maxH then
				maxH = y2 - y1
			end
		end
		
		local _, borderH = _G.res.getSpriteBounds("", "TUTORIAL_BOTTOM_MIDDLE")
		local borderW, _ = _G.res.getSpriteBounds("", "TUTORIAL_LEFT")
		page.backgroundBox.x, page.backgroundBox.y = _G.math.floor(screenWidth / 2), _G.math.floor(screenHeight / 2)
		page.backgroundBox.width, page.backgroundBox.height = _G.math.floor(maxW - (borderW * 1.5)), _G.math.floor(maxH - (borderH * 1.5))
		local sw, sh = _G.res.getSpriteBounds("", "TUTORIAL_OK")
		local gew, geh = _G.res.getSpriteBounds("", "GOLDEN_EGG_1")
		page.okButtonX, page.okButtonY = page.backgroundBox.x + page.backgroundBox.width / 2 - sw / 3, _G.math.floor(page.backgroundBox.y + page.backgroundBox.height / 2 + borderH * 0.7)
		tutorialGoldenEggPosition.x, tutorialGoldenEggPosition.y = (page.backgroundBox.x + page.backgroundBox.width / 6) * 1.54, (page.backgroundBox.y - page.backgroundBox.height / 7) * 1.54
		tutorialGoldenEggPosition.hitBoxMinX, tutorialGoldenEggPosition.hitBoxMaxX = tutorialGoldenEggPosition.x * 0.65 - gew, tutorialGoldenEggPosition.x * 0.65 + gew
		tutorialGoldenEggPosition.hitBoxMinY, tutorialGoldenEggPosition.hitBoxMaxY = tutorialGoldenEggPosition.y * 0.65 - geh, tutorialGoldenEggPosition.y * 0.65 + geh
	end
	
	if page == gameComplete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_outro", 1, false, 7)
		getItemByName(page.items, "storyEnd1").visible = true
		getItemByName(page.items, "storyEnd2").visible = true
		getItemByName(page.items, "storyEndEyeNormal").visible = true
		page.timer = 2.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		
		page.tuneTimer = 3	
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local _, endStoryHeight = _G.res.getSpriteBounds("", "STORY_END_1_1")
		page.backgroundWidth = getCutsceneBackgroundWidth(page.items)
		local endStoryYPos = (screenHeight - endStoryHeight) / 2
		page.offsetY = endStoryYPos
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
	
		prepareCutScene(page, page.backgroundWidth, endStoryHeight, page.tuneTimer)
		
		setGameOn(true)
	end
	
	if page == theme5Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_outro", 1, false, 7)
		page.items[1].visible = true
		getItemByName(page.items, "storyBg").visible = true
		getItemByName(page.items, "storyBoss").visible = true
		getItemByName(page.items, "storyTongue").visible = true
		getItemByName(page.items, "storyEggs").visible = true
		getItemByName(page.items, "storyKing").visible = true
		getItemByName(page.items, "storyEyeOpen").visible = true
		getItemByName(page.items, "storyEyePeek").visible = false
		getItemByName(page.items, "storyEyeWink").visible = false
		getItemByName(page.items, "storySmile").visible = false
		page.timer = 2.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 1.002	
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local endStoryWidth, endStoryHeight = _G.res.getSpriteBounds("", "STORY_BOSS_BG")
		page.backgroundWidth = endStoryWidth
		local endStoryYPos = (screenHeight - endStoryHeight) / 2
		page.offsetY = endStoryYPos
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
	
		prepareCutScene(page, endStoryWidth, endStoryHeight, page.tuneTimer)
		
		setGameOn(true)
	end
	
		
	if page == gameStart and not resume then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5
		page.tuneTimer = 8.62
		page.offsetX = 0
		page.animationState = "SCROLL"		
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		getItemByName(page.items, "storyBegin1").selectable = true
		getItemByName(page.items, "storyBegin2").selectable = true
	
		local bgStory2Width, _ = _G.res.getSpriteBounds("", "STORY_BEGIN_BG_2")
		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_BG_1")
		local beginStoryYPos = (screenHeight - beginStoryHeight) / 2
		
		page.backgroundWidth = beginStoryWidth + bgStory2Width
		page.offsetY = beginStoryYPos
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
	
		prepareCutScene(page, page.backgroundWidth, beginStoryHeight, page.tuneTimer)
		
		if settings.gameStarted ~= true then
			getItemByName(page.items, "storyBegin1").selectable = false
			getItemByName(page.items, "storyBegin2").selectable = false
		end
		
		setGameOn(true)
	end	
	
	if page == theme1Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_boss", 1, false, 7)
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.dontScroll = false
		page.scale = false
		page.xs, page.ys = 1, 1
		page.tuneTimer = 1.002
		
		local bossStoryWidth, bossStoryHeight = _G.res.getSpriteBounds("", "STORY_BOSS_BG")
		local bossStoryYPos = (screenHeight - bossStoryHeight) / 2
		page.offsetY = bossStoryYPos
		page.backgroundWidth = bossStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, page.backgroundWidth, bossStoryHeight, page.tuneTimer)
		
		setGameOn(true)
		
		if isLiteVersion then
			getItemByName(page.items, "storyBoss").visible = false
		end
	end
	
	if page == theme4Start and not resume then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5
		page.offsetX = 0
		page.tuneTimer = 8.62
		page.animationState = "SCROLL"		
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_BG_1")
		local beginStoryYPos = (screenHeight - beginStoryHeight) / 2
		page.backgroundWidth = getCutsceneBackgroundWidth(page.items)	

		page.offsetY = beginStoryYPos
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
	
		prepareCutScene(page, page.backgroundWidth, beginStoryHeight, page.tuneTimer)
		
		getItemByName(page.items, "storyBg").selectable = true
		getItemByName(page.items, "storyBegin1").selectable = true
		if settings.lp2Started ~= true then
			getItemByName(page.items, "storyBg").selectable = false
			getItemByName(page.items, "storyBegin1").selectable = false
		end
	
		setGameOn(true)
	end	
	
	if page == theme6Start and not resume then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5
		page.offsetY = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 8.62
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		--local fadeStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_FADE")
		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_BG_1")
		local fadeWidth, fadeHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_FADE")
		
		page.scale = true
		page.ys = screenWidth / fadeWidth
		page.xs = page.ys

		--local _, fadeHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_FADE_2")
		
		local _, py = _G.res.getSpritePivot("", "STORY_FLYING_PIGS_1")
		
		
		local beginStoryYPos = (screenHeight - beginStoryHeight * page.ys)
		page.backgroundWidth = beginStoryWidth / 2
		page.backgroundHeight = py
		page.offsetY = beginStoryYPos
		
		theme6Start.maxOffsetY = py * page.ys
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		page.scrollSpeed = ((page.backgroundHeight * page.ys) - beginStoryYPos) / page.tuneTimer
		
		if page.scrollSpeed < 0 then
			page.dontScroll = true
		end
		--print("page.scrollSpeed:"..page.scrollSpeed)
		
		--prepareCutScene(page, page.backgroundWidth, page.backgroundHeight, page.tuneTimer)

		getItemByName(page.items, "storyBg").selectable = true
		if settings.lp3Started ~= true then
			getItemByName(page.items, "storyBg").selectable = false
		end
		setGameOn(true)
	end
	
	if page == theme9Start and not resume then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5 
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 8.62	
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local beginStoryWidth, beginStoryHeight = _G.res.getSpriteBounds("", "STORY_BEGIN_BG_1")
		local beginStoryYPos = (screenHeight - beginStoryHeight) / 2
		page.backgroundWidth = getCutsceneBackgroundWidth(page.items)	
		page.offsetY = beginStoryYPos
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		local sw2, _ = _G.res.getSpriteBounds("", getItemByName(page.items, "bg_extension").sprite)
		prepareCutScene(page, page.backgroundWidth, beginStoryHeight, page.tuneTimer)
		
		if page.backgroundWidth * page.xs <= screenWidth then
			page.dontScroll = true
		else
			page.scrollSpeed = -(screenWidth - page.backgroundWidth * page.xs) / page.tuneTimer
		end
		
		getItemByName(page.items, "storyBg1").selectable = true
		if settings.lp4Started ~= true then
			getItemByName(page.items, "storyBg1").selectable = false
		end
		
		setGameOn(true)
	end	
	
	if page == theme12Start and not resume then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 8.62
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local x1, y1, x2, y2 = _G.res.getCompoSpriteBounds("", getItemByName(page.items, "storyWesternBegin").sprite)
		getItemByName(page.items, "storyWesternBegin").x, getItemByName(page.items, "storyWesternBegin").y = 0 , 0
		
		if y2 ~= screenHeight then
			page.scale = true
			page.xs = screenHeight / y2
			page.ys = screenHeight / y2
			if (x2 * page.xs) < screenWidth then
				getItemByName(page.items, "storyWesternBegin").x = ((screenWidth - (x2 * page.xs)) / 2) 
			end
		end
		

		page.backgroundWidth = x2 * page.xs
		
		
		if page.backgroundWidth <= screenWidth then
			page.dontScroll = true
		else
			page.scrollSpeed = (-(screenWidth - page.backgroundWidth) / page.tuneTimer)
		end
		
	end
	
	if page == theme12Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_boss", 1, false, 7)
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 1.002
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local x1, y1, x2, y2 = _G.res.getCompoSpriteBounds("", getItemByName(page.items, "storyWesternEndOne").sprite)
		getItemByName(page.items, "storyWesternEndOne").x, getItemByName(page.items, "storyWesternEndOne").y = 0 , 0
		
		if y2 ~= screenHeight then
			page.scale = true
			page.xs = screenHeight / y2
			page.ys = screenHeight / y2
			if (x2 * page.xs) < screenWidth then
				getItemByName(page.items, "storyWesternEndOne").x = ((screenWidth - (x2 * page.xs)) / 2) 
			end
		end
		

		page.backgroundWidth = x2 * page.xs
		
		
		if page.backgroundWidth <= screenWidth then
			page.dontScroll = true
		else
			page.scrollSpeed = (-(screenWidth - page.backgroundWidth) / page.tuneTimer)
		end
			
	end
	
	if page == theme13Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_boss", 1, false, 7)
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 1.002
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local x1, y1, x2, y2 = _G.res.getCompoSpriteBounds("", getItemByName(page.items, "storyWesternEndTwo").sprite)
		getItemByName(page.items, "storyWesternEndTwo").x, getItemByName(page.items, "storyWesternEndTwo").y = 0 , 0
		
		if y2 ~= screenHeight then
			page.scale = true
			page.xs = screenHeight / y2
			page.ys = screenHeight / y2
			if (x2 * page.xs) < screenWidth then
				getItemByName(page.items, "storyWesternEndTwo").x = ((screenWidth - (x2 * page.xs)) / 2) 
			end
		end
		

		page.backgroundWidth = x2 * page.xs
		
		
		if page.backgroundWidth <= screenWidth then
			page.dontScroll = true
		else
			page.scrollSpeed = (-(screenWidth - page.backgroundWidth) / page.tuneTimer)
		end
			
	end
	
	if page == theme14Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_outro", 1, false, 7)
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 1.002
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local x1, y1, x2, y2 = _G.res.getCompoSpriteBounds("", getItemByName(page.items, "storyWesternEndFinal").sprite)
		getItemByName(page.items, "storyWesternEndFinal").x, getItemByName(page.items, "storyWesternEndFinal").y = 0 , 0
		
		getItemByName(page.items, "kingEyeOpen").x, getItemByName(page.items, "kingEyeOpen").y = 0 , 0
		getItemByName(page.items, "kingEyePeak").x, getItemByName(page.items, "kingEyePeak").y = 0 , 0
		getItemByName(page.items, "kingEyeBlink").x, getItemByName(page.items, "kingEyeBlink").y = 0 , 0
		getItemByName(page.items, "kingEyeOpen").visible, getItemByName(page.items, "kingEyePeak").visible, getItemByName(page.items, "kingEyeBlink").visible = false, false, false
		
		if y2 ~= screenHeight then
			page.scale = true
			page.xs = screenHeight / y2
			page.ys = screenHeight / y2
			if (x2 * page.xs) < screenWidth then
				getItemByName(page.items, "storyWesternEndFinal").x = ((screenWidth - (x2 * page.xs)) / 2) 
				getItemByName(page.items, "kingEyeOpen").x = getItemByName(page.items, "storyWesternEndFinal").x
				getItemByName(page.items, "kingEyePeak").x = getItemByName(page.items, "storyWesternEndFinal").x
				getItemByName(page.items, "kingEyeBlink").x = getItemByName(page.items, "storyWesternEndFinal").x
			end
		end
	
		page.backgroundWidth = x2 * page.xs
		
		if page.backgroundWidth <= screenWidth then
			page.dontScroll = true
		else
			page.scrollSpeed = (-(screenWidth - page.backgroundWidth) / page.tuneTimer)
		end				
	end
	
	if page == theme15Complete or page == theme16Complete or page == theme17Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_boss", 1, false, 7)
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 1.002
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local pageName = "storyCaveEndOne"
		if(page == theme16Complete) then
			pageName = "storyCaveEndTwo"
		end

		if(page == theme17Complete) then
			pageName = "storyCaveEndThree"
		end
		
		local x1, y1, x2, y2 = _G.res.getCompoSpriteBounds("", getItemByName(page.items, pageName).sprite)
		getItemByName(page.items, pageName).x, getItemByName(page.items, pageName).y = 0 , 0
		
		if y2 ~= screenHeight then
			page.scale = true
			page.xs = screenHeight / y2
			page.ys = screenHeight / y2
			if (x2 * page.xs) < screenWidth then
				getItemByName(page.items, pageName).x = ((screenWidth - (x2 * page.xs)) / 2) 
			end
		end

		page.backgroundWidth = x2 * page.xs
		
		if page.backgroundWidth <= screenWidth then
			page.dontScroll = true
		else
			page.scrollSpeed = (-(screenWidth - page.backgroundWidth) / page.tuneTimer)
		end			
	end
	
	
	
	if page == theme15Start then
		_G.res.stopAllAudio()
		loadCutScenes()
		_G.res.playAudio("birds_intro", 1, false, 7)
		page.timer = 4.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.tuneTimer = 8.62
		page.dontScroll = false
		page.scale = false
		page.xs = 1
		page.ys = 1
		
		local x1, y1, x2, y2 = _G.res.getCompoSpriteBounds("", getItemByName(page.items, "storyCaveBegin").sprite)
		getItemByName(page.items, "storyCaveBegin").x, getItemByName(page.items, "storyCaveBegin").y = 0 , 0
		
		if y2 ~= screenHeight then
			page.scale = true
			page.xs = screenHeight / y2
			page.ys = screenHeight / y2
			if (x2 * page.xs) < screenWidth then
				getItemByName(page.items, "storyCaveBegin").x = ((screenWidth - (x2 * page.xs)) / 2) 
			end
		end

		page.backgroundWidth = x2 * page.xs
		
		if page.backgroundWidth <= screenWidth then
			page.dontScroll = true
		else
			page.scrollSpeed = (-(screenWidth - page.backgroundWidth) / page.tuneTimer)
		end
		
	end
	
	
	if page == theme2Complete or page == theme4Complete or page == theme6Complete 
		or page == theme7Complete or page == theme9Complete or page == theme10Complete
		or page == theme11Complete or page == theme8Complete then
		_G.res.stopAllAudio()
		loadCutScenes()
		if page == theme11Complete or page == theme8Complete then
			_G.res.playAudio("birds_outro", 1, false, 7)
		else
			_G.res.playAudio("birds_boss", 1, false, 7)
		end
		if page == theme11Complete then
			getItemByName(page.items, "storyKingPeak").visible = false
			getItemByName(page.items, "storyKingWink").visible = true
		end
		page.timer = 3.5
		page.offsetX = 0
		page.animationState = "SCROLL"
		page.dontScroll = false
		page.scale = false
		page.xs, page.ys = 1, 1
		page.tuneTimer = 1.002
		
		local bossStoryWidth, bossStoryHeight = _G.res.getSpriteBounds("", "STORY_BOSS_BG")
		local bossStoryYPos = (screenHeight - bossStoryHeight) / 2
		page.offsetY = bossStoryYPos
		page.backgroundWidth = bossStoryWidth
		
		for i = 1, #page.items do
			page.items[i].x, page.items[i].y = 0, 0
		end
		
		prepareCutScene(page, bossStoryWidth, bossStoryHeight, page.tuneTimer)
		
		setGameOn(true)
	end
	
	if page == gameFinished or page == gameFinishedThreeStars or
	   page == gameFinishedLP2 or page == gameFinishedThreeStarsLP2 or 
	   page == gameFinishedLP3 or page == gameFinishedThreeStarsLP3 or
	   page == gameFinishedLP4 or page == gameFinishedThreeStarsLP4 or 
	   page == gameFinishedLP5 or page == gameFinishedThreeStarsLP5 or 
	   page == gameFinishedLP6 or page == gameFinishedThreeStarsLP6 then
		page.items[4].textBoxSize = 0.6 * screenWidth
		if page.items[4].textBoxSize > 395 then
			page.items[4].textBoxSize = 395
		end
		
		local text = page.items[4]
		local text2 = page.items[5]
		prepareTextItem(page, text)
		prepareTextItem(page, text2)
		local textRows = text.h / text2.h
		local borderW, borderH = _G.res.getSpriteBounds("POPUPS_SHEET_1", "POPUP_TOP_MIDDLE")
		local _, borderBottomH = _G.res.getSpriteBounds("POPUPS_SHEET_1", "POPUP_BOTTOM_MIDDLE")
		local _, rewardH = _G.res.getSpriteBounds("", page.items[3].sprite)
		local _, rewardPy = _G.res.getSpritePivot("", page.items[3].sprite)
		local extraRewardSpace = _G.math.floor(_G.math.max(4, (rewardH - rewardPy) - borderH * 0.7)) -- minimum of 4 is hack for font size problems
		local sh, sw = _G.res.getSpriteBounds("", "MENU_YES")
		local _, buttonPy = _G.res.getSpritePivot("", "MENU_YES")
		local extraButtonSpace = _G.math.max(0, buttonPy - borderBottomH * 0.5)  
		
		-- background box
		page.backgroundBox.x, page.backgroundBox.y = screenWidth / 2, screenHeight / 2 + text.h * 0.1
		page.backgroundBox.width, page.backgroundBox.height = page.items[4].textBoxSize, text.h * 0.95 + extraRewardSpace + extraButtonSpace
		-- star effect
		page.items[1].x, page.items[1].y = page.backgroundBox.x + page.backgroundBox.width / 2.5, page.backgroundBox.y - page.backgroundBox.height / 2 - borderH
		-- reward
		page.items[3].x, page.items[3].y = page.backgroundBox.x + page.backgroundBox.width / 2.5, page.backgroundBox.y - page.backgroundBox.height / 2 - borderH 
		-- yes button
		page.items[2].x, page.items[2].y = page.backgroundBox.x + page.items[4].textBoxSize / 2.75, page.backgroundBox.y + page.backgroundBox.height / 2 + borderBottomH * 0.5
		-- texts
		page.items[4].x, page.items[4].y = page.backgroundBox.x - page.items[4].textBoxSize / 2, page.backgroundBox.y - extraButtonSpace * 0.5 - borderH / 4 + extraRewardSpace * 0.5 -- - page.backgroundBox.height / 2 -- + borderH / 2
		
		page.items[5].x, page.items[5].y = page.backgroundBox.x - page.items[4].textBoxSize / 2, page.backgroundBox.y - page.backgroundBox.height / 2 - borderH 

	end
			
	if page == achievementPopUpPage then
		if gameCenterEnabled and gameCenter and gameCenter.achievements then
			local achi = gameCenter.achievements[gameCenter.achievements.showPopUpID]
			local achiText = getItemByName(page.items, "achievementText")
			achiText.text = achi.achievedText or "Earned an achievement."
			local achiTitle = getItemByName(page.items, "achievementTitle")
			achiTitle.text = achi.title or "Achievement Title"
			
			local achiIcon = getItemByName(achievementPopUpPage.items, "achievementIcon")
			
			if achi.icon then
				achiIcon.sprite = achi.icon
			else
				achiIcon.sprite = ""
			end
			
			setFont(achiTitle.font)
			local fh1 = _G.res.getFontHeight()
			local sw1 = _G.res.getStringWidth(achiTitle.text)
			setFont(achiText.font)
			local fh2 = _G.res.getFontHeight()
			local sw2 = _G.res.getStringWidth(achiText.text)
			local sw3, sh3 = _G.res.getSpriteBounds("", "ACHIEVEMENT_BG_RIGHT")
			local sw4, sh4 = _G.res.getSpriteBounds("", achiIcon.sprite)
			local bgBox = getItemByName(page.items, "achievementBox")
			bgBox.width = _G.math.max(sw1, sw2 + sw4) * 1.2
			bgBox.height = sh3
			bgBox.x = screenWidth - sw3
			
			if page.animationTimer == nil then
				page.animationTimer = 2.7
			end
			local bgBox = getItemByName(page.items, "achievementBox")
			local boxOffset = 190
			if deviceModel == "ipad" then
				boxOffset = 280
			end
			if page.animationTimer > 2.4 then
				bgBox.y = screenHeight - boxOffset * (2.7 - page.animationTimer)
			elseif page.animationTimer > 0.4 and page.animationTimer <= 2.4 then
				bgBox.y = screenHeight - boxOffset * 0.3
			elseif page.animationTimer > 0 and page.animationTimer <= 0.4 then
				bgBox.y = screenHeight - boxOffset * (page.animationTimer - 0.1)
			elseif page.animationTimer <= 0 then
				bgBox.y = screenHeight
			end
						
			achiIcon.x, achiIcon.y = -bgBox.width * 0.9, bgBox.height * 0.5
						
			achiTitle.x, achiTitle.y = -bgBox.width * 0.5, bgBox.height * 0.1
			achiText.x, achiText.y = achiIcon.x + sw4, bgBox.height * 0.63
		end
	end
		
	if page == goldenEggAchievedPage then -- or page == mightyEagleAvailablePage then
		_G.res.playAudio("goldenegg", 1, false)
		page.enablePhysicsWhenDone = isPhysicsEnabled()
		setPhysicsEnabled(false)
		page.animationState = "FADEIN"
		page.fadeInLength = 0.8
		page.fadedLength = 1.5
		page.fadeOutLength = 0.8
		page.fullyShaded = 0.75
		page.timer = page.fadeInLength
		page.items[1].angle = 0
		page.items[1].visible = false
		page.items[1].x = screenWidth*0.5
		page.items[1].y = screenHeight*0.5
	end
	
	if page == goldenEggStarAchievedPage then
		page.enablePhysicsWhenDone = isPhysicsEnabled()
		setPhysicsEnabled(false)
		page.animationState = "FADEIN"
		page.fadeInLength = 0.8
		page.fadedLength = 1.5
		page.fadeOutLength = 0.8
		page.fullyShaded = 0.75
		page.timer = page.fadeInLength
		page.items[1].angle = 0
		page.items[1].visible = false
		page.items[1].x = screenWidth*0.5
		page.items[1].y = screenHeight*0.5
	end
	
	if page == boomerangBirdAchievedPage then
		setPhysicsEnabled(false)
		page.animationState = "FADEIN"
		page.fadeInLength = 0.8
		page.fadedLength = 1.5
		page.fadeOutLength = 0.8
		page.fullyShaded = 0.75
		page.timer = page.fadeInLength
		page.items[1].angle = 0
		page.items[1].visible = false
		page.items[1].x = screenWidth*0.5
		page.items[1].y = screenHeight*0.5
	end
	
	-- page specific controls end
	
	if deviceModel == "n900" or deviceModel == "s60" then
		getItemByName(overlayMenuPage.items, "close").x = screenWidth
	elseif deviceModel == "android" and isBetaVersion then
		local betaUp = getItemByName(overlayMenuPage.items, "betaUp")
		betaUp.x, betaUp.y = 0, 0
	end
	
	
	--page.prepared = true
	
	-- prepare all text items
	if page.items ~= nil then
		local i = 1
		while i <= #page.items do
			local ci = page.items[i]
			prepareTextItem(page, ci)
			if ci.children ~= nil then
				for j = 1, #ci.children do
					prepareTextItem(page, ci.children[j])
				end
			end
			i = i + 1
		end
	end
	
	if page == about then
		local textAbout = getItemByName(page.items, "textAbout")
		local k = 1
		-- replace version number
		while k <= #textAbout.lines do
			local beginIndex, endIndex = _G.string.find(textAbout.lines[k], "$GAME_VERSION")
			if beginIndex ~= nil and beginIndex >= 1 then
				local verStr = gameVersionNumber
				if not releaseBuild then
					verStr = verStr .." (".. svnRevisionNumber ..") - ".. customerString
				end
				local s = _G.string.gsub(textAbout.lines[k], "(%$GAME_VERSION)", verStr)
				textAbout.lines[k] = s
			end
			k = k + 1
		end
	end
end

function setLevelButtonLocked(page, i)
	page.items[i].sprite = "LS_LEVEL_BG_NORMAL_CLOSED"
	page.items[i].folder = nil
	page.items[i].filename = nil
	page.items[i].text = nil
	page.items[i].selectable = false						
end


function prepareCutScene(page, backgroundWidth, backgroundHeight, tuneTimer)
	if screenHeight < backgroundHeight then
		page.scale = true
		page.ys = screenHeight / backgroundHeight 
		page.xs = screenHeight / backgroundHeight
		page.offsetY = 0
		local newWidth = backgroundWidth * page.xs
		if newWidth < screenWidth then
			page.offsetX = (screenWidth - newWidth) / 2
		end
	elseif backgroundWidth  < screenWidth then
		page.scale = true
		page.xs = screenWidth / backgroundWidth
		page.ys = screenWidth / backgroundWidth
		page.offsetY = (screenHeight - backgroundHeight * page.ys) / 2
		local newHeight = backgroundHeight * page.ys
		if screenHeight < newHeight then
			page.xs = screenHeight / backgroundHeight
			page.ys = screenHeight / backgroundHeight
			page.offsetY = 0
			local newWidth = backgroundWidth * page.xs
			page.offsetX = (screenWidth - newWidth) / 2
		end
	end
	
	if backgroundWidth * page.xs <= screenWidth then
		page.dontScroll = true
	else
		page.scrollSpeed = -(screenWidth - backgroundWidth * page.xs) / tuneTimer
	end	
end

function createFeatherBox(index, page)
	local epBgBox = getItemByName(page.items, "ep"..index.."BgBox")
	local epFeathersBox = getItemByName(page.items, "ep"..index.."FeathersBox")
	--local episode1 = getItemByName(page.items, "episode1")
	local episode = getItemByName(page.items, "episode"..index)
	local ep1ScoreBox1 = getItemByName(page.items, "ep1ScoreBox1")
	local fh = _G.res.getFontHeight()
	local topPieceW, topPieceH = _G.res.getSpriteBounds("EPISODE1_TOP_MIDDLE")
	local episodeFeatherScore = getItemByName(page.items, "episode"..index.."FeatherScore")
	local scoreFeathers, maxFeathers = getEpisodeFeathers(index)

	epBgBox.width, epBgBox.height = episode.width, episode.height 
	epBgBox.x, epBgBox.y = 0,0
	
	-- episode2.x, episode2.y = (2 - settings.selectedEpisode) * (screenWidth / 2) + screenWidth / 2, screenHeight / 2
	
	------------- Feather box
	---epFeathersBox.width, epFeathersBox.height = _G.math.min(episode.width / 2.25, (episode.width / 2.25) - (ep1ScoreBox1.width - (episode.width / 2.25))), fh * 0.95 
	
	epFeathersBox.width, epFeathersBox.height = episode.width * 0.35, fh * 0.85
--	epFeathersBox.x, epFeathersBox.y = 0, episode1.width * 0.50 + epFeathersBox.height * 0.95
	epFeathersBox.x, epFeathersBox.y = 0, episode.height * 0.50 + epFeathersBox.height * 0.95

	-------------- Feather score	
	
	setFont(episodeFeatherScore.font)

	
	episodeFeatherScore.text = scoreFeathers.."/"..maxFeathers 
	
	local yPos =  epFeathersBox.y + (epFeathersBox.height + topPieceH) * 0.95 * 0.5	
	episodeFeatherScore.x, episodeFeatherScore.y = 0, epFeathersBox.y + (epFeathersBox.height + topPieceH) * 0.95 * 0.5		
	local featherX = -0.5 *_G.res.getStringWidth(episodeFeatherScore.text) 
	--------------- 
	-- Feather Sprite
	local epFeatherSprite = getItemByName(page.items, "ep"..index.."FeatherSprite")
	epFeatherSprite.x, epFeatherSprite.y = featherX, epFeathersBox.y + (epFeathersBox.height + topPieceH) * 0.95 * 0.5				
	----------------
	if(iOS ~= true) then
		epFeatherSprite.visible = false
		episodeFeatherScore.visible = false
		epFeathersBox.visible = false		
	end
	
	flowPosition(-epFeathersBox.width / 2,yPos,epFeathersBox.width, epFeathersBox.height, {epFeatherSprite, episodeFeatherScore})
	
	
end

function getItemValues(item)
	if(item.sprite ~= nil) then
		local w,h = _G.res.getSpriteBounds(item.sprite)
		local px,py = _G.res.getSpritePivot(item.sprite)
		return {width = w, height = h, pivotX = px, pivotY = py}
	elseif(item.text ~= nil) then
		local w = _G.res.getStringWidth(item.text)
		local h = _G.res.getFontLeading(item.text)
		local px,py = w / 2, h / 2
		return {width = w, height = h, pivotX = px, pivotY = py}		
	end
end

function flowPosition(x,y,w,h,items)
	local totalw = 0
	
	for k,v in _G.pairs(items) do
	
		totalw = totalw + getItemValues(v).width
	end
	
	local diff = w - totalw
	local item1values = getItemValues(items[1])
	
	local x1 = x + (diff / 2) + item1values.pivotX
	
	
	items[1].x = x1 
	
	if(#items > 1) then
		for i = 2, #items do	
			items[i].x = x1 + getItemValues(items[i]).pivotX
--			items[i].y = y + h / 2
		end	
	end	
end

function handleGameModeChange(page, selectedMenuItem)	
	-- game specific
	
	if levelSelectionPagesGoldenEggs and levelSelectionPages == levelSelectionPagesGoldenEggs[1] then
		if currentGameMode == updateGame or currentGameMode == updatePictureLevel or currentGameMode == updateSoundboard then
			if settings.openGoldenEggLevels["Level" .. selectedMenuItem - levelSelectionPagesGoldenEggs[1].firstLevelIndex + 1] == 0 then
				-- mark golden egg level as visited
				settings.openGoldenEggLevels["Level" .. selectedMenuItem - levelSelectionPagesGoldenEggs[1].firstLevelIndex + 1] = 1
			end
		end
	end
	
	if currentGameMode == updateGame then
		currentLevelNumberInTheme = page.items[selectedMenuItem].pageLevelIndex or currentLevelNumberInTheme
		currentWorldNumber = page.items[selectedMenuItem].worldNumber or currentWorldNumber
		
		if levelSelectionPagesGoldenEggs and levelSelectionPages == levelSelectionPagesGoldenEggs[1] then -- if we're starting an extra level

			if page.items[selectedMenuItem].restartLevel == nil then
				levelName = page.items[selectedMenuItem].filename
				levelFolder = page.items[selectedMenuItem].folder
				
				numberOfAttemptsInLevel = 1
				--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
				logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]) 
			else
				-- level restarted
				settings.gameRestarted = settings.gameRestarted + 1
				--print("FlurryEventWithParam: Golden egg level restarted, Level, " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
				logFlurryEventWithParam("Golden egg level restarted", "Level", "" .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]) 
				numberOfAttemptsInLevel = numberOfAttemptsInLevel + 1
			end
			currentThemeNumber = 1
			inExtraWorld = true
		else
			if page.items[selectedMenuItem].restartLevel == nil then
				levelName = page.items[selectedMenuItem].filename
				levelFolder = page.items[selectedMenuItem].folder
				
				numberOfAttemptsInLevel = 1
				levelRestartedFlurryParams = {}
				if currentWorldNumber ~= nil and currentLevelNumberInTheme ~= nil then
					levelRestartedFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
				else
					levelRestartedFlurryParams["Level"] = "undefined"
				end
				levelRestartedFlurryParams["From"] = "levelselection menu"
				-- [1.5.4
				-- logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]) 
				
				--storeLevelStart(levelName)

				--logLevelStartFlurry(levelRestartedFlurryParams)
				--1.5.4]
				logFlurryEventWithParams("Level started", "levelRestartedFlurryParams") 
				--print("FlurryEventWithParam: Level started, Level, " .. currentWorldNumber .. "-" ..currentLevelNumberInTheme .. "\n")
			else
				-- level restarted
				settings.gameRestarted = settings.gameRestarted + 1
				
				levelRestartedFlurryParams = {}
				
				if currentWorldNumber ~= nil and currentLevelNumberInTheme ~= nil then
					levelRestartedFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
				else
					levelRestartedFlurryParams["Level"] = "undefined"
				end
				
				if numberOfAttemptsInLevel ~= nil then
					levelRestartedFlurryParams["Attempts"] = "" .. numberOfAttemptsInLevel
				else
					levelRestartedFlurryParams["Attempts"] = "undefined"
				end
				
				if birdsShot ~= nil then
					levelRestartedFlurryParams["Birds used"] = "" .. birdsShot
				else
					levelRestartedFlurryParams["Birds used"] = "undefined"
				end
				
				if birdsCounter ~= nil then
					levelRestartedFlurryParams["Birds available"] = "" .. birdsCounter
				else
					levelRestartedFlurryParams["Birds available"] = "undefined"
				end
				
				if levelRestartedFrom ~= nil then
					levelRestartedFlurryParams["From"] = "" .. levelRestartedFrom
				else
					levelRestartedFlurryParams["From"] = "undefined" 
				end
				--[1.5.4
				--storeLevelStart(levelName)
				--logLevelStartFlurry(levelRestartedFlurryParams)

				--1.5.4]
				logFlurryEventWithParams("Level restarted", "levelRestartedFlurryParams")
					
				
				--print("FlurryEventWithParam: Level restarted, Level, " .. currentWorldNumber .. "-" ..currentLevelNumberInTheme .. "\n")
				if numberOfAttemptsInLevel == nil then
					numberOfAttemptsInLevel = 0
				end
				numberOfAttemptsInLevel = numberOfAttemptsInLevel + 1
			end
			inExtraWorld = false
			increaseAttemptsAfterEagleOffer()
		end
		
		setEditing(false)
		setPhysicsEnabled(false)
		currentLevelNumber = page.items[selectedMenuItem].levelIndex or currentLevelNumber
		currentThemeNumber = page.items[selectedMenuItem].themeIndex or currentThemeNumber
		currentPageNumber = page.pageNumber or currentPageNumber
		loading = true
		setGameMode(updateLoading)
		
	end
		
	if currentGameMode == updatePictureLevel then
		pictureLevelName = page.items[selectedMenuItem].pictureLevel
		if pictureLevelName ~= nil then
			currentPictureLevel = pictureLevelName
			currentLevelNumberInTheme = page.items[selectedMenuItem].pageLevelIndex
			initPictureLevel()
		end
	end
	
	if currentGameMode == updateSoundboard then
		soundboardName = page.items[selectedMenuItem].soundboard
		if soundboardName ~= nil then
			currentSoundboard = soundboardName
			currentLevelNumberInTheme = page.items[selectedMenuItem].pageLevelIndex
			initSoundboard()
		end
	end
	
	if currentGameMode == updateEditor then
		_G.res.stopAudio(currentMainMenuSong)
		levelName = page.items[selectedMenuItem].filename
		levelFolder = page.items[selectedMenuItem].folder
		setEditing(true)
		setPhysicsEnabled(physicsEnabled)
		currentLevelNumberInTheme = page.items[selectedMenuItem].pageLevelIndex or currentLevelNumberInTheme		
		currentLevelNumber = page.items[selectedMenuItem].levelIndex or currentLevelNumber
		currentThemeNumber = page.items[selectedMenuItem].themeIndex or currentThemeNumber
		currentWorldNumber = page.items[selectedMenuItem].worldNumber or currentWorldNumber
		currentPageNumber = page.pageNumber or currentPageNumber
		loadLevelInternal(levelFolder .. levelName)
	end
end



function checkLogLevelNotCompleted()
	if(highscores ~= nil and levelName ~= nil) then
		local levelNotCompleted = highscores[levelName] == nil
		
		if (levelNotCompleted and currentWorldNumber ~= nil and currentLevelNumberInTheme ~= nil) then				
			local level = getWorldLevelNumberCombination()
			print("(1.5.4) logging level started before completion..\n")
			logFlurryEventWithParam("Level started before completion", "Level", level)					
		end				
	end
end



function updateLoading(dt)
	if loadingPageDrawn == false then
		loadingPage.backgroundOverlay.shade = 0.65
		drawMenu()
		loadingPageDrawn = true
		loadLevelDelayed = levelFolder .. levelName
		loadLevelInternal(loadLevelDelayed)
		changeResolution = true
		wantedResolution = "FULL"
		
		if iapEnabled == true and inExtraWorld ~= true and eagleBaitLaunched ~= true then
			inGameEagleButtonVisible = true
			--[[
			if settings.mightyEagleEnabled == true then 
				inGameEagleButtonVisible = true
			else
				local currentEpisodeAttemps = 0
				if levelSelectionPages == levelSelectionPagesBasic then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.basic
				elseif levelSelectionPages == levelSelectionPagesExtra then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.extra
				elseif levelSelectionPages == levelSelectionPagesPack3 then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.pack3
				elseif levelSelectionPages == levelSelectionPagesPack4 then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.pack4
				elseif levelSelectionPages == levelSelectionPagesPack5 then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.pack5
				-- ADDED
				elseif levelSelectionPages == levelSelectionPagesPack6 then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.pack6					
				end
				if currentEpisodeAttemps ~= nil and currentEpisodeAttemps > 3 then
					inGameEagleButtonVisible = true
				end
			end]]
		end
	end
end

function updateLoadingEx(dt)
	if loadingPageDrawn == false then
		loadingPage.backgroundOverlay.shade = 0.65
		loading = true
		drawMenu()
		loadingPageDrawn = true
		if loadingPage.nextPage.bgColor ~= nil then
			loadingPage.nextPage.bgColor = { red = loadingPage.nextPage.bgColor.red, green = loadingPage.nextPage.bgColor.green, blue = loadingPage.nextPage.bgColor.blue}
		end
		setActiveMenuPage(loadingPage.nextPage)
		popupPage = nil
		loadingPageDrawn = false
		loading = false
		--drawMenu()
		setGameMode(updateMenu)		
	end
end

function releaseCutScenes()
	releaseCompoSprites( {"CUTSCENES_COMPOSPRITES"} )
	releaseImages( {"CUTSCENES"} )
	loadImages( {"OTHER", "MENU"} )
	loadCompoSprites( {"TUTORIALS_COMPOSPRITES"} )
end

backgroundsLoaded = false
function releaseBackgrounds()
	
	releaseImages( {"BACKGROUNDS"} )
		
end

function loadBackgrounds()
	loadImages( {"BACKGROUNDS"} )
end




function loadCutScenes()
	-- Fix for bug# 1758
	if(currentGameMode ~= updateGame) then
		releaseCompoSprites( {"TUTORIALS_COMPOSPRITES"} )
		releaseImages( {"OTHER", "MENU" } )		
		releaseBackgrounds()
		
		loadImages( {"CUTSCENES"} )
		loadCompoSprites( {"CUTSCENES_COMPOSPRITES"} )	
	end
end

function gotoLevelSelection(dt)
	print("(1.5.4) ep 1 clicked..\n")
	logFlurryEvent("goto episode 1")
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesBasic
	if levelSelectionPagesBasic.currentPage ~= settings.currentLevelSelectionPages.basic then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesBasic.currentPage = settings.currentLevelSelectionPages.basic
	end
	setActiveMenuPage(levelSelectionPagesBasic)
	
	drawMenu()
	releaseCutScenes()
end

function gotoLevelSelectionExtra(dt)
	print("(1.5.4) ep 2 clicked..\n")
	logFlurryEvent("goto episode 2")
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesExtra
	if levelSelectionPagesExtra.currentPage ~= settings.currentLevelSelectionPages.extra then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesExtra.currentPage = settings.currentLevelSelectionPages.extra
	end
	setActiveMenuPage(levelSelectionPagesExtra)

	drawMenu()
	releaseCutScenes()
end

function gotoLevelSelectionGoldenEggs(dt)
	print("(1.5.4) ep Golden Eggs clicked..\n")
	logFlurryEvent("goto episode GE")
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesGoldenEggs[1]
	setActiveMenuPage(levelSelectionPagesGoldenEggs[1], true)
	drawMenu()
end

function gotoLevelSelectionPack3(dt)
	print("(1.5.4) ep 3 clicked..\n")
	logFlurryEvent("goto episode 3")
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesPack3
	if levelSelectionPagesPack3.currentPage ~= settings.currentLevelSelectionPages.pack3 then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesPack3.currentPage = settings.currentLevelSelectionPages.pack3
	end
	setActiveMenuPage(levelSelectionPagesPack3)

	drawMenu()
	releaseCutScenes()
end

function gotoLevelSelectionPack4(dt)
	print("(1.5.4) ep 4 clicked..\n")
	logFlurryEvent("goto episode 4")
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesPack4
	if levelSelectionPagesPack4.currentPage ~= settings.currentLevelSelectionPages.pack4 then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesPack4.currentPage = settings.currentLevelSelectionPages.pack4
	end
	setActiveMenuPage(levelSelectionPagesPack4)

	drawMenu()
	releaseCutScenes()
end

function gotoLevelSelectionPack5(dt)
	print("(1.5.4) ep 5 clicked..\n")
	logFlurryEvent("goto episode 5")
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesPack5
	if levelSelectionPagesPack5.currentPage ~= settings.currentLevelSelectionPages.pack5 then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesPack5.currentPage = settings.currentLevelSelectionPages.pack5
	end
	setActiveMenuPage(levelSelectionPagesPack5)

	drawMenu()
	releaseCutScenes()
end
-- ADDED
function gotoLevelSelectionPack6(dt)
	setGameMode(updateMenu)
	levelSelectionPages = levelSelectionPagesPack6
	if levelSelectionPagesPack6.currentPage ~= settings.currentLevelSelectionPages.pack6 then
		levelSelectionScrollStartTimer = 0.5
		levelSelectionPagesPack6.currentPage = settings.currentLevelSelectionPages.pack6
	end
	setActiveMenuPage(levelSelectionPagesPack6)

	drawMenu()
	releaseCutScenes()
end

function loadPreviousLevel(dt)
	drawGame()
	drawMenu()																																																															-- ADDED
	if  levelSelectionPages == levelSelectionPagesBasic or levelSelectionPages == levelSelectionPagesExtra or levelSelectionPages == levelSelectionPagesPack3 or levelSelectionPages == levelSelectionPagesPack4 or levelSelectionPages == levelSelectionPagesPack5  or levelSelectionPages == levelSelectionPagesPack6 then
		if currentLevelNumberInTheme <= 1 then
			levelSelectionPages.currentPage = levelSelectionPages.currentPage - 1
			if levelSelectionPages.currentPage <= 0 then
				if levelSelectionPages == levelSelectionPagesBasic then
					levelSelectionPages.currentPage = 1
				else
					if levelSelectionPages == levelSelectionPagesExtra then
						levelSelectionPages = levelSelectionPagesBasic
					elseif levelSelectionPages == levelSelectionPagesPack3 then
						levelSelectionPages = levelSelectionPagesExtra
					elseif levelSelectionPages == levelSelectionPagesPack4 then
						levelSelectionPages = levelSelectionPagesPack3
					elseif levelSelectionPages == levelSelectionPagesPack5 then						
						levelSelectionPages = levelSelectionPagesPack4
						-- ADDED
					elseif levelSelectionPages == levelSelectionPagesPack6 then						
						levelSelectionPages = levelSelectionPagesPack5
					end
					levelSelectionPages.currentPage = levelSelectionPages.pageCount
					currentLevelNumberInTheme = levelSelectionPages.levelsPerPage
					currentLevelNumber = levelSelectionPages.pageCount * levelSelectionPages.levelsPerPage
					currentThemeNumber = currentThemeNumber	- 1
					currentWorldNumber = currentWorldNumber - 1
				end
			else
				currentLevelNumberInTheme = levelSelectionPages.levelsPerPage
				currentLevelNumber = currentLevelNumber - 1
				currentThemeNumber = currentThemeNumber	- 1
				currentWorldNumber = currentWorldNumber - 1
			end

		else
			currentLevelNumberInTheme = currentLevelNumberInTheme - 1
			currentLevelNumber = currentLevelNumber - 1
		end
		
		local index = (levelSelectionPages.currentPage - 1) * levelSelectionPages.levelsPerPage + levelSelectionPages.firstLevelIndex		
		levelName = levelSelectionPages.items[currentLevelNumberInTheme + index - 1].filename
		levelFolder = levelSelectionPages.items[currentLevelNumberInTheme + index - 1].folder
			
	end
	
	levelRestartedFrom = nil
	loading = true
	setGameMode(updateLoading)
end

function loadNextLevel(dt)
	drawGame()
	--drawMenu()																																																																				-- ADDED
	if  levelSelectionPages == levelSelectionPagesBasic or levelSelectionPages == levelSelectionPagesExtra or levelSelectionPages == levelSelectionPagesPack3 or levelSelectionPages == levelSelectionPagesPack4 or levelSelectionPages == levelSelectionPagesPack5 or levelSelectionPages == levelSelectionPagesPack6 then
		if currentLevelNumberInTheme >= levelSelectionPages.levelsPerPage then
			levelSelectionPages.currentPage = levelSelectionPages.currentPage + 1
			if levelSelectionPages.currentPage > levelSelectionPages.pageCount then
				if levelSelectionPages == levelSelectionPagesPack5 then
					levelSelectionPages.currentPage = levelSelectionPages.pageCount
				else
					if levelSelectionPages == levelSelectionPagesBasic then
						levelSelectionPages = levelSelectionPagesExtra
					elseif levelSelectionPages == levelSelectionPagesExtra then
						levelSelectionPages = levelSelectionPagesPack3
					elseif levelSelectionPages == levelSelectionPagesPack3 then
						levelSelectionPages = levelSelectionPagesPack4	
					elseif levelSelectionPages == levelSelectionPagesPack4 then
						levelSelectionPages = levelSelectionPagesPack5	
					-- ADDED
					elseif levelSelectionPages == levelSelectionPagesPack5 then
						levelSelectionPages = levelSelectionPagesPack6
					end
					levelSelectionPages.currentPage = 1
					currentLevelNumberInTheme = 1
					currentLevelNumber = 1
					currentThemeNumber = currentThemeNumber	+ 1
					currentWorldNumber = currentWorldNumber + 1
				end
			else				
				currentLevelNumberInTheme = 1
				currentLevelNumber = currentLevelNumber + 1
				currentThemeNumber = currentThemeNumber	+ 1
				currentWorldNumber = currentWorldNumber + 1
			end
		else
			currentLevelNumberInTheme = currentLevelNumberInTheme + 1
			currentLevelNumber = currentLevelNumber + 1
		end
		
		numberOfAttemptsInLevel = 1
		
		levelStartedFlurryParams = {}
		if currentWorldNumber ~= nil and currentLevelNumberInTheme ~= nil then
			levelStartedFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
		else
			levelStartedFlurryParams["Level"] = "undefined"
		end
		if levelRestartedFrom ~= nil then
			levelStartedFlurryParams["From"] = "" .. levelRestartedFrom
		else
			levelStartedFlurryParams["From"] = "undefined" 
		end
		--flurryParams["attempts"] = statistics[levelName].starts

		--[1.5.4
		--storeLevelStart(levelName)
		--logLevelStartFlurry(flurryParams)
		-- 1.5.4]
		
		logFlurryEventWithParams("Level started", "levelStartedFlurryParams") 
		
		
		--print("FlurryEventWithParam: Level started, Level, " .. currentWorldNumber .. "-" ..currentLevelNumberInTheme .. "\n")
		
		local index = (levelSelectionPages.currentPage - 1) * levelSelectionPages.levelsPerPage + levelSelectionPages.firstLevelIndex
		levelName = levelSelectionPages.items[currentLevelNumberInTheme + index - 1].filename
		levelFolder = levelSelectionPages.items[currentLevelNumberInTheme + index - 1].folder
	end
	
	increaseAttemptsAfterEagleOffer()
	levelRestartedFrom = nil
	loading = true
	setGameMode(updateLoading)
end

--
-- adds number of attempts - information to table
-- 1.5.4
--[[
function logLevelStartFlurry(targetTable)
	if(statistics ~= nil and levelName ~= nil and statistics[levelName] ~= nil and statistics[levelName].starts ~= nil) then
		print("-- Flurry : logging level starts, levelName = "..levelName.." starts = "..statistics[levelName].starts.."\n")
		targetTable["attempts"] = statistics[levelName].starts		
	end
end]]

function hasLevelPack1()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesBasic.levelsPerPage + levelSelectionPagesBasic.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesBasic.items[index].folder .. levelSelectionPagesBasic.items[index].filename .. ".lua")
	end
end

function hasLevelPack2()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesExtra.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesExtra.items[index].folder .. levelSelectionPagesExtra.items[index].filename .. ".lua")
	end
end

function hasLevelPack3()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesPack3.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesPack3.items[index].folder .. levelSelectionPagesPack3.items[index].filename .. ".lua")
	end
end

function hasLevelPack4()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesPack4.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesPack4.items[index].folder .. levelSelectionPagesPack4.items[index].filename .. ".lua")
	end
end

function hasLevelPack5()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesPack5.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesPack5.items[index].folder .. levelSelectionPagesPack5.items[index].filename .. ".lua")
	end
end
-- ADDED
function hasLevelPack6()
	if isLiteVersion then
		return false
	else
		local index = levelSelectionPagesPack6.firstLevelIndex
		return checkForLuaFile(levelSelectionPagesPack6.items[index].folder .. levelSelectionPagesPack6.items[index].filename .. ".lua")
	end
end

-- Game Center main menu animations
function showLoadingInitGameCenter()
	if mainMenu and mainMenu.items then
		local leaderboards = getItemByName(mainMenu.items, "leaderboards")
		local achievements = getItemByName(mainMenu.items, "achievements")
		local loaderLB = getItemByName(mainMenu.items, "loaderLB")
		local loaderAC = getItemByName(mainMenu.items, "loaderAC")
		
		achievements.selectable = false
		leaderboards.selectable = false
		
		loaderLB.x, loaderLB.y = leaderboards.x, leaderboards.y
		loaderAC.x, loaderAC.y = achievements.x, achievements.y
		
		loaderLB.show = true
		loaderAC.show = true
		
		loaderLB.angle = 0
		loaderAC.angle = 0
		
		leaderboards.sprite = "BUTTON_EMPTY"
		achievements.sprite = "BUTTON_EMPTY"
		
		initGameCenter()

		leaderboards.callFunction = nil
		achievements.callFunction = nil
	end
end

function hideLoadingInitGameCenter()
	if mainMenu and mainMenu.items then
		local leaderboards = getItemByName(mainMenu.items, "leaderboards")
		local achievements = getItemByName(mainMenu.items, "achievements")
		local loaderLB = getItemByName(mainMenu.items, "loaderLB")
		local loaderAC = getItemByName(mainMenu.items, "loaderAC")
		
		achievements.selectable = true
		leaderboards.selectable = true
		
		loaderLB.x, loaderLB.y = leaderboards.x, leaderboards.y
		loaderAC.x, loaderAC.y = achievements.x, achievements.y
		
		loaderLB.show = false
		loaderAC.show = false
		
		loaderLB.angle = 0
		loaderAC.angle = 0
		
		leaderboards.sprite = "BUTTON_LEADERBOARDS"
		achievements.sprite = "BUTTON_ACHIEVEMENTS"
		
		if gameCenterEnabled then
			leaderboards.callFunction = showLoadingLeaderboards
			achievements.callFunction = showLoadingAchievements
		else
			leaderboards.callFunction = showLoadingInitGameCenter
			achievements.callFunction = showLoadingInitGameCenter
		end
	end
end

function showLoadingLeaderboards()
	local leaderboards = getItemByName(mainMenu.items, "leaderboards")
	local loader = getItemByName(mainMenu.items, "loaderLB")
	
	getItemByName(mainMenu.items, "achievements").selectable = false
	getItemByName(mainMenu.items, "achievements").sprite = "BUTTON_ACHIEVEMENTS_DISABLED"
	
	loader.x, loader.y = leaderboards.x, leaderboards.y
	loader.show = true
	loader.angle = 0
	leaderboards.sprite = "BUTTON_EMPTY"
	
	showLeaderboards()

	leaderboards.callFunction = nil
end

function hideLoadingLeaderboards()
	local leaderboards = getItemByName(mainMenu.items, "leaderboards")
	local loader = getItemByName(mainMenu.items, "loaderLB")
	
	getItemByName(mainMenu.items, "achievements").selectable = true
	
	loader.x, loader.y = leaderboards.x, leaderboards.y
	loader.show = false
	loader.angle = 0
	leaderboards.sprite = "BUTTON_LEADERBOARDS"
	getItemByName(mainMenu.items, "achievements").sprite = "BUTTON_ACHIEVEMENTS"
	leaderboards.callFunction = showLoadingLeaderboards
end

function showLoadingAchievements()
	local achievements = getItemByName(mainMenu.items, "achievements")
	local loader = getItemByName(mainMenu.items, "loaderAC")
	
	getItemByName(mainMenu.items, "leaderboards").selectable = false
	getItemByName(mainMenu.items, "leaderboards").sprite = "BUTTON_LEADERBOARDS_DISABLED"
	
	loader.x, loader.y = achievements.x, achievements.y
	loader.show = true
	loader.angle = 0
	achievements.sprite = "BUTTON_EMPTY"
	
	showAchievements()
	
	achievements.callFunction = nil
end

function hideLoadingAchievements()
	local achievements = getItemByName(mainMenu.items, "achievements")
	local loader = getItemByName(mainMenu.items, "loaderAC")
	
	getItemByName(mainMenu.items, "leaderboards").selectable = true
	
	loader.x, loader.y = achievements.x, achievements.y
	loader.show = false
	loader.angle = 0
	achievements.sprite = "BUTTON_ACHIEVEMENTS"
	getItemByName(mainMenu.items, "leaderboards").sprite = "BUTTON_LEADERBOARDS"
	achievements.callFunction = showLoadingAchievements
end

--- end of Game Center main menu animations

function isGEPage2Unlocked()
	local flag = false
	for i = 1, levelSelectionPagesGoldenEggs[1].levelCount - 15 do
		if settings.openGoldenEggLevels["Level"..15+i] then
			flag = flag or true
		end
	end
	return flag
end

-- Show system game popup
function showSystemPopup(title, message, icon)
	getItemByName(systemPopup.items, "title").text = title
	getItemByName(systemPopup.items, "message").text = message
	getItemByName(systemPopup.items, "icon").sprite = icon
	setActivePopupPage(systemPopup)
end

function hideSystemPopup()
	popupPage = nil
end

-- FB Like popup
function showFBLikePopup()
	showSystemPopup("TEXT_FB_LEVELS_HINT_TITLE", "TEXT_FB_LEVELS_HINT")
end

-- about
function showLeftMenu(dt)
	logFlurryEvent("About menu viewed")
	
	
	local goldenEgg = getItemByName(about.items, "goldenEgg")

	if(goldenEgg ~= nil) then
		if isLiteVersion or settings.openGoldenEggLevels["Level5"] ~= nil then		
			goldenEgg.sprite = "ABOUT_BIRDS_3"
			goldenEgg.callFunction = nil
		else	
			goldenEgg.sprite = "GOLDEN_EGG_5"
			goldenEgg.callFunction = aboutGoldenEggAchieved
		end	
	end
	
	about.items[1].visible = true
	about.items[2].visible = true
	about.items[3].visible = true
	about.items[4].visible = true
	about.items[5].visible = true
	about.items[6].visible = true
	about.items[7].visible = true
	about.items[8].visible = true
	about.items[9].visible = true
	about.items[10].visible = true
	
	setAnimationState("aboutPageScroll", "ENTERING")
	setActiveMenuPage(about)
end


function hideLeftMenu(dt)
	about.items[1].visible = false
	about.items[2].visible = false
	about.items[3].visible = false
	about.items[4].visible = false
	about.items[5].visible = false
	about.items[6].visible = false
	about.items[7].visible = false
	about.items[8].visible = false
	about.items[9].visible = false
	about.items[10].visible = false
		
	setAnimationState("aboutPageScroll", "EXITING")
	setActiveMenuPage(mainMenu, false)
end

-- about
function showPauseMenu(dt)
	levelRestartedFrom = "pause menu"
	setAnimationState("ingamePausePageScroll", "ENTERING")
	changeResolution = true
	wantedResolution = "HALF"
	setActiveMenuPage(pausePage, true)
	setGameMode(updateMenu)
		
	--stop looping rolling sounds
	_G.res.stopAudio("wood_rolling")
	_G.res.stopAudio("rock_rolling")
	_G.res.stopAudio("light_rolling")
	drawMenu()

	-- create a web view if it has not been created yet
	if rovioNewsCreated ~= true and (deviceModel == "android" or deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad") then
		if pausePage.backgroundBox.width == nil then
			prepareMenuPage(pausePage)
		end
	
		local resumeButtonW = _G.res.getSpriteBounds("", getItemByName(pausePage.items, "buttonResume").sprite)
		local x = pausePage.backgroundBox.width + resumeButtonW / 1.5
		local y = 0
		local height = screenHeight
		local width = screenWidth - x
		
		if deviceModel == "iphone4" and screenWidth ~= 480 then
			height = screenHeight/2
			width = screenWidth/2 - x
		end
		
		-- Create a WebView	
		if(_G.WebView == nil) then
			return		
		end
		rovioNews = _G.WebView.new(x, y, height, width)
		rovioNewsCreated = true
		
		-- Add onLinkClicked call-back
		local onLinkClicked = function(view, url)
			return _G.WebView.LOAD_PAGE_INTO_EXTERNAL_BROWSER
		end
		
		rovioNews:setOnLinkClickedCallback(onLinkClicked)
		
		-- Load RovioNews
		local onPageLoaded = function(view, success, pageTitle)
			if success and pageTitle == "Rovio News [hjsdu]" then
				rovioNewsIsLoaded = true
				if rovioNewsShowWhenLoaded then
					hideAd()
					view:show()
					rovioNewsIsShown = true
				end
			end
		end
		
		rovioNewsShowWhenLoaded = true
		rovioNews:setOnPageLoadedCallback(onPageLoaded)
		rovioNews:loadPage(ROVIO_NEWS_URL)
	end	
end

function hidePauseMenu(dt)
	setAnimationState("ingamePausePageScroll", "EXITING")
	setGameMode(updateMenu)
	drawMenu()
	
	if rovioNewsIsShown then
		rovioNews:hide()
		rovioNewsIsShown = false
	end
	rovioNewsShowWhenLoaded = false
end

function showEagleTimeLeft()
	eagleInfoTimer = 3.0
	--setGameMode(updateMenu)
	--drawMenu()
	--print("eagle lost clicked\n")
end

function launchEagleBaitInGame()
	--setAnimationState("ingamePausePageScroll", "EXITING")
	--setActiveMenuPage(pausePage, false)
	
	rubberBandPos.x = levelStartPosition.x
	rubberBandPos.y = levelStartPosition.y
	rubberBandSpeed = 0
	
	if currentBirdName ~= nil and objects.world[currentBirdName].shot ~= true then
		removeBird(objects.world[currentBirdName])
	elseif birdToSlingshotBirdName ~= nil then 
		removeBird(objects.world[birdToSlingshotBirdName])
		currentBirdIndex = currentBirdIndex + 1
	end
	local nextBirdName = nil
	repeat
		currentBirdIndex = currentBirdIndex + 1
		nextBirdName = getNextBird(currentBirdIndex)
		if nextBirdName ~= nil then
			removeBird(objects.world[nextBirdName])
		end
	until nextBirdName == nil
	currentBirdIndex = currentBirdIndex - 1
	birdToSlingshotBirdName = nil
	currentBirdName = nil
	launchEagleBait()
	if #birdTutorialPopups == 0 then
		changeResolution = nil
	end
	fillInNextBird = true
end

function launchEagleBait()
	--[[cameraFunction = launchCamera
	animationScreen.x = screen.x
	animationScreen.y = screen.y
	animationWorldScale = worldScale					
	castleCameraTimer = 2.5
	currentZoomedScale = objects.birdCameraData[deviceModel].sx]]
	local tempFlyingBird = flyingBird
	returnToBirdCamera()
	flyingBird = tempFlyingBird

	eagleSoundPlayed = nil
	eagleBaitLaunched = true
	inGameEagleButtonVisible = false
	levelCompleteTimer = 0
	levelFailedTimer = -200
	
	-- baitsardine is the next bird
	--baitSardine.x, baitSardine.y = levelStartPosition.x, levelStartPosition.y
	local obj = baitSardine
	local name = createObject(blockTable, obj.definition, obj.name, obj.x*scaleFactor, obj.y*scaleFactor)

	-- clamp angle to 0 - 2*PI range
	obj.angle = _G.math.fmod(obj.angle, _G.math.pi*2)
	if obj.angle < 0 then
		obj.angle = obj.angle + _G.math.pi*2
	end
	
	setRotation(name, obj.angle)
	setMaterial(name, objects.world[name].material)
	if objects.world[name].texture ~= nil then
		setTexture(name, objects.world[name].texture)
	end
	
	if objects.world[name].controllable then
		birdsCounter = birdsCounter + 1
		objects.world[name].startNumber = birdsCounter
	end
	objects.world[name].animTimer = 3
	objects.world[name].jumpTimer = 3
	birds[name] = objects.world[name]
	local sprites = getDamageSprite(objects.world[name], blockTable.blocks)
	objects.world[name].damageSprite = sprites.sprite
	objects.world[name].blinkSprite = sprites.blink		
	objects.world[name].smileSprite = sprites.smile		
	objects.world[name].frozen = false
	objects.world[name].isEagleBait = true
	objects.world[name].recordTrajectory = false
	
	if settings.tutorials[objects.world[name].sprite] == nil then
		settings.tutorials[objects.world[name].sprite] = {}
		settings.tutorials[objects.world[name].sprite].sprite = blockTable.blocks[objects.world[name].definition].tutorialInfo
		_G.table.insert(birdTutorialPopups, blockTable.blocks[objects.world[name].definition].tutorialInfo)
		if deviceModel == "iphone4" then
			changeResolution = true
			wantedResolution = "HALF"
		end
	else
		if deviceModel == "iphone4" then
			changeResolution = true
			wantedResolution = "FULL"
		end
	end
	
	setGameMode(updateGame)
	setPhysicsEnabled(true)
	nextBirdTimer = 0.1
	drawGame()
end

function isEagleDisabled()
	local disabled = false
	if settings.eagleUsedTime ~= nil and (highscores[levelName] == nil or ((highscores[levelName].score == 0 or highscores[levelName].completed ~= true) and highscores[levelName].eagleScore == nil)) and
	   eagleUsedInCurrentLevel ~= true and timeDiff( currentTime(), settings.eagleUsedTime) < eagleLockedTime then
		disabled = true
	end
	return disabled
end

-- settings
function showRightMenu(dt)
	setAnimationState("settingsPageScroll", "ENTERING")
	setActiveMenuPage(settingsPage)
	setGameMode(updateMenu)
	drawMenu()
end

function hideRightMenu(dt)
	setAnimationState("settingsPageScroll", "EXITING")
	setActiveMenuPage(mainMenu, false)
	setGameMode(updateMenu)
	drawMenu()
end

-- function setEffectsVolume(volume)
-- 	_G.res.setTrackVolume(volume, 0)
-- 	_G.res.setTrackVolume(volume, 1)
-- 	_G.res.setTrackVolume(volume, 2)
-- 	_G.res.setTrackVolume(volume, 3)
-- 	_G.res.setTrackVolume(volume, 4)
-- end

-- function setMusicVolume(volume)
-- 	_G.res.setTrackVolume(volume, 7)
-- end

function changeAudio()
	if settings.audioEnabled ~= false then
		audioRampVolume = _G.res.getTrackVolume(7)
		audioRampLength = -0.5
		pausePage.items[2].visible = true
		getItemByName(mainMenu.items, "buttonOff").visible = true
		settings.audioEnabled = false
	else
		audioRampVolume = _G.res.getTrackVolume(7)
		audioRampLength = 0.5
		--settingsPage.items[2].visible = false
		pausePage.items[2].visible = false
		--mainMenu.items[7].visible = false
		getItemByName(mainMenu.items, "buttonOff").visible = false
		settings.audioEnabled = true
		_G.res.startAudioOutput()
	end
	saveLuaFileWrapper("settings.lua", "settings", true)
end

function gotoFirstLevel()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesBasic, levelSelectionPagesBasic.firstLevelIndex)
	drawMenu()	
end

function gotoFirstLevelLP2()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesExtra, levelSelectionPagesExtra.firstLevelIndex)
	drawMenu()
end

function gotoFirstLevelLP3()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesPack3, levelSelectionPagesPack3.firstLevelIndex)
	drawMenu()
end

function gotoFirstLevelLP4()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesPack4, levelSelectionPagesPack4.firstLevelIndex)
	drawMenu()
end

function gotoFirstLevelLP5()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesPack5, levelSelectionPagesPack5.firstLevelIndex)
	drawMenu()
end
-- ADDED
function gotoFirstLevelLP6()
	setGameMode(updateGame)
	_G.res.stopAllAudio()
	handleGameModeChange(levelSelectionPagesPack6, levelSelectionPagesPack6.firstLevelIndex)
	drawMenu()
end
function gotoAbout()
	releaseCutScenes()
	setAnimationState("aboutPageScroll", "VISIBLE")
	setGameMode(updateMenu)
	showLeftMenu()
	about.backgroundOverlay.shade = 0.65
	_G.res.stopAudio("birds_outro")
	_G.res.playAudio(currentMainMenuSong, 0.8, true, 7)
	drawMenu()
end

function gotoReportBug()
	_G.res.openURL(REPORT_BUG_URL)
end

function gotoMightyEagleTrailer()
	-- 1.5.4
	logFlurryEvent("ME: trailer viewed")
	_G.res.openURL(MIGHTY_EAGLE_TRAILER)
end


function gotoSeasonsInAppStore()
	-- setGameMode(updateMenu)
	-- if isLiteVersion then
		-- setActiveMenuPage(levelSelectionPagesBasic, true)
	-- else
		-- setActiveMenuPage(episodeSelectionPage, true)
	-- end
	-- drawMenu()
	logFlurryEvent("AB Seasons link clicked.")
	_G.res.openURL(APP_STORE_HALLOWEEN_URL)
end



function gotoFullVersionInAppStore()
	setGameMode(updateMenu)
	if isLiteVersion then
		--setActiveMenuPage(levelSelectionPagesBasic, true)  -- Is this nesessary? Things seem to work much better without this.
	else
		setActiveMenuPage(episodeSelectionPage, true)
	end
	drawMenu()
	logFlurryEvent("Full version link clicked")
	_G.res.openURL(APP_STORE_FULL_VERSION_URL)
end

function gotoNewsLetter()
	-- setGameMode(updateMenu)
	-- if isLiteVersion then
		-- setActiveMenuPage(levelSelectionPagesBasic, true)
	-- else
		-- setActiveMenuPage(episodeSelectionPage, true)
	-- end
	-- drawMenu()
	logFlurryEvent("Newsletter link clicked")
	_G.res.openURL(NEWSLETTER_URL)
end


function gotoABFBConnect()
	
	setGameMode(updateMenu)
	setActiveMenuPage(currentMenuPage, true)
	settings.fbPageLiked = true
	drawMenu()
	logFlurryEvent("ABFBConnect link clicked")
	_G.res.openURL(AB_FBCONNECT_URL)
	
	
--[[
	-- Create a WebView if it hasn't been created yet
	if not ABLikeViewCreated and not settings.fbPageLiked and webViewIsSupported then
		if deviceModel == "ipad" then
			ABLikeView = _G.WebView.new((screenWidth - 640) / 2, (screenHeight - 480) / 2, 480, 640)
		else
			ABLikeView = _G.WebView.new(0, 0, screenHeight, screenWidth)
		end
		ABLikeViewCreated = true
		isWebViewLoading = true
		--facebookTimeout = FACEBOOK_TIMEOUT
		
		-- ABLikeView:allowCallsFromJavaScript("_G")
		-- _G.hideABLikeView = function()
								-- print("_G.hideABLikeView called \n")
								-- ABLikeView:hide()
							-- end
		-- Add onLinkClicked call-back
		local onLinkClickedABLike = function(view, url)
			print("link clicked: "..url.."\n")
			local beginIndex, endIndex = _G.string.find(url, "close")
			if beginIndex ~= nil and beginIndex >= 1 then
				return _G.WebView.LOAD_PAGE_INTO_WEBVIEW
			else
				return _G.WebView.DONT_LOAD_PAGE
			end
		end
		
		ABLikeView:setOnLinkClickedCallback(onLinkClickedABLike)
		
		-- Load RovioNews
		local onPageLoadedABLike = function(view, success, pageTitle)
			isWebViewLoading = false
			--webViewTimeout = 0
			local beginIndex, endIndex = _G.string.find(pageTitle, "404")
			if success and beginIndex == nil then
				if pageTitle == "dismissABLikePage[jqrt]" then
					ABLikeView:hide()
					popupPage = nil
				elseif pageTitle == "dismissABLikePage[jqrtakta]" then
					popupPage = nil
					view:hide()
					settings.fbPageLiked = true
					view:delete()
					ABLikeView = nil
					ABLikeViewCreated = nil
					setActiveMenuPage(currentMenuPage, true)
				else
					ABLikeView:executeJavaScript("document.addEventListener('touchmove', function(e){ e.preventDefault(); });")
					isWebViewLoading = true
					view:show()
				end
			else
				if popupPage ~= systemPopup then
					view:hide()
					popupPage = nil
					showSystemPopup("TEXT_NETWORK_ERROR_TITLE", "TEXT_NETWORK_ERROR")
				end
			end
			print("pageTitle: "..pageTitle.."\n")
		end
		
		ABLikeView:setOnPageLoadedCallback(onPageLoadedABLike)					
	elseif not webViewIsSupported and not settings.fbPageLiked then
		setGameMode(updateMenu)
		setActiveMenuPage(currentMenuPage, true)
		settings.fbPageLiked = true
		_G.res.openURL(AB_FBCONNECT_URL)
	elseif settings.fbPageLiked then
		showSystemPopup("TEXT_LIKE_CONFIRMED_TITLE", "TEXT_LIKE_CONFIRMED")
	end
	
	if ABLikeView ~= nil then
		isWebViewLoading = true
		setActivePopupPage(loadingPage)
		ABLikeView:loadPage(ABLIKE_URL)
	end
	
	setGameMode(updateMenu)
	-- setActiveMenuPage(currentMenuPage, true)
	-- -- if currentMenuPage == levelSelectionPagesPackV then
		-- -- settings.fbPageLiked = true
	-- -- else
		-- -- settings.fbPageLikedSP = true
	-- -- end
	
	drawMenu()
	logFlurryEvent("ABFBConnect link clicked")
	-- _G.res.openURL(AB_FBCONNECT_URL)]]
end

function gotoABShop()
	setGameMode(updateMenu)
	if isLiteVersion then
		setActiveMenuPage(levelSelectionPagesBasic, true)
	else
		setActiveMenuPage(episodeSelectionPage, true)
	end
	drawMenu()
	logFlurryEvent("ABshop link clicked")
	_G.res.openURL(ABSHOP_URL)
end

function gotoAppleGiftPurchase()
	setGameMode(updateMenu)
	setActiveMenuPage(episodeSelectionPage, true)
	drawMenu()
	logFlurryEvent("Apple gift purchase link clicked")
	_G.res.openURL(APPLE_GIFT_PURCHASE_URL)
end

function gotoLenovoNoAdsVersion()
	setGameMode(updateMenu)
	setActiveMenuPage(episodeSelectionPage, true)
	drawMenu()
	logFlurryEvent("Lenovo no ads link clicked")
	_G.res.openURL(LENOVO_NO_ADS_URL)
end

function gotoRioContest()
	setGameMode(updateMenu)
	drawMenu()
	logFlurryEvent("Rio contest link clicked")
	_G.res.openURL(RIO_CONTEST_URL)
end

function gotoAndroidMarket()
	_G.res.openURL(ANDROID_MARKET_FULL_VERSION_URL)
end

function gotoPrivacyPolicy()
	_G.res.openURL(PRIVACY_POLICY_URL)
end

function gotoEula()
	_G.res.openURL(EULA_URL)
end

function gotoFacebook()
	logFlurryEvent("Facebook link clicked")
	_G.res.openURL(FACEBOOK_URL)
end

function gotoTwitter()
	logFlurryEvent("Twitter link clicked")
	_G.res.openURL(TWITTER_URL)
end

function gotoAngryBirdsTrailer()
	--logFlurryEvent("Trailer link clicked")
	_G.res.openURL(ANGRY_BIRDS_TRAILER_URL)
	
	--playVideo( "videos/lite_iPhone.m4v" )
end

function bingSearchGE(keyword)
	bingButtonSearchParams = {}
	bingButtonSearchParams["Keyword"] = keyword
	logFlurryEventWithParams("Bing button search clicked", "bingButtonSearchParams")
	_G.res.openURL(BING_SEARCH_URL..""..keyword)
end

function gotoNewsletter(dt)
	print("gotoNewsletter\n")
	setGameMode(updateMenu)
	setActiveMenuPage(episodeSelectionPage, true)
	drawMenu()
	_G.res.openURL(NEWSLETTER_URL)
	logFlurryEvent("Newsletter link clicked")
end

function gotoHalloweenInAppStore(dt)
	print("gotoHalloweenInAppStore\n")
	setGameMode(updateMenu)
	setActiveMenuPage(episodeSelectionPage, true)
	drawMenu()
	logFlurryEvent("Halloween link clicked")
	_G.res.openURL(APP_STORE_HALLOWEEN_URL)
end

function gotoOviStore(dt)
	if deviceModel == "n900" then
		_G.res.openURL(OVI_STORE_URL)
	elseif deviceModel == "s60" then
		_G.res.openURL(OVI_STORE_URL_S60)
	end
	setGameMode(updateMenu)
end

function gotoS60UpdatePage()
	_G.res.openURL(ROVIO_UPDATE_URL_S60 .. _G.res.getLocale())
end

function gotoMoreOnOviStore()
	_G.res.openURL(OVI_STORE_MORE_GAMES_URL_S60)
	removePopupMenu()
end


function showTutorials()
	if rovioNewsIsShown then
		rovioNews:hide()
		rovioNewsIsShown = false
	end
	rovioNewsShowWhenLoaded = false
	
	logFlurryEvent("Tutorials viewed")

	if settings.tutorials["BIRD_RED"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_RED"].sprite)
	end
	if settings.tutorials["BIRD_BLUE"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_BLUE"].sprite)
	end
	if settings.tutorials["BIRD_YELLOW"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_YELLOW"].sprite)
	end
	if settings.tutorials["BIRD_GREY"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_GREY"].sprite)
	end
	if settings.tutorials["BIRD_GREEN"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_GREEN"].sprite)
		if not isLiteVersion then
			showTutorialGoldenEgg = true
		end
	end
	if settings.tutorials["BIRD_BOOMERANG"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_BOOMERANG"].sprite)
	end
	if settings.tutorials["BIRD_BIG_BROTHER"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BIRD_BIG_BROTHER"].sprite)
	end
	if settings.tutorials["BAIT_SARDINE"] ~= nil then
		_G.table.insert(birdTutorialPopups, settings.tutorials["BAIT_SARDINE"].sprite)
	end
	setGameMode(hidePauseMenu)
	pausePage.backgroundOverlay.shade = 0
	if #birdTutorialPopups > 0 then
		prepareMenuPage(tutorials)
	end
	drawMenu()
end

--[[
function changeVibra()
	if settings.vibraEnabled ~= false then
		settingsPage.items[5].visible = true
		pausePage.items[5].visible = true
		settings.vibraEnabled = false
	else
		settingsPage.items[5].visible = false
		pausePage.items[5].visible = false
		settings.vibraEnabled = true	
	end
	saveLuaFileWrapper("settings.lua", "settings", true)
end
--]]

-- function changeLanguage()
	-- currentLanguageId = currentLanguageId + 1
	-- if currentLanguageId > #languageNames then
		-- currentLanguageId = 1
	-- end

	-- currentLanguage = languageNames[currentLanguageId]
	-- --print("current language " .. currentLanguage .. "\n")
	-- settings.currentLanguage = languageNames[currentLanguageId]
	-- settingsPage.items[5].sprite = languageSprites[settings.currentLanguage]
	-- _G.res.loadLocale("TEXTS_BASIC", settings.currentLanguage)
	-- _G.res.useLocale(settings.currentLanguage)		
-- end

function addPopupMenu()
end

function removePopupMenu()
end

function animateBirds(dt)
	local itemsPerCategory = 0.75
	local itemsInTotal = #birdSprites * itemsPerCategory
	
	if #birdAnimations < itemsInTotal and _G.math.random(1,5) == 1 then
		local layer = _G.math.random(3, 5)
		local tx = _G.math.random(-screenWidth * 0.75, screenWidth * 0.75)
		local ty = screenHeight + 30*screenHeight / 320
		
		local scale = layer * 0.2
		local txVel = _G.math.random(100, 350) * scale * (screenWidth / 480 + 1) / 2
		local tyVel = _G.math.random(-400, -150) * scale * (screenHeight / 320 + 1) / 2
		
		if layer == 1 then
			tyVel = tyVel * 1.75 
			txVel = txVel * 1.75 
		end		
		
		local tempBirdSprite = birdSprites[_G.math.random(#birdSprites)]
		local sprite = tempBirdSprite.sprite
		local sheet = tempBirdSprite.sheet
		local reward = tempBirdSprite.reward
		local angleSpeed = 0
		
		local _, spriteHeight = _G.res.getSpriteBounds("", sprite)
		if reward == 1 then
			angleSpeed = _G.math.random() * _G.math.pi * 1.5
		elseif reward == 2 then
			tx = _G.math.random(screenWidth * 0.1, screenWidth * 0.9)
			tyVel = _G.math.random(-250, -150) * scale * (screenHeight / 320 + 1) * 0.175
			txVel = 0
		end

		_G.table.insert(birdAnimations, { sheet = sheet, sprite = sprite, angle = 0, angleSpeed = angleSpeed, x = tx, y = ty, xVel = txVel, yVel = tyVel, scale = scale, layer = layer, spriteHeight = spriteHeight, reward = reward} )
	end

	for i = #birdAnimations, 1, -1 do
		local v = birdAnimations[i]
		if v.reward == 2 then -- balloon movement
			v.angle = _G.math.sin(v.angleSpeed) * 0.15
			v.angleSpeed = (v.angleSpeed + dt * 2) % (_G.math.pi * 2)
			v.x = v.x - v.angle * v.layer / 2
		else
			v.yVel = v.yVel + 150*dt
			v.angle = v.angle + v.angleSpeed * dt
		end
		v.x = v.x + v.xVel * dt
		v.y = v.y + v.yVel * dt
		
		if v.y > screenHeight + 50 * screenHeight / 320 or ((v.reward == 2 or v.reward == 2) and v.y < -v.spriteHeight) then
			_G.table.remove(birdAnimations, i)
		end 
		
	end
	
	if keyPressed["LBUTTON"] and currentMenuPage ~= about then
		for i = 1, #birdAnimations do
			if birdAnimations[i].layer == 5 then
				birdAnimations[i].renderState = true
				if SpriteItem.checkBounds(birdAnimations[i], cursor.x, cursor.y) 
				   and birdAnimations[i].yelling ~= true 
				   and _G.string.sub(birdAnimations[i].sprite, 1, 4) == "BIRD" then
					birdAnimations[i].yelling = true
					_G.res.playAudio(birdSpriteSoundMapping[birdAnimations[i].sprite], 1.0, false, 0)
					birdAnimations[i].sprite = birdAnimations[i].sprite .. "_YELL"
				end
			end
		end
	end
	
end

-------------------------------------------------------------------------------

-- This function only draws the menu without any logic
function drawMenu(dt)
	
	-- Draw background image
	if currentMenuPage == mainMenu or currentMenuPage == about or currentMenuPage == settingsPage then
		local xs = 1
		local ys = 1
	
		-- draw main menu theme according to the last theme played
		episode4BGCranes = { startX = 64 }
		local bW, bH = _G.res.getSpriteBounds("","BUTTON_EMPTY")
						
		local worldScale = (0.5 * screenHeight / 400) / (currentZoomLevelMainMenu * 0.66)
		local topCamera = (-2*screenHeight) / (screenHeight / (450 * currentZoomLevelMainMenu * 0.605)) + ((bH * 2.15 )/ (screenHeight / (450 * currentZoomLevelMainMenu * 0.5)))
		setTopLeft(50*time,topCamera )
		setWorldScale(worldScale)
		
		setTheme(currentMainMenuTheme)
		if settings.gfxLowQuality == false or settings.gfxLowQuality == nil then
			drawBackgroundNative()	
		end	
		--setWorldScale(0.5)
		--setTopLeft(50*time,-2*screenHeight + bH * 1.6 )
		-- draw birds, rewards..
		for k, v in _G.pairs(birdAnimations) do
			if v.layer == 3 then
				local scale = v.scale * 0.45
				setRenderState(0, 0, scale, scale, v.angle, _G.res.getSpritePivot(v.sheet, v.sprite))
				_G.res.drawSprite(v.sheet, v.sprite, _G.math.floor(v.x/scale), _G.math.floor(v.y/scale - screenHeight * 0.2 / v.scale))
			end
		end	
		
	
		for k, v in _G.pairs(birdAnimations) do
			if v.layer == 4 then
				local scale = v.scale * 0.6
				setRenderState(0, 0, scale, scale, v.angle, _G.res.getSpritePivot(v.sheet, v.sprite))
				_G.res.drawSprite(v.sheet, v.sprite, _G.math.floor(v.x/scale), _G.math.floor(v.y/scale - screenHeight * 0.125 / v.scale))
			end
		end		
		
		
		for k, v in _G.pairs(birdAnimations) do
			if v.layer == 5 then
				local scale = v.scale * 0.75
				setRenderState(0, 0,scale, scale, v.angle, _G.res.getSpritePivot(v.sheet, v.sprite))
				_G.res.drawSprite(v.sheet, v.sprite, _G.math.floor(v.x/scale), _G.math.floor(v.y/scale))
			end
		end	
		
		drawForegroundNative()
		-- end of main menu draw 
	
		setRenderState(0, 0, 1, 1, 0, 0, 0)
		drawMenuPage(mainMenu)

		local loaderLB = getItemByName(mainMenu.items, "loaderLB")
		local loaderAC = getItemByName(mainMenu.items, "loaderAC")
		local lW, lH = _G.res.getSpriteBounds("", loaderLB.sprite)
		if loaderLB.show and dt then
			local px, py = _G.res.getSpritePivot("", loaderLB.sprite)
			loaderLB.angle = loaderLB.angle + 10 * dt
			
			 if deviceModel == "ipad" then
				setRenderState(0, 0, 1, 1, loaderLB.angle, px, py)
				--setRenderState(0, 0, 1, 1, loaderLB.angle, px - 2, py - 3)
				_G.res.drawSprite("", loaderLB.sprite, loaderLB.x, loaderLB.y)
			 else
				setRenderState(0, 0, 1, 1, loaderLB.angle, px, py)
				--setRenderState(0, 0, 1, 1, loaderLB.angle, px - 1, py - 1)
				_G.res.drawSprite("", loaderLB.sprite, loaderLB.x + 1, loaderLB.y + 1)
			 end			
		end
		
		if loaderAC.show and dt then
			
			local px, py = _G.res.getSpritePivot("", loaderAC.sprite)
			loaderAC.angle = loaderAC.angle + 10 * dt
			 if deviceModel == "ipad" then
				setRenderState(0, 0, 1, 1, loaderAC.angle, px, py)
				--setRenderState(0, 0, 1, 1, loaderAC.angle, px - 2, py - 3)
				_G.res.drawSprite("", loaderAC.sprite, loaderAC.x, loaderAC.y)
			 else
				setRenderState(0, 0, 1, 1, loaderAC.angle, px, py)
				--setRenderState(0, 0, 1, 1, loaderAC.angle, px - 1, py - 1)
				_G.res.drawSprite("", loaderAC.sprite, loaderAC.x + 1, loaderAC.y + 1)
			 end	
		end
		if elementAnimations.aboutPageScroll.percentage > 0 then
			setRenderState(0, 0, 1, ys, 0)
			drawAboutPage()
		end
		-- settingsPage.backgroundOverlay.visible = false
		-- settingsPage.items[7].visible = false
		-- if currentMenuPage == settingsPage then
			-- settingsPage.items[7].visible = true
			-- settingsPage.backgroundOverlay.visible = true
		-- end	
		
		setRenderState(0, 0, 1, ys, 0)
		drawSettingsPage()
	--elseif currentMenuPage == levelComplete and deviceModel == "s60" then 
	elseif currentMenuPage == levelComplete then -- japanese version
		drawMenuPage(currentMenuPage)
		local newHighScore = getItemByName(currentMenuPage.items, "newHighScore")
		if newHighScore.visible == true and inExtraWorld ~= true then
			local spriteName = _G.res.getString("TEXTS_BASIC", "TEXT_HIGHSCORE_SPRITE")
			setRenderState(0, 0, 1, 1, 0.471238898, _G.res.getSpritePivot("", spriteName))
			_G.res.drawSprite("", spriteName, newHighScore.x+2, newHighScore.y-2)
			setRenderState(0, 0, 1, 1, 0, 0, 0)
		end
	else
		drawMenuPage(currentMenuPage)
	end
	
	--[[local testBoxSprites = { --topLeft = "POPUP_TOP_LEFT", 
							 --topMiddle = "POPUP_TOP_MIDDLE", 
							 --topRight = "POPUP_TOP_RIGHT",
							 
							 left = "ACHIEVEMENT_BG_LEFT", 
							 right = "ACHIEVEMENT_BG_RIGHT",
							 
							 --bottomLeft = "POPUP_BOTTOM_LEFT", 
							 --bottomMiddle = "POPUP_BOTTOM_MIDDLE", 
							 --bottomRight = "POPUP_BOTTOM_RIGHT",
							 
							 center = "ACHIEVEMENT_BG_MIDDLE",}

	drawBox(testBoxSprites, "", screenWidth / 2, screenHeight / 2, _G.math.floor(cos(time)*200+200), _G.math.floor(sin(time)*200+200), "HCENTER", "VCENTER", nil)
	--]]
	if popupPage ~= nil then
		drawMenuPage(popupPage)
	end
	
	if loading then
		if rovioNewsIsShown then
			rovioNews:hide()
			rovioNewsIsShown = false
		end
		rovioNewsShowWhenLoaded = false
		
		prepareMenuPage(loadingPage)
		drawMenuPage(loadingPage)
	end
	
	if (deviceModel == "n900" or deviceModel == "s60") and currentMenuPage.animationState == nil and currentMenuPage ~= upsellPage and currentMenuPage ~= pausePage then
		drawMenuPage(overlayMenuPage)	
	elseif deviceModel == "android" and isBetaVersion then
		drawMenuPage(overlayMenuPage)
	end
end


function drawMenuPage(page)
	
	if page == nil then
		return
	end
	
	-- if page.prepared ~= true then
		-- print("MenuPage not prepared! " .. page.name .. "\n")
	-- end
	
	-- gamecenter achievement popups need to be scaled 2x when in retina resolution
	if page == achievementPopUpPage and deviceModel == "iphone4" and ((changeResolution ~= true and wantedResolution == "FULL") or (changeResolution == true and wantedResolution == "HALF")) then
		setRenderState(-screenWidth * 0.5, -screenHeight * 0.5, 2, 2, 0)
	else
		setRenderState(0, 0, 1, 1, 0)
	end
	if page.backgroundDrawFunction ~= nil then
		page.backgroundDrawFunction(page)
	end
	
	if page.backgroundOverlay ~= nil then
		if page.backgroundOverlay.sprite ~= nil and page.backgroundOverlay.visible ~= false then
			if page.backgroundOverlay.sprite == "DIM_BLOCK" and page.backgroundOverlay.shade ~= nil then
				if page.backgroundOverlay.shade ~= 0 then
					drawRect( 0, 0, 0, page.backgroundOverlay.shade, 0, 0, screenWidth, screenHeight, false)
				end
			else
				w, h = _G.res.getSpriteBounds("", page.backgroundOverlay.sprite)
				for y = 0, screenHeight/h do
					for x = 0, screenWidth/w do
						_G.res.drawSprite("", page.backgroundOverlay.sprite, _G.math.floor(x*w), _G.math.floor(y*h))
					end
				end
			end
		end
	end

	drawMenuBackground(page)
	
	
	drawMenuItems(page)
	drawMenuTitle(page)	
	setRenderState(0, 0, 1, 1, 0)
end

function drawMenuBackground(page)

	if page.backgroundBox ~= nil then
		local sx, sy = 0, 0

		if page.backgroundBox.x ~= nil then
			sx = page.backgroundBox.x
		end
		if page.backgroundBox.y ~= nil then
			sy = page.backgroundBox.y
		end
		
		local x, y = offsetCoordinates(page, sx, sy)
		local sheet = ""
		if page.backgroundBox.sheet ~= nil then
			sheet = page.backgroundBox.sheet
		end
		
		setRenderState(0, 0, 1, 1, 0, 0, 0)
		if page.backgroundBox.color ~= nil then
			local r,g,b,a = 1.0, 1.0, 1.0, 1.0
			if page.backgroundBox.color.red ~= nil then
				r = page.backgroundBox.color.red
			end
			if page.backgroundBox.color.green ~= nil then
				g = page.backgroundBox.color.green
			end
			if page.backgroundBox.color.blue ~= nil then
				b = page.backgroundBox.color.blue
			end
			if page.backgroundBox.color.alpha ~= nil then
				a = page.backgroundBox.color.alpha
			end
			
			drawBox(page.backgroundBox.sprites, sheet, _G.math.floor(x), _G.math.floor(y), _G.math.floor(page.backgroundBox.width), _G.math.floor(page.backgroundBox.height), page.backgroundBox.hanchor, page.backgroundBox.vanchor, { red = r, green = g, blue = b, alpha = a })
		else
			drawBox(page.backgroundBox.sprites, sheet, _G.math.floor(x), _G.math.floor(y), _G.math.floor(page.backgroundBox.width), _G.math.floor(page.backgroundBox.height), page.backgroundBox.hanchor, page.backgroundBox.vanchor, nil)
		end
	
	elseif page.backgroundSprite ~= nil then
		if page.backgroundSprite.scale and page.backgroundSprite.xs and page.backgroundSprite.ys then
			setRenderState(0, 0, page.backgroundSprite.xs, page.backgroundSprite.ys, 0)
			_G.res.drawSprite("", page.backgroundSprite.name, _G.math.floor(page.backgroundSprite.x) / page.backgroundSprite.xs, _G.math.floor(page.backgroundSprite.y) / page.backgroundSprite.ys)
			setRenderState(0, 0, 1, 1, 0)
		else
			local sx, sy = 0, 0

			if page.backgroundSprite.x ~= nil then
				sx = page.backgroundSprite.x
			end
			if page.backgroundSprite.y ~= nil then
				sy = page.backgroundSprite.y
			end
			
			local x, y = offsetCoordinates(page, sx, sy)
				
			setRenderState(0, 0, 1, 1, 0)
			_G.res.drawSprite("", page.backgroundSprite.name, _G.math.floor(x), _G.math.floor(y))
		end
	end
end

function drawMenuTitle(page)
	if page.title == nil then
		return
	end
	
	local title = page.title
	
	local x = 0
	local y = 0
	
	if title.text ~= nil then
		x = screenWidth * 0.5
		y = (_G.res.getFontMaxAscending() + _G.res.getFontMaxDescending()) * 0.75
	end
	
	if title.x ~= nil then
		x = title.x
	end		
	if title.y ~= nil then
		y = title.y
	end		

	x, y = offsetCoordinates(page, x, y)

	setRenderState(0, 0, 1, 1, 0)
	if title.text ~= nil then
		local hanchor = "HCENTER"
		local vanchor = "VCENTER"
		hanchor = title.hanchor and title.hanchor or hanchor
		vanchor = title.vanchor and title.vanchor or vanchor
		
		--[[if deviceModel == "s60" then
			setFont(defaultMenuFont)
		else
			setFont(fontMenu)
		end--]]
		setFont(defaultMenuFont) --japanese version

		if title.font ~= nil then
			setFont(title.font)
		end
		_G.res.drawString("TEXTS_BASIC", title.text, _G.math.floor(x), _G.math.floor(y), hanchor, vanchor)
	end

	if title.sprite ~= nil then
		_G.res.drawSprite("", title.sprite, _G.math.floor(x), _G.math.floor(y))
	end
end

function drawMenuItems(page)
																																																								-- ADDED
	if (page == levelSelectionPagesBasic or page == levelSelectionPagesExtra or page == levelSelectionPagesPack3 or page == levelSelectionPagesPack4 or page == levelSelectionPagesPack4 or page == levelSelectionPagesPack5 or page == levelSelectionPagesPack6) then
		return drawLevelSelectionItems(page)
	end
	
	-- check if user want's to draw one whole item at a time or all sprites (and boxes) first and then text
	local drawSprites = true
	local drawText = true
	local loops = 0
	if page.drawSpritesFirst == true then
		drawText = false
		loops = 1
	end
	
	if levelSelectionPagesGoldenEggs and page == levelSelectionPagesGoldenEggs[1] then
		-- draw effect for new golden egg levels
		setRenderState(0, 0, 1, 1, goldenEggsStarEffectAngle, _G.res.getSpritePivot("", "GOLDEN_EGG_STAR_EFFECT"))
		for i = 1, page.levelCount do
			if settings.openGoldenEggLevels["Level" .. i] == 0 then
				_G.res.drawSprite("", "GOLDEN_EGG_STAR_EFFECT", page.items[levelSelectionPagesGoldenEggs[1].firstLevelIndex - 1 + i].x, page.items[levelSelectionPagesGoldenEggs[1].firstLevelIndex - 1 + i].y)
			end
		end
		setRenderState(0, 0, 1, 1, 0)
	end
	
	if (page == goldenEggAchievedPage or page == boomerangBirdAchievedPage) and page.items[1].visible == true then
		local starEffectSprite = "GOLDEN_EGG_STAR_EFFECT"
		setRenderState(0, 0, 1, 1, page.items[1].angle, _G.res.getSpritePivot("", starEffectSprite))
		_G.res.drawSprite("", starEffectSprite, page.items[1].x, page.items[1].y)
		setRenderState(0, 0, 1, 1, 0)
	end
	
	--[[if page == boomerangBirdAchievedPage and page.items[1].visible == true then
		local starEffectSprite = "GOLDEN_EGG_STAR_EFFECT"
		setRenderState(0, 0, 1, 1, page.items[1].angle, _G.res.getSpritePivot("", starEffectSprite))
		_G.res.drawSprite("", starEffectSprite, page.items[1].x, page.items[1].y)
		setRenderState(0, 0, 1, 1, 0)
	end]]
	
	if page == mightyEaglePaymentPage and page.items[1].angle < 1080 then		
		setRenderState(0, 0, 1, 1, page.items[1].angle, _G.res.getSpritePivot("", page.items[1].sprite))
		_G.res.drawSprite("", page.items[1].sprite, page.items[1].x, page.items[1].y)
		setRenderState(0, 0, 1, 1, 0)
	end
	
	if page == goldenEggStarAchievedPage and page.items[1].visible == true and page.items[2].visible == true then
		local starEffectSprite = "GOLDEN_EGG_STAR_EFFECT"
		setRenderState(0, 0, 1, 1, page.items[1].angle, _G.res.getSpritePivot("", starEffectSprite))
		_G.res.drawSprite("", starEffectSprite, page.items[1].x, page.items[1].y)
		setRenderState(0, 0, 1, 1, 0)
	end
	
	-- draw normal menu items
	for k = 0, loops do
		local i = 1
		while i <= #page.items do
			local ci = page.items[i]
			if ci.visible ~= false then
				-- calculate position
				local x = screenWidth/2
				local y = screenHeight/(#page.items + 1) * i
				x = ci.x and ci.x or x
				y = ci.y and ci.y or y
				x, y = offsetCoordinates(page, x, y)
				if ci.itemDrawFunction ~= nil then
					ci.itemDrawFunction(page, ci, x, y, drawSprites, drawText)
				else
					drawMenuItem(page, ci, _G.math.floor(x), _G.math.floor(y), drawSprites, drawText)
				end
			end
			i = i + 1
		end
		drawSprites = not drawSprites
		drawText = not drawText
	end
end

function drawMenuItem(page, item, x, y, drawSprites, drawText)
	
	if item.visible == false then
		return
	end
	
	local ci = item
	
	-- get anchor data
	local hanchor = ci.hanchor and ci.hanchor or "HCENTER"
	local vanchor = ci.vanchor and ci.vanchor or "VCENTER"

	-- local xs = 1
	-- local ys = 1
	-- local angle = 0
	
	-- if item.xs ~= nil then xs = item.xs	end
	-- if item.ys ~= nil then ys = item.ys	end
	-- if item.angle ~= nil then angle = item.angle	end
	
	-- setRenderState(0, 0, xs, ys, angle)
	
	if drawSprites == true then
		if ci.sprite ~= nil then
			local sheet = ""
			if ci.sheet ~= nil then
				sheet = ci.sheet
			end
			if page.scale and page.xs and page.ys then
				if ci.isCompoSprite then
					setRenderState(0, 0, page.xs, page.ys)
					_G.res.drawCompoSprite("", ci.sprite, _G.math.floor(x) / page.xs, _G.math.floor(y) / page.ys)
					setRenderState(0, 0, 1, 1)
				else
					setRenderState(0, 0, page.xs, page.ys)
					_G.res.drawSprite(sheet, ci.sprite, _G.math.floor(x) / page.xs, _G.math.floor(y) / page.ys)
					setRenderState(0, 0, 1, 1)
				end
			else
				if ci.isCompoSprite then
					_G.res.drawCompoSprite("", ci.sprite, _G.math.floor(x), _G.math.floor(y))
				else
					_G.res.drawSprite(sheet, ci.sprite, _G.math.floor(x), _G.math.floor(y))
				end
			end
		elseif ci.box ~= nil then
			
			local sheet = ""
			if ci.sheet ~= nil then
				sheet = ci.sheet
			end
			
			if ci.color ~= nil then
				local r,g,b,a = 1.0, 1.0, 1.0, 1.0
				if ci.color.red ~= nil then
					r = ci.color.red
				end
				if ci.color.green ~= nil then
					g = ci.color.green
				end
				if ci.color.blue ~= nil then
					b = ci.color.blue
				end
				if ci.color.alpha ~= nil then
					a = ci.color.alpha
				end
				
				drawBox(ci.box, sheet, _G.math.floor(x), _G.math.floor(y), _G.math.floor(ci.width), _G.math.floor(ci.height), ci.hanchor, ci.vanchor, { red = r, green = g, blue = b, alpha = a })
			else
				drawBox(ci.box, sheet, _G.math.floor(x), _G.math.floor(y), _G.math.floor(ci.width), _G.math.floor(ci.height), ci.hanchor, ci.vanchor, nil)
			end
		end
	end
	
	if drawText == true then
		if ci.lines ~= nil then
			--check font
			setFont(ci.font)

			local fh = _G.res.getFontLeading()			
			local k = 1
			while k <= #ci.lines do
				_G.res.drawString("", ci.lines[k], _G.math.floor(x), _G.math.floor(y - ci.h * 0.5 + fh * (k-0.5)), hanchor, vanchor)
				k = k + 1
			end			
		end
	end
	
	if ci.children ~= nil then
		for i = 1, #ci.children do
			local childItem = ci.children[i]
--			if(childItem.name ~= nil) then
	--			print("name = "..(childItem.name).."\n")
		--	end
			drawMenuItem(page, childItem, childItem.x + x, childItem.y + y, drawSprites, drawText)
		end
	end
end

function drawLevelSelectionItems(page)
	local i = 1
	
	while i <= #page.items do
		local ci = page.items[i]
		if ci.visible ~= false and ci.sprite then-- and ci.name == nil then
			local sheet = ci.sheet or ""
			if not ci.filename or ci.x >= 0 - ci.spriteWidth and ci.x <= screenWidth + ci.spriteWidth then 
				_G.res.drawSprite(sheet, ci.sprite, _G.math.floor(ci.x), _G.math.floor(ci.y))
				--[[if settings.mightyEagleEnabled then
					for k, v in _G.pairs(settings.eaglesUsedIn) do
						if v.world == ci.worldNumber and v.level == ci.pageLevelIndex then
							_G.res.drawSprite("LEVELSELECTION_SHEET_1", "LS_EAGLE_BUTTON", _G.math.floor(ci.x), _G.math.floor(ci.y))
						end
					end
				end]]
			end
		end
		i = i + 1
	end
	
	for i = 1, #levelSelectionButtonIndeces do
		local ci = page.items[levelSelectionButtonIndeces[i].index]
		if ci.visible ~= false and ci.x >= 0 - ci.spriteWidth and ci.x <= screenWidth + ci.spriteWidth then	
			if levelSelectionButtonIndeces[i].eagleUsed then
				_G.res.drawSprite("LEVELSELECTION_SHEET_1", "LS_EAGLE_BUTTON", _G.math.floor(ci.x), _G.math.floor(ci.y))
			end
			if levelSelectionButtonIndeces[i].starSprite then
				_G.res.drawSprite("LEVELSELECTION_SHEET_1", levelSelectionButtonIndeces[i].starSprite, _G.math.floor(ci.x), _G.math.floor(ci.y + ci.spriteHeight * 0.5))			
			end
			if levelSelectionButtonIndeces[i].featherSprite ~= nil then
				_G.res.drawSprite("LEVELSELECTION_SHEET_1", levelSelectionButtonIndeces[i].featherSprite, _G.math.floor(ci.x), _G.math.floor(ci.y))			
			end
		end
	end
			
	for i = 1, #levelSelectionButtonIndeces do
		local ci = page.items[levelSelectionButtonIndeces[i].index]
		if ci.text ~= nil and ci.visible ~= false and ci.lines and ci.x >= 0 - ci.spriteWidth and ci.x <= screenWidth + ci.spriteWidth and (levelSelectionButtonIndeces[i].eagleUsed ~= true or settings.mightyEagleEnabled ~= true) then
			setFont(ci.font)
			_G.res.drawString("", ci.lines[1], _G.math.floor(ci.x), _G.math.floor(ci.y), "HCENTER", "VCENTER")
		end
	end
	
	if deviceModel == "n900" and page == levelSelectionPagesBasic and getItemByName(page.items, "overlay").visible then
		local itm = getItemByName(page.items, "overlay")
		drawRect( 0, 0, 0, itm.shade, itm.x, itm.y, screenWidth, screenHeight, false)
		itm = getItemByName(page.items, "button1")
		_G.res.drawSprite(itm.sheet, itm.sprite, itm.x, itm.y)
		itm = getItemByName(page.items, "button2")
		_G.res.drawSprite(itm.sheet, itm.sprite, itm.x, itm.y)
	end
	
	
	local _, textIndex = getItemByName(page.items, "text_" .. page.themes[1])
	for i = textIndex, page.pageCount + textIndex - 1 do
		local numberText = page.items[i]
		if numberText.visible and numberText.lines then
			setFont(numberText.font)
			_G.res.drawString("", numberText.lines[1], numberText.x, numberText.y, "HCENTER", "VCENTER")
		end
	end
		
end

function goldenEggMenuDimDraw(page, item, x, y, drawSprites, drawText)
	if getItemByName(page.items, "overlay").visible then
		local itm = getItemByName(page.items, "overlay")
		drawRect( 0, 0, 0, itm.shade, itm.x, itm.y, screenWidth, screenHeight, false)
	end
end

function bingSignDraw(page, item, x, y, drawSprites, drawText)
	local ci = item
	local buttonSprite = "BING_SIGN"
	if ci.sprite ~= nil then
		buttonSprite = ci.sprite
	end
	setRenderState(0, 0, 1, 1, ci.angle, _G.res.getSpritePivot("", buttonSprite))
	_G.res.drawSprite("", buttonSprite, ci.x, ci.y)
	setRenderState(0, 0, 1, 1, 0)	
end

-- Menu stuff ends
-------------------------------------------------------------------------------

function drawLevelSelectionBackground(page)
	setRenderState(0, 0, -1, 1, 0)
	_G.res.drawSprite("", "LS_BACKGROUND", -screenWidth, 0, "LEFT", "TOP", _G.math.ceil(screenWidth / 2), screenHeight)
	setRenderState(0, 0, 1, 1, 0)
	_G.res.drawSprite("", "LS_BACKGROUND", 0, 0, "LEFT", "TOP", _G.math.floor(screenWidth / 2), screenHeight)
	setRenderState(0, 0, 1, 1, 0)	
end

function drawAboutPage()
	drawMenuPage(about)
end

function drawSettingsPage()
	drawMenuPage(settingsPage)
end

function starEffectItemDraw(page, item, x, y, drawSprites, drawText)
	local ci = item
	local starEffectSprite = "GOLDEN_EGG_STAR_EFFECT"
	if ci.sprite ~= nil then
		starEffectSprite = ci.sprite
	end
	setRenderState(0, 0, 1, 1, ci.angle, _G.res.getSpritePivot("", starEffectSprite))
	_G.res.drawSprite("", starEffectSprite, ci.x, ci.y)
	setRenderState(0, 0, 1, 1, 0)
--	ci.angle = ci.angle + 1.6 * dt
end

function buttonSliderDraw(page, item, x, y, drawSprites, drawText)
	local ci = item
	local buttonSprite = "BUTTON_OPTIONS"
	if ci.sprite ~= nil then
	buttonSprite = ci.sprite
	end
	local px, py = _G.res.getSpritePivot("", buttonSprite)
	if deviceModel == "ipad" then
	setRenderState(0, 0, 1, 1, ci.angle, px, py)
	_G.res.drawSprite("", buttonSprite, ci.x, ci.y)
	else
	setRenderState(0, 0, 1, 1, ci.angle, px - 0.5, py - 0.5)
	_G.res.drawSprite("", buttonSprite, ci.x, ci.y + 1)
	end
	setRenderState(0, 0, 1, 1, 0)	
end

function buttonSliderOptionsDraw(page, item, x, y, drawSprites, drawText)
	local ci = item
	local buttonSprite = "BUTTON_SLIDER"
	if ci.sprite ~= nil then
		buttonSprite = ci.sprite
	end
	
	local px, py = _G.res.getSpritePivot("", buttonSprite)
	if deviceModel == "ipad" or (deviceModel == "android" and isHDVersion) then
		setRenderState(0, 0, 1, 1, ci.angle, px + 0.25, py - 0.5)
		_G.res.drawSprite("", buttonSprite, ci.x, ci.y)
	else
		setRenderState(0, 0, 1, 1, ci.angle, px + 0.5, py + 0.5)
		_G.res.drawSprite("", buttonSprite, ci.x, ci.y)
	end
	setRenderState(0, 0, 1, 1, 0)	
end

function eagleFeatherFillDraw(page, item, x, y, drawSprites, drawText)
	local ci = item
	local fillEffectSprite = "EAGLE_METER_FILL"
	if ci.sprite ~= nil then
		fillEffectSprite = ci.sprite
	end
	local w, h = _G.res.getSpriteBounds("", fillEffectSprite)
	local px, py = _G.res.getSpritePivot("", fillEffectSprite)
	local left = x - px
	local top = y - py
	
	_G.res.setClipRect(left, 0, _G.math.floor(w * (ci.fill / 100)), screenHeight)
	_G.res.drawSprite("", fillEffectSprite, ci.x, ci.y)
	_G.res.setClipRect(0, 0, screenWidth, screenHeight)
end
-------------------------------------------------------------------------------

function filterLoadedLevel()
	if currentGameMode ~= updateEditor then
		if currentLevelNumberInTheme == 7 and currentWorldNumber == 4 then
			if settings.openGoldenEggLevels["Level9"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 19 and currentWorldNumber == 5 then
			if settings.openGoldenEggLevels["Level2"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 15 and currentWorldNumber == 8 then
			if settings.openGoldenEggLevels["Level13"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if (currentLevelNumberInTheme == 4 and currentWorldNumber == 6 and settings.boomerangBirdAchieved == true) or 
		   (currentLevelNumberInTheme == 5 and currentWorldNumber == 9 and settings.boomerangBirdAchieved2 == true) then
			loadedObjects.world["ExtraBoomerangBird_1"] = nil
		end
		
		if currentLevelNumberInTheme == 14 and currentWorldNumber == 9 then
			if settings.openGoldenEggLevels["Level14"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 15 and currentWorldNumber == 11 then
			if settings.openGoldenEggLevels["Level16"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 10 and currentWorldNumber == 13 then
			if settings.openGoldenEggLevels["Level19"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 12 and currentWorldNumber == 13 then
			if settings.openGoldenEggLevels["Level22"] then
				loadedObjects.world["ExtraSuperBowl_2"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraSuperBowl_2" or v.end2 == "ExtraSuperBowl_2" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 4 and currentWorldNumber == 14 then
			if settings.openGoldenEggLevels["Level20"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end

		
		--[[		
			15-12 - Level695 - ExtraGoldenEgg_1 -> LevelGE_20
			16-9 - Level697 - ExtraGoldenEgg_1 -> LevelGE_21
			17-12 - LevelP6_7 - ExtraTreasureChest_1 -> LevelGE_22		
		]]
		
		if currentLevelNumberInTheme == 12 and currentWorldNumber == 15 then
			if settings.openGoldenEggLevels["Level23"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		

		if currentLevelNumberInTheme == 9 and currentWorldNumber == 16 then
			if settings.openGoldenEggLevels["Level22"] then
				loadedObjects.world["ExtraGoldenEgg_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraGoldenEgg_1" or v.end2 == "ExtraGoldenEgg_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end
		
		if currentLevelNumberInTheme == 12 and currentWorldNumber == 17 then
			if settings.openGoldenEggLevels["Level23"] then
				loadedObjects.world["ExtraTreasureChest_1"] = nil
				for k,v in _G.pairs(loadedObjects.joints) do
					if v.end1 == "ExtraTreasureChest_1" or v.end2 == "ExtraTreasureChest_1" then
						loadedObjects.joints[k] = nil
					end
				end
			end
		end	
	end
end

function loadLevelInternal(levelFileName)
	print("  ------------  LOAD LEVEL INTERNAL..\n")
	releaseCutScenes()
	prepareMenuPage(loadingPage)
	prepareMenuPage(tutorials)
	
	if rovioNewsIsShown then
		rovioNews:hide()
		rovioNewsIsShown = false
	end
	rovioNewsShowWhenLoaded = false
	
	--[[ BEGIN FPS DEBUG CODE --
	FPSFrames = 0
	FPSTime = 0
	FPSMin = nil
	FPSMax = nil
	drawFPSStatistics = false
	-- END FPS DEBUG CODE --]] 

	setAnimationState("ingamePausePageScroll", "HIDDEN")
	pausePage.offsetX = elementAnimations["ingamePausePageScroll"].percentage / 100 * pauseBGw - pauseBGw
	pausePage.backgroundOverlay.shade = elementAnimations["ingamePausePageScroll"].percentage / 100 * 0.65
	_G.res.stopAllAudio()
	-- print("-Object table-\n")
	-- for k, v in _G.pairs(objects) do
		-- print("Object: " .. k .. " - " .. v.name .. "\n")
	-- end
	
	quadClick = false
	quadClickCounter = 0	
	eagleBaitLaunched = false
	eagleTimer = nil
	cameraShake = nil
	
	editor = {drawOneLayer = false, currentLayer = 0}
	
	birdToSlingshotAnimationTimer = 0
	birdToSlingshotAnimationAngle = 135 / 180 * _G.math.pi
	birdToSlingshotSurplusAngle =  birdToSlingshotAnimationAngle - _G.math.pi * 0.5
	birdToSlingshotAnimationHeight = 0
	birdToSlingshotAnimationStartX = 0
	birdToSlingshotAnimationStartY = 0
	birdToSlingshotBirdName = nil	
	
	currentBirdIndex = 1
	currentBirdName = nil
	flyingBird = nil
	birdSpecialtyAvailable = false
	birdFired = false
	birdReady = false
	fillInNextBird = false
	birdSelected = false
	showTapIcon = true
	birdsShot = 0

	tapStarted = false
	tapCount = 0
	tapTimer = 0
	tapPosition = { x = 0, y = 0 }
	doubleClickTimer = 0
	levelCompleteTimer = 0
	levelCompleted = false
	levelFailedTimer = 0
	birdBuffTimer = 0
	castleCameraTimer = 0
	dragCursorIndex = 1
	dragCursorTable = { {dx = 0, dy = 0, dt = 1} }
	
	rubberBandAngle = 0
	rubberBandLength = 0
	oldRubberBandLength = 0

	cameraResetTimer = 0
	showTapTimer = 0
	nextBirdTimer = 0.5
	zoomLevel = 0
	oldZoomLevel = 0
	worldScale = 1
	oldScoreLen = 0
	
	sweepSpeed = 0
	particleAmount = 0
	
	levelLeftEdge = 100000
	levelRightEdge = -100000
	
	--local birdsCounter = 0
	birdsCounter = 0
	objectCounts = {}

	floatingScores = {}
	score = 0
	scoreTable = {}
	scoreTable.blocks = { score = 0, blockDestroyedScore = blockDestroyedScoreIncrement }
	scoreTable.birds = { score = 0 }
	
	selectedObjects = { }
	cameraTargetObject = nil
	allowResetToBirdCamera = false
	
	particles = {}
	birdTutorialPopups = {}
	showTutorialGoldenEgg = false
	deadBlocks = {}
	
	--print("-Load-\n")
	if objects.world ~= nil then
		if objects.world["MightyEagle_a"] ~= nil then
			removeObject("MightyEagle_a")
			objects.world["MightyEagle_a"] = nil
		end
		for k, v in _G.pairs(objects.world) do
			--print("Removing world object: " .. k .. "\n")
			objects.world[k] = nil
		end
	end

	birds = {}
	levelGoals = {}
	
	flyingGrenades = {}
	birdTrajectory = { {}, {}, {} }
	otherBirds = {}
	
	 --print("-Object table-\n")
	 --for k, v in _G.pairs(objects) do
		--print("Object: " .. k .. " - " .. v.name .. "\n")
	 --end

	--print("Loading level\n")
	
	--episode4BGCranes = { startX = (wx1 + wx2) * 0.5 }
	episode4BGCranes = { startX = 64 }
	
	eagleInfoTimer = nil
	oldEagleButtonStatusDisabled = false
	inGameEagleButtonVisible = false
	inGameEagleButtonScalingTimer = 0
	inGameEagleButtonScale = nil

	currentThemeIndex = 1

	objects.world = {}
	objects.joints = {}
	objects.counts = {}
	objects.themeSprites = {}
	objects.physicsToWorld = physicsToWorld
	objects.theme = "theme1"
	objects.castleCameraData = nil --{ px = 0, py = 0, sx = 1, sy = 1, }
	objects.birdCameraData = nil --{ px = 0, py = 0, sx = 1, sy = 1, }
	-- flyCameraData = { px = 0, py = 0, sx = 1, sy = 1, }
	
	-- Reset scale and screen position
	setWorldScale(worldScale)
	screen.x = 0
	screen.y = 0
	levelStartPosition.x = 0
	levelStartPosition.y = 0
	rubberBandPos.x = 0
	rubberBandPos.y = 0
	rubberBandSpeed = 0
	
	loadLevel(levelFileName)
	print(" - - - Level loaded \n")
	filterLoadedLevel()
	
	print(" - - - Filter loaded level done \n")
	-- level was not found
	if loadedObjects == nil then
		-- find the current theme based on the theme index in blocktable
		for k0, v0 in _G.pairs(blockTable.themes) do
			if v0.index ~= nil and v0.index == currentThemeIndex then
				currentTheme = k0
			end
		end		
		
		createBox("ground", "", (levelLeftEdge + levelRightEdge)*0.5, 5, 2000, 10, 0, 0.8, 0, true, false, 0)
		objects.world["ground"].material = "staticGround"
		objects.world["ground"].definition = "Ground"
		objects.world["ground"].strength = 30
		objects.world["ground"].defence = 1000000		
		print("Setting current theme to "..currentTheme.."\n")
		setTheme(currentTheme)
		themeSpriteObjects = {}
		return		
	end

	-- init counts table
	local countsSaved = false
	if loadedObjects.counts ~= nil then
		countsSaved = true
		for k, v in _G.pairs(loadedObjects.counts) do
			objects.counts[k] = v
		end
	end

	-- temp code for testing the right scale
	local pscale = 100
	if loadedObjects.physicsToWorld ~= nil then
		pscale = loadedObjects.physicsToWorld
	end
	scaleFactor = pscale/physicsToWorld
	
	
	-- handle theme
	if loadedObjects.theme ~= nil then
		objects.theme = loadedObjects.theme
		currentThemeIndex = blockTable.themes[objects.theme].index
		-- find the current theme based on the theme index in blocktable
		for k0, v0 in _G.pairs(blockTable.themes) do
			if v0.index ~= nil and v0.index == currentThemeIndex then
				currentTheme = k0
				settings.currentMainMenuTheme = k0
				local layersAmount = 0
				for l = 1, #v0.bgLayers do
					layersAmount = layersAmount + 1
					settings.currentZoomLevelMainMenu = v0.bgLayers[l][4] + settings.currentZoomLevelMainMenu
				end
				settings.currentZoomLevelMainMenu = settings.currentZoomLevelMainMenu /  layersAmount
				currentMusic = v0.music
				settings.currentMainMenuSong = "title_theme"
				currentMainMenuSong = "title_theme"
			end
		end
	end
	--print("Setting theme to "..currentTheme.."\n")
	--loadThemeGraphics(currentTheme)
	setTheme(currentTheme)
	
	themeSpriteObjects = {}
	print("Theme set\n")
	--print("Creating objects\n")
	if loadedObjects.world ~= nil then
		for k, v in _G.pairs(loadedObjects.world) do
			local obj = v
			-- quick fix to disable ground block creation from the level data
			if obj.name ~= "ground" then
				local name = createObject(blockTable, obj.definition, obj.name, obj.x*scaleFactor, obj.y*scaleFactor)

				-- clamp angle to 0 - 2*PI range
				obj.angle = _G.math.fmod(obj.angle, _G.math.pi*2)
				if obj.angle < 0 then
					obj.angle = obj.angle + _G.math.pi*2
				end
				
				setRotation(name, obj.angle)
				setMaterial(name, objects.world[name].material)
				if objects.world[name].texture ~= nil then
					setTexture(name, objects.world[name].texture)
				end
				
				if objects.world[name].controllable then
					birdsCounter = birdsCounter + 1
					if obj.startNumber ~= nil then
						objects.world[name].startNumber = obj.startNumber
					else
						objects.world[name].startNumber = birdsCounter
					end
				end
				
				local width = objects.world[name].width
				if width == nil then width = objects.world[name].radius end
				if objects.world[name].x - width < levelLeftEdge then
					levelLeftEdge = objects.world[name].x - width
				end
				if objects.world[name].x + width > levelRightEdge then
					levelRightEdge = objects.world[name].x + width
				end
			end
		end
	end

	createBox("ground", "", (levelLeftEdge + levelRightEdge)*0.5, 5, 2000, 10, 0, 0.8, 0, true, false, 0)
	objects.world["ground"].material = "staticGround"
	objects.world["ground"].definition = "Ground"
	objects.world["ground"].strength = 30
	objects.world["ground"].defence = 1000000
	
	countsSaved = true
	
	--creating theme sprites
	if loadedObjects.themeSprites then
		for k, v in _G.pairs(loadedObjects.themeSprites) do
	
			addThemeSprite(k,v)		

			if not objects.themeSprites then
				objects.themeSprites = {}
			end
						
			objects.themeSprites[v.name] = { definition = v.definition, 
											 name = v.name, x = v.x, y = v.y, 
											 layer = v.layer, 
											angle = v.angle, scale = v.scale }			
		end
	end	
	
	print("Creating joints\n")
	if loadedObjects.joints ~= nil then
		for k, v in _G.pairs(loadedObjects.joints) do
			--createJoint(v.name, v.end1, v.end2, v.type, v.coordType, v.x1, v.y1, v.x2, v.y2)
			createJoint(v)
			
		end
	end

	-- level camera data
	objects.castleCameraData = loadedObjects.castleCameraData
	objects.birdCameraData = loadedObjects.birdCameraData
	
	-- level end condition
	objects.doNotWaitForMovingObjects = loadedObjects.doNotWaitForMovingObjects

	
	for k, v in _G.pairs(loadedObjects) do
		loadedObjects[k] = nil
	end
	loadedObjects.cameraData = nil
	selectedBird = nil
	
	
	-- if starTable[levelName] == nil then
		-- starTable[levelName] = { silverScore = 25000, goldScore = 75000 }
		-- saveLuaFileWrapper("scripts/starLimits.lua", "starTable", false)
	-- end
	
	local maxScore = 0
		
	for k, v in _G.pairs(objects.world) do
		if v.controllable == true then
			-- add bird to bird table for faster access
			v.animTimer = _G.math.random(10, 30) / 10
			v.jumpTimer = _G.math.random(10, 30) / 10
			setRotation(v.name, 0)
			setObjectParameter(v.name, 2, 0)
			birds[k] = v
			if blockTable.blocks[v.definition].tutorialInfo ~= nil then
				if settings.tutorials[v.sprite] == true then
					settings.tutorials[v.sprite] = nil
				end
				if settings.tutorials[v.sprite] == nil then
					settings.tutorials[v.sprite] = {}
					settings.tutorials[v.sprite].sprite = blockTable.blocks[v.definition].tutorialInfo
					_G.table.insert(birdTutorialPopups, blockTable.blocks[v.definition].tutorialInfo)
					
					local birdSprite = blockTable.blocks[v.definition].sprite					
					-- Extra tutorials
					if(birdSprite == "BIRD_GREEN" or birdSprite == "BIRD_BLUE" or birdSprite == "BIRD_YELLOW" or birdSprite == "BIRD_GREY" or birdSprite == "BIRD_BOOMERANG") then
						settings.tutorials[birdSprite].showHelp = true																	
					end

					
					if settings.tutorials["BIRD_BLUE"] ~= nil then
						addToAchievementUnlockQueue("Split it!")
					end
					if settings.tutorials["BIRD_YELLOW"] ~= nil then
						addToAchievementUnlockQueue("Speed is the Essence")
					end
					if settings.tutorials["BIRD_GREY"] ~= nil then
						addToAchievementUnlockQueue("Boom Boom!")
					end
					if settings.tutorials["BIRD_GREEN"] ~= nil then
						addToAchievementUnlockQueue("Mother of all Bombs")
					end
					if settings.tutorials["BIRD_BOOMERANG"] ~= nil then
						addToAchievementUnlockQueue("Return to Sender")
					end
					if settings.tutorials["BIRD_BIG_BROTHER"] ~= nil then
						addToAchievementUnlockQueue("Seeing Red") 
					end
					if settings.tutorials["BAIT_SARDINE"] ~= nil then
						addToAchievementUnlockQueue("Aquiline Benefactor")
					end
				end
			end
		end
		if v.levelGoal then
			v.blinkTimer = _G.math.random(5, 30) / 10
			v.oinkTimer = _G.math.random(5, 30) / 10			
			levelGoals[k] = v
			setObjectParameter(k, 1, 1) -- set this object as level goal
		end
		local sprites = getDamageSprite(v, blockTable.blocks)
		v.damageSprite = sprites.sprite
		v.blinkSprite = sprites.blink		
		v.smileSprite = sprites.smile		
		v.frozen = false
		
		if v.controllable  then
			maxScore = maxScore + birdsLeftScoreIncrement
		elseif v.levelGoal then
			maxScore = maxScore + v.strength * 10 + pigletteDestroyedScoreIncrement
		elseif v.defence <= 1000 then
			
			maxScore = maxScore + v.strength * 10
			
			destroyedBonus = blockDestroyedScoreIncrement
			if blockTable.blocks[v.definition].destroyedScoreInc ~= nil then
				destroyedBonus = blockTable.blocks[v.definition].destroyedScoreInc
			end
			maxScore = maxScore + destroyedBonus
		end
	end
	
	
	
	-- one bird must be shot...
	maxScore = maxScore - birdsLeftScoreIncrement
	print("Max score for " .. currentWorldNumber .. "-" .. currentLevelNumberInTheme .. ": " .. maxScore .. "\n")
	
	-- init level positions
	levelStartTimer = 0
	local startObjectName = getNextBird(1)
	if startObjectName ~= nil then
		setObjectParameter(startObjectName, 2, 1)
	end

	if startObjectName ~= nil and objects.world[startObjectName] ~= nil then
		local px, py = _G.res.getSpritePivot("", "SLING_SHOT_01_BACK")
		local sw, sh = _G.res.getSpriteBounds("", "SLING_SHOT_01_BACK")
		local r = objects.world[startObjectName].radius
		if r == nil then
			r = 0
		end
		levelStartPosition.x = objects.world[startObjectName].x
		levelStartPosition.y = objects.world[startObjectName].y - (sh - py) * physicsScale + r + 0.2
		rubberBandPos.x = levelStartPosition.x - 0.1
		rubberBandPos.y = levelStartPosition.y - 0.1
		baitSardine.x, baitSardine.y = objects.world[startObjectName].x, objects.world[startObjectName].y
		
		-- createBox("slingShotPole", "", levelStartPosition.x, levelStartPosition.y + 115 * physicsScale, sw * physicsScale, 110 * physicsScale, 0, 0.8, 0, true, false)
		-- objects.world["slingShotPole"].material = "immovable"
		-- objects.world["slingShotPole"].definition = "Ground"
		-- objects.world["slingShotPole"].strength = 30
		-- objects.world["slingShotPole"].defence = 1000000		
	end

	local c = blockTable.themes[objects.theme].color
	setBGColor(c.r, c.g, c.b)
	
	initCameras()
	
	-- mighty eagle is available if it's 'locked' in current level
	eagleUsedInCurrentLevel = false
	for k, v in _G.pairs(settings.eaglesUsedIn) do
		if v.world == currentWorldNumber and v.level == currentLevelNumberInTheme then
			eagleUsedInCurrentLevel = true
			break
		end
	end
	editor = {drawOneLayer = false, currentLayer = 0}
	loadedObjects = nil
	loading = false
	loadingPageDrawn = false
	print("level load complete\n")
	
	checkLogLevelNotCompleted()
	_G.collectgarbage("collect")
end

-- Creates object from definition (blocks.lua)
function createObject(definitions, objectDefinition, objName, xpos, ypos)
	local name = ""
	print("objName = "..objName.."\n")
	local blockDef = definitions.blocks[objectDefinition]
	local materialDef = definitions.materials[blockDef.material]

	-- get basic data from block definition
	local density = blockDef.density
	local friction = blockDef.friction
	local restitution = blockDef.restitution
	local controllable = blockDef.controllable
	local strength = blockDef.strength
	local defence = blockDef.defence
	local levelGoal = blockDef.levelGoal
	local collision = blockDef.collision
	local damageFactors = blockDef.damageFactors
	local useLegacyCollisionPath = blockDef.useLegacyCollisionPath
	local z_order = blockDef.z_order

	local pivotx, pivoty

	-- get rest of the information from material if it has not been overridden in the block definition
	if materialDef ~= nil then
		if density == nil then
			density = materialDef.density
			definitions.blocks[objectDefinition].density = density
		end
		if friction == nil then
			friction = materialDef.friction
			definitions.blocks[objectDefinition].friction = friction
		end
		if restitution == nil then
			restitution = materialDef.restitution
			definitions.blocks[objectDefinition].restitution = restitution
		end
		if controllable == nil then
			controllable = materialDef.controllable
			definitions.blocks[objectDefinition].controllable = controllable
		end
		if strength == nil then
			strength = materialDef.strength
			definitions.blocks[objectDefinition].strength = strength
		end
		if defence == nil then
			defence = materialDef.defence
			definitions.blocks[objectDefinition].defence = defence
		end
		if z_order == nil then
			z_order = materialDef.z_order
			definitions.blocks[objectDefinition].z_order = z_order
		end		
	end

	-- failsafe if z_order not defined
	if z_order == nil then
		z_order = 0
		definitions.blocks[objectDefinition].z_order = z_order
	end
	
	--set object names using cumulative counter
	if countsSaved == false or objName == nil then
		if objects.counts[objectDefinition] == nil then
			objects.counts[objectDefinition] = 0
		end
		objects.counts[objectDefinition] = objects.counts[objectDefinition] + 1
		name = objectDefinition .. "_" .. objects.counts[objectDefinition]
	else
		name = objName
	end

	local sprite = blockDef.sprite
	local w, h = 1, 1
	local sizeFactor = 0.92
	
	-- if sprite has not been set use the first damage sprite
	if sprite == nil then
		if blockDef.damageSprites ~= nil then
			sprite = blockDef.damageSprites.damage1.sprite
		end
	end
	
	-- set physics related settings
	if blockDef.type == "box" then
		-- use sprite if available if not use defined width and height
		if blockDef.width == nil or blockDef.height == nil then
			w, h = _G.res.getSpriteBounds("", sprite)
			-- immovable walls have always the sprites size to prevent gaps
			if blockDef.density == 0 then
				sizeFactor = 1
			end
			w = w * physicsScale * sizeFactor
			h = h * physicsScale * sizeFactor
			pivotx, pivoty = _G.res.getSpritePivot("", sprite)
		else
			w = blockDef.width
			h = blockDef.height
			pivotx, pivoty = _G.res.getSpritePivot("", sprite)
		end

		if collision == nil then
			collision = true
		end
		
		createBox(name, sprite, xpos, ypos, w, h, density, friction, restitution, collision, controllable, z_order)
		
		-- set damage factors for birds
		if controllable then
			objects.world[name].damageFactors = damageFactors
			objects.world[name].useLegacyCollisionPath = useLegacyCollisionPath
		end
	end

	-- set physics related settings
	if blockDef.type == "polygon" then
			--use sprite if available if not use defined width and height
		if sprite ~= "" and sprite ~= nil then
			w, h = _G.res.getSpriteBounds("", sprite)
			--immovable walls have always the sprites size to prevent gaps
			if blockDef.density == 0 then
				sizeFactor = 1
			end
			w = w * physicsScale * sizeFactor
			h = h * physicsScale * sizeFactor
			pivotx, pivoty = _G.res.getSpritePivot("", sprite)
		else
			w = blockDef.width
			h = blockDef.height
			pivotx, pivoty = _G.res.getSpritePivot("", sprite)
		end

		if collision == nil then
			collision = true
		end

		clearVertices()
		if blockDef.vertices ~= nil then
			for i = 1, #blockDef.vertices do
				local vert = blockDef.vertices[i]
				addVertex(vert.x * w - w * 0.5, vert.y * h - h * 0.5)
			end
		end
		
		createPolygon(name, sprite, xpos, ypos, w, h, density, friction, restitution, collision, controllable, z_order)
	
		-- set damage factors for birds
		if controllable then
			objects.world[name].damageFactors = damageFactors
			objects.world[name].useLegacyCollisionPath = useLegacyCollisionPath
		end
	end	
	
	if blockDef.type == "circle" then
		-- use sprite if available if not use defined width and height
		if blockDef.radius ~= nil then
			w = blockDef.radius
		else
			if sprite ~= "" and sprite ~= nil then
				w, h = _G.res.getSpriteBounds("", sprite)
				w = w * 0.5 * physicsScale * sizeFactor
			end
		end
		pivotx, pivoty = _G.res.getSpritePivot("", sprite)
		createCircle(name, sprite, xpos, ypos, w, density, friction, restitution, controllable, z_order)
		
		-- set damage factors for birds
		if controllable then
			objects.world[name].damageFactors = damageFactors
			objects.world[name].useLegacyCollisionPath = useLegacyCollisionPath
		end
	end

	-- set general settings
	objects.world[name].definition = objectDefinition
	objects.world[name].damageSprite = sprite	
	objects.world[name].controllable = controllable
	objects.world[name].strength = strength
	objects.world[name].defence = defence
	objects.world[name].material = blockDef.material
	objects.world[name].texture = blockDef.texture
	objects.world[name].levelGoal = levelGoal
	objects.world[name].spritePivotX = pivotx
	objects.world[name].spritePivotY = pivoty
	return name
end

-------------------------------------------------------------------------------
-- Editor stuff starts

function checkDirectories()
	if not checkDirectory(levelFolder) then
		createDirectory(levelFolder)
	end
	if not checkDirectory(levelFolder .. "temp/") then
		createDirectory(levelFolder .. "temp/")
	end		
end

-- updates current cursor object to match theme
function updateCursorObjectAccordingToTheme()
	for k, v in _G.pairs(blockTable.blocks) do
		-- check the group
		if v.group == currentGroup and v.groupIndex == currentGroupIndex then
			--print("Object candidate " .. k .. " group:" .. v.group .. " groupIndex:" .. v.groupIndex .. "\n")
			--if theme is defined check if it matches the current theme
			if v.theme == nil or v.theme == currentTheme then
				--print("Selected object to add " .. k .. "\n")
				objectToAdd = k
				selectedObjects = { }
			end
		end
	end
end

function getObjectListBounds(objects)
	local w, h, px, py
	local minx = 1000000 
	local maxx = -1000000
	local miny = 1000000 
	local maxy = -1000000

	for k, v in _G.pairs(objects) do
		local width = v.width
		local height = v.height
		if width == nil then
			width = v.radius
			height = v.radius
		else
			width = width * 0.5
			height = height * 0.5
		end
		
		if v.x - width < minx then
			minx = v.x - width
		end
		if v.x + width > maxx then
			maxx = v.x + width
		end

		if v.y - height < miny then
			miny = v.y - height
		end
		if v.y + height > maxy then
			maxy = v.y + height
		end
	end
	
	w = maxx - minx
	h = maxy - miny
	px = (maxx + minx) * 0.5
	py = (maxy + miny) * 0.5
	
	return px, py, w, h
end

function updateEditor(dt, time)
	
	if not editorJointPage then
		editorJointPage = EditorJointPage:new()
		editorJointPage:onEntry()
	end

	if oldZoomLevel ~= zoomLevel then
		worldScale = worldScale + zoomLevel - oldZoomLevel
		setWorldScale(worldScale)
		oldZoomLevel = zoomLevel
	end	

	updateScale()
	cursorPhysics.x, cursorPhysics.y = screenToPhysicsTransform(cursor.x, cursor.y)
	cursorWorld.x, cursorWorld.y = screenToWorldTransform(cursor.x, cursor.y)
	
	

	-- XXX: ADD TO OTHERS
	if(selectedObjects ~= nil and #selectedObjects == 1) then
		initCollisionDummy(selectedObjects[1])	
	end
	
	if(keyReleased["LBUTTON"] or keyReleased["RBUTTON"]) then
		
	end
	
	if(keyHold["RETURN"] and keyPressed["DOWN"]) then
		alignObjects("DOWN")
	end
	
	if(keyHold["RETURN"] and keyPressed["UP"]) then
		alignObjects("UP")
	end

	if(keyHold["RETURN"] and keyPressed["RIGHT"]) then
		alignObjects("RIGHT")
	end
	
	if(keyHold["RETURN"] and keyPressed["LEFT"]) then
		alignObjects("LEFT")
	end

	-- XXX: ADD TO OTHERS
	if (keyHold["SHIFT"] or keyHold["CONTROL"]) and (keyPressed["W"] or keyPressed["E"]) and showSleepingObjects == true then
		if  #selectedObjects == 1 then
			local name = selectedObjects[1].name
			local selected = objects.world[name]
			local blockDef = blockTable.blocks[selected.definition]
			local dir = 1

			if(keyHold["CONTROL"]) then dir = -1 end

			if(blockDef.radius) then
				adjustedBlockDef.objectNames[name].radius = adjustedBlockDef.objectNames[name].radius + 0.1 * dir
				
				if(adjustedBlockDef.objectNames[name].radius < 0) then
					adjustedBlockDef.objectNames[name].radius = 0
				end
				
			elseif(blockDef.width and blockDef.height) then
				if(keyPressed["W"]) then
					adjustedBlockDef.objectNames[name].width = adjustedBlockDef.objectNames[name].width + 0.1 * dir
					if(adjustedBlockDef.objectNames[name].width < 0) then
						adjustedBlockDef.objectNames[name].width = 0
					end			

				else
					adjustedBlockDef.objectNames[name].height = adjustedBlockDef.objectNames[name].height + 0.1 * dir
					if(adjustedBlockDef.objectNames[name].height < 0) then
						adjustedBlockDef.objectNames[name].height = 0
					end			
				end
			elseif(blockDef.vertices ~= nil) then
				for k,v in _G.pairs(blockDef.vertices) do
					local vert = adjustedBlockDef.objectNames[name].vertices[k]
					if(keyPressed["W"]) then
						if(vert.x > 0.5) then
							vert.x = vert.x + 0.05 * dir
						elseif(vert.x < 0.5) then
							vert.x = vert.x - 0.05 * dir
						end
					else
						if(vert.y > 0.5) then
							vert.y = vert.y + 0.05 * dir										
						elseif(vert.y < 0.5) then
							vert.y = vert.y - 0.05 * dir
						end
					end
				end
			end
		end		
	end
	
	
	--the m_cursorWorldDownX will keep the values of the cursor in world coordinates when 
	--the RMB was pressed on the screen, will be used for scaling sprites on the background
	if(keyHold["RBUTTON"]) then
		if editor.m_cursorWorldDownX == nil and editor.m_cursorWorldDownY == nil then
			editor.m_cursorWorldDownX = cursorWorld.x
			editor.m_cursorWorldDownY = cursorWorld.y
		end
	else
		editor.m_cursorWorldDownX = nil
		editor.m_cursorWorldDownY = nil
	end
	
	--print("cp.x_ " .. cursorPhysics.x .. " - cp.y: " .. cursorPhysics.y .. "\n")
	--print("cw.x_ " .. cursorWorld.x .. " - cw.y: " .. cursorWorld.y .. "\n")

	if keyPressed["ESCAPE"] or touchcount == 3 then

		setGameMode(updateMenu)
		setPhysicsEnabled(false)
		physicsEnabled = false
		setActiveMenuPage(levelSelectionEdit[currentThemeNumber])
		editorJointPage:onExit()
		editorJointPage = nil
		return
	end

	if keyHold["CONTROL"] and keyPressed["S"] then
		checkDirectories()
		saveLevel(levelFolder .. levelName)
		saveLevel(levelFolder .. "temp/" .. levelName .. ".temp")
		levelSaved = true
	end

	if not keyHold["CONTROL"] and keyHold["SHIFT"] and keyPressed["C"] then
		if objects.castleCameraData == nil then
			objects.castleCameraData = {}
		end
		
		objects.castleCameraData.version = "0.02"
		objects.castleCameraData[deviceModel] = { px = screen.x,
												  py = screen.y,
												  sx = worldScale,
												  sy = worldScale,
												  screenWidth = screenWidth,
												  screenHeight = screenHeight }
		levelSaved = false
	end

	if not keyHold["CONTROL"] and keyHold["SHIFT"] and keyPressed["B"] then
		if objects.birdCameraData == nil then
			objects.birdCameraData = {}
		end
		
		objects.birdCameraData.version = "0.02"
		objects.birdCameraData[deviceModel] = { px = screen.x,
												py = screen.y,
												sx = worldScale,
												sy = worldScale,
												screenWidth = screenWidth,
												screenHeight = screenHeight }
		levelSaved = false
	end

	if (keyHold["SHIFT"] and keyPressed["P"]) or touchcount == 2 then
		setEditing(false)
		setPhysicsEnabled(false)
		local name = "temp/" .. levelName .. ".temp.playtest"
		
		if(touchcount == 2) then
			name = levelName
		end
		
		if(touchcount ~= 2) then
			checkDirectories()
			saveLevel(levelFolder .. name)
		end
		
		loadLevelInternal(levelFolder .. name)		
		setGameMode(updateGame)
		levelSelectionPageNumber = currentThemeNumber
		currentThemeNumber = currentThemeIndex
	end

	if keyPressed["TAB"] then
		physicsEnabled = not physicsEnabled
		if physicsEnabled then
			checkDirectories()
			saveLevel(levelFolder .. "temp/" .. levelName .. ".temp")
		else
			loadLevelInternal(levelFolder .. "temp/" .. levelName .. ".temp")
		end
		setPhysicsEnabled(physicsEnabled)
	end

	if keyPressed["MBUTTON"] then
		if keyPressed["SHIFT"] then
			setWorldScale(1)
			worldScale = 1
		else
			setWorldScale(1)
			worldScale = 1
			screen.x = 0
			screen.y = 0
		end
	end

	-- set active theme
	if keyHold["SHIFT"] and keyPressed[blockTable.themes.settings.keyCode] then
		currentThemeIndex = currentThemeIndex + 1
		if currentThemeIndex > blockTable.themes.settings.themeAmount then
			currentThemeIndex = 1
		end

		for k0, v0 in _G.pairs(blockTable.themes) do
			if v0.index ~= nil and v0.index == currentThemeIndex then
				currentTheme = k0
				setTheme(currentTheme)
				-- replace all blocks that are theme dependent
				for k1, v1 in _G.pairs(objects.world) do
					v1def = blockTable.blocks[v1.definition]
					if v1def.theme ~= nil and v1def.theme ~= currentTheme then
						-- go through all block definitions to find the correct block to replace this one
						for k2, v2 in _G.pairs(blockTable.blocks) do
							-- if this block definition's group is the same as the one on the current block and the group indexes match then check the theme
							if v2.group == v1def.group and v2.groupIndex == v1def.groupIndex then
								-- does the theme match to the current theme requirements
								if v2.theme == nil or v2.theme == currentTheme then
									-- we found a replacement, update values accordingly
									v1.definition = k2
									v1.sprite = v2.sprite
									v1.damageSprite = v1.sprite
									setSprite(k1, v1.sprite)
									levelSaved = false
								end
							end
						end
					end
				end

				-- update the cursor object
				if objectToAdd ~= nil then
					updateCursorObjectAccordingToTheme()
				end
				-- replace level defines
				objects.theme = currentTheme

			end
		end
	end

	birdSelected = false
	if selectedObjects[1] ~= nil then
		if selectedObjects[1].controllable then
			birdSelected = true
			for i = 1, #numberKeys do
				if keyPressed[numberKeys[i]] then
					selectedObjects[1].startNumber = i
				end
			end
		end
	end


	-- create blocks from the blocks.lua definitions
	if keyHold["CONTROL"] == false and keyHold["SHIFT"] == false and birdSelected == false then
		for k, v in _G.pairs(blockTable.groups) do
			local groupDataUpdate = false
			if keyPressed[v.keyUp] then
				-- update group information
				if currentGroup == k then
					currentGroupIndex = currentGroupIndex + 1
				else
					currentGroup = k
				end
				groupDataUpdate = true
			end
			if keyPressed[v.keyDown] then
				-- update group information
				if currentGroup == k then
					currentGroupIndex = currentGroupIndex - 1
				else
					currentGroup = k
				end
				groupDataUpdate = true
			end
			-- find the next object to add based on group information
			if groupDataUpdate then
				if currentGroupIndex > blockTable.groups[currentGroup].lastIndex then
					currentGroupIndex = blockTable.groups[currentGroup].firstIndex
				end
				if currentGroupIndex < blockTable.groups[currentGroup].firstIndex then
					currentGroupIndex = blockTable.groups[currentGroup].lastIndex
				end

				--print("Searching for group " .. currentGroup .. " " .. currentGroupIndex .. "\n")
				updateCursorObjectAccordingToTheme()
			end
		end
	end

	if keyPressed["RBUTTON"] then
		if copiedObjects ~= nil then
			copiedObjects = nil
		end
		
		if objectToAdd ~= nil then
			objectToAdd = nil
		else
			if not keyHold["SHIFT"] and not keyHold["ALT"] then
				selectedObjects = { }
			end
			selectedObjectPos.x = 0
			selectedObjectPos.y = 0

			draggingStartPosWorld.x = cursorWorld.x
			draggingStartPosWorld.y = cursorWorld.y
			
			if editor.drawOneLayer then
				--find object that was clicked
				for k, v in _G.pairs(themeSpriteObjects) do
					object = v
					if object.type == "polygon" then						
						if checkPolygonObjectBounds(object.x, object.y, object.width * object.scale.x, object.height * object.scale.y, object.angle, object.vertices, cursorPhysics.x, cursorPhysics.y) then
							addObjectToSelection(object, true)
						end
					end
					if object.type == "box" then
						if checkObjectBounds( object.x, object.y, object.width * object.scale.x, object.height * object.scale.y, object.angle, cursorPhysics.x, cursorPhysics.y) then
							addObjectToSelection(object, true)
						end
					end
					if object.type == "circle" then
						local t_scale = _G.math.max(object.scale.x, object.scale.y)
						if distance(object.x, object.y, cursorPhysics.x, cursorPhysics.y) < (object.radius * t_scale) then
							addObjectToSelection(object, true)
						end
					end
				end
			else
				--find object that was clicked
				for k, v in _G.pairs(objects.world) do
					object = v
					if object.type == "polygon" then
						x = object.x
						y = object.y
						--print(object.name .. " ")
						if checkPolygonObjectBounds(x, y, object.width, object.height, object.angle, getObjectDefinition(k).vertices, cursorPhysics.x, cursorPhysics.y) then
							addObjectToSelection(object, true)
						end
					end
					if object.type == "box" then
						x = object.x
						y = object.y
						--print(object.name .. " ")
						if checkObjectBounds(x, y, object.width, object.height, object.angle, cursorPhysics.x, cursorPhysics.y) then
							addObjectToSelection(object, true)
						end
					end
					if object.type == "circle" then
						if distance(object.x, object.y, cursorPhysics.x, cursorPhysics.y) < object.radius then
							addObjectToSelection(object, true)
						end
					end
				end
			end
		end
	end

	if keyHold["RBUTTON"] and (not keyHold["CONTROL"]) then
		selectionRectActive = true
	end
	
	--scales backgrond sprites
	if keyHold["RBUTTON"] and keyHold["CONTROL"] and editor.drawOneLayer and (#selectedObjects > 0) then
		
		for k, v in _G.pairs(selectedObjects) do
			object = v
			
			local t_scaleX = 1
			local t_scaleY = 1
			
			--if the user is pressing shif, we scale both axis equally
			if(keyHold["SHIFT"]) then
				local t_oldCursorPhysicsX, t_oldCursorPhysicsY = worldToPhysicsTransform(editor.m_cursorWorldDownX, editor.m_cursorWorldDownY)
									
				local t_originalDistance = distance(v.x, v.y, t_oldCursorPhysicsX, t_oldCursorPhysicsY)
				
				local t_newDistance = distance(v.x, v.y, cursorPhysics.x, cursorPhysics.y)
				
				local t_scale = t_newDistance / t_originalDistance
				
				t_scaleX = t_scale
				t_scaleY = t_scale
			else
				local t_oldCursorPhysicsX, t_oldCursorPhysicsY = worldToPhysicsTransform(editor.m_cursorWorldDownX, editor.m_cursorWorldDownY)
									
				local t_oldDistanceX = t_oldCursorPhysicsX - v.x
				local t_oldDistanceY = t_oldCursorPhysicsY - v.y
				
				local t_newDistanceX = cursorPhysics.x - v.x
				local t_newDistanceY = cursorPhysics.y - v.y
								
				t_scaleX = t_newDistanceX / t_oldDistanceX
				t_scaleY = t_newDistanceY / t_oldDistanceY
			end
			
			modifyThemeSprite(object.name, object.x, object.y, t_scaleX, t_scaleY, object.angle, object.layer)
			
			object.scale = {x = t_scaleX, y = t_scaleY}			
			objects.themeSprites[object.name].scale = { x =  t_scaleX, y = t_scaleY}			
			
		end
		
	end
	
	-- this is here so that the dragging position is not set on this frame if LBUTTON is released
	if keyReleased["RBUTTON"] then
		if objectToAdd ~= nil and selectedObjects == nil or #selectedObjects < 1 then
			if editor.drawOneLayer then
				selectedObjects = getThemeObjectsInsideRect(draggingStartPosWorld.x, draggingStartPosWorld.y, cursorWorld.x, cursorWorld.y, editor.currentLayer)
			else 
				selectedObjects = getObjectsInsideRect(draggingStartPosWorld.x, draggingStartPosWorld.y, cursorWorld.x, cursorWorld.y)
				
			end
		else
			if keyHold["SHIFT"] then
				local tempObjects = getObjectsInsideRect(draggingStartPosWorld.x, draggingStartPosWorld.y, cursorWorld.x, cursorWorld.y)
				for k, v in _G.pairs(tempObjects) do
					addObjectToSelection(object, false)
				end
			end
			if keyHold["ALT"] then
				local tempObjects = getObjectsInsideRect(draggingStartPosWorld.x, draggingStartPosWorld.y, cursorWorld.x, cursorWorld.y)
				for k, v in _G.pairs(tempObjects) do
					for soi = 1, #selectedObjects do
						if selectedObjects[soi] == v then
							_G.table.remove(selectedObjects, soi)
							soi = #selectedObjects
						end
					end
				end				
			end
		end
		selectionRectActive = false
	end

	if keyPressed["LBUTTON"] then
		oldCursor.x = cursor.x
		oldCursor.y = cursor.y
		if not keyHold["SPACE"] then
			if objectToAdd ~= nil then
				-- local name = createObject(blockTable, objectToAdd, nil, cursorPhysics.x, cursorPhysics.y)
				-- setRotation(name, objectToAddAngle)
				-- selectedObjects = {}
				-- _G.table.insert(selectedObjects, objects.world[name])
				-- levelSaved = false
				if not editor.drawOneLayer then
					local name = createObject(blockTable, objectToAdd, nil, cursorPhysics.x, cursorPhysics.y)
					setRotation(name, objectToAddAngle)
					selectedObjects = {}
					birdSelected = false
					_G.table.insert(selectedObjects, objects.world[name])
				else
					local spr = blockTable.blocks[objectToAdd].sprite
					if not spr and blockTable.blocks[objectToAdd].damageSprites then
						spr = blockTable.blocks[objectToAdd].damageSprites.damage1
					end
					if spr then
					
						if objects.counts[objectToAdd] == nil then
							objects.counts[objectToAdd] = 0
						end
	
						objects.counts[objectToAdd] = objects.counts[objectToAdd] + 1
						local name = objectToAdd .. "_" .. objects.counts[objectToAdd]
						selectedObjects = {}
						
						addThemeSprite(name, {definition=objectToAdd, name=name, x = cursorPhysics.x, y = cursorPhysics.y, angle = 0, scale = {x=1,y=1}, layer = editor.currentLayer })
						
						if not objects.themeSprites then
							objects.themeSprites = {}
						end
						objects.themeSprites[name] = { definition = objectToAdd, 
													   name = name, x = cursorPhysics.x, 
													   y = cursorPhysics.y, layer = editor.currentLayer, 
													   angle = objectToAddAngle, scale = {x=1,y=1} }							   						
					end
				end	
			end
			if copiedObjects ~= nil then
				-- for k, v in _G.pairs(copiedObjects) do
					-- local name = createObject(blockTable, v.definition, nil, cursorPhysics.x + v.x, cursorPhysics.y + v.y)
					-- setRotation(name, v.angle)
				-- end
				
				--this table will be indexed by the copied objects names, and the values
				--will be the new copies name
				local t_nameRelationTable = {}
				for k, v in _G.pairs(copiedObjects) do
					if editor.drawOneLayer then
						--print("k = "..k.." value = " ..v.definition)
						
						if objects.counts[v.definition] then
							objects.counts[v.definition] = objects.counts[v.definition] + 1						
						else
							objects.counts[v.definition] = 1			
						end
						local name = v.definition .. "_" .. objects.counts[v.definition]
						addThemeSprite(name, {definition=v.definition, name=name, x = cursorPhysics.x + v.x, y = cursorPhysics.y + v.y, angle = v.angle, scale = v.scale, layer = editor.currentLayer })
						
						if not objects.themeSprites then
							objects.themeSprites = {}
						end
						objects.themeSprites[name] = { 	definition = v.definition, 
														name = name, x = cursorPhysics.x + v.x, 
														y = cursorPhysics.y + v.y, 
														layer = editor.currentLayer, 
														angle = v.angle,
														scale = v.scale}
					else
						local name = createObject(blockTable, v.definition, nil, cursorPhysics.x + v.x, cursorPhysics.y + v.y)
						t_nameRelationTable[v.name] = name
						setRotation(name, v.angle)
						objects.world[name].strength = v.strength
					end
					
				end						
				
				--will create new joints based on the new objects
				if copiedJoints ~= nil then
					for k, v in _G.pairs(copiedJoints) do
						
						
						local t_newJointName = t_nameRelationTable[v.end1] .. t_nameRelationTable[v.end2]
						
						--makes a copy of the joint to be copied, with updated name, and1 and end2 values					
						
						t_newJoint = {}
						
						
						--distance joint
						if v.type == 1 then
							t_newJoint = { name = t_newJointName, type =  v.type, end1 = t_nameRelationTable[v.end1], end2= t_nameRelationTable[v.end2], x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected, dampingRatio=v.dampingRatio, frequency=v.frequency }
						--weld joint
						elseif v.type == 2 then
							t_newJoint = { name = t_newJointName, type =  v.type, end1 = t_nameRelationTable[v.end1], end2= t_nameRelationTable[v.end2], x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected }
						--revolute joint
						elseif v.type == 3 then
							t_newJoint = { name = t_newJointName, type =  v.type, end1 = t_nameRelationTable[v.end1], end2= t_nameRelationTable[v.end2], x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected, maxTorque=v.maxTorque,limit=v.limit,backAndForth=v.backAndForth,motorSpeed=v.motorSpeed,motor=v.motor,lowerLimit=v.lowerLimit,upperLimit=v.upperLimit }
						--prismatic joint
						elseif v.type == 4 then
							t_newJoint = { name = t_newJointName, type =  v.type, end1 = t_nameRelationTable[v.end1], end2= t_nameRelationTable[v.end2], x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected, maxTorque=v.maxTorque, limit=v.limit, backAndForth=v.backAndForth,motorSpeed=v.motorSpeed,worldAxisY=v.worldAxisY, motor=v.motor, lowerLimit=v.lowerLimit, upperLimit=v.upperLimit, worldAxisX = v.worldAxisX}
						--anihilation joint
						elseif v.type == 5 then
							t_newJoint = { name = t_newJointName, type =  v.type, end1 = t_nameRelationTable[v.end1], end2= t_nameRelationTable[v.end2], x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected, destroyTimer = v.destroyTimer}
						end					
						
						--print("\nnew joint name: " .. t_newJointName)
						createJoint(t_newJoint)
						editorJointPage.addJoint(editorJointPage, t_newJointName)
					end
				end
			end
		end
	end

	if keyHold["LBUTTON"] then
		if keyHold["SPACE"] then
			screen.x = screen.x - (cursorWorld.x - draggingStartPosWorld.x) * 0.5
			screen.y = screen.y - (cursorWorld.y - draggingStartPosWorld.y) * 0.5
		else
			if objectToAdd ~= nil then
				-- do not allow object selection if object to add is active
			elseif selectedObjects ~= nil and #selectedObjects > 0 and (not editor.drawOneLayer)then
				for k, v in _G.pairs(selectedObjects) do
					object = v
					x, y = worldToPhysicsTransform(cursor.x - oldCursor.x, cursor.y - oldCursor.y)
					x = x / worldScale
					y = y / worldScale
					setSleeping(object.name, false)
					if keyHold["CONTROL"] then
						setRotation(object.name, object.angle + (cursor.x - oldCursor.x)/180 * _G.math.pi )
					else
						setPosition(object.name, x + object.x, y + object.y)
					end
				end
				levelSaved = false
			elseif selectedObjects ~= nil and #selectedObjects > 0 and editor.drawOneLayer then
				for k, v in _G.pairs(selectedObjects) do
					object = v
					x, y = worldToPhysicsTransform(cursor.x - oldCursor.x, cursor.y - oldCursor.y)
					x = x / worldScale
					y = y / worldScale
					if keyHold["CONTROL"] then
						modifyThemeSprite(object.name, object.x, object.y, object.scale.x, object.scale.y, object.angle + (cursor.x - oldCursor.x)/180 * _G.math.pi , object.layer)
						object.angle = object.angle + (cursor.x - oldCursor.x)/180 * _G.math.pi 
						objects.themeSprites[object.name].angle = object.angle
					else
						modifyThemeSprite(object.name,  x + object.x, y + object.y, object.scale.x, object.scale.y, object.angle, object.layer)
						object.x = x + object.x
						object.y = y + object.y
						objects.themeSprites[object.name].x = object.x
						objects.themeSprites[object.name].y = object.y
					end
				end
				levelSaved = false
			end
		end
	end

	if not keyHold["LBUTTON"] and not keyHold["RBUTTON"] then
		draggingStartPosWorld.x = cursorWorld.x
		draggingStartPosWorld.y = cursorWorld.y
	end

	-- handle key input
	if selectedObjects ~= nil and #selectedObjects > 0 then
		local moveAmount = 1
		if keyHold["SHIFT"] then
			moveAmount = 10
		end	
		if keyHold["SHIFT"] and keyHold["CONTROL"] then
			moveAmount = 100
		end
		if not keyHold["SHIFT"] and keyHold["CONTROL"] then
			-- remove movement if only control pressed
			moveAmount = 0
		end
		
		if keyReleased["DELETE"] then
			if editor.drawOneLayer then
				for k, v in _G.pairs(selectedObjects) do					
					local name = v.name
					objects.themeSprites[v.name] = nil
					themeSpriteObjects[v.name] = nil
					removeThemeSprite(name, editor.currentLayer)
				end
			else
	
				for k, v in _G.pairs(selectedObjects) do
					for key, value in _G.pairs(objects.joints) do
						if value.end1 == v.name or value.end2 == v.name then
							editorJointPage:removeItem(value.name)
							editorJointPage:removeItem(value.name .. "_ANCHOR_1")
							editorJointPage:removeItem(value.name .. "_ANCHOR_2")
						end
					end
					
					local name = v.name
					objects.world[name] = nil
					removeObject(name)
				end
				
			end
			selectedObjects = {}
			levelSaved = false
		end
		if not keyHold["RETURN"] then
			local moveKeyDown = false

			if (keyHold["LEFT"] or keyHold["RIGHT"] or keyHold["UP"] or keyHold["DOWN"])then
				moveKeyDown = true
			end
			
			if blockMoveTimer == 0 or blockMoveTimer > 0.3 then
				if keyHold["LEFT"] then
					setPositions(-moveAmount, 0)
				end
				if keyHold["RIGHT"] then
					setPositions(moveAmount, 0)
				end
				if keyHold["UP"] then
					setPositions(0, -moveAmount)
				end
				if keyHold["DOWN"] then
					setPositions(0, moveAmount)
				end
			end
			
			if moveKeyDown then
				blockMoveTimer = blockMoveTimer + dt
			else
				blockMoveTimer = 0
			end		
		end
	end

	if keyHold["SHIFT"] then
		if keyPressed["R"] then
			local angle = _G.math.pi / 8
			if keyHold["CONTROL"] then
				angle = -angle
			end
			if copiedObjects ~= nil then
				local px, py, w, h = getObjectListBounds(copiedObjects)
				for k, v in _G.pairs(copiedObjects) do
	
					v.angle = v.angle + angle
					
					-- move to origin
					local cx = v.x - px
					local cy = v.y - py
					
					-- rotate around origin
					local tcx = cx * _G.math.cos(angle) - cy * _G.math.sin(angle)
					local tcy = cx * _G.math.sin(angle) + cy * _G.math.cos(angle)
	
					-- move back
					v.x = tcx + px
					v.y = tcy + py
					--print("Rotating copied object: " .. k .. "\n")
				end
			else
				if objectToAdd ~= nil then
					objectToAddAngle = objectToAddAngle + angle
				else
					if selectedObjects ~= nil and #selectedObjects > 0 then
						for k, v in _G.pairs(selectedObjects) do
							setRotation(v.name, v.angle + angle)
						end
						levelSaved = false
					end
				end
			end
		end
		
		if keyPressed["J"] then
			if #selectedObjects == 2 then
				--createJoint(selectedObjects[1].name .. selectedObjects[2].name, selectedObjects[1].name, selectedObjects[2].name, 1, 2, 0, 0, 0, 0)
				--levelSaved = false
				
				editor.newJoint = { name = selectedObjects[1].name .. selectedObjects[2].name, 
								end1 = selectedObjects[1].name, end2 = selectedObjects[2].name, type = 1,
								coordType = 2, x1 = 0, y1 = 0, x2 = 0, y2 = 0, collideConnected = false }
				editorJointPage.newJoint = true	
				levelSaved = false
				
			end
		end
	end
	
	if #selectedObjects == 2 then
		if keyPressed["F1"] then -- distance joint
			editor.newJoint = { name = selectedObjects[1].name .. selectedObjects[2].name, 
								end1 = selectedObjects[1].name, end2 = selectedObjects[2].name, type = 1,
								coordType = 2, x1 = 0, y1 = 0, x2 = 0, y2 = 0 }
			editorJointPage.newJoint = true		
		elseif keyPressed["F2"] then -- weld joint
			editor.newJoint = { name = selectedObjects[1].name .. selectedObjects[2].name, 
								end1 = selectedObjects[1].name, end2 = selectedObjects[2].name, type = 2,
								coordType = 2, x1 = 0, y1 = 0, x2 = 0, y2 = 0 }
			editorJointPage.newJoint = true	
		elseif keyPressed["F3"] then -- revolute joint
			editor.newJoint = { name = selectedObjects[1].name .. selectedObjects[2].name, 
								end1 = selectedObjects[1].name, end2 = selectedObjects[2].name, type = 3,
								coordType = 2, x1 = 0, y1 = 0, x2 = 0, y2 = 0 }
			editorJointPage.newJoint = true		
		elseif keyPressed["F4"] then -- prismatic joint
			editor.newJoint = { name = selectedObjects[1].name .. selectedObjects[2].name, 
								end1 = selectedObjects[1].name, end2 = selectedObjects[2].name, type = 4,
								coordType = 2, x1 = 0, y1 = 0, x2 = 0, y2 = 0}
			editorJointPage.items.x.visible = true
			editorJointPage.items.y.visible = true
			editorJointPage.items.x.text = editorJointPage.xTexts[1]
			editorJointPage.items.y.text = editorJointPage.yTexts[1]
			editorJointPage.newJoint = true	
		elseif keyPressed["F5"] then -- "destroy attached" -joint
			editor.newJoint = { name = selectedObjects[1].name .. selectedObjects[2].name,
								end1 = selectedObjects[1].name, end2 = selectedObjects[2].name, type = 5,
								coordType = 2, x1 = 0, y1 = 0, x2 = 0, y2 = 0								}
			editorJointPage.newJoint = true	
		end
	end
		
	if not keyHold["SHIFT"] and keyHold["CONTROL"] then		
		if keyPressed["LEFT"] or keyPressed["RIGHT"] then
			if selectedObjects ~= nil and #selectedObjects > 0 then
				local px, py, w, h = getObjectListBounds(selectedObjects)
								
				for k, v in _G.pairs(selectedObjects) do
					setPosition(v.name, px + (px - v.x), v.y)
				end
				levelSaved = false
			end			
		end
	
		if keyPressed["UP"] or keyPressed["DOWN"] then
			if selectedObjects ~= nil and #selectedObjects > 0 then
				local px, py, w, h = getObjectListBounds(selectedObjects)
								
				for k, v in _G.pairs(selectedObjects) do
					setPosition(v.name, v.x, py + (py - v.y))
				end
				levelSaved = false
			end
		end
	end
	
	if keyHold["SHIFT"] and keyHold["CONTROL"] and (keyPressed["B"] or keyPressed["HOME"]) then
		if objects.birdCameraData and objects.birdCameraData[deviceModel] ~= nil then
			screen.x = objects.birdCameraData[deviceModel].px
			screen.y = objects.birdCameraData[deviceModel].py
			worldScale = objects.birdCameraData[deviceModel].sx
			setWorldScale(worldScale)
			oldScale = worldScale
		end
	end
	
	if keyHold["SHIFT"] and keyHold["CONTROL"] and (keyPressed["C"] or keyPressed["END"]) then
		if objects.castleCameraData ~= nil and objects.castleCameraData[deviceModel]then
			screen.x = objects.castleCameraData[deviceModel].px
			screen.y = objects.castleCameraData[deviceModel].py
			worldScale = objects.castleCameraData[deviceModel].sx
			setWorldScale(worldScale)
			oldScale = worldScale
		end
	end
	
	if not keyHold["SHIFT"] and not keyHold["CONTROL"] and keyPressed["END"] then
		if objects.doNotWaitForMovingObjects ~= nil then
			objects.doNotWaitForMovingObjects = nil
		else
			objects.doNotWaitForMovingObjects = true
		end
	end
	
	if not keyHold["SHIFT"] and keyHold["CONTROL"] and keyPressed["C"] then
		copiedObjects = {}
		copiedJoints = {}
		local x, y, w, h = getObjectListBounds(selectedObjects)
		for k, v in _G.pairs(selectedObjects) do
			--print("Adding to copied objects: " .. v.name .. "\n")
			copiedObjects[v.name] = { name = v.name, definition = v.definition, x = v.x - x, y = v.y - y, angle = v.angle }
			if v.width == nil then
				copiedObjects[v.name].width = v.radius
				copiedObjects[v.name].height = v.radius
			else
				copiedObjects[v.name].width = v.width
				copiedObjects[v.name].height = v.height
			end
			
			if editor.drawOneLayer then
				copiedObjects[v.name].scale = v.scale
			end	
			
		end
		
		for k, v in _G.pairs(objects.joints) do
			--print("Current joints to check: " .. v.name .. "\n")
			
			--change the clause below to or if you want to select a joint even if you have
			--only selected one block of it
			--if isKeyInList(v.end1, copiedObjects) and isKeyInList(v.end2, copiedObjects) then
			if copiedObjects[v.end1] ~= nil and copiedObjects[v.end2] ~= nil then
				--print("this joint is going to get copied " .. v.name .. "\n")
				
				--distance joint
				if v.type == 1 then
					copiedJoints[v.name] = { type =  v.type, end1 = v.end1, end2= v.end2, x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected, dampingRatio=v.dampingRatio, frequency=v.frequency }
				--weld joint
				elseif v.type == 2 then
					copiedJoints[v.name] = { type =  v.type, end1 = v.end1, end2= v.end2, x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected }
				--revolute joint
				elseif v.type == 3 then
					copiedJoints[v.name] = { type =  v.type, end1 = v.end1, end2= v.end2, x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected, maxTorque=v.maxTorque,limit=v.limit,backAndForth=v.backAndForth,motorSpeed=v.motorSpeed,motor=v.motor,lowerLimit=v.lowerLimit,upperLimit=v.upperLimit }
				--prismatic joint
				elseif v.type == 4 then
					copiedJoints[v.name] = { type =  v.type, end1 = v.end1, end2= v.end2, x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected, maxTorque=v.maxTorque, limit=v.limit, backAndForth=v.backAndForth,motorSpeed=v.motorSpeed,worldAxisY=v.worldAxisY, motor=v.motor, lowerLimit=v.lowerLimit, upperLimit=v.upperLimit, worldAxisX = v.worldAxisX}
				--anihilation joint
				elseif v.type == 5 then
					copiedJoints[v.name] = { type =  v.type, end1 = v.end1, end2= v.end2, x1=v.x1, y1=v.y1, x2=v.x2, y2=v.y2, coordType=v.coordType,collideConnected=v.collideConnected, destroyTimer = v.destroyTimer}
				end
			end
			
		end
		--the loop below is for selecting blocks that were left off from the selection
		--but are connected to a joint that is connected to a selected block. 
		--uncomment it out if needed later
		--[[
		for k, v in _G.pairs(copiedJoints) do
			--print("this joint will be copied: " .. k .. "\n")
			
			
			
			if (not isKeyInList(v.end1, copiedObjects)) then
				--print("this object is not selected, but will be copied " .. v.end1 .. "\n")				
				
				copiedObjects[v.end1] = { name = v.end1, definition = objects.world[v.end1].definition, x = objects.world[v.end1].x - x, y = objects.world[v.end1].y - y, angle = objects.world[v.end1].angle, strength=objects.world[v.end1].strength }
				if objects.world[v.end1].width == nil then
					copiedObjects[v.end1].width = objects.world[v.end1].radius
					copiedObjects[v.end1].height = objects.world[v.end1].radius
				else
					copiedObjects[v.end1].width = objects.world[v.end1].width
					copiedObjects[v.end1].height = objects.world[v.end1].height
				end
			
			elseif (not isKeyInList(v.end2, copiedObjects)) then
				--print("this object is not selected, but will be copied " .. v.end1 .. "\n")				
				
				copiedObjects[v.end2] = { name = v.end2, definition = objects.world[v.end2].definition, x = objects.world[v.end2].x - x, y = objects.world[v.end2].y - y, angle = objects.world[v.end2].angle, strength=objects.world[v.end2].strength }
				if objects.world[v.end2].width == nil then
					copiedObjects[v.end2].width = objects.world[v.end2].radius
					copiedObjects[v.end2].height = objects.world[v.end2].radius
				else
					copiedObjects[v.end2].width = objects.world[v.end2].width
					copiedObjects[v.end2].height = objects.world[v.end2].height
				end
			end
			
		end
		]]--
		
		--for k, v in _G.pairs(copiedObjects) do
		--	print("Final objects to copy: " .. v.name .. "\n")
		--end
		
		selectedObjects = {}
	end
	
	if keyPressed["0"] then
		editor.drawOneLayer = not editor.drawOneLayer
		selectedObjects = {}
		copiedObjects = {}
		copiedJoints = {}
		objectToAdd = nil
	end
	
	defaultCamera(dt)

	oldCursor.x = cursor.x
	oldCursor.y = cursor.y	
	
--	drawGame()
	for k, v in _G.pairs(objects.joints) do
		if v.backAndForth then
			checkJointLimits(v.name)
		end
	end
	
	if editor.drawOneLayer and keyHold["CONTROL"] and cursor.wheelTriggered then
		editor.currentLayer = editor.currentLayer - cursor.wheel
		local maxLayer = #blockTable.themes[objects.theme].bgLayers + #blockTable.themes[objects.theme].fgLayers 
		if editor.currentLayer >= maxLayer then
			editor.currentLayer = 0
		elseif editor.currentLayer < 0 then
			editor.currentLayer = maxLayer - 1
		end
	end
	
	editorJointPage:update(dt)
	drawEditor()
	editorJointPage:draw()
	
	if cursor.wheelTriggered then
		cursor.wheelTriggered = false
	end
	

	
end


-------------------
--OverlayPage-class
-------------------

OverlayPage = Page:new()

function OverlayPage:init()
	self:insertItem("shade", RectItem:new({alpha = 0.0}))
	self:insertItem("kingText", TextItem:new({default = "Pigs popped: ", text = "Pigs popped: ", x = screenWidth / 2, y = screenHeight / 2, visible = false}))
	self:insertItem("trainText", TextItem:new({default = "Carts wrecked: ", text = "Carts Wrecked: ", x = screenWidth / 2, y = screenHeight / 2, visible = false}))
	self:insertItem("again", TextItem:new({text = "Try again", x = screenWidth / 2, y = (screenHeight / 2) + (50 / 320) * screenHeight, visible = false,
										   action = {[function(x) sm:changeScene(x) end] = "kingOfTheHill"}}))
	self:insertItem("quit", TextItem:new({text = "Quit", x = screenWidth / 2, y = (screenHeight / 2) + (80 / 320) * screenHeight, visible = false,
										   action = {[function(x) sm:changeScene(x) end] = "mainMenu"}}))
end

function OverlayPage:onEntry()
	--print("\noverlay on entry")
	self.items.shade.x1 = 0
	self.items.shade.x2 = screenWidth
	self.items.shade.y1 = 0
	self.items.shade.y2 = screenHeight
	
end

function OverlayPage:update(dt, time)
	if self.fadeIn == true then
		self.fadeTime = self.fadeTime - dt
		self.items.shade.alpha = self.items.shade.alpha + dt * self.fadeIncrement
		if self.fadeTime < 0 then
			self.fadeIn = false
			self.items.shade.alpha = self.fadeTo
			self.fadeTime = 0
		end
	elseif self.fadeOut == true then
		self.fadeTime = self.fadeTime - dt
		self.items.shade.alpha = self.items.shade.alpha - dt * self.fadeIncrement
		if self.fadeTime < 0 then
			self.fadeOut = false
			self.items.shade.alpha = self.fadeTo
			self.fadeTime = 0
		end
	end
end

function OverlayPage:initTexts(score)
	self.visible = true
	self.items.kingText.text = self.items.kingText.default .. score
	self.items.kingText.visible = true
	self.items.again.visible = true
	self.items.quit.visible = true
	self:fade(0, 0.3, 1)
end


function OverlayPage:initTrainTexts(score)
	self.visible = true
	self.items.trainText.text = self.items.trainText.default .. score
	self.items.trainText.visible = true
	self.items.again.visible = true
	self.items.quit.visible = true
	self:fade(0, 0.3, 1)
end

function OverlayPage:updatePositions()
	self.items.shade.x2 = screenWidth
	self.items.shade.y2 = screenHeight
	self.items.kingText.x = screenWidth / 2
	self.items.kingText.y = screenHeight / 2
	self.items.trainText.x = screenWidth / 2
	self.items.trainText.y = screenHeight / 2
	self.items.again.x = screenWidth / 2
	self.items.again.y = screenHeight / 2 + (50 / 320) * screenHeight
	self.items.quit.x = screenWidth / 2
	self.items.quit.y = screenHeight / 2 + (80 / 320) * screenHeight
end

function OverlayPage:fade(from, to, time)
	if from < to then
		self.items.shade.alpha = from
		self.fadeTo = to
		self.fadeIncrement = (to - from)/ time
		self.fadeTime = time
		self.fadeIn = true
	else 
		self.items.shade.alpha = from
		self.fadeTo = to
		self.fadeIncrement = (from - to)/ time
		self.fadeTime = time
		self.fadeOut = true
	end
end

function roundNumber(number, decimalDigits) 	
	local t_shift = 10 ^ decimalDigits
	
	return (_G.math.floor( number*t_shift + 0.5 ) / t_shift)
end

EditorJointPage = Page:new()

function EditorJointPage:init()
	self.m_selectedAnchor = nil
end

function EditorJointPage:onEntry()
	
	self:insertItem("shade", RectItem:new({alpha = 0.0, renderState = true}))
	
	self.jointTexts = { "Distance Joint", "Weld Joint", "Revolute Joint", "Prismatic Joint", "\"Destroy-attached\" -joint" }
	self.motorTexts = { "Motor: disabled", "Motor: enabled" }
	self.limitTexts = { "Limits: disabled", "Limits: enabled" }
	self.backAndForthTexts = { "Back-and-forth: disabled", "Back-and-forth: enabled"}
	self.xTexts = { "x: 0", "x: 1" }
	self.yTexts = { "y: 0", "y: 1" }
	self.collideTexts = { "Collide connected: disabled", "Collide connected: enabled" }
	
	setFont("FONT_BASIC")
	local fl = _G.res.getFontLeading()
	fl = fl * 1.5
	self:insertItem("name", TextItem:new({name = "name", text = "", visible = false, font = "FONT_BASIC", x = 0, y = (80 / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("type", TextItem:new({name = "type", text = "", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("motor", TextItem:new({name = "motor", text = "", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl * 2) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("motorSpeed", TextItem:new({name = "motorSpeed", text = "", visible = false, font = "FONT_BASIC", x = (20 / 480) * screenWidth, y = ((80 + fl * 3) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("maxTorque", TextItem:new({name = "maxTorque", text = "", visible = false, font = "FONT_BASIC", x = (20 / 480) * screenWidth, y = ((80 + fl * 4) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("limit", TextItem:new({name = "limit", text = "", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl * 5) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("lowerLimit", TextItem:new({name = "lowerLimit", text = "", visible = false, font = "FONT_BASIC", x = (20 / 480) * screenWidth, y = ((80 + fl * 6) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("upperLimit", TextItem:new({name = "upperLimit", text = "", visible = false, font = "FONT_BASIC", x = (20 / 480) * screenWidth, y = ((80 + fl * 7) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("backAndForth", TextItem:new({name = "backAndForth", text = "", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl * 8) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("ok", TextItem:new({name = "ok", text = "OK", visible = false, font = "FONT_BASIC", x = (40 / 480) * screenWidth, y = ((80 + fl * 4) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("x", TextItem:new({name = "x", text = "", visible = false, font = "FONT_BASIC", x = (10 / 480) * screenWidth, y = ((80 + fl * 3) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("y", TextItem:new({name = "y", text = "", visible = false, font = "FONT_BASIC", x = (60 / 480) * screenWidth, y = ((80 + fl * 3) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("frequency", TextItem:new({name = "frequency", text = "", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl * 2) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("damping", TextItem:new({name = "damping", text = "", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl * 3) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("collide", TextItem:new({name = "collide", text = "", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl * 2) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("destroyTimer", TextItem:new({name = "destroyTimer", text = "", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl * 2) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	
	self:insertItem("anchor1", TextItem:new({name = "anchors1", text = "Anchors 1", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl * 9) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("anchor2", TextItem:new({name = "anchors1", text = "Anchors 2", visible = false, font = "FONT_BASIC", x = 0, y = ((80 + fl * 10) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	
	self:insertItem("anchorX1", TextItem:new({name = "anchorX1", text = "x:", visible = false, font = "FONT_BASIC", x = 100, y = ((80 + fl * 9) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("anchorY1", TextItem:new({name = "anchorY1", text = "y:", visible = false, font = "FONT_BASIC", x = 200, y = ((80 + fl * 9) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	
	self:insertItem("anchorX2", TextItem:new({name = "anchorX2", text = "x:", visible = false, font = "FONT_BASIC", x = 100, y = ((80 + fl * 10) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	self:insertItem("anchorY2", TextItem:new({name = "anchorY2", text = "y:", visible = false, font = "FONT_BASIC", x = 200, y = ((80 + fl * 10) / 480) * screenHeight, hanchor = "LEFT", vanchor = "TOP"}))
	
	
	self.selectedJoint = nil
	for k, v in _G.pairs(objects.joints) do
		self:addJoint(v.name)
	end
	self:updatePositions()
	self:prepareTexts()
end	

function EditorJointPage:hideAllNonCommonItems()
	
	self.items.motor.visible = false
	self.items.motorSpeed.visible = false
	self.items.maxTorque.visible = false
	self.items.limit.visible = false
	self.items.lowerLimit.visible = false
	self.items.upperLimit.visible = false
	self.items.backAndForth.visible = false
	
	self.items.x.visible = false
	self.items.y.visible = false
	self.items.frequency.visible = false
	self.items.damping.visible = false
	self.items.collide.visible = false
	self.items.destroyTimer.visible = false
	
	
end

function EditorJointPage:onExit()
	for i = 1, #self.items do
		self:removeItem(self.items[i])
	end
end

function EditorJointPage:addJoint(joint)

	self:insertItem(joint, SpriteItem:new({ sprite = "TRAIL_FLOWER_1",spriteIdle = "TRAIL_FLOWER_1", spriteClick="TRAIL_FLOWER_3", inWorld = true }))
	self:insertItem(joint .. "_ANCHOR_1", SpriteItem:new({ sprite = "TRAIL_WHITE_1",spriteIdle = "TRAIL_WHITE_1", spriteClick="TRAIL_FLOWER_3", inWorld = true }))
	self:insertItem(joint .. "_ANCHOR_2", SpriteItem:new({ sprite = "TRAIL_WHITE_1",spriteIdle = "TRAIL_WHITE_1", spriteClick="TRAIL_FLOWER_3", inWorld = true }))
	
end

function EditorJointPage:create_joint()
	if editor.newJoint.type == 4 then
		if self.items.x.text == self.xTexts[1] then
			editor.newJoint.worldAxisX = 0
		else
			editor.newJoint.worldAxisX = 1
		end
		if self.items.y.text == self.yTexts[1] then
			editor.newJoint.worldAxisY = 0
		else
			editor.newJoint.worldAxisY = 1
		end
		self.items.x.visible = false
		self.items.y.visible = false
	end
	
	--makes all anchors coordinates in object's local space
	editor.newJoint.coordType = 2

	createJoint(editor.newJoint)
	self:addJoint(editor.newJoint.name)
	selectedObjects = {}
	self.selectedJoint = objects.joints[editor.newJoint.name]
	--self.items[self.selectedJoint.name].sprite = "TRAIL_FLOWER_3"
	self.items[self.selectedJoint.name].sprite = self.items[self.selectedJoint.name].spriteClick
	editor.newJoint = nil
	levelSaved = false
	self.items.ok.visible = false
	self:prepareTexts()
end

function EditorJointPage:update(dt, time) 
	
	self:updatePositions()
	
	if self.newJoint then
		if not self.fadeIn and self.items.shade.alpha <= 0 then 
			OverlayPage.fade(self, 0, 0.5, 0.2)
			self.fadeIn = true
		end
	--	self.items.ok.visible = true
		self:prepareTexts()
		self.newJoint = false
	end
	
	local itm = self:checkClicks()
	if itm and (self.selectedJoint or editor.newJoint) then
		local joint = self.selectedJoint
		-- toggle motor for revolute and prismatic joints
		if itm.name == "motor" then
			if joint.motor ~= nil then
				setJointParameters({name = joint.name, motor = not joint.motor})
				if not joint.motor then
					joint.backAndForth = false
				end	
				self:prepareTexts()
				levelSaved = false
			end
		-- toggle limits
		elseif itm.name == "limit" then
			if joint.limit ~= nil then
				setJointParameters({name = joint.name, limit = not joint.limit})
				if not joint.limit then
					joint.backAndForth = false
				end
				self:prepareTexts()
				levelSaved = false
			end
		-- toggle back-and-forth
		elseif itm.name == "backAndForth" then
			if joint.motor ~= nil and joint.limit ~= nil then
				joint.backAndForth = not joint.backAndForth
				if joint.backAndForth then
					self.items.backAndForth.text = self.backAndForthTexts[2]
				else
					self.items.backAndForth.text = self.backAndForthTexts[1]
				end
				levelSaved = false
			end
		elseif itm.name == "x" then
			if itm.text == self.xTexts[1] then
				itm.text = self.xTexts[2]
			else
				itm.text = self.xTexts[1]
			end
		elseif itm.name == "y" then
			if itm.text == self.yTexts[1] then
				itm.text = self.yTexts[2]
			else
				itm.text = self.yTexts[1]
			end
		elseif not joint and itm.name == "collide" then
			editor.newJoint.collideConnected = not editor.newJoint.collideConnected
			if itm.text == self.collideTexts[1] then
				itm.text = self.collideTexts[2]
			else
				itm.text = self.collideTexts[1]
			end
		elseif itm.name == "type" and not joint and editor.newJoint then
			editor.newJoint.type = editor.newJoint.type + 1
			if editor.newJoint.type == 6 then
				editor.newJoint.type = 1
			end
			if editor.newJoint.type == 4 then
				self.items.x.visible = true
				self.items.y.visible = true
				self.items.x.text = self.xTexts[1]
				self.items.y.text = self.yTexts[1]
			else
				self.items.x.visible = false
				self.items.y.visible = false
			end
			if editor.newJoint.type == 5 then 
				self.items.collide.visible = false
			else
				self.items.collide.visible = true
			end
			self.items.type.text = self.jointTexts[editor.newJoint.type]
		-- create new joint
		elseif not joint and editor.newJoint and itm.name == "ok" then
			self:create_joint()
		end
	end
	
	if keyPressed["RETURN"] then
		if not self.selectedJoint and editor.newJoint then
			self:create_joint()
		elseif self.selectedJoint ~= nil then
			self.disableSelectedJoint = true
		end
	end

	-- change joint parameters
	if (keyHold["LBUTTON"] or keyHold["RBUTTON"] or (keyHold["CONTROL"] and cursor.wheel and cursor.wheelTriggered and (cursor.wheel == -1 or cursor.wheel == 1)))
		and (self.selectedJoint or editor.newJoint) then
		
		local itms = self:getHoveredItems()
		local offset = 1
		if keyHold["RBUTTON"] then
			offset = -1
		end
		if keyHold["CONTROL"] and cursor.wheel and (cursor.wheel == -1 or cursor.wheel == 1) and cursor.wheelTriggered then
			offset = cursor.wheel
		end
		if itms then 
			if keyHold["SHIFT"] then 
				offset = offset * 10
			end
			for k, v in _G.pairs(itms) do
				if v == "motorSpeed" then
					setJointParameters({name = self.selectedJoint.name, motorSpeed = self.selectedJoint.motorSpeed + offset / 10 })--+ cursor.wheel / 10})
					self.items.motorSpeed.text = "Speed: " .. self.selectedJoint.motorSpeed
					levelSaved = false
				elseif v == "maxTorque" then
					setJointParameters({name = self.selectedJoint.name, maxTorque = self.selectedJoint.maxTorque + offset * 100})--cursor.wheel * 100})
					self.items.maxTorque.text = "MaxTorque: " .. self.selectedJoint.maxTorque
					levelSaved = false
				elseif v == "lowerLimit" then
					local newLowLimit = _G.math.min(self.selectedJoint.lowerLimit + (offset / 360) * (_G.math.pi * 2), 0)
					setJointParameters({name = self.selectedJoint.name, lowerLimit = newLowLimit })
					if self.selectedJoint.type == 3 then
						self.items.lowerLimit.text = "Lower: " .. (self.selectedJoint.lowerLimit / (2 * _G.math.pi)) * 360
					elseif self.selectedJoint.type == 4 then
						self.items.lowerLimit.text = "Lower: " .. self.selectedJoint.lowerLimit
					end
					levelSaved = false
				elseif v == "upperLimit" then
					local newHighLimit = _G.math.max(0, self.selectedJoint.upperLimit + (offset / 360) * (_G.math.pi * 2))
					setJointParameters({name = self.selectedJoint.name, upperLimit = newHighLimit})
					if self.selectedJoint.type == 3 then
						self.items.upperLimit.text = "Upper: " .. (self.selectedJoint.upperLimit / (2 * _G.math.pi)) * 360
					elseif self.selectedJoint.type == 4 then
						self.items.upperLimit.text = "Upper: " .. self.selectedJoint.upperLimit
					end
					levelSaved = false
				elseif v == "frequency" then
					setJointParameters({name = self.selectedJoint.name, frequency = self.selectedJoint.frequency + offset / 10 })
					self.items.frequency.text = "Frequency: " .. self.selectedJoint.frequency
					levelSaved = false
				elseif v == "damping" then
					local newDamping = _G.math.max(0, _G.math.min(self.selectedJoint.dampingRatio + offset / 100, 1))
					setJointParameters({name = self.selectedJoint.name, dampingRatio = newDamping })
					self.items.damping.text = "Damping: " .. self.selectedJoint.dampingRatio
					levelSaved = false
				elseif v == "destroyTimer" then
					self.selectedJoint.destroyTimer = _G.math.max(0, self.selectedJoint.destroyTimer + offset / 100)
					self.items.destroyTimer.text = "Annihilation(!) timer: " .. self.selectedJoint.destroyTimer
					levelSaved = false				
				elseif v == "anchorX1" then
					self.selectedJoint.x1 = self.selectedJoint.x1 + (offset / 100)
					self.items.anchorX1.text = "x: " .. roundNumber(self.selectedJoint.x1, 2)
					levelSaved = false				
				elseif v == "anchorY1" then
					self.selectedJoint.y1 = self.selectedJoint.y1 + (offset / 100)
					self.items.anchorY1.text = "y: " .. roundNumber(self.selectedJoint.y1,2)
					levelSaved = false
				elseif v == "anchorX2" then
					self.selectedJoint.x2 = self.selectedJoint.x2 + (offset / 100)
					self.items.anchorX2.text = "x: " .. roundNumber(self.selectedJoint.x2,2)
					levelSaved = false				
				elseif v == "anchorY2" then
					self.selectedJoint.y2 = self.selectedJoint.y2 + (offset / 100)
					self.items.anchorY2.text = "y: " .. roundNumber(self.selectedJoint.y2,2)
					levelSaved = false
				end
			end
		end
	end
	
	if keyPressed["RBUTTON"] then
		local t_clickedOnAJointElement = false
		local t_clickedOnAnEditorItem = false
		local t_jointSelectedBefore = self.selectedJoint ~= nil
		
		local t_items = self:getHoveredItems()
		
		if not t_items then
			t_clickedOnAnEditorItem = false
		else
			t_clickedOnAnEditorItem = true
		end		
		
		--checks if the user has clicked any joint elements
		for k, v in _G.pairs(objects.joints) do							
					
			if 	(self.items[v.name] and self.items[v.name]:checkBounds(cursor.x, cursor.y)) or 
				(self.items[v.name .. "_ANCHOR_1"] and self.items[v.name  .. "_ANCHOR_1"]:checkBounds(cursor.x, cursor.y)) or
				(self.items[v.name .. "_ANCHOR_2"] and self.items[v.name  .. "_ANCHOR_2"]:checkBounds(cursor.x, cursor.y)) then
				
				--brings the selected joint to the idle state
				if self.selectedJoint then
					self.items[self.selectedJoint.name  .. "_ANCHOR_1"].sprite = self.items[self.selectedJoint.name  .. "_ANCHOR_1"].spriteIdle
					self.items[self.selectedJoint.name  .. "_ANCHOR_2"].sprite = self.items[self.selectedJoint.name  .. "_ANCHOR_2"].spriteIdle
					self.items[self.selectedJoint.name].sprite = self.items[self.selectedJoint.name].spriteIdle
				end		
				
				selectedObjects = {}
				
				self.selectedJoint = v
				
				editor.newJoint = false
				
				t_clickedOnAJointElement = true								
				
				--sets clicked joint with the click sprite
				self.items[v.name].sprite = self.items[v.name].spriteClick
					
				--if an anchor was clicked, put also the click sprite
				if self.items[v.name  .. "_ANCHOR_1"]:checkBounds(cursor.x, cursor.y) then
					self.items[v.name  .. "_ANCHOR_1"].sprite = self.items[v.name  .. "_ANCHOR_1"].spriteClick
					self.items[v.name  .. "_ANCHOR_2"].sprite = self.items[v.name  .. "_ANCHOR_1"].spriteIdle
					self.m_selectedAnchor = self.items[v.name  .. "_ANCHOR_1"]
				elseif self.items[v.name  .. "_ANCHOR_2"]:checkBounds(cursor.x, cursor.y) then
					self.items[v.name  .. "_ANCHOR_2"].sprite = self.items[v.name  .. "_ANCHOR_2"].spriteClick
					self.items[v.name  .. "_ANCHOR_1"].sprite = self.items[v.name  .. "_ANCHOR_2"].spriteIdle
					self.m_selectedAnchor = self.items[v.name  .. "_ANCHOR_2"]
				end		

			
				self:hideAllNonCommonItems()
				self:prepareTexts()
				
				break
			end
		end
		
		if not editor.newJoint then
		
			--user has clicked outside the editing buttons or joints
			if (not t_clickedOnAnEditorItem) and (not t_clickedOnAJointElement) then
				--print("\nclick outside")
				--there was a joint selected, wil disable this joint
				if self.selectedJoint ~= nil then
					self.disableSelectedJoint = true
				end
			end
			
			--new joint has been selected outside the editing page
			if (t_clickedOnAJointElement) and not t_jointSelectedBefore then
				OverlayPage.fade(self, 0, 0.5, 0.2)
				self.fadeIn = true
			end
			
		end
		
	end	
	
	--moving joint anchors
	if self.selectedJoint and self.m_selectedAnchor and keyHold["LBUTTON"] then
		if self.items[self.selectedJoint.name .. "_ANCHOR_1"]:checkBounds(cursor.x, cursor.y) then
			
			local t_worldPosX = 0
			local t_worldPosY = 0
			
			local t_localPosX = 0
			local t_localPosY = 0						
			
			t_worldPosX, t_worldPosY = screenToPhysicsTransform(cursor.x, cursor.y)												
			t_localPosX , t_localPosY = getLocalPoint(objects.joints[self.selectedJoint.name].end1, t_worldPosX, t_worldPosY);						
			
			objects.joints[self.selectedJoint.name].x1 = t_localPosX
			objects.joints[self.selectedJoint.name].y1 = t_localPosY
			
			self.items.anchorX1.text = "x: " .. roundNumber(t_localPosX, 2)
			self.items.anchorY1.text = "y: " .. roundNumber(t_localPosY, 2)
			
			self:updatePositions()
			
			levelSaved = false
			
		elseif self.items[self.selectedJoint.name .. "_ANCHOR_2"]:checkBounds(cursor.x, cursor.y) then
			local t_worldPosX = 0
			local t_worldPosY = 0
			
			local t_localPosX = 0
			local t_localPosY = 0						
			
			t_worldPosX, t_worldPosY = screenToPhysicsTransform(cursor.x, cursor.y)												
			t_localPosX , t_localPosY = getLocalPoint(objects.joints[self.selectedJoint.name].end2, t_worldPosX, t_worldPosY);						
			
			objects.joints[self.selectedJoint.name].x2 = t_localPosX
			objects.joints[self.selectedJoint.name].y2 = t_localPosY
			
			self.items.anchorX2.text = "x: " .. roundNumber(t_localPosX, 2)
			self.items.anchorY2.text = "y: " .. roundNumber(t_localPosY, 2)
			
			self:updatePositions()
			
			levelSaved = false
		end
	
	end
	
	if keyPressed["DELETE"] and self.selectedJoint and not physicsEnabled then
		self:removeItem(self.selectedJoint.name)
		self:removeItem(self.selectedJoint.name .. "_ANCHOR_1")
		self:removeItem(self.selectedJoint.name .. "_ANCHOR_2")
		destroyJoint(self.selectedJoint.name)
		self.selectedJoint = nil
		self.disableSelectedJoint = true
	end
	
	if self.disableSelectedJoint then
		if self.selectedJoint then
			--self.items[self.selectedJoint.name].sprite = "TRAIL_FLOWER_1"
			self.items[self.selectedJoint.name].sprite = self.items[self.selectedJoint.name].spriteIdle
			
			
			self.items[self.selectedJoint.name .. "_ANCHOR_1"].sprite = self.items[self.selectedJoint.name .. "_ANCHOR_1"].spriteIdle
			self.items[self.selectedJoint.name .. "_ANCHOR_2"].sprite = self.items[self.selectedJoint.name .. "_ANCHOR_2"].spriteIdle
			
			self.m_selectedAnchor = nil			
			self.selectedJoint = nil
		end
		if not self.fadeOut and self.items.shade.alpha >= 0.5 then
			self.fadeOut = true
			OverlayPage.fade(self, 0.5, 0, 0.2)
		end
		editor.newJoint = nil
		self:prepareTexts()
		self.disableSelectedJoint = false
	end


	if self.fadeIn then
		OverlayPage.update(self, dt)
		if self.items.shade.alpha >= 0.5 then
			self.fadeIn = false
		end
	elseif self.fadeOut then
		OverlayPage.update(self, dt)
		if self.items.shade.alpha <= 0 then
			self.fadeOut = false
		end 
	end
	
end

function EditorJointPage:setJointSelection()
	

end

function EditorJointPage:prepareTexts()
	
	local joint = self.selectedJoint or editor.newJoint
	
	if joint then
		self.items.name.text = "Name: " .. joint.name		
		self.items.type.text = self.jointTexts[joint.type]
		if joint.collideConnected then
			self.items.collide.text = self.collideTexts[2]
		else
			self.items.collide.text = self.collideTexts[1]
		end
		self.items.type.visible = true
		self.items.name.visible = true
		
		if self.selectedJoint then
			self.items.anchor1.visible = true
			self.items.anchor2.visible = true
			self.items.anchorX1.visible = true
			self.items.anchorY1.visible = true
			self.items.anchorX2.visible = true
			self.items.anchorY2.visible = true
			
			
		
			self.items.anchorX1.text = "x: " .. roundNumber(joint.x1,2)
			self.items.anchorY1.text = "y: " .. roundNumber(joint.y1, 2)
			self.items.anchorX2.text = "x: " .. roundNumber(joint.x2,2)
			self.items.anchorY2.text = "y: " .. roundNumber(joint.y2,2)
		end
	
		
		
		if editor.newJoint and not self.selectedJoint then
			self.items.ok.visible = true
			if editor.newJoint.type ~= 5 then
				self.items.collide.visible = true
			end
			return
		else
			self.items.ok.visible = false	
			self.items.collide.visible = false
		end
		if joint.type == 3 or joint.type == 4 then -- revolute and prismatic joint
			
			if joint.motor then
				self.items.motor.text = self.motorTexts[2]
			else
				self.items.motor.text = self.motorTexts[1]
			end
			if joint.limit then
				self.items.limit.text = self.limitTexts[2]
			else
				self.items.limit.text = self.limitTexts[1]
			end
			
			if joint.backAndForth then
				self.items.backAndForth.text = self.backAndForthTexts[2]
			else
				self.items.backAndForth.text = self.backAndForthTexts[1]
			end
			
			self.items.motorSpeed.text = "Speed: " .. joint.motorSpeed
			self.items.maxTorque.text = "MaxTorque: " .. joint.maxTorque
			if joint.type == 3 then
				self.items.lowerLimit.text = "Lower: " .. (joint.lowerLimit / (2 * _G.math.pi)) * 360
				self.items.upperLimit.text = "Upper: " .. (joint.upperLimit / (2 * _G.math.pi)) * 360
			else
				self.items.lowerLimit.text = "Lower: " .. joint.lowerLimit
				self.items.upperLimit.text = "Upper: " .. joint.upperLimit
			end
			
			self.items.motor.visible = true
			self.items.limit.visible = true
			if joint.motor then
				self.items.motorSpeed.visible = true
				self.items.maxTorque.visible = true
			else
				self.items.motorSpeed.visible = false
				self.items.maxTorque.visible = false
			end
			if joint.limit then
				self.items.lowerLimit.visible = true
				self.items.upperLimit.visible = true
			else
				self.items.lowerLimit.visible = false
				self.items.upperLimit.visible = false
			end
			
			if joint.motor and joint.limit then
				self.items.backAndForth.visible = true	
			else
				self.items.backAndForth.visible = false
			end
		elseif joint.type == 1 then
			self.items.frequency.text = "Frequency: " .. joint.frequency
			self.items.damping.text = "Damping: " .. joint.dampingRatio
			self.items.frequency.visible = true
			self.items.damping.visible = true
		elseif joint.type == 5 then
			self.items.destroyTimer.text = "Annihilation(!) timer: " .. joint.destroyTimer
			self.items.destroyTimer.visible = true
			self.items.collide.visible = false
		end
	elseif not joint then
		self.items.name.visible = false
		self.items.type.visible = false
		self.items.motor.visible = false	
		self.items.motorSpeed.visible = false
		self.items.maxTorque.visible = false
		self.items.limit.visible = false
		self.items.lowerLimit.visible = false
		self.items.upperLimit.visible = false
		self.items.backAndForth.visible = false
		self.items.x.visible = false
		self.items.y.visible = false
		self.items.damping.visible = false
		self.items.frequency.visible = false
		self.items.ok.visible = false
		self.items.collide.visible = false
		self.items.destroyTimer.visible = false
		
		self.items.anchor1.visible = false
		self.items.anchor2.visible = false
		self.items.anchorX1.visible = false
		self.items.anchorY1.visible = false
		self.items.anchorX2.visible = false
		self.items.anchorY2.visible = false
	end

end


function EditorJointPage:draw()
	if editor.drawOneLayer then
		return
	end
	
	self.items["shade"]:draw()	
	
	if self.selectedJoint or editor.newJoint then 
		local joint = self.selectedJoint or editor.newJoint
		local obj1 = objects.world[joint.end1]
		local obj2 = objects.world[joint.end2]
		local xCoord, yCoord = physicsToWorldTransform(obj1.x, obj1.y)
		setRenderState(-screen.left, -screen.top, worldScale, worldScale, obj1.angle, _G.res.getSpritePivot("", obj1.sprite))
		_G.res.drawSprite("", obj1.sprite, xCoord, yCoord)
		setRenderState(-screen.left, -screen.top, worldScale, worldScale, obj2.angle, _G.res.getSpritePivot("", obj2.sprite))
		xCoord, yCoord = physicsToWorldTransform(obj2.x, obj2.y)
		_G.res.drawSprite("", obj2.sprite, xCoord, yCoord)
		setRenderState(0, 0, 1, 1, 0, 0, 0)
		if self.selectedJoint then
			drawJoint(editor, objects.joints[self.selectedJoint.name], "EDITOR_JOINT")
		end
	--	self.items.name:draw()
	--	self.items[self.selectedJoint.name]:draw()
	end
	
	for k, v in _G.pairs(self.order) do
		if v ~= "shade" and self.items[v].sprite then
			--self.items[v]:draw()
			local xCoord, yCoord = self.items[v].x, self.items[v].y
			local xs, ys = self.items[v].xs or 1, self.items[v].ys or 1
			local angle = self.items[v].angle or 0
			local px, py = self.items[v].pivotX or 0, self.items[v].pivotY or 0
		
			setRenderState(-screen.left, -screen.top, worldScale, worldScale, 0, 0, 0)
			xCoord, yCoord = physicsToWorldTransform(xCoord, yCoord)
			
			_G.res.drawSprite(self.items[v].sheet, self.items[v].sprite, xCoord, yCoord)
			setRenderState(0, 0, 1, 1, 0, 0, 0)
		else
			self.items[v]:draw()
		end
	end
	
	

end

function EditorJointPage:updatePositions()
	
	for k, v in _G.pairs(objects.joints) do
		local joint = v
		local jointWorldX1 = joint.x1
		local jointWorldY1 = joint.y1
		local jointWorldX2 = joint.x2
		local jointWorldY2 = joint.y2
	
		if joint.coordType == 2 then
			jointWorldX1, jointWorldY1 = getWorldPoint(joint.end1, jointWorldX1, jointWorldY1);
			jointWorldX2, jointWorldY2 = getWorldPoint(joint.end2, jointWorldX2, jointWorldY2);
		end
		local xdif = jointWorldX2 - jointWorldX1
		local ydif = jointWorldY2 - jointWorldY1
		local xCoord, yCoord = jointWorldX1 + (xdif / 2), jointWorldY1 + (ydif / 2)
		self.items[joint.name].x = xCoord
		self.items[joint.name].y = yCoord
		
		
		self.items[joint.name .. "_ANCHOR_1"].x = jointWorldX1
		self.items[joint.name .. "_ANCHOR_1"].y = jointWorldY1
		
		self.items[joint.name .. "_ANCHOR_2"].x = jointWorldX2
		self.items[joint.name .. "_ANCHOR_2"].y = jointWorldY2
		
		
	end
	self.items.shade.x2 = screenWidth
	self.items.shade.y2 = screenHeight
	
end

function returnToEditor()
	setEditing(true)
	local name = "temp/" .. levelName .. ".temp.playtest"
	currentThemeNumber = levelSelectionPageNumber
	loadLevelInternal(levelFolder .. name)
	setGameMode(updateEditor)
	setPhysicsEnabled(false)
	-- if editorJointPage then
		-- editorJointPage:onExit()
		-- editorJointPage = nil
	-- end
end

function goToMenu()
	pausePage.offsetX = -pauseBGw
	setGameMode(showPauseMenu)
	setPhysicsEnabled(false)
end

function addObjectToSelection(object, removeDuplicate)
	local objectFound = false
	for soi = 1, #selectedObjects do
		if selectedObjects[soi] == object then
			if removeDuplicate then
				_G.table.remove(selectedObjects, soi)
			end
			objectFound = true
			soi = #selectedObjects
		end
	end
	if not objectFound then
		_G.table.insert(selectedObjects, object)
	end
end

function addToAchievementUnlockQueue(desc, inFront)
	
	if achievements ~= nil and achievements[desc] ~= nil then
		local id = achievements[desc].id
		for i = 1, #achievementUnlockQueue do
			if achievementUnlockQueue[i].id == id then
				return
			end
		end
		inFront = inFront or false
		if inFront then
			_G.table.insert(achievementUnlockQueue, 1, {id = id, desc = desc} )
		else
			_G.table.insert(achievementUnlockQueue, {id = id, desc = desc} )
		end
	end
end

function checkForAchievements()

	calculatePlaytime()
	local totalBlocks = 0
	if settings.woodBlocksDestroyed ~= nil then
		totalBlocks = totalBlocks + settings.woodBlocksDestroyed
	end
	if settings.iceBlocksDestroyed ~= nil then
		totalBlocks = totalBlocks + settings.iceBlocksDestroyed
	end
	if settings.rockBlocksDestroyed ~= nil then
		totalBlocks = totalBlocks + settings.rockBlocksDestroyed
	end

	if settings.theme1Completed == true then
		addToAchievementUnlockQueue("Herr Helmet")
	end
	
	if settings.wilhelmTell == true then
		addToAchievementUnlockQueue("Wilhelm Tell")
	end
	
	if settings.bullsEye == true then
		addToAchievementUnlockQueue("Bull's Eye")
	end
	
	if settings.theme2Completed == true then
		addToAchievementUnlockQueue("Mr Moustache")
	end
	
	if settings.gameCompleted == true then
		addToAchievementUnlockQueue("Defeat of The King")
	end
	
	if settings.theme4Completed == true then
		addToAchievementUnlockQueue("The Imposter")
	end
	
	if settings.theme5Completed == true then
		addToAchievementUnlockQueue("The Mysterious Escape")
	end
		
	if settings.theme6Completed == true then
		addToAchievementUnlockQueue("Hovering Helmet")
	end
	
	if settings.theme7Completed == true then
		addToAchievementUnlockQueue("Mounting Moustache")
	end
	
	if settings.theme8Completed == true then
		addToAchievementUnlockQueue("Green Baron") 
	end
	
	if settings.theme9Completed == true then
		addToAchievementUnlockQueue("Hardhat Hidalgo")  
	end
	
	if settings.theme10Completed == true then
		addToAchievementUnlockQueue("Mason Moustache")  
	end
	
	if settings.theme11Completed == true then
		addToAchievementUnlockQueue("Royal Ringleader")  
	end
	
	if settings.theme12Completed == true then
		addToAchievementUnlockQueue("Billy The Pig")  
	end
	
	if settings.theme13Completed == true then
		addToAchievementUnlockQueue("Clint Eastbacon")  
	end
	
	if settings.theme14Completed == true then
		addToAchievementUnlockQueue("Wild Pork Hickok")  
	end

	if settings.theme15Completed == true then
		addToAchievementUnlockQueue("Cave Explorer")  
	end

	if settings.theme16Completed == true then
		addToAchievementUnlockQueue("Cave Conquer")  
	end

	if settings.theme17Completed == true then
		addToAchievementUnlockQueue("King of the Caves")  
	end
	
	local episode1TotalScore, episode1Stars, episode1TotalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
	if episode1Stars >= episode1TotalStars then
		addToAchievementUnlockQueue("Episode 1 - Total Destruction")
	end
	if episode1TotalScore >= 4000000 then
		addToAchievementUnlockQueue("Episode 1 - Score Addict")
	end

	local episode2TotalScore, episode2Stars, episode2TotalStars = calculateTotalScoreAndStars(levelOrder_packOne)
	if episode2Stars >= episode2TotalStars then
		addToAchievementUnlockQueue("Episode 2 - Total Destruction")
	end
	if episode2TotalScore >= 3300000 then
		addToAchievementUnlockQueue("Episode 2 - Score Addict")
	end
	
	local episode3TotalScore, episode3Stars, episode3TotalStars = calculateTotalScoreAndStars(levelOrder_packThree)
	if episode3Stars >= episode3TotalStars then
		addToAchievementUnlockQueue("Episode 3 - Total Destruction")
	end
	if episode3TotalScore >= 4800000 then 
		addToAchievementUnlockQueue("Episode 3 - Score Addict")
	end
	
	local episode4TotalScore, episode4Stars, episode4TotalStars = calculateTotalScoreAndStars(levelOrder_packFour)
	if episode4Stars >= episode4TotalStars then
		addToAchievementUnlockQueue("Episode 4 - Total Destruction")
	end
	if episode4TotalScore >= 3900000 then 
		addToAchievementUnlockQueue("Episode 4 - Score Addict")
	end
	
	local episode5TotalScore, episode5Stars, episode5TotalStars = calculateTotalScoreAndStars(levelOrder_packFive)
	if episode5Stars >= episode5TotalStars then
		addToAchievementUnlockQueue("Episode 5 - Total Destruction") 
	end
	
	if episode5TotalScore >= 4100000 then
		addToAchievementUnlockQueue("Episode 5 - Score Addict")
	end
	
	local feathers, maxFeathers = calculateFeathers(levelOrder_allLevels)
	--print("Checking for feather achievement, feathers: " .. feathers .. ", maxFeathers: " .. maxFeathers .. "\n")
	if feathers >= 200 then
		addToAchievementUnlockQueue("Feather Gatherer")
	elseif feathers >= 100 then
		addToAchievementUnlockQueue("Feather Collector")
	elseif feathers >= 50 then
		addToAchievementUnlockQueue("Feather Picker")		
	end

	if settings.tutorials["BIRD_BLUE"] ~= nil then
		addToAchievementUnlockQueue("Split it!")
	end
	
	if settings.tutorials["BIRD_YELLOW"] ~= nil then
		addToAchievementUnlockQueue("Speed is the Essence")
	end
	
	if settings.tutorials["BIRD_GREY"] ~= nil then
		addToAchievementUnlockQueue("Boom Boom!")
	end
	
	if settings.tutorials["BIRD_GREEN"] ~= nil then
		addToAchievementUnlockQueue("Mother of all Bombs")
	end
	
	if settings.tutorials["BIRD_BOOMERANG"] ~= nil then
		addToAchievementUnlockQueue("Return to Sender")
	end
	
	if settings.tutorials["BIRD_BIG_BROTHER"] ~= nil then
		addToAchievementUnlockQueue("Seeing Red")
	end
	
	if settings.tutorials["BAIT_SARDINE"] ~= nil then
		addToAchievementUnlockQueue("Aquiline Benefactor")
	end
	
	if settings.backwardsBirdCount ~= nil and settings.backwardsBirdCount >= 10 then
		addToAchievementUnlockQueue("Backward Compatibility", true)
	end
	
	if totalBlocks >= 50000 then
		addToAchievementUnlockQueue("Block Smasher", true)
	end
	
	if totalBlocks >= 500000 then
		addToAchievementUnlockQueue("Smash Maniac", true)
	end
	
	if settings.woodBlocksDestroyed ~= nil and settings.woodBlocksDestroyed >= 5000 then
		addToAchievementUnlockQueue("Woodpecker", true)
	end

	if settings.jewelsDestroyed ~= nil and settings.jewelsDestroyed >= 100 then
		print(" ::::::::::: ULTIMATE BEJEWELER ADDED TO ACH QUE")
		addToAchievementUnlockQueue("Ultimate Bejeweler", true)
	end

	if settings.stalaktitesDestroyed ~= nil and settings.stalaktitesDestroyed >= 100 then
		print(" ::::::::::: HARD AS ROCK ADDED TO ACH QUE")
		addToAchievementUnlockQueue("Hard as a Rock", true)
	end
	
	if settings.iceBlocksDestroyed ~= nil and settings.iceBlocksDestroyed >= 5000 then
		addToAchievementUnlockQueue("Icepicker", true)
	end
	
	if settings.rockBlocksDestroyed ~= nil and settings.rockBlocksDestroyed >= 5000 then
		addToAchievementUnlockQueue("Stonecutter", true)
	end
	
	if settings.pigsDestroyed ~= nil and settings.pigsDestroyed >= 1000 then
		addToAchievementUnlockQueue("Pig Popper", true)
	end
	
	if calculateOpenGoldenEggLevels() >= 10 then
		addToAchievementUnlockQueue("Egg Hunter")
	end
	
	if calculateStarsFromGoldenEggLevels() >= 10 then
		addToAchievementUnlockQueue("Egg Cracker")
	end
	
	if settings.gameCompleted == true then
		addToAchievementUnlockQueue("Ready For More")
	end
	
	if settings.threeStars == true then
		addToAchievementUnlockQueue("Total Destruction Lite")
	end
	
	if totalBlocks >= 500 then
		addToAchievementUnlockQueue("Block Smasher Lite", true)
	end
	
	if settings.woodBlocksDestroyed ~= nil and settings.woodBlocksDestroyed >= 100 then
		addToAchievementUnlockQueue("Woodpecker Lite", true)
	end
	
	if settings.iceBlocksDestroyed ~= nil and settings.iceBlocksDestroyed >= 100 then
		addToAchievementUnlockQueue("Icepicker Lite", true)
	end
	
	if settings.playtime ~= nil and (settings.playtime * 1) >= 18000 then
		addToAchievementUnlockQueue("Angry Birds Fan", true)
	end
	
	if settings.playtime ~= nil and (settings.playtime * 1) >= 54000 then
		addToAchievementUnlockQueue("True Angry Birds Fan", true)
	end
	
	if settings.playtime ~= nil and (settings.playtime * 1) >= 108000 then
		addToAchievementUnlockQueue("Angry Birds Addict", true)
	end
	
	if settings.cumulativeStars ~= nil and settings.cumulativeStars >= 750 then
		addToAchievementUnlockQueue("Star Collector", true)
	end
	
	if settings.cumulativeStars ~= nil and settings.cumulativeStars >= 1500 then
		addToAchievementUnlockQueue("Star Gatherer", true)
	end
	
	if settings.birdsShooted >= 5000 then
		addToAchievementUnlockQueue("Bird Slinger", true)
	end
end


function postTotalHighScores()
	if postHighscores == true then
		if not isLiteVersion then
		
			local totalScore = 0
			local worldNumber = 0
			
			-- iterate through episodes
			for i = 1, #levelOrder.episodes do
				local epPack = levelOrder.episodes[i]
				local epTotalScore = 0
				-- iterate through worlds
				for j = 1, #epPack do
					worldNumber = worldNumber + 1
					local worldTotalScore = getWorldScore(worldNumber)	
					epTotalScore = epTotalScore + worldTotalScore
					
					-- post world score
					local lboardName = getLeaderboardNameForWorld(worldNumber)
					if lboardName and worldTotalScore > 0 then
						postLevelHighScore(lboardName, worldTotalScore, false)
					end
				end
			
				totalScore = totalScore + epTotalScore
				
				-- post episode score
				local lboardName = getLeaderboardNameForEpisode(i)
				if lboardName and epTotalScore > 0 then
					postLevelHighScore(lboardName, epTotalScore, false)
				end
			end
			
			-- post total score
			local lboardName = getLeaderboardNameForTotalScore()
			if lboardName and totalScore > 0 then
				postLevelHighScore(lboardName, totalScore, false)
			end

		else
			local liteTotalScore, gainedStars, maxStars = calculateTotalScoreAndStars(levelOrder_packBasic)
			if liteTotalScore > 0 then
				postLevelHighScore("liteTotalScore", liteTotalScore, false);
			end
		end
	end
end

function postLevelHighScore(levelName, score, isLevelScore)
	if postHighscores == true then
		if leaderboards ~= nil then
			leaderboardid = leaderboards[levelName]
			if leaderboardid ~= nil then
				print("Posting highscore for level " .. levelName .. " (score = " .. score ..  " leaderboard = " .. leaderboardid .. ")\n")
				postHighscore(leaderboardid, score, isLevelScore)
			else
				print("Leaderboard id for level " .. levelName .. " not found!\n")
			end
		end
	end
end
--[[
function postGameCenterScore(lboardName, score)
	if lboardName and score > 0 then
		local lboardId = leaderboards[lboardName]
		if lboardId then
			if gameCenter.leaderboards and gameCenter.leaderboards[lboardId] then
				if gameCenter.leaderboards[lboardId].posted == false then
					print("Posting highscore for leaderboard " .. lboardName .. " (score = " .. score ..  " leaderboard = " .. lboardId .. ")\n")
					postHighscore(lboardId, score)
				else
					print("Current highscore of " .. score .. " is already posted to leaderboard " .. lboardName .. "\n")
				end
			end
		else
			print("Leaderboard id for leaderboard  " .. lboardName .. " not found!\n")
		end
	else
		print("Not posting score because leaderboard name was not found or because score for it was 0 \n")
	end
end]]


function gotoLevelEnding()
	if startedFromEditor then
		returnToEditor()
		return
	else
		local saveScores = false
		
		if(eagleBaitLaunched == true) then
			print("level played using mighty eagle\n")				
			logFlurryEventWithParam("ME: Level played", "Level", getWorldLevelNumberCombination())	

			--[1.5.4
			if(highscores[levelName] == nil) then
				
				print("level skipped using mighty eagle\n")
				logFlurryEventWithParam("ME: Level skipped", "Level", getWorldLevelNumberCombination())	
			end --]
		end
		
		if highscores[levelName] == nil then
			highscores[levelName] = { score = 0 }
		end

		if highscores[levelName].score == nil then
			highscores[levelName] = { score = 0 }
		end
		
		if levelCompleted then
			levelRestartedFrom = "complete menu"
			if eagleBaitLaunched == true then
				-- percentage from mighty eagle points
				mightyEagleScore = _G.math.min(_G.math.floor( (score / starTable[levelName].eagleScore ) * 100), 100)
				print("mightyEagleScore = min(100, " .. score .. " / " .. starTable[levelName].eagleScore .. ") = " .. mightyEagleScore .. ", levelName: " .. levelName .. "\n")
				-- if mighty eagle was used for passing the level for the first time, mark eagle used, eagle used time, no score and add notification
				local eScore = highscores[levelName].eagleScore-- or highscores[levelName].trialEagleScore
				eScore = eScore or 0
				
				--if highscores[levelName].score == 0 and (highscores[levelName].eagleScore == nil or highscores[levelName].eagleScore == 0) then
				if highscores[levelName].score == 0 and eScore == 0 then
					-- this check shoudn't be nesessary anymore because if eagleScore == 0 eagle can't be used in this level before 
					local eagleAlreadyUsedInLevel = false
					for k, v in _G.pairs(settings.eaglesUsedIn) do
						if v.world == currentWorldNumber and v.level == currentLevelNumberInTheme then
							eagleAlreadyUsedInLevel = true
							break
						end
					end
					if quadClick ~= true then
						if eagleAlreadyUsedInLevel ~= true then
							_G.table.insert(settings.eaglesUsedIn, { world = currentWorldNumber, level = currentLevelNumberInTheme } )
						end
						
						settings.eagleUsedTime = currentTime()
						local eagleNotificationText = _G.res.getString("TEXTS_BASIC", "TEXT_MIGHTY_EAGLE_RETURNS")
						addNotificationAfter("mightyEagleAvailable", eagleLockedTime, eagleNotificationText)
					end
				end
				
				if highscores[levelName].eagleScoreMax == nil or score > highscores[levelName].eagleScoreMax then
					--print("eagle top score: "..score)
					highscores[levelName].eagleScoreMax = score
					saveScores = true
				end
				
				if highscores[levelName].eagleScoreMin == nil or score < highscores[levelName].eagleScoreMin then
					--print("eagle low score: "..score)
					highscores[levelName].eagleScoreMin = score
					saveScores = true
				end
				
				getItemByName(levelComplete.items, "eagleFeatherEmpty").visible = true
				getItemByName(levelComplete.items, "eagleFeatherFill").visible = true
				getItemByName(levelComplete.items, "eagleFeatherFull").visible = false
				getItemByName(levelComplete.items, "totalDestruction").visible = false
				getItemByName(levelComplete.items, "starEffect").visible = false
				getItemByName(levelComplete.items, "eagleScoreNumber").visible = true
				getItemByName(levelComplete.items, "eagleScoreNumber").text = "0%"
				getItemByName(levelComplete.items, "levelComplete").visible = false							
				getItemByName(levelComplete.items, "score").visible = false							
				getItemByName(levelComplete.items, "scoreNumber").visible = false							
				getItemByName(levelComplete.items, "highScoreText").visible = false							
				getItemByName(levelComplete.items, "highScoreNumber").visible = false
				getItemByName(levelComplete.items, "eagleHighScoreNumber").visible = true
				getItemByName(levelComplete.items, "scoreNumber").visible = false
				getItemByName(levelComplete.items, "scoreNumber").text = mightyEagleScore .. "%"
				getItemByName(levelComplete.items, "eagleHighScoreFeatherEmpty").visible = true
				getItemByName(levelComplete.items, "eagleHighScoreFeatherFull").visible = false
				getItemByName(levelComplete.items, "eagleHighScoreText").visible = true
				getItemByName(levelComplete.items, "newHighScore").sprite = "NEW_HIGHSCORE_BG"
				
				local eagleHighScoreNumber = getItemByName(levelComplete.items, "eagleHighScoreNumber")
				eagleHighScoreNumber.number = highscores[levelName].eagleScore or 0
				--[[
				if settings.mightyEagleEnabled == true then
					if highscores[levelName].eagleScore == nil then
						eagleHighScoreNumber.number = 0
					else
						eagleHighScoreNumber.number = highscores[levelName].eagleScore
					end
				else
					if highscores[levelName].trialEagleScore == nil then
						eagleHighScoreNumber.number = 0
					else
						eagleHighScoreNumber.number = highscores[levelName].trialEagleScore
					end				
				end]]
				
				eagleHighScoreNumber.text = _G.string.format("%d", eagleHighScoreNumber.number) .. "%"
				--[[
				if(settings.mightyEagleEnabled == true) then
					local trialScore = highscores[levelName].trialEagleScore
					if highscores[levelName].trialEagleScore ~= nil and then
						
					end
					if highscores[levelName].eagleScore == nil or highscores[levelName].eagleScore < mightyEagleScore then
					end
				else				
				
				end]]
				-- If purchased then 
				local MEscore = 0
				MEscore = highscores[levelName].eagleScore or 0;				
				--[[
				if(settings.mightyEagleEnabled ~= true) then
					MEscore = highscores[levelName].trialEagleScore or 0;
				else
					MEscore = highscores[levelName].eagleScore or 0;				
				end]]
				
				if MEscore == nil or MEscore < mightyEagleScore then
					--MEscore = mightyEagleScore		
					highscores[levelName].eagleScore = mightyEagleScore
					--[1.5.4
					if(mightyEagleScore >= 100) then						
						print("Feather achieved using mighty eagle!\n")
						logFlurryEventWithParam("ME: got feather", "Level", getWorldLevelNumberCombination())
					end
					--]
					saveScores = true
				end
			
				score = 0
				--print("Mighty eagle used in world: " .. currentWorldNumber .. " & level: " .. currentLevelNumberInTheme)
			else 
				-- mighty eagle not used this time, check if it was previously used for this level
				for i = #settings.eaglesUsedIn , 1, -1 do
					local v = settings.eaglesUsedIn[i]
					if v.world == currentWorldNumber and v.level == currentLevelNumberInTheme then
						_G.table.remove(settings.eaglesUsedIn, i)
						settings.eagleUsedTime = nil
						removeNotification("mightyEagleAvailable")
					end
				end
				if levelSelectionPages == levelSelectionPagesBasic then
					settings.attemptsAfterEagleOffer.basic = 0
				elseif levelSelectionPages == levelSelectionPagesExtra then
					settings.attemptsAfterEagleOffer.extra = 0
				elseif levelSelectionPages == levelSelectionPagesPack3 then
					settings.attemptsAfterEagleOffer.pack3 = 0
				elseif levelSelectionPages == levelSelectionPagesPack4 then
					settings.attemptsAfterEagleOffer.pack4 = 0
				elseif levelSelectionPages == levelSelectionPagesPack5 then
					settings.attemptsAfterEagleOffer.pack5 = 0
				-- ADDED
				elseif levelSelectionPages == levelSelectionPagesPack6 then
					settings.attemptsAfterEagleOffer.pack6 = 0					
				end
				
				getItemByName(levelComplete.items, "eagleFeatherEmpty").visible = false
				getItemByName(levelComplete.items, "eagleFeatherFill").visible = false
				getItemByName(levelComplete.items, "eagleFeatherFull").visible = false
				getItemByName(levelComplete.items, "totalDestruction").visible = false
				getItemByName(levelComplete.items, "starEffect").visible = false
				getItemByName(levelComplete.items, "eagleScoreNumber").visible = false
				getItemByName(levelComplete.items, "levelComplete").visible = true							
				getItemByName(levelComplete.items, "score").visible = true							
				getItemByName(levelComplete.items, "scoreNumber").visible = true
				getItemByName(levelComplete.items, "score").visible = true
				getItemByName(levelComplete.items, "scoreNumber").visible = true
				getItemByName(levelComplete.items, "eagleHighScoreNumber").visible = false
				getItemByName(levelComplete.items, "highScoreText").text = "MI_HIGH_SCORE"
				getItemByName(levelComplete.items, "eagleHighScoreFeatherEmpty").visible = false 
				getItemByName(levelComplete.items, "eagleHighScoreFeatherFull").visible = false
				getItemByName(levelComplete.items, "eagleHighScoreText").visible = false
				
				getItemByName(levelComplete.items, "highScoreText").visible = true
				getItemByName(levelComplete.items, "highScoreNumber").visible = true
			end
			
			local newHighScore = getItemByName(levelComplete.items, "newHighScore")
			newHighScore.visible = false
			if highscores[levelName].score < score then
				--[1.5.4]
				if highscores[levelName].score < starTable[levelName].goldScore and score >= starTable[levelName].goldScore then
					levelCompleteFirstTimeFlurryParams = {}
					levelCompleteFirstTimeFlurryParams["Level"] = currentWorldNumber  .. "-" .. currentLevelNumberInTheme
					logFlurryEventWithParams("Level complete first time 3 stars", "levelCompleteFirstTimeFlurryParams")
				end
				--[1.5.4]
				if highscores[levelName].score < starTable[levelName].silverScore and score >= starTable[levelName].silverScore then
					levelCompleteFirstTimeFlurryParams = {}
					levelCompleteFirstTimeFlurryParams["Level"] = currentWorldNumber  .. "-" .. currentLevelNumberInTheme
					logFlurryEventWithParams("Level complete first time 2 stars", "levelCompleteFirstTimeFlurryParams")
				end
				highscores[levelName].score = score
				highscores[levelName].birds = birdsShot
				if inExtraWorld ~= true then
					newHighScore.sprite = "NEW_HIGHSCORE_BG"
					newHighScore.visible = true
				end
				saveScores = true
				if gameCenterEnabled and gameCenter and gameCenter.leaderboards then
					setPostedStatus(levelName)
				end
			end
			
			getItemByName(levelComplete.items, "scoreNumber").text = _G.string.format("%d", score)
			--levelComplete.items[6].text = _G.res.getString("TEXTS_BASIC", "MI_HIGH_SCORE") .. " " .. highscores[levelName].score
			getItemByName(levelComplete.items, "highScoreNumber").text = _G.string.format("%d", highscores[levelName].score)
				
			if inExtraWorld == true then
				-- three star limit gives the golden egg star
				if score >= starTable[levelName].goldScore then
					if settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 2 then
						newHighScore.sprite = "GOLDEN_EGG_STAR_COLLECTED"
					else
						newHighScore.sprite = "GOLDEN_EGG_STAR"
					end
					
					if currentLevelNumberInTheme == 22 then
						newHighScore.sprite = "ICON_BABY_BLU"
					end
					newHighScore.visible = true
										
					settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] = 2
					if calculateStarsFromGoldenEggLevels() == 10 then
						addToAchievementUnlockQueue("Egg Cracker")
					end
				end
			end

			if highscores[levelName].lowScore == nil then
				highscores[levelName].lowScore = score
				saveScores = true
			end
			if highscores[levelName].lowScore > score then
				highscores[levelName].lowScore = score
				saveScores = true
			end
			
			if highscores[levelName].completed ~= true then
				levelCompleteFirstTimeFlurryParams = {}
				levelCompleteFirstTimeFlurryParams["Level"] = currentWorldNumber  .. "-" .. currentLevelNumberInTheme
				logFlurryEventWithParams("Level complete first time", "levelCompleteFirstTimeFlurryParams")
				--print("Level complete first time: "..currentWorldNumber  .. "-" .. currentLevelNumberInTheme)
				highscores[levelName].completed = true
			end

			if saveScores then
				saveLuaFileWrapper("highscores.lua", "highscores", true)
			end
			
			if deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4" then
				postTotalHighScores()
				if not isLiteVersion then
					postLevelHighScore(levelName, highscores[levelName].score, true)
				end
			end
			
			setFont(fontBasic)
								
			local starsItem = getItemByName(levelComplete.items, "stars")					
			starsItem.sprite = "RESULT_STARS_1"
			if highscores[levelName].score >= starTable[levelName].silverScore then
				starsItem.sprite = "RESULT_STARS_2"
			end
			if highscores[levelName].score >= starTable[levelName].goldScore then
				starsItem.sprite = "RESULT_STARS_3"
			end
			
			local gainedStars = 1

			local starsCurrentItem = getItemByName(levelComplete.items, "starsCurrent")					
			starsCurrentItem.sprite = "STARS_BIG_1"
			if score >= starTable[levelName].silverScore then
				gainedStars = 2
				starsCurrentItem.sprite = "STARS_BIG_2"
			end
			
			-- Check if user got three stars from this level
			local threeStars = false
			if score >= starTable[levelName].goldScore then
				gainedStars = 3
				threeStars = true
				starsCurrentItem.sprite = "STARS_BIG_3"
				-- Check if user got three stars from all levels in the pack
	
				-- Select the right order table
				local orderTable
				if currentWorldNumber >= 1 and currentWorldNumber <= 3 then
					orderTable = levelOrder_packBasic
				elseif currentWorldNumber >= 4 and currentWorldNumber <= 5 then
					orderTable = levelOrder_packOne
				elseif currentWorldNumber >= 6 and currentWorldNumber <= 8 then
					orderTable = levelOrder_packThree
				elseif currentWorldNumber >= 9 and currentWorldNumber <= 11 then
					orderTable = levelOrder_packFour
				elseif currentWorldNumber >= 12 and currentWorldNumber <= 14 then
					orderTable = levelOrder_packFive
				elseif currentWorldNumber >= 15 and currentWorldNumber <= 17 then
					orderTable = levelOrder_packSix
				else
					orderTable = nil
				end
				
				if orderTable ~= nil then
					for k = 1, #orderTable do
						for i = 1, #orderTable[k] do
							if highscores[orderTable[k][i]] == nil then
								threeStars = false
							else
								if starTable[orderTable[k][i]].goldScore > highscores[orderTable[k][i]].score then
									threeStars = false
								end
							end
						end
					end
				end
			end
			
			if eagleBaitLaunched == true then
				gainedStars = 0
			end	
			
			settings.cumulativeStars = settings.cumulativeStars + gainedStars
			
			if settings.cumulativeStars >= 750 and settings.cumulativeStars < 1500 then
				addToAchievementUnlockQueue("Star Collector", true)
			end
			
			if settings.cumulativeStars >= 1500 then
				addToAchievementUnlockQueue("Star Gatherer", true)
			end
			
			settings.cumulativeScore = _G.string.format("%d", settings.cumulativeScore + score)
			settings.totalLevelsCompleted = settings.totalLevelsCompleted + 1
			
			if inExtraWorld == true then
				--change world number to egg
				if currentLevelNumberInTheme == 22 then
					levelComplete.items[2].text = "*"
				else
					levelComplete.items[2].text = "^-" .. currentLevelNumberInTheme
				end
			else
				if currentWorldNumber == 14 and currentLevelNumberInTheme > 15 then
					levelComplete.items[2].text = "|-"..currentLevelNumberInTheme - 15
				else
					levelComplete.items[2].text = currentWorldNumber .. "-" .. currentLevelNumberInTheme
				end
			end
			if inExtraWorld == true or eagleBaitLaunched == true then
				--hide stars
				starsItem.visible = false
				starsCurrentItem.visible = false
			else
				starsItem.visible = true
				starsCurrentItem.visible = true
			end
			--levelComplete.items[1].sprite = "LS_THEME_" .. currentThemeNumber .. "_SELECTED"

			local buttonMenu = getItemByName(levelComplete.items, "buttonMenu")					
			local buttonRestart = getItemByName(levelComplete.items, "buttonRestart")					
			local buttonNextLevel = getItemByName(levelComplete.items, "buttonNextLevel")					
			--if levelSelectionPages == levelSelectionPagesBasic or levelSelectionPages == levelSelectionPagesExtra or levelSelectionPages == levelSelectionPagesPack3 or levelSelectionPages == levelSelectionPagesPack4 or levelSelectionPages == levelSelectionPagesPack5 then
				buttonMenu.page = levelSelectionPages
			--else
			--	buttonMenu.page = levelSelectionPages[currentPageNumber]
			--end
			buttonMenu.visible = true
			buttonRestart.visible = true							
			if inExtraWorld == true or (currentWorldNumber == 14 and currentLevelNumberInTheme > 15) then
				buttonNextLevel.visible = false
			else
				buttonNextLevel.visible = true
			end
			
			-- each cutscene has it's own button
			for i = 1, #levelComplete.items do
				if _G.string.sub(levelComplete.items[i].name, 1, 14) == "buttonCutscene" then
					levelComplete.items[i].visible = false
				end
			end
			
			levelEndMenuPage = levelComplete
			
			if inExtraWorld ~= true then
				if currentWorldNumber == 1 then
					worldCompleted = false

					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene1").visible = true
						if settings.theme1Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme1Completed = true
							if isLiteVersion then
								settings.gameCompleted = true
								addToAchievementUnlockQueue("Ready For More")
							else
								addToAchievementUnlockQueue("Herr Helmet")
							end
						end
					end
				
				elseif currentWorldNumber == 2 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene2").visible = true
						if settings.theme2Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme2Completed = true
							addToAchievementUnlockQueue("Mr Moustache")
						end
					end
					
				elseif currentWorldNumber == 3 then
					worldCompleted = false
		
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene3").visible = true
						if settings.gameCompleted ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.gameCompleted = true
							addToAchievementUnlockQueue("Defeat of The King")
							levelEndMenuPage = gameFinished
							if threeStars and settings.threeStars ~= true then
								settings.threeStars = true
								goldenEggAchieved("Level4")
								getItemByName(gameFinished.items, "buttonYes").page = gameFinishedThreeStars
							end
						end
					end
				end
				
				if threeStars and settings.threeStars ~= true and currentWorldNumber >= 1 and currentWorldNumber <= 3 then
					settings.threeStars = true
					if not isLiteVersion then
						goldenEggAchieved("Level4")
						levelEndMenuPage = gameFinishedThreeStars
					else
						addToAchievementUnlockQueue("Total Destruction Lite")
					end
				end
				
				if currentWorldNumber == 4 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene4").visible = true
						if settings.theme4Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme4Completed = true
							addToAchievementUnlockQueue("The Imposter")
						end
					end
				
				elseif currentWorldNumber == 5 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene5").visible = true
						if settings.theme5Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme5Completed = true
							addToAchievementUnlockQueue("The Mysterious Escape")
							levelEndMenuPage = gameFinishedLP2
							if threeStars and settings.threeStarsLP2 ~= true then
								settings.threeStarsLP2 = true
								goldenEggAchieved("Level7")
								getItemByName(gameFinishedLP2.items, "buttonYes").page = gameFinishedThreeStarsLP2
							end
						end
					end
				end
				if threeStars and settings.threeStarsLP2 ~= true and currentWorldNumber >= 4 and currentWorldNumber <= 5 then
					settings.threeStarsLP2 = true
					goldenEggAchieved("Level7")
					levelEndMenuPage = gameFinishedThreeStarsLP2	
				end
				
				if currentWorldNumber == 6 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene6").visible = true
						if settings.theme6Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false
							settings.theme6Completed = true
							addToAchievementUnlockQueue("Hovering Helmet")
						end
					end
				
				elseif currentWorldNumber == 7 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene7").visible = true
						if settings.theme7Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false
							settings.theme7Completed = true
							addToAchievementUnlockQueue("Mounting Moustache")
						end
					end
				
				elseif currentWorldNumber == 8 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene8").visible = true
						if settings.theme8Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme8Completed = true
							addToAchievementUnlockQueue("Green Baron")
							levelEndMenuPage = gameFinishedLP3
							if threeStars and settings.threeStarsLP3 ~= true then
								settings.threeStarsLP3 = true
								goldenEggAchieved("Level12")
								getItemByName(gameFinishedLP3.items, "buttonYes").page = gameFinishedThreeStarsLP3
							end
						end
					end
				end
				if threeStars and settings.threeStarsLP3 ~= true and currentWorldNumber >= 6 and currentWorldNumber <= 8 then
					settings.threeStarsLP3 = true
					goldenEggAchieved("Level12")
					levelEndMenuPage = gameFinishedThreeStarsLP3	
				end
				
				if currentWorldNumber == 9 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene9").visible = true
						if settings.theme9Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme9Completed = true
							addToAchievementUnlockQueue("Hardhat Hidalgo")
						end
					end
					
				elseif currentWorldNumber == 10 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene10").visible = true
						if settings.theme10Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme10Completed = true
							addToAchievementUnlockQueue("Mason Moustache")
						end
					end

				elseif currentWorldNumber == 11 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene11").visible = true
						if settings.theme11Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme11Completed = true
							addToAchievementUnlockQueue("Royal Ringleader") 
							levelEndMenuPage = gameFinishedLP4
							if threeStars and settings.threeStarsLP4 ~= true then
								settings.threeStarsLP4 = true
								goldenEggAchieved("Level17") 
								getItemByName(gameFinishedLP4.items, "buttonYes").page = gameFinishedThreeStarsLP4
							end
						end
					end
				end
				
				if threeStars and settings.threeStarsLP4 ~= true and currentWorldNumber >= 9 and currentWorldNumber <= 11 then
					settings.threeStarsLP4 = true
					goldenEggAchieved("Level17")
					levelEndMenuPage = gameFinishedThreeStarsLP4
				end
				
				if currentWorldNumber == 12 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene12").visible = true
						if settings.theme12Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme12Completed = true
							addToAchievementUnlockQueue("Billy The Pig")
						end
					end	
				elseif currentWorldNumber == 13 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene13").visible = true
						if settings.theme13Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme13Completed = true
							addToAchievementUnlockQueue("Clint Eastbacon")
						end
					end	
				elseif currentWorldNumber == 14 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene14").visible = true
						if settings.theme14Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme14Completed = true
							addToAchievementUnlockQueue("Wild Pork Hickok") 
							levelEndMenuPage = gameFinishedLP5
							if threeStars and settings.threeStarsLP5 ~= true then
								settings.threeStarsLP5 = true
								goldenEggAchieved("Level21") 
								getItemByName(gameFinishedLP5.items, "buttonYes").page = gameFinishedThreeStarsLP5
							end
						end
					end				
				end
				
				
				
				-- TODO: what is this?
				if threeStars and settings.threeStarsLP5 ~= true and currentWorldNumber >= 12 and currentWorldNumber <= 14 then
					settings.threeStarsLP5 = true
					goldenEggAchieved("Level21")
					levelEndMenuPage = gameFinishedThreeStarsLP5
				end
				
				if currentWorldNumber == 15 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene15").visible = true
						if settings.theme15Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme15Completed = true
							addToAchievementUnlockQueue("Cave Explorer")
						end
					end	
				elseif currentWorldNumber == 16 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene16").visible = true
						if settings.theme16Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme16Completed = true
							--addToAchievementUnlockQueue("")
						end
					end

				elseif currentWorldNumber == 17 then
					worldCompleted = false
					
					if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage then
						worldCompleted = true
					end
					
					if worldCompleted then
						buttonNextLevel.visible = false
						getItemByName(levelComplete.items, "buttonCutscene17").visible = true
						if settings.theme17Completed ~= true then
							buttonMenu.visible = false
							buttonRestart.visible = false							
							settings.theme17Completed = true
							--addToAchievementUnlockQueue("") 
							levelEndMenuPage = gameFinishedLP6
							if threeStars and settings.threeStarsLP6 ~= true then
								settings.threeStarsLP6 = true
								goldenEggAchieved("Level17") 
								getItemByName(gameFinishedLP6.items, "buttonYes").page = gameFinishedThreeStarsLP6
							end
						end
					end
				end
				
				-- TODO: what is this?
				if threeStars and settings.threeStarsLP6 ~= true and currentWorldNumber >= 15 and currentWorldNumber <= 17 then
					settings.threeStarsLP6 = true
					-- goldenEggAchieved("Level21")
					levelEndMenuPage = gameFinishedThreeStarsLP6
				end
				
				if currentWorldNumber >= 1 and currentWorldNumber <= 3 then
					if settings.lastOpenLevel <= currentLevelNumber then
						settings.lastOpenLevel = currentLevelNumber + 1
						saveLuaFileWrapper("settings.lua", "settings", true)
					end
				end
				
				if currentWorldNumber >= 4 and currentWorldNumber <= 5 then
					if settings.lastOpenLevelLP2 <= currentLevelNumber then
						settings.lastOpenLevelLP2 = currentLevelNumber + 1
						saveLuaFileWrapper("settings.lua", "settings", true)
					end
				end
				
				if currentWorldNumber >= 6 and currentWorldNumber <= 8 then
					if settings.lastOpenLevelLP3 <= currentLevelNumber then
						settings.lastOpenLevelLP3 = currentLevelNumber + 1
						saveLuaFileWrapper("settings.lua", "settings", true)
					end
				end
				
				if currentWorldNumber >= 9 and currentWorldNumber <= 11 then
					if settings.lastOpenLevelLP4 <= currentLevelNumber then
						settings.lastOpenLevelLP4 = currentLevelNumber + 1
						saveLuaFileWrapper("settings.lua", "settings", true)
					end
				end
				
				if currentWorldNumber >= 12 and currentWorldNumber <= 14 then
					if settings.lastOpenLevelLP5 <= currentLevelNumber and currentLevelNumber <= 45 then
						settings.lastOpenLevelLP5 = currentLevelNumber + 1
						saveLuaFileWrapper("settings.lua", "settings", true)
					end
				end

				if currentWorldNumber >= 15 and currentWorldNumber <= 17 then
					if settings.lastOpenLevelLP6 <= currentLevelNumber and currentLevelNumber <= 45 then
						settings.lastOpenLevelLP6 = currentLevelNumber + 1
						saveLuaFileWrapper("settings.lua", "settings", true)
					end
				end
			end
			
			--log flurry event
			if inExtraWorld == true then
				--print("FlurryEventWithParam: Golden egg level completed, param: Level, paramValue: " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
				logFlurryEventWithParam("Golden egg level completed", "Level", "" .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]) 
			else
				levelCompleteFlurryParams = {}
				
				levelCompleteFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
				
				if score >= starTable[levelName].goldScore then
					levelCompleteFlurryParams["Stars"] = "3"
				elseif score >= starTable[levelName].silverScore then
					levelCompleteFlurryParams["Stars"] = "2"
				else
					levelCompleteFlurryParams["Stars"] = "1"
				end
				
				levelCompleteFlurryParams["Attempts"] = "" .. numberOfAttemptsInLevel
				levelCompleteFlurryParams["Birds used"] = "" .. birdsShot
				levelCompleteFlurryParams["Birds available"] = "" .. birdsCounter
				
				logFlurryEventWithParams("Level complete", "levelCompleteFlurryParams")
				--print("FlurryEventWithParams: Level complete \n")
			end				
			numberOfAttemptsInLevel = 0
							
			local episode1TotalScore, episode1Stars, episode1TotalStars = calculateTotalScoreAndStars(levelOrder_packBasic)
			if episode1Stars >= episode1TotalStars then
				addToAchievementUnlockQueue("Episode 1 - Total Destruction")
			end
			
			if episode1TotalScore >= 4000000 then
				addToAchievementUnlockQueue("Episode 1 - Score Addict")
			end

			local episode2TotalScore, episode2Stars, episode2TotalStars = calculateTotalScoreAndStars(levelOrder_packOne)
			if episode2Stars >= episode2TotalStars then
				addToAchievementUnlockQueue("Episode 2 - Total Destruction")
			end
			if episode2TotalScore >= 3300000 then
				addToAchievementUnlockQueue("Episode 2 - Score Addict")
			end
			
			local episode3TotalScore, episode3Stars, episode3TotalStars = calculateTotalScoreAndStars(levelOrder_packThree)
			if episode3Stars >= episode3TotalStars then
				addToAchievementUnlockQueue("Episode 3 - Total Destruction")
			end
			if episode3TotalScore >= 4800000 then
				addToAchievementUnlockQueue("Episode 3 - Score Addict")
			end
			
			local episode4TotalScore, episode4Stars, episode4TotalStars = calculateTotalScoreAndStars(levelOrder_packFour)
			if episode4Stars >= episode4TotalStars then
				addToAchievementUnlockQueue("Episode 4 - Total Destruction")
			end
			if episode4TotalScore >= 3900000 then
				addToAchievementUnlockQueue("Episode 4 - Score Addict")
			end
			
			-- check and uncomment this for future update
			local episode5TotalScore, episode5Stars, episode5TotalStars = calculateTotalScoreAndStars(levelOrder_packFive)
			if episode5Stars >= episode5TotalStars then
				addToAchievementUnlockQueue("Episode 5 - Total Destruction")
			end
			if episode5TotalScore >= 4100000 then 
				addToAchievementUnlockQueue("Episode 5 - Score Addict")
			end
			
			local feathers, maxFeathers = calculateFeathers(levelOrder_allLevels)
			--print("Checking for feather achievement, feathers: " .. feathers .. ", maxFeathers: " .. maxFeathers .. "\n")
			if feathers >= 200 then
				addToAchievementUnlockQueue("Feather Gatherer")
			elseif feathers >= 100 then
				addToAchievementUnlockQueue("Feather Collector")
			elseif feathers >= 50 then
				addToAchievementUnlockQueue("Feather Picker")		
			end
			
			_G.res.playAudio("level_complete", 1, false, 7)				
			prepareMenuPage(levelComplete)					
		else

			levelEndMenuPage = levelFailed

			-- flurry fail logging 
			levelRestartedFrom = "failed menu"
			if inExtraWorld == true then
				logFlurryEventWithParam("Golden egg level failed", "Level", goldenEggLevelMapping["Level" .. currentLevelNumberInTheme])
				--print("FlurryEventWithParam: Golden egg level failed, Level, " .. goldenEggLevelMapping["Level" .. currentLevelNumberInTheme] .. "\n")
			else
				levelFailedFlurryParams = {}
				levelFailedFlurryParams["Level"] = currentWorldNumber .. "-" .. currentLevelNumberInTheme
				levelFailedFlurryParams["Attempts"] = "" .. numberOfAttemptsInLevel
				levelFailedFlurryParams["Birds used"] = "" .. birdsShot
				levelFailedFlurryParams["Birds available"] = "" .. birdsCounter
				
				logFlurryEventWithParams("Level failed", "levelFailedFlurryParams")
			end
			
			levelFailed.items[5].text = "" .. _G.string.format("%d", highscores[levelName].score)
			
			--if levelSelectionPages == levelSelectionPagesBasic or levelSelectionPages == levelSelectionPagesExtra or levelSelectionPages == levelSelectionPagesPack3 or levelSelectionPages == levelSelectionPagesPack4 or levelSelectionPages == levelSelectionPagesPack5 then 
				levelFailed.items[6].page = levelSelectionPages
			--else
			--	levelFailed.items[6].page = levelSelectionPages[currentPageNumber]
			--end
				
			if iapEnabled == true and settings.mightyEagleEnabled == true then
				getItemByName(levelFailed.items, "buttonEagle").visible = true
				getItemByName(levelFailed.items, "buttonEagleLost").visible = false
			end
			getItemByName(levelFailed.items, "buttonNextLevel").visible = false
			-- each cutscene has it's own button
			for i = 1, #levelFailed.items do
				if _G.string.sub(levelFailed.items[i].name, 1, 14) == "buttonCutscene" then
					levelFailed.items[i].visible = false
				end
			end
		
			print("highscore: " .. highscores[levelName].score .. "\n")

			local buttonEagleBuy = getItemByName(levelFailed.items, "buttonEagleBuy")
			buttonEagleBuy.visible = false

			
			-- check if mighty eagle is unavailable
			if iapEnabled == true and settings.mightyEagleEnabled == true and settings.eagleUsedTime ~= nil and
			   (highscores[levelName] == nil or ((highscores[levelName].score == nil or highscores[levelName].score == 0) and (highscores[levelName].eagleScore == nil or highscores[levelName].eagleScore == 0))) and 
			   timeDiff(currentTime(), settings.eagleUsedTime) < eagleLockedTime then
				getItemByName(levelFailed.items, "buttonEagle").visible = false
				getItemByName(levelFailed.items, "buttonEagleLost").visible = true
			end
			if iapEnabled ~= true or settings.mightyEagleEnabled ~= true or (highscores[levelName] ~= nil and highscores[levelName].score > 0) then
				getItemByName(levelFailed.items, "buttonEagle").visible = false
				getItemByName(levelFailed.items, "buttonEagleLost").visible = false
			end

			
			if iapEnabled == true and settings.mightyEagleEnabled ~= true and (highscores[levelName] == nil or highscores[levelName].score == 0) then
				local currentEpisodeAttemps = 0
				if levelSelectionPages == levelSelectionPagesBasic then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.basic
				elseif levelSelectionPages == levelSelectionPagesExtra then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.extra
				elseif levelSelectionPages == levelSelectionPagesPack3 then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.pack3
				elseif levelSelectionPages == levelSelectionPagesPack4 then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.pack4
				elseif levelSelectionPages == levelSelectionPagesPack5 then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.pack5
				-- ADDED
				elseif levelSelectionPages == levelSelectionPagesPack6 then
					currentEpisodeAttemps = settings.attemptsAfterEagleOffer.pack6					
				end
				--if currentEpisodeAttemps ~= nil and currentEpisodeAttemps > 3 then
					buttonEagleBuy.visible = true
				--end
			end
			
			-- hide all eagle stuff in lite version and golden egg levels or if in-app-purchase is disabled
			if isLiteVersion == true or iapEnabled ~= true or inExtraWorld == true then
				getItemByName(levelFailed.items, "buttonEagle").visible = false
				getItemByName(levelFailed.items, "buttonEagleLost").visible = false
				buttonEagleBuy.visible = false
			end
			
			
			getItemByName(levelFailed.items, "stars").sprite = "RESULT_STARS_0"
			if highscores[levelName].score > 0 then
				getItemByName(levelFailed.items, "stars").sprite = "RESULT_STARS_1"
				getItemByName(levelFailed.items, "buttonNextLevel").visible = true
				
				if currentLevelNumberInTheme == levelSelectionPages.levelsPerPage and inExtraWorld ~= true and mightyEagleSupported ~= true then
					getItemByName(levelFailed.items, "buttonCutscene" .. currentWorldNumber).visible = true
					getItemByName(levelFailed.items, "buttonNextLevel").visible = false
				end	
			end
			if highscores[levelName].score >= starTable[levelName].silverScore then
				getItemByName(levelFailed.items, "stars").sprite = "RESULT_STARS_2"
			end
			if highscores[levelName].score >= starTable[levelName].goldScore then
				getItemByName(levelFailed.items, "stars").sprite = "RESULT_STARS_3"
			end
			
			if inExtraWorld == true then
				if currentLevelNumberInTheme == 22 then
					levelFailed.items[2].text = "*"
				else
					levelFailed.items[2].text = "^-" .. currentLevelNumberInTheme
				end
				getItemByName(levelFailed.items, "buttonNextLevel").visible = false
				getItemByName(levelFailed.items, "stars").visible = false
			else
				if currentWorldNumber == 14 and currentLevelNumberInTheme > 15 then
					levelFailed.items[2].text = "|-"..currentLevelNumberInTheme - 15
				else
					levelFailed.items[2].text = currentWorldNumber .. "-" .. currentLevelNumberInTheme
				end
				
				getItemByName(levelFailed.items, "stars").visible = true
			end
			
			if bingIsEnabled == true then
				if numberOfAttemptsInLevel >= 3 and getItemByName(levelFailed.items, "buttonNextLevel").visible == false then
					getItemByName(levelFailed.items, "bingButton").visible = true
					getItemByName(levelFailed.items, "bingSign").visible = true
					if inExtraWorld then
						getItemByName(levelFailed.items, "bingButton").callParam1 = "angry+birds+walkthrough+golden+eggs+stars"
					else
						getItemByName(levelFailed.items, "bingButton").callParam1 = "angry+birds+walkthrough+"..currentWorldNumber.."-"..currentLevelNumberInTheme
					end
					bingButtonShownParams = {}
					bingButtonShownParams["Level"] = currentWorldNumber.."-"..currentLevelNumber
					logFlurryEventWithParams("Bing button shown", "bingButtonShownParams")
				else
					getItemByName(levelFailed.items, "bingButton").visible = false
					getItemByName(levelFailed.items, "bingSign").visible = false
				end
			end
			prepareMenuPage(levelFailed)
		end

		_G.res.stopAudio(currentMusic)
		--stop looping rolling sounds
		_G.res.stopAudio("wood_rolling")
		_G.res.stopAudio("rock_rolling")
		_G.res.stopAudio("light_rolling")					
		
		setGameMode(updateMenu)
		setActiveMenuPage(levelEndMenuPage)
		changeResolution = true
		wantedResolution = "HALF"
		
		setPhysicsEnabled(false)
		drawGame()
		showAd()
		return
	end
end

function updateLevelEnding(dt)
	-- level has been completed puff the birds
	if levelCompleted then
		eagleDarkness = nil
		birdBuffTimer = birdBuffTimer - dt
		if birdBuffTimer < 0 then
			local nextBirdName = getNextBird(birdsLeftCounter)
			if nextBirdName ~= nil then
				birdsLeftCounter = birdsLeftCounter + 1
				
				-- if mighty eagle is selected don't add points from unused birds
				if eagleBaitLaunched ~= true then
					scoreTable["birds"].score = scoreTable["birds"].score + birdsLeftScoreIncrement
				end
				
				local nbo = objects.world[nextBirdName]
				-- if nbo == selectedBird then
					-- birdFired = true
				-- end
				_G.res.playAudio(getAudioName("bird_misc"), 1, false, 0)
				_G.table.insert(floatingScores, { x = nbo.x, y = nbo.y, sprite = getObjectDefinition(nextBirdName).spriteScore, score = birdsLeftScoreIncrement, time = 0, lifetime = 0.9, maxScale = floatingScoreScaling * 1, xs = 0 } )
				birdBuffTimer = 0.5
				--removeBird(nbo)
			else
				-- show boomerang bird popup just before going to level complete screen
				if showBoomerangBirdPopup == true and (levelCompleteTimer > 0 and levelCompleteTimer - dt <= 0) then
					showBoomerangBirdPopup = false
					setActivePopupPage(boomerangBirdAchievedPage)
					_G.res.playAudio("star_collect", 1, false)
					if currentLevelNumberInTheme == 4 and currentWorldNumber == 6 then
						settings.boomerangBirdAchieved = true
					elseif currentLevelNumberInTheme == 5 and currentWorldNumber == 9 then
						settings.boomerangBirdAchieved2 = true
					end
					addToAchievementUnlockQueue("Return to Sender")
					if deviceModel == "iphone4" then
						changeResolution = true
						wantedResolution = "HALF"
					end
				else
					levelCompleteTimer = levelCompleteTimer - dt
				end
			end
			updateScore(dt)
			-- for testing
			if quadClick == true then
				score = starTable[levelName].goldScore
				if eagleBaitLaunched == true then
					score = starTable[levelName].eagleScore
				end
			end
		end
	else
		levelCompleteTimer = levelCompleteTimer - dt
	end
	-- is level going to end
	if levelCompleteTimer <= 0 then
		gotoLevelEnding()
	end
end

function initLevelComplete()

	if isEagleDisabled() ~= true then
		inGameEagleButtonVisible = false
	end
	rubberBandPos.x = levelStartPosition.x
	rubberBandPos.y = levelStartPosition.y
	rubberBandSpeed = 0
	
	allowResetToBirdCamera = false
	showTapIcon = false
	showTapTimer = 0
	levelCompleted = true
	--setPhysicsEnabled(false)			
	-- count the remaining birds that have not been fired
	birdsLeftCounter = currentBirdIndex

	if currentBirdName == nil or objects.world[currentBirdName].shot == true then
		birdsLeftCounter = birdsLeftCounter + 1
	end

	-- if some birds are left go to launch camera and show the scores
	if getNextBird(birdsLeftCounter) ~= nil then
		birdBuffTimer = 2.5			
		if cameraFunction ~= launchCamera then
			birdBuffTimer = 3.5
			castleCameraTimer = 1.0
			cameraFunction = launchCamera
			animationScreen.x = screen.x
			animationScreen.y = screen.y
			animationWorldScale = worldScale					
		end
	end
	
	_G.res.playAudio(getAudioName("level_clear_military"), 1, false)
	levelCompleteTimer = 1.0
	if eagleBaitLaunched then
		levelCompleteTimer = 2.0
	end
	
	if (currentWorldNumber == 6 and currentLevelNumberInTheme == 4 and settings.boomerangBirdAchieved ~= true) or
	   (currentWorldNumber == 9 and currentLevelNumberInTheme == 5 and settings.boomerangBirdAchieved2 ~= true) then
		showBoomerangBirdPopup = true
	end
end

function initLevelFailed(dt)
	-- wait for 1.5 seconds until declare level as failed
	levelFailedTimer = levelFailedTimer + dt
	if levelFailedTimer > 1.5 then
		--setPhysicsEnabled(false)
		levelCompleteTimer = 0.5
		_G.res.playAudio(getAudioName("level_failed_piglets"), 1, false)
	end
end

--
--
--
function setExtraTutorialShown(sprite)
	if(settings.tutorials ~= nil) then
		if(settings.tutorials[sprite]) then						
			if(settings.tutorials[sprite].showHelp == true) then
				settings.tutorials[sprite].showHelp = nil									
			end						
		end				
	end
end


-------------------------------------------------------------------------------
-- GAME
--
currentFrame = 0
function updateGame(dt, time)


	--[[ BEGIN FPS DEBUG CODE -- 
	
	if drawFPSStatistics or FPSFrames > 1 then
	
		if not drawFPSStatistics then
			drawFPSStatistics = true
			FPSFrames = 0
			FPSTime = 0
			FPSMin = 1000000
			FPSMax = 0
		end
		
		local FPS = 1/dt
		if FPS < FPSMin then
			FPSMin = FPS
		end
		if FPS > FPSMax then
			FPSMax = FPS
		end
	end
	FPSFrames = FPSFrames + 1
	FPSTime = FPSTime + dt
	
	-- END FPS DEBUG CODE --]]
	
	if(flyingBird ~= nil and settings ~= nil and settings.tutorials ~= nil) then
		local bDef = getObjectDefinition(flyingBird.name)
		
		if(bDef ~= nil and bDef.sprite ~= nil and settings.tutorials[bDef.sprite] and settings.tutorials[bDef.sprite].showHelp) then
			extraTutorialTimer = extraTutorialTimer + dt
		end		
	end
	
	if oldScreenWidth ~= screenWidth or oldScreenHeight ~= screenHeight then
		
		if #birdTutorialPopups > 0 then
			prepareMenuPage(tutorials)
		end
		
		if popupPage ~= nil then
			if popupPage == achievementPopUpPage then
				-- reset the layout of gamecenter achievement popup except the animation
				local tempAnimationState = popupPage.animationState
				local tempAnimationTimer = popupPage.animationTimer
				prepareMenuPage(achievementPopUpPage)
				popupPage.animationState = tempAnimationState 
				popupPage.animationTimer = tempAnimationTimer 
			end
		end
	end
			
	cameraShakeX, cameraShakeY = 0, 0
	if cameraShake ~= nil and cameraShake ~= 0 then
		cameraShakeX = _G.math.floor(_G.math.random(-_G.math.abs(cameraShake), _G.math.abs(cameraShake)))
		cameraShakeY = _G.math.floor(_G.math.random(-_G.math.abs(cameraShake), _G.math.abs(cameraShake)))
	end
	
	if inGameEagleButtonScale ~= nil then
		inGameEagleButtonScalingTimer = inGameEagleButtonScalingTimer + dt * 6
		if inGameEagleButtonVisible == true then
			inGameEagleButtonScale = _G.math.cos(inGameEagleButtonScalingTimer) * 0.25 + 0.75
		else
			inGameEagleButtonScale = inGameEagleButtonScale - dt * 3
			if inGameEagleButtonScale <= 0 then
				inGameEagleButtonScale = nil
			end
		end
	end
	
	if settings.eagleUsedTime ~= nil and timeDiff(currentTime(), settings.eagleUsedTime) >= eagleLockedTime then 
		print("Mighty eagle available again!\n")
			
		settings.eagleUsedTime = nil
		settings.eaglesUsedIn = {}
	end
	
	if popupPage ~= nil then
		if popupPage == achievementPopUpPage then
			local page = achievementPopUpPage
			
			page.animationTimer = page.animationTimer - dt
			local bgBox = getItemByName(page.items, "achievementBox")
			local boxOffset = 190
			if deviceModel == "ipad" then
				boxOffset = 280
			end
			if page.animationTimer > 2.4 then
				bgBox.y = screenHeight - boxOffset * (2.7 - page.animationTimer)
			elseif page.animationTimer > 0.4 and page.animationTimer <= 2.4 then
				bgBox.y = screenHeight - boxOffset * 0.3
			elseif page.animationTimer > 0 and page.animationTimer <= 0.4 then
				bgBox.y = screenHeight - boxOffset * (page.animationTimer - 0.1)
			elseif page.animationTimer <= 0 then
				popupPage = nil
			end
		else
			updateMenuPage(popupPage, dt)
			drawGame()
			return
		end
	end
		
	if currentMenuPage ~= pausePage then
		setActiveMenuPage(pausePage)
	end
	
	currentFrame = currentFrame + 1
	
	--updateScale()
	updateAnimations(dt)
	
	-- update cursors
	oldCursorWorld.x = cursorWorld.x
	oldCursorWorld.y = cursorWorld.y
	cursorPhysics.x, cursorPhysics.y = screenToPhysicsTransform(cursor.x, cursor.y)
	cursorWorld.x, cursorWorld.y = screenToWorldTransform(cursor.x, cursor.y)
	
	rightSweep = false
	leftSweep = false	
	
	-- update game timers
	quadClickTimer = quadClickTimer - dt
	
	-- Handle input -- 
	if keyPressed["ESCAPE"] or keyPressed["KEY_BACK"] or (startedFromEditor == true and touchcount == 3) then
		_G.res.stopAudio(currentMusic)
		--setPhysicsEnabled(false)
		if startedFromEditor then
			returnToEditor()
		else
			goToMenu()
		end
		return
	end
	
	if startedFromEditor ~= true then
		if keyPressed["LEFT"] then
			levelRestartedFrom = "keyboard command"
			setGameMode(loadPreviousLevel)
		end
		
		if keyPressed["RIGHT"] then
			levelRestartedFrom = "keyboard command"
			setGameMode(loadNextLevel)
		end
		
		if keyPressed["F5"] or keyPressed["R"] then
			levelRestartedFrom = "keyboard command"
			loading = true
			setGameMode(updateLoading)
		end
	else
		if keyPressed["F5"] or keyPressed["R"] then
			levelRestartedFrom = "keyboard command"
			setEditing(false)
			setPhysicsEnabled(false)
			local name = "temp/" .. levelName .. ".temp.playtest"
			checkDirectories()
			loadLevelInternal(levelFolder .. name)
			setGameMode(updateGame)
			if startedFromEditor ~= true then
				levelSelectionPageNumber = currentThemeNumber
			end
			currentThemeNumber = currentThemeIndex
		end
	end
	
	if levelStartTimer == 0 then
		levelStartTimer = levelStartTimer + 0.01
		_G.res.playAudio(getAudioName("level_start_military"), 1, false)
		_G.res.stopAudio(currentMainMenuSong)
		currentBirdIndex = 0
		fillInNextBird = true
	end
	
	if _G.res.isAudioPlaying(currentMusic) == false then
		_G.res.playAudio(currentMusic, 1, true,7)
	end
	
	if #birdTutorialPopups > 0 then
		
		--[[if settings.tutorials["BAIT_SARDINE"] ~= nil and birdTutorialPopups[1] == settings.tutorials["BAIT_SARDINE"].sprite then
			_G.table.remove(birdTutorialPopups, 1)
			if #birdTutorialPopups == 0 then
				setPhysicsEnabled(true)
				if deviceModel == "iphone4" then
					changeResolution = true
					wantedResolution = "FULL"
				end
			end
		else
		]]
			if deviceModel == "iphone4" and wantedResolution == "FULL" then
				changeResolution = true
				wantedResolution = "HALF"
				return
			end
			
			setPhysicsEnabled(false)
			if keyPressed["LBUTTON"] then
				
				if isLiteVersion == false and showTutorialGoldenEgg == true and birdTutorialPopups[1] == settings.tutorials["BIRD_GREEN"].sprite then
					if cursor.x >= tutorialGoldenEggPosition.hitBoxMinX and cursor.x < tutorialGoldenEggPosition.hitBoxMaxX and cursor.y >= tutorialGoldenEggPosition.hitBoxMinY and cursor.y < tutorialGoldenEggPosition.hitBoxMaxY then
						goldenEggAchieved("Level1")
					end
				end
				
				if checkSpriteBounds("", "TUTORIAL_OK", tutorials.okButtonX, tutorials.okButtonY, cursor.x, cursor.y) then
					_G.table.remove(birdTutorialPopups, 1)
					if #birdTutorialPopups == 0 then
						if deviceModel == "iphone4" then
							changeResolution = true
							wantedResolution = "FULL"
						end
						setPhysicsEnabled(true)
					else
					--	prepareMenuPage(tutorials)
					end
				end

			end
			oldCursor.x = cursor.x
			oldCursor.y = cursor.y
			
			-- Draw game
			drawGame()
			
			pausePage.backgroundOverlay.shade = 0
			return
		--end
	end
	
	if keyPressed["LBUTTON"] then
		if cursor.x < pauseButtonW and cursor.y < pauseButtonH then
			if startedFromEditor then
				returnToEditor()
			else
				goToMenu()
				drawGame()
				return
			end
		elseif iapEnabled == true and inGameEagleButtonVisible == true and cursor.x < eagleButtonW + pauseButtonW and cursor.x > eagleButtonW and cursor.y < eagleButtonH then
			if settings.mightyEagleEnabled == true then
				if isEagleDisabled() == true then 
				   -- eagle sleeping
				   eagleInfoTimer = 3.0
				else
					inGameEagleButtonVisible = false
					launchEagleBaitInGame()
				end
			else
				goToMightyEagleDemoPageFromGame()
			end
			skipInput = true
			--drawGame()
			--return
		end
	end
	
	if keyPressed["KEY_MENU"] or keyPressed["P"] then
		goToMenu()
		drawGame()
		return
	end

	if keyPressed["MBUTTON"] then
		setWorldScale(1)
		worldScale = 1
	end
	
	if doubleClick == true then
		if currentWorldNumber == 1 and currentLevelNumberInTheme == 8 then
			treasureChest = objects.world["ExtraTreasureChest_1"]
			if treasureChest ~= nil then
				if distance(cursorPhysics.x, cursorPhysics.y, treasureChest.x, treasureChest.y) < 2.5 then
					goldenEggAchieved("Level6")
					-- additional popup delay isn't needed (and must not be used) here, because goldenEggAchieved is not called from removeBlocks
					additionalPopupPageDelay = false
				end
			end
		end
	end
	
	-- if keyPressed["TAB"] then
		-- physicsEnabled = not physicsEnabled
		-- setPhysicsEnabled(physicsEnabled)
	-- end

	if levelStartTimer < 1 or levelStartTimer > 6 then
		levelStartTimer = levelStartTimer + dt
	else
		setPhysicsEnabled(true)
		levelStartTimer = 10
		--print("Level started\n")
		-- set first bird to start position
		--nextBirdTimer = 1
		-- currentBirdName = getNextBird(currentBirdIndex)
	end

	-- check level complete rule
	if levelCompleteTimer > 0 then
		updateLevelEnding(dt)
	else
		if checkLevelComplete() or keyPressed["C"] or quadClick == true then
			initLevelComplete()
		end
		if checkLevelFailed() then 
			initLevelFailed(dt)
		end
	end
	
	-- update timers
	gameTimer = gameTimer + dt
	
	-- update tap timer
	if tapStarted then
		tapTimer = tapTimer + dt
				
		if tapTimer > 0.25 then
			if tapCount == 1 and showTapIcon then
				-- todo: put these to own function, this code is used in three places
				returnToBirdCamera()
			end
			-- reset camera scale
			if tapCount == 2 then
				if cameraAnimationSliderTarget == 0 then
					currentZoomedScale = objects.birdCameraData[deviceModel].sx
				else
					currentZoomedScale = objects.castleCameraData[deviceModel].sx
				end
				maxZoomLevel = true
			end
		
			tapTimer = 0
			tapCount = 0
			tapStarted = false
		end
	end

	-- Handle keypress
	if keyPressed["LBUTTON"] and not levelCompleted then
		if skipInput ~= true then
			inGamePressed = true
		
			draggingStartPosPhysics.x = cursorPhysics.x
			draggingStartPosPhysics.y = cursorPhysics.y
			
			draggingStartPosScreen.x = cursor.x
			draggingStartPosScreen.y = cursor.y

			oldCursor.x = cursor.x
			oldCursor.y = cursor.y

			if tapStarted == false then
				tapPosition.x = cursor.x
				tapPosition.y = cursor.y
				tapStarted = true
				tapTimer = 0
			end
			
			-- try it out - just for fun
			--makeClickExplosion(cursorPhysics.x, cursorPhysics.y, 20000, 10, 200, 5, getAudioName("special_explosion"))
		end

		-- if gamestate is bird flying use special action
		if flyingBird ~= nil and birdSpecialtyAvailable then
			birdSpecialtyAvailable = false
			local bDef = getObjectDefinition(flyingBird.name)
			birdSpecialty = bDef.specialty
			if birdSpecialty == "BOOST" then
				setExtraTutorialShown(bDef.sprite) --1.5.4
			
				local force = boostForce * physicsScale * flyingBird.mass
				local x, y = vNormalize(flyingBird.xVel, flyingBird.yVel)
				applyImpulse( flyingBird.name,
							-x * force,
							-y * force,
							flyingBird.x,
							flyingBird.y )
				addParticles(flyingBird.name, blockTable.blocks[flyingBird.definition].particles, 10, false)
				_G.res.playAudio(getAudioName(blockTable.blocks[flyingBird.definition].specialSound), 1, false)
				objects.world[flyingBird.name].sprite = "BIRD_YELLOW_SPECIAL"
				setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)
				local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
				addPuffToTrajectory(1, lx, ly)
			end
			if birdSpecialty == "BOMB" then
				--birdSpecialtyAvailable = true
				
				setExtraTutorialShown(bDef.sprite) --1.5.4
				
				makeExplosion(flyingBird, bDef, getAudioName(blockTable.blocks[flyingBird.definition].specialSound))
				
				removeBird(flyingBird)
			end
			if birdSpecialty == "SOUND" then
				_G.res.playAudio(getAudioName(blockTable.blocks[flyingBird.definition].specialSound), 1, false)
			end
			if birdSpecialty == "CLUSTER_BOMB" then
				--
				setExtraTutorialShown(bDef.sprite) --1.5.4
				
				local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
				addPuffToTrajectory(1, lx, ly)
				
				local x, y = vNormalize(flyingBird.yVel, -flyingBird.xVel)
				local newName = flyingBird.name .. "a"
				createCircle(newName, flyingBird.sprite, flyingBird.x - x, flyingBird.y - y, flyingBird.radius, flyingBird.density, flyingBird.friction, flyingBird.restitution, flyingBird.controllable, flyingBird.z_order)
				objects.world[newName].definition = flyingBird.definition
				objects.world[newName].controllable = flyingBird.controllable
				objects.world[newName].strength = flyingBird.strength
				objects.world[newName].defence = flyingBird.defence
				objects.world[newName].material = flyingBird.material
				objects.world[newName].levelGoal = flyingBird.levelGoal
				objects.world[newName].damageFactors = flyingBird.damageFactors
				objects.world[newName].spritePivotX = flyingBird.spritePivotX
				objects.world[newName].spritePivotY = flyingBird.spritePivotY
				objects.world[newName].damageSprite = flyingBird.damageSprite
				objects.world[newName].useLegacyCollisionPath = flyingBird.useLegacyCollisionPath
				objects.world[newName].shot = true
				objects.world[newName].sleeping = false
				objects.world[newName].hasCollided = false
				objects.world[newName].parentName = flyingBird.name
				objects.world[newName].xVel = flyingBird.xVel - x*7
				objects.world[newName].yVel = flyingBird.yVel - y*7
				setSprite(newName, flyingBird.damageSprite)
				setRotation(newName, flyingBird.angle)
				setVelocity(newName, flyingBird.xVel - x*7, flyingBird.yVel - y*7)
				--_G.table.insert(extraObjects, newName)
				birds[newName] = objects.world[newName]
				
				newName = flyingBird.name .. "b"
				createCircle(newName, flyingBird.sprite, flyingBird.x, flyingBird.y, flyingBird.radius, flyingBird.density, flyingBird.friction, flyingBird.restitution, flyingBird.controllable, flyingBird.z_order)
				objects.world[newName].definition = flyingBird.definition
				objects.world[newName].controllable = flyingBird.controllable
				objects.world[newName].strength = flyingBird.strength
				objects.world[newName].defence = flyingBird.defence
				objects.world[newName].material = flyingBird.material
				objects.world[newName].levelGoal = flyingBird.levelGoal
				objects.world[newName].damageFactors = flyingBird.damageFactors
				objects.world[newName].spritePivotX = flyingBird.spritePivotX
				objects.world[newName].spritePivotY = flyingBird.spritePivotY
				objects.world[newName].damageSprite = flyingBird.damageSprite				
				objects.world[newName].useLegacyCollisionPath = flyingBird.useLegacyCollisionPath
				objects.world[newName].shot = true
				objects.world[newName].sleeping = false
				objects.world[newName].hasCollided = false
				objects.world[newName].parentName = flyingBird.name
				objects.world[newName].xVel = flyingBird.xVel
				objects.world[newName].yVel = flyingBird.yVel
				setSprite(newName, flyingBird.damageSprite)				
				setRotation(newName, flyingBird.angle)
				setVelocity(newName, flyingBird.xVel, flyingBird.yVel)
				--_G.table.insert(extraObjects, newName)
				birds[newName] = objects.world[newName]
				
				newName = flyingBird.name .. "c"
				createCircle(newName, flyingBird.sprite, flyingBird.x + x, flyingBird.y + y, flyingBird.radius, flyingBird.density, flyingBird.friction, flyingBird.restitution, flyingBird.controllable, flyingBird.z_order)
				objects.world[newName].definition = flyingBird.definition
				objects.world[newName].controllable = flyingBird.controllable
				objects.world[newName].strength = flyingBird.strength
				objects.world[newName].defence = flyingBird.defence
				objects.world[newName].material = flyingBird.material
				objects.world[newName].levelGoal = flyingBird.levelGoal
				objects.world[newName].damageFactors = flyingBird.damageFactors
				objects.world[newName].spritePivotX = flyingBird.spritePivotX
				objects.world[newName].spritePivotY = flyingBird.spritePivotY
				objects.world[newName].damageSprite = flyingBird.damageSprite				
				objects.world[newName].useLegacyCollisionPath = flyingBird.useLegacyCollisionPath
				objects.world[newName].shot = true
				objects.world[newName].sleeping = false
				objects.world[newName].hasCollided = false
				objects.world[newName].parentName = flyingBird.name
				objects.world[newName].xVel = flyingBird.xVel + x*7
				objects.world[newName].yVel = flyingBird.yVel + y*7
				setSprite(newName, flyingBird.damageSprite)				
				setRotation(newName, flyingBird.angle)
				setVelocity(newName, flyingBird.xVel + x*7, flyingBird.yVel + y*7)
				birds[newName] = objects.world[newName]
				
				otherBirds = { flyingBird.name .. "a", flyingBird.name .. "b" }
				removeBird(flyingBird)
				--objects.world[flyingBird.name] = nil
				flyingBird = objects.world[newName]
				cameraTargetObject = flyingBird

				_G.res.playAudio(blockTable.blocks[flyingBird.definition].specialSound, 1, false)

			end
			-- drop explosive
			if birdSpecialty == "GRENADE" then
				setExtraTutorialShown(bDef.sprite) --1.5.4
			
				local x, y = vNormalize(flyingBird.yVel, -flyingBird.xVel)
				local newName = flyingBird.name .. "a"
				objects.world[flyingBird.name].sprite = "BIRD_GREEN_SPECIAL"
				setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)
				
				createCircle(newName, "DROPPABLE_EGG", flyingBird.x, flyingBird.y + flyingBird.radius*2, flyingBird.radius, flyingBird.density, flyingBird.friction, flyingBird.restitution, true, flyingBird.z_order)
				objects.world[newName].definition = "EggGranade"
				objects.world[newName].controllable = true
				objects.world[newName].strength = flyingBird.strength
				objects.world[newName].defence = flyingBird.defence
				objects.world[newName].material = flyingBird.material
				objects.world[newName].damageFactors = blockTable.blocks[objects.world[newName].definition].damageFactors
				objects.world[newName].useLegacyCollisionPath = flyingBird.useLegacyCollisionPath
				objects.world[newName].levelGoal = false
				local xp, yp = _G.res.getSpritePivot("INGAME_BIRDS_1","DROPPABLE_EGG")
				objects.world[newName].spritePivotX = xp
				objects.world[newName].spritePivotY = yp
				objects.world[newName].damageSprite = "DROPPABLE_EGG"
				objects.world[newName].xVel = 0 --flyingBird.xVel * 0.5
				objects.world[newName].yVel = 100 --flyingBird.yVel * 0.5
				setSprite(newName, objects.world[newName].damageSprite)
				setRotation(newName, flyingBird.angle)
				--setVelocity(newName, flyingBird.xVel*0.5, flyingBird.yVel*0.5)
				setVelocity(newName, objects.world[newName].xVel, objects.world[newName].yVel)
				--objects.world[newName].specialty = "BOMB"
				_G.table.insert(flyingGrenades, { name = newName, timer = 5 })
				--_G.table.insert(extraObjects, newName)
				_G.res.playAudio(getAudioName(blockTable.blocks[flyingBird.definition].specialSound), 1, false)
				--_G.res.playAudio(getAudioName("bird_pushing_egg_out"), 1, false)
				cameraTargetObject = objects.world[newName]
				
				applyImpulse( flyingBird.name,
							-0.04*defaultForce * flyingBird.mass,
							0.08*defaultForce * flyingBird.mass,
							flyingBird.x-0.5,
							flyingBird.y )
				local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
				addPuffToTrajectory(1, lx, ly)
			end
			if birdSpecialty == "BOOMERANG" then
				setExtraTutorialShown(bDef.sprite) --1.5.4
				
				flyingBird.boomerangActive = true
				if flyingBird.xVel ~= 0 then
					yForceCoeff = 2 - _G.math.min(_G.math.abs(flyingBird.yVel / flyingBird.xVel), 2)
				else
					yForceCoeff = 0
				end
				
				flyingBird.boomerangXForce = flyingBird.xVel * physicsScale * flyingBird.mass * blockTable.blocks[flyingBird.definition].boomerangHorizontalForce
				flyingBird.boomerangYForce = yForceCoeff * physicsScale * flyingBird.mass * blockTable.blocks[flyingBird.definition].boomerangVerticalForce
				flyingBird.boomerangMinXVel = -blockTable.blocks[flyingBird.definition].boomerangMaxHorizontalSpeed
				flyingBird.boomerangMaxXVel = blockTable.blocks[flyingBird.definition].boomerangMaxHorizontalSpeed
				
				--flyingBird.angularVelocity = 0
				objects.world[flyingBird.name].sprite = "BIRD_BOOMERANG_SPECIAL"
				setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)
				
				_G.res.playAudio(getAudioName(blockTable.blocks[flyingBird.definition].specialSound), 1, false)
				
				local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
				addPuffToTrajectory(1, lx, ly)
			end
		elseif skipInput ~= true then
			dragStarted = true
			dragCursorTable = {}
			dragCursorIndex = 1
			dragCursorTable[dragCursorIndex] = { dx = 0, dy = 0, dt = dt }
			tapPosWorld.x = cursorWorld.x
			tapPosWorld.y = cursorWorld.y
			
			if touchcount == 1 then
				if currentBirdName ~= nil then
					local obj = objects.world[currentBirdName]
					if distance(obj.x, obj.y, cursorPhysics.x, cursorPhysics.y) < shootRange/worldScale * screenWidth/480 then
						selectedBird = obj
					end
				end
			end			
		end
	end

	if keyHold["LBUTTON"] and not levelCompleted and inGamePressed and skipInput ~= true then
		if dragStarted == true then
			dragCursorIndex = dragCursorIndex + 1
			if dragCursorIndex > 5 then
				dragCursorIndex = 1
			end
			dragCursorTable[dragCursorIndex] = { dx = cursor.x - oldCursor.x, dy = cursor.y - oldCursor.y, dt = dt }
		
			if selectedBird ~= nil then
				draggingStartPosPhysics.x = levelStartPosition.x
				draggingStartPosPhysics.y = levelStartPosition.y
				-- for the slingshot
				if birdReady == true then
					local distToRest = distance(draggingStartPosPhysics.x, draggingStartPosPhysics.y, cursorPhysics.x, cursorPhysics.y)
					local vecToRest = { x = draggingStartPosPhysics.x - cursorPhysics.x, y = draggingStartPosPhysics.y - cursorPhysics.y }

					rubberBandAngle = _G.math.atan2(vecToRest.y, vecToRest.x)
					shootMaxLength = shootRange + 3.2

					-- if distToRest < shootRange/worldScale then
						-- rubberBandPos.x, rubberBandPos.y = levelStartPosition.x, levelStartPosition.y
						-- rubberBandAngle = 0
						-- rubberBandLength = 0
						-- if birdSelected == true then
							-- _G.res.playAudio(getObjectDefinition(selectedBird.name).unselectionSound, 1, false)
							-- birdSelected = false
						-- end
					-- else
					if distToRest < shootMaxLength then
						rubberBandPos.x, rubberBandPos.y = cursorPhysics.x, cursorPhysics.y
						rubberBandLength = distToRest
						if _G.math.abs(rubberBandLength - oldRubberBandLength) > 0.1 and _G.res.isAudioPlaying("slingshot_stretched") == false then
							_G.res.playAudio("slingshot_stretched", 1, false)
						end
						oldRubberBandLength = rubberBandLength
						if birdSelected == false then
							_G.res.playAudio(getObjectDefinition(selectedBird.name).selectionSound, 1, false)
							birdSelected = true
						end
					else
						--print("rba: " .. rubberBandAngle .. "\n")
						rubberBandPos.x = draggingStartPosPhysics.x - vecToRest.x * shootMaxLength / distToRest
						rubberBandPos.y = draggingStartPosPhysics.y - vecToRest.y * shootMaxLength / distToRest
						rubberBandLength = shootMaxLength
						rubberBandSpeed = 0
						-- if _G.res.isAudioPlaying("slingshot_stretched") == false then
							-- _G.res.playAudio("slingshot_stretched", 1, false)
						-- end
						if birdSelected == false then
							_G.res.playAudio("slingshot_stretched", 1, false)
							_G.res.playAudio(getObjectDefinition(selectedBird.name).selectionSound, 1, false)
							birdSelected = true
						end
					end
					local factor = 1
					if rubberBandAngle >= -1.9 and rubberBandAngle < -1.75 then
						factor = -(rubberBandAngle + 1.75) / 0.15
					end
					if rubberBandAngle >= -1.75 and rubberBandAngle < -1.5 then
						factor = 0.25
					end
					if rubberBandAngle >= -1.5 and rubberBandAngle < -1.35 then
						factor = (1.5 + rubberBandAngle) / 0.15
					end

					if factor < 0.25 then factor = 0.25 end
					if rubberBandLength > factor * shootMaxLength then 
						rubberBandPos.y = draggingStartPosPhysics.y - shootMaxLength * factor * vecToRest.y / distToRest
						rubberBandLength = distance(draggingStartPosPhysics.x, draggingStartPosPhysics.y, rubberBandPos.x, rubberBandPos.y)
					end
				end
			else
				local dx = (objects.castleCameraData[deviceModel].px - objects.birdCameraData[deviceModel].px)
				if dx > 1 then
					local delta = dragCursorTable[dragCursorIndex].dx / (dx * worldScale)
					sweepSpeed = 0
					cameraAnimationSlider = cameraAnimationSlider - delta
					--print("keyHold[LBUTTON] and not levelCompleted: cameraFunction = doItAllCamera\n")									
					cameraFunction = doItAllCamera					
				end
				--print("dx: " .. dragCursorTable[dragCursorIndex].dx .. ", dy " .. dragCursorTable[dragCursorIndex].dy .. "\n")
				
				if deviceModel == "n900" then
					local angle = _G.math.abs(_G.math.atan2(dragCursorTable[dragCursorIndex].dy, dragCursorTable[dragCursorIndex].dx))
					--print("angle: " .. angle .. "\n")
					if _G.math.pi*0.3333 < angle and angle < _G.math.pi*0.6666 or _G.math.pi*1.3333 < angle and angle < _G.math.pi*1.6666 then
						--local deltay = dragCursorTable[dragCursorIndex].dy * 0.00125 * (((objects.castleCameraData[deviceModel].right - objects.birdCameraData[deviceModel].left)/screenWidth) - worldScale) / worldScale
						local deltay = dragCursorTable[dragCursorIndex].dy * 0.00125
						zoomLevel = zoomLevel + deltay
					end
				end
			end
		end
	end
	
	if (keyReleased["LBUTTON"] or not keyHold["LBUTTON"]) and skipInput ~= true then
		--not holding LBUTTON
		if dragStarted then
			dragStarted = false
					
			if selectedBird ~= nil and not levelCompleted then
				settings.birdsShooted = settings.birdsShooted + 1
				if settings.birdsShooted >= 5000 then
					addToAchievementUnlockQueue("Bird Slinger", true)
				end
			
				local distToRest = distance(draggingStartPosPhysics.x, draggingStartPosPhysics.y, cursorPhysics.x, cursorPhysics.y)
				local vecToRest = { x = draggingStartPosPhysics.x - cursorPhysics.x, y = draggingStartPosPhysics.y - cursorPhysics.y }

				-- local distFactor = (distToRest - shootRange/worldScale)/8
				-- if distFactor < 0 then distFactor = 0 end
				-- if distFactor > 1 then distFactor = 1 end

				local distFactor = rubberBandLength / shootMaxLength
				if distFactor < 0 then distFactor = 0 end
				if distFactor > 1 then distFactor = 1 end

				--if distToRest > shootRange/worldScale and flyingBird == nil then
				
				-- shoot new bird
				--if flyingBird == nil then
					--force = dampedSpring(springConstant, springDampening, distToRest, 0) * -2.0 * physicsScale * (selectedBird.density / 5)
					local force = -defaultForce * physicsScale * selectedBird.mass
					setPosition(selectedBird.name, rubberBandPos.x, rubberBandPos.y)
					setVelocity(selectedBird.name, 0, 0)
					applyImpulse(selectedBird.name,
								vecToRest.x / distToRest * force * distFactor,
								vecToRest.y / distToRest * force * distFactor,
								selectedBird.x,
								selectedBird.y)
					--setAngularVelocity(selectedBird.name, 0)
					cameraTargetObject = selectedBird
					flyingBird = selectedBird
					
					-- Reset timer [1.5.4]
					extraTutorialTimer = 0
					
					--print("keyReleased[LBUTTON] && dragging: cameraFunction = doItAllCamera\n")					
					cameraFunction = doItAllCamera
					
					-- set target camera based on shooting direction
					if vecToRest.x > 0 then
						cameraAnimationSliderTarget = 1
					else
						cameraAnimationSliderTarget = 0
					end

					animationScreen.x = screen.x
					animationScreen.y = screen.y
					animationWorldScale = worldScale
					animationWorldScale2 = worldScale
					
					selectedBird.shot = true
					selectedBird.hasCollided = false
					birdSpecialtyAvailable = true
					allowResetToBirdCamera = true
					--print("Can reset to bird camera\n")
					allowTrajectoryClearing = true
					hasMovingObjectsAboveTolerance = true
					birdSelected = false
					birdReady = false
					birdFired = true
					showTapIcon = false
					birdsShot = birdsShot + 1
					cameraResetTimer = 0
					showTapTimer = 0
					nextBirdTimer = 1
					currentBirdName = nil
	
					--print(currentFrame .. " Bird shot\n")
					
					otherBirds = {}
					birdTrajectory =  { {}, {}, {} }
					
					flyingBird.sprite = getObjectDefinition(flyingBird.name).spriteFlying
					setSprite(flyingBird.name, flyingBird.sprite)
					
					-- mighty eagle used time is set when completing level using eagle
					--if flyingBird.isEagleBait and (highscores[levelName] == nil or highscores[levelName] == 0 or highscores[levelName] ~= true) then
					--	settings.eagleUsedTime = currentTime()
					--end
					
					--print("currentBird shot: " .. selectedBird.name .. "\n")

					if getObjectDefinition(selectedBird.name).launchSound ~= nil then
						_G.res.playAudio(getAudioName("bird_shot"), 1, false)
						_G.res.playAudio(getObjectDefinition(selectedBird.name).launchSound, 1, false)
					end
				-- else
					-- if birdSelected == true then
						-- _G.res.playAudio(getObjectDefinition(selectedBird.name).unselectionSound, 1, false)
						-- rubberBandPos.x, rubberBandPos.y = levelStartPosition.x - 0.1, levelStartPosition.y - 0.1
						-- birdSelected = false
					-- end
				-- end
				selectedBird = nil
				
				if eagleBaitLaunched ~= true and vecToRest.x < 0 then
					if settings.backwardsBirdCount == nil then
						settings.backwardsBirdCount = 0
					end
					settings.backwardsBirdCount = settings.backwardsBirdCount + 1
					
					if settings.backwardsBirdCount == 10 then
						addToAchievementUnlockQueue("Backward Compatibility", true)
					end
				end
			else
				local i = 1
				local dxSum = 0
				local dtSum = 0
				local speed = 0
				while i <= #dragCursorTable do
					dtSum = dtSum + dragCursorTable[i].dt
					dxSum = dxSum + dragCursorTable[i].dx
					--print("SEvent: dx:" .. dragCursorTable[i].dx .. " dt:" .. dragCursorTable[i].dt .. "\n")
					i = i + 1
				end
				speed = dxSum / dtSum
				
				-- if #dragCursorTable < 2 then
					-- speed = 0
				-- end
				dragCursorTable = {}

				if touchcount == 1 and distance(draggingStartPosScreen.x, draggingStartPosScreen.y, cursor.x, cursor.y) > screenWidth * 0.1 or _G.math.abs(speed) > 200 then
					sweepSpeed = speed
					if _G.math.abs(sweepSpeed) > 0 then
						--print("SweepSpeed: " .. sweepSpeed .. "\n")
						if _G.math.abs(draggingStartPosScreen.x - cursor.x) > _G.math.abs(draggingStartPosScreen.y - cursor.y) then
							if draggingStartPosScreen.x - cursor.x > 0 then
								leftSweep = true
							else
								rightSweep = true
							end
						end
						
						if _G.math.abs(sweepSpeed) < 200 then
							--take sign and multiply by 100
							sweepSpeed = sweepSpeed/_G.math.abs(sweepSpeed) * 200
						end
						if _G.math.abs(sweepSpeed) > 5000 then
							sweepSpeed = sweepSpeed/_G.math.abs(sweepSpeed) * 5000
						end
					end
				else
					sweepSpeed = 0
				end
			end

			-- local testIndex = currentBirdIndex + 1
			-- if getNextBird(testIndex) == nil then
				-- if birdFired and not levelCompleted then
					-- if doubleClickTimer > 0 then
						-- for k, v in _G.pairs(objects.world) do
							-- if v.controllable then
								-- removeBird(v)
							-- end
						-- end
					-- else
						-- doubleClickTimer = 0.5
					-- end
				-- end
			-- end
	
			if leftSweep == true and sweepSpeed < 0 then
				--print("leftSweep: cameraFunction = doItAllCamera\n")
				cameraFunction = doItAllCamera
				cameraAnimationSliderTarget = 1
				if cameraAnimationSlider < 0 then
					cameraAnimationSlider = 0
				end
				doubleClickTimer = 0
			end
			if rightSweep == true and sweepSpeed > 0 then
				animationScreen.x = screen.x
				animationScreen.y = screen.y
				animationWorldScale = worldScale
				--print("rightSweep: cameraFunction = doItAllCamera\n")	
				cameraFunction = doItAllCamera
				cameraAnimationSliderTarget = 0
				if cameraAnimationSlider > 1 then
					cameraAnimationSlider = 1
				end
				allowResetToBirdCamera = false
				cameraTargetObject = nil
				--print(currentFrame .. " Right sweep: camera target object set to nil\n")
				--flyingBird = nil  -- this was commented as a bugfix to boomerang bird beak not bruising after camera sweep
				doubleClickTimer = 0
				showTapIcon = false
				showTapTimer = 0
			end

			if tapStarted then
				if vLength(cursor.x - tapPosition.x, cursor.y - tapPosition.y) < tapRadius then
					tapCount = tapCount + 1
					tapTimer = 0
				end
			end	
		end
	end

	if cheatsEnabled == true or releaseBuild ~= true then
		if keyPressed["LBUTTON"] then
			if quadClickTimer > 0 and cursor.x > screenWidth - 60 and cursor.y > screenHeight - 60 then
				quadClickCounter = quadClickCounter + 1
				quadClickTimer = 0.5
				if quadClickCounter >= 4 then
					quadClick = true
				end
			else
				quadClick = false
				quadClickTimer = 0.5
				quadClickCounter = 1
			end
		end
	end
	
	-- if allowResetToBirdCamera == true then print("allowResetToBirdCamera: pass")	end
	-- if hasMovingObjectsZeroTolerance == false then print(" hasMovingObjectsZeroTolerance: pass") end
	-- if hasMovingObjects == false then print(" hasMovingObjects: pass") end
	-- if levelCompleted == false then print(" levelCompleted: pass") end
	-- if birdSpecialtyAvailable == false then print(" birdSpecialtyAvailable: pass") end
	-- print("\n")
	
	if allowResetToBirdCamera == true and hasMovingObjectsAboveTolerance == false and hasMovingObjects == false and levelCompleted == false and birdSpecialtyAvailable == false then
		if cameraResetTimer <= 0 then
			cameraResetTimer = 0.5
		end
		
		cameraResetTimer = cameraResetTimer - dt
		
		if cameraResetTimer <= 0 then
			--print("Moving to start position. Camera target object set to nil.\n")
			--print(currentFrame .. " Automatic camera reset: camera target object set to nil\n")
			returnToBirdCamera()
		end
	end	

	-- tap icon handling
	-- if allowResetToBirdCamera == true and showTapTimer <= 0 and cameraAnimationSliderTarget == 1 and birdSpecialtyAvailable == false and cameraTargetObject == nil then
		-- showTapTimer = 0.5
	-- end

	if showTapTimer <= 0 and cameraAnimationSliderTarget == 1 and birdSpecialtyAvailable == false and cameraTargetObject == nil then
		showTapTimer = 0.5
	end
	
	if cameraAnimationSliderTarget == 0 then
		showTapTimer = 0
		showTapIcon = false
	end
	
	if showTapTimer > 0 then
		showTapTimer = showTapTimer - dt
		if showTapTimer <= 0 then
			showTapIcon = true
		end
	end	
	
	-- fill the next bird
	animateBirdToSlingShot(dt)
	
	-- trajectory
	local recordTrajectory = false
	if flyingBird ~= nil then
		if flyingBird.recordTrajectory ~= false then
			recordTrajectory = true
			local lx, ly = physicsToWorldTransform(flyingBird.x, flyingBird.y)
			local bt = birdTrajectory[1]
			if #bt < 1 or vLengthsq(lx - bt[#bt].x, ly - bt[#bt].y) > 400 then
				-- if getObjectDefinition(flyingBird.name).particlesTrail ~= nil then
					-- addParticles(flyingBird.name, getObjectDefinition(flyingBird.name).particlesTrail, 1)
				-- end
				_G.table.insert(bt, { x = lx, y = ly })
				addToTrajectory(1, lx, ly)
			end
		end
		
		-- space invader achievement (not allowed for the bomb bird)
		if eagleBaitLaunched ~= true and flyingBird.definition ~= "BasicBird2" then
			if previousSpaceInvaderY == nil then
				previousSpaceInvaderY = 0
			end
			if previousSpaceInvaderY > -125 and flyingBird.y <= -125 then
				addToAchievementUnlockQueue("Space Invader", true)
			end
			previousSpaceInvaderY = flyingBird.y
		end
	end
	
	if otherBirds ~= nil then
		for i = 1, 2 do
			local obj = objects.world[otherBirds[i]]
			if obj ~= nil then
				if obj.recordTrajectory ~= false then
					recordTrajectory = true
					local lx, ly = physicsToWorldTransform(obj.x, obj.y)
					local bt = birdTrajectory[i+1] 
					if #bt < 1 or vLengthsq(lx - bt[#bt].x, ly - bt[#bt].y) > 400 then
						-- if getObjectDefinition(obj.name).particlesTrail ~= nil then
							-- addParticles(obj.name, getObjectDefinition(obj.name).particlesTrail, 1)
						-- end
						_G.table.insert(bt, { x = lx, y = ly })
						addToTrajectory(i+1, lx, ly)
					end
				end
			end
		end
	end

	if recordTrajectory == false then
		if allowTrajectoryClearing == true then
			startNewTrajectory()
			allowTrajectoryClearing = false
		end
	end
	
	if birdReady == true then
		--print("Bird is ready!\n")
		if currentBirdName ~= nil then
			--print("Setting position and velocity. " .. currentBirdName .. "\n")
			setPosition(currentBirdName, rubberBandPos.x, rubberBandPos.y)
			setVelocity(currentBirdName, 0, 0)
		end
	end

	-- we have fired a bird from the slingshot
	if birdFired then
	
		local rubberBandDtLeft = dt
		local rubberBandDt
		
		-- Integrate rubber band position multiple times if time step is too large
		while rubberBandDtLeft > 0 do
		
			if rubberBandDtLeft < 0.05 then
				rubberBandDt = rubberBandDtLeft
			else
				rubberBandDt = 0.05
			end
			
			rubberBandDtLeft = rubberBandDtLeft - rubberBandDt
		
			local distToRest = distance(levelStartPosition.x, levelStartPosition.y, rubberBandPos.x, rubberBandPos.y)
			local vecToRest = { x = levelStartPosition.x - rubberBandPos.x, y = levelStartPosition.y - rubberBandPos.y }

			rubberBandAngle = _G.math.atan2(vecToRest.y, vecToRest.x)
			rubberBandLength = distToRest

			rubberBandSpeed = rubberBandSpeed + dampedSpring(springConstant, springDampening, distToRest, rubberBandSpeed) * 0.05 * physicsScale
			if distToRest > 0 then
				rubberBandPos.x = rubberBandPos.x + (vecToRest.x / distToRest) * rubberBandSpeed * rubberBandDt
				rubberBandPos.y = rubberBandPos.y + (vecToRest.y / distToRest) * rubberBandSpeed * rubberBandDt
				rubberBandLength = distance(levelStartPosition.x, levelStartPosition.y, rubberBandPos.x, rubberBandPos.y)
			end
		end
	end
	
	-- explode the granade
	for i = #flyingGrenades, 1, -1 do
		if flyingGrenades[i].explode == true then
			local flyingGrenade = flyingGrenades[i].name
			local grenadeDef = getObjectDefinition(flyingGrenade)
			addParticles(flyingGrenade, grenadeDef.particles, 6, true)
			makeExplosion(objects.world[flyingGrenade], grenadeDef, getAudioName("special_explosion"))
			addParticles(flyingGrenade, "eggShells", 5, true)
			if cameraTargetObject ~= nil and cameraTargetObject.name == flyingGrenades[i].name then
				cameraTargetObject = nil
			end
			removeObject(flyingGrenade)
			objects.world[flyingGrenade] = nil
			_G.table.remove(flyingGrenades, i)
		end
	end

	if eagleTimer ~= nil then
		eagleTimer = eagleTimer - dt
	end

	if eagleDarkness ~= nil then
		eagleDarkness = eagleDarkness - dt * 0.4
		eagleDarkness = _G.math.max(_G.math.min(eagleDarkness, 0.5), 0)
	end
	
	-- loop over all objects and do updates if necessary
	for k, v in _G.pairs(objects.world) do
		-- remove birds if criteria is met
		if v.bombTimer ~= nil then
			v.bombTimer = v.bombTimer - dt
			if v.bombTimer < 0 then
				makeExplosion(v, getObjectDefinition(k), getAudioName("special_explosion"))
				removeBird(v)
			elseif v.bombTimer < 1 then
				v.damageSprite = "BIRD_GREY_3"
				setSprite(v.name, v.damageSprite)
			elseif v.bombTimer < 2 then
				v.damageSprite = "BIRD_GREY_2"			
				setSprite(v.name, v.damageSprite)			
			end
		elseif v.isEagleBait == true and eagleTimer ~= nil then
			if eagleTimer < 6.2 and eagleMoving == true then
				birdSpecialtyAvailable = false
				eagleMoving = false
				createMightyEagle(v.x, v.y)
				--print("Mighty Eagle coming!")
			end
		elseif v.isMightyEagle then
			--local eagleHeight = objects.world["ground"].y - v.y
			eagleHeight = levelStartPosition.y - v.y
			if objects.world["ground"].y - v.y < 0 then
				v.lowerThanGround = true
			end
			eagleHeight = _G.math.max(_G.math.min(eagleHeight, 50), 0)
			--print("eagleHeight: " .. eagleHeight .. "\n")
			local speed = 10000
			v.particleTimer = v.particleTimer + dt
			local particleAmount = _G.math.floor(v.particleTimer / v.particleTimerLimit)
			if particleAmount > 0 then
				v.particleTimer = _G.math.fmod(v.particleTimer, v.particleTimerLimit)
				addParticles(v.name, "mightyEagleParticles", particleAmount, false)
			end	
			if v.hitGround ~= true then -- and v.x < v.targetX then
				--cameraShake = ((50 - eagleHeight) * (50 - eagleHeight) * (50 - eagleHeight) * (50 - eagleHeight)) / 209000
				--v.wantedVelX, v.wantedVelY = vNormalize(v.targetX - v.x, v.targetY - v.y)
				local angle = _G.math.atan2(v.initVelY, v.initVelX)
				setVelocity(v.name, v.initVelX * speed, v.initVelY * speed)
				setRotation(v.name, angle)
			elseif v.hitGround == true then
				setVelocity(v.name, v.initVelX * speed, -v.initVelY * speed)
				setAngularVelocity(v.name, _G.math.pi * 4)
			end
		else
			if v.controllable and v.shot == true then
				
				if v.isReadyForRemoveTimer ~= nil and vLengthsq(v.xVel, v.yVel) < 0.0025 then
					v.isReadyForRemoveTimer = v.isReadyForRemoveTimer - dt
				else
					v.isReadyForRemoveTimer = 1.0
				end
				
				if v.isReadyForRemoveTimer < 0 and cameraTargetObject == nil then
					--print(currentFrame .. " Removing stopped bird.\n")
					removeBird(v)
					v = nil
				end
			end
		end
		
		-- remove all frozen objects
		if v ~= nil and v.frozen then
			
			if v.controllable then
				if v.isEagleBait == true then
					eagleX, eagleY = v.x, v.y
					--print("baitSardine frozen!\N")
					if eagleTimer == nil then
						eagleTimer = 8.7
						eagleMoving = true
					end
				end
				if v.boomerangActive ~= true then
					removeBird(v)
				end
				if v.isMightyEagle and v.hitGround ~= true then
					cameraShake = 100
					_G.res.playAudio("mighty_eagle_thump", 1, false)
					for k2, v2 in _G.pairs(objects.world) do
						if v2 ~= nil then
							if v2.strength ~= nil and v2.levelGoal then
								local force = -v2.mass * 15
								applyImpulse( v2.name,
											0,
											force,
											v2.x,
											v2.y )
								v2.strength = 0.00001
								v2.defence = 0
							end
						end
					end
					if objects.joints ~= nil then
						for k, v in _G.pairs(objects.joints) do
							destroyJoint(v.name)
						end
					end
					eagleTimer = 4
				end
			else
				removeObject(k)
				objects.world[k] = nil
				levelGoals[k] = nil
				if settings.mightyEagleEnabled == true and checkLevelGoalsDestroyed() == true and isEagleDisabled() ~= true then
					inGameEagleButtonScale = 1
				end
			end
			v = nil
		end
	end
	
	if eagleTimer ~= nil then
		--print("eagleTimer: " .. eagleTimer .. "\n")
		if eagleTimer < 6.2 and eagleMoving == true and eagleX ~= nil and eagleY ~= nil then
			birdSpecialtyAvailable = false
			eagleMoving = false
			--[[local ccd = objects.castleCameraData[deviceModel]
			local wx1, wy1 = worldToPhysicsTransform(ccd.left, ccd.top)
			local wx2, wy2 = worldToPhysicsTransform(ccd.right, ccd.bottom)
			
			createMightyEagle((wx1 + wx2) * 0.5, (wy1 + wy2) * 0.5)--]]
			createMightyEagle(eagleX, eagleY)
		elseif eagleTimer < 7.7 and eagleSoundPlayed ~= true then
			_G.res.playAudio("mighty_eagle_yell", 1, false)
			_G.res.playAudio("mighty_eagle_fly", 1, false)
			eagleSoundPlayed = true
		end
		if cameraShake ~= nil and cameraShake > 0 then
			--cameraShake = _G.math.max(cameraShake - 200 * dt, 0)
			cameraShake = _G.math.max(cameraShake - cameraShake*dt*2.2, 0)
		end
		if eagleTimer < 0 then
			for k, v in _G.pairs(objects.world) do
				if v.strength ~= nil and v.levelGoal then
					v.strength = 0
					deadBlocks[k] = v
				end
			end
		end
		
		-- Delete all joints when eagle hits ground, joints cannot be destroyed from BirdCollision
		if destroyJoints then
			if objects.joints ~= nil then
				for k, v in _G.pairs(objects.joints) do
					destroyJoint(v.name)
				end
			end
			destroyJoints = nil
		end
	end
	
	-- update camera
	if cameraFunction ~= nil then
		cameraFunction(dt)
	end
	
	for k,v in _G.pairs(birds) do
		bird = v
		if bird.shot == true and bird.definition == "BoomerangBird" then
			if v.boomerangActive == true then
				
				if bird.prevAngle ~= nil then
					if bird.prevAngle < -1 and bird.angle >= -1 then
						
						if bird.x < levelLeftEdge then
							vol = _G.math.max( 1 - ((levelLeftEdge - bird.x) / 100.0),  0.0)
						elseif bird.x > levelRightEdge then
							vol = _G.math.max( 1 - ((bird.x - levelRightEdge) / 100.0),  0.0)
						else
							vol = 1.0
						end
						_G.res.playAudio("boomerang_swish", vol, false)
					end
				end
				bird.prevAngle = bird.angle
				
				if bird.xVel >= bird.boomerangMinXVel and bird.xVel <= bird.boomerangMaxXVel then
					applyForce( bird.name,
										bird.boomerangXForce,
										0,
										bird.x,
										bird.y )
				end
				
				if bird.yVel > 5 then
					applyForce( bird.name,
										0,
										bird.boomerangYForce,
										bird.x,
										bird.y )
				end
				
				bird.angularVelocity = bird.angularVelocity + dt * 20
				if bird.angularVelocity > 20 then
					bird.angularVelocity = 20
				end
				
				setAngularVelocity(bird.name, bird.angularVelocity)
			elseif bird == flyingBird and birdSpecialtyAvailable then
				applyForce( bird.name,
									0,
									blockTable.blocks[bird.definition].flyVerticalForce,
									bird.x,
									bird.y )
				--setAngularVelocity(bird.name, 0)
				if bird.angularVelocity == nil then
					bird.angularVelocity = 0
				end
				
				bird.angularVelocity = bird.angularVelocity + dt * 15
				if bird.angularVelocity > 6.28 then
					bird.angularVelocity = 6.28
				end
				
				setAngularVelocity(bird.name, bird.angularVelocity)
			end
		elseif bird.shot == true and bird.definition == "BaitSardine" then
			if bird.angularVelocity == nil then
				bird.angularVelocity = 0
			end
				
			if bird.hasCollided ~= true then
				bird.angularVelocity = bird.angularVelocity + dt * 10
				if bird.angularVelocity > 20 then
					bird.angularVelocity = 20
				end
				setAngularVelocity(bird.name, bird.angularVelocity)
			end
		end
	end
	
	--updateParticles(dt)
	for k, v in _G.pairs(objects.joints) do
		if v.backAndForth then
			checkJointLimits(v.name)
		end
	end
	updateCharacterAnimations(dt)
	
	updateFloatingScores(dt)

	updateScore(dt)
	
	-- store current values to old for the next frame
	oldCursor.x = cursor.x
	oldCursor.y = cursor.y
	
	-- Draw game
	drawGame()
	if currentMenuPage == pausePage and elementAnimations["ingamePausePageScroll"].state ~= "HIDDEN" and (birdTutorialPopups == nil or #birdTutorialPopups == 0) then
		pausePage.offsetX = elementAnimations["ingamePausePageScroll"].percentage / 100 * pauseBGw - pauseBGw
		pausePage.backgroundOverlay.shade = elementAnimations["ingamePausePageScroll"].percentage / 100 * 0.65
		drawMenuPage(pausePage)
	end
	if tempWorldScale ~= nil then
		print("tempWorldScale = nil\n")
		tempWorldScale = nil
	end

	if showAdFrame ~= nil and currentFrame ~= nil and currentFrame >= showAdFrame then
		if videoReady then
			showVideoAd()
		else
			showAd()
		end
		-- make sure that ad is not tried to be shown more than once
		showAdFrame = nil
	end
	
	skipInput = false
end

function closeMightyEaglePurchasePage()
	setGameMode(updateMenu)
	popupPage = nil
	setActiveMenuPage(levelFailed)
	setPhysicsEnabled(false)
	drawGame()
end

function closeBetaDisclaimerPage()
	setGameMode(updateMenu)
	popupPage = nil
	setActiveMenuPage(mainMenu)
	drawMenu()
end

function cancelMightyEaglePurchase()
	logFlurryEvent("Mighty eagle purchase canceled") 
	if currentMenuPage == mainMenu then
		setGameMode(updateMenu)
		setActiveMenuPageDelayed(mainMenu)
		drawMenu()
		print("going to mainmenu\n")
	--[[elseif currentMenuPage == pausePage then 
		if mightyEagleDemoPage.enablePhysicsWhenDone then
			setPhysicsEnabled(true)
		end
		if currentGameMode == updateGame then
			print("currentGameMode: updateGame\n")
		elseif currentGameMode == updateMenu then
			print("currentGameMode: updateMenu\n")
		end

		--setGameMode(updateGame)
		print("going to game\n")
		if deviceModel == "iphone4" then
			changeResolution = true
			wantedResolution = "FULL"
			print("change resolution to full\n")
		end
	end]]
	
	elseif currentGameMode == updateGame then
		print("going to pause menu\n")
		showPauseMenu()
		setPhysicsEnabled(false)
		pausePage.offsetX = 0
		pausePage.backgroundOverlay.shade = 0.65
		setAnimationState("ingamePausePageScroll", "VISIBLE")
	end
	
	popupPage = nil
	settings.attemptsAfterEagleOffer = {}
	--inGameEagleButtonVisible = false
end




function goToMightyEagleDemoPageFromGame()
	--additionalPopupPageDelay = true
	mightyEagleDemoPage.enablePhysicsWhenDone = isPhysicsEnabled()
	setActivePopupPage(mightyEagleDemoPage, nil, "ingame")
	settings.mightyEagleUpsellPageViewed = true
	--setActivePopupPage(mightyEagleIngamePage, nil, "ingame")

	if deviceModel == "iphone4" then
		changeResolution = true
		wantedResolution = "HALF"
		print("change resolution to half\n")
	end
end

function goToMightyEaglePaymentPage()
	--additionalPopupPageDelay = true
	newPopupPage =  mightyEaglePaymentPage
	
	if settings.mightyEagleEnabled ~= true then
		purchaseMightyEagle()
	end
	
	
	
	--[ 1.5.4
	if(mightyEagleDemoPage ~= nil and mightyEagleDemoPage.info ~= nil) then
		print("Mighty Eagle purchase button clicked, from = "..(mightyEagleDemoPage.info).."\n")
		logFlurryEventWithParam("ME: purchase clicked", "From", mightyEagleDemoPage.info)		
	end
	-- ]
	if deviceModel == "iphone4" then
		changeResolution = true
		wantedResolution = "HALF"
		print("change resolution to half\n")
	end
end

--[[function enableMightyEagleFeature()
	--settings.mightyEagleEnabled = true
	
	local mightyEagleButton = getItemByName(levelFailed.items, "buttonEagle")
	local mightyEagleButtonBuy = getItemByName(levelFailed.items, "buttonEagleBuy")
	
	mightyEagleButton.visible = true
	mightyEagleButtonPM.visible = true
	mightyEagleButtonBuy.visible = false	
end]]

function resetMightyEagleFeature()
	settings.mightyEagleEnabled = nil
	settings.tutorials.BAIT_SARDINE = nil
	settings.eaglesUsedIn = {}
	
	setActiveMenuPage(mainMenu)
	setGameMode(updateMenu)
	drawMenu()
	highscores = {}
	
	--[[setAnimationState("ingamePausePageScroll", "EXITING")
	setActiveMenuPage(pausePage, false)
	setGameMode(updateGame)
	setPhysicsEnabled(true)
	drawMenu()--]]
end

--[[
function unlockLevels()
	releaseBuild = false
	settings.lastOpenLevel = 200
	settings.lastOpenLevelLP2 = 200
	settings.lastOpenLevelLP3 = 200
	settings.lastOpenLevelLP4 = 200
	settings.lastOpenLevelLP5 = 200
	settings.theme1Completed = true
	settings.theme2Completed = true
	settings.gameCompleted = true
	settings.theme4Completed = true
	settings.theme5Completed = true
	settings.theme6Completed = true
	settings.theme7Completed = true
	settings.theme8Completed = true
	settings.theme9Completed = true
	settings.theme10Completed = true
	settings.theme11Completed = true
	settings.theme12Completed = true
	settings.theme13Completed = true
	settings.theme14Completed = true
	
	--prepareMenuPage(mainMenu)
	prepareMenuPage(episodeSelectionPage)
	prepareMenuPage(levelSelectionPagesBasic)
	prepareMenuPage(levelSelectionPagesExtra)
	prepareMenuPage(levelSelectionPagesGoldenEggs[1])
	prepareMenuPage(levelSelectionPagesPack3)
	prepareMenuPage(levelSelectionPagesPack4)
	
	setActiveMenuPage(mainMenu, true)
	setGameMode(updateMenu)
	drawMenu()
	print("Levels unlocked.\n")
end

function lockLevels()
	releaseBuild = true
	settings.lastOpenLevel = 200
	settings.lastOpenLevelLP2 = 1
	settings.lastOpenLevelLP3 = 1
	settings.lastOpenLevelLP4 = 1
	settings.lastOpenLevelLP5 = 1
	settings.theme1Completed = true
	settings.theme2Completed = true
	settings.gameCompleted = true
	settings.theme4Completed = nil
	settings.theme5Completed = nil
	settings.theme6Completed = nil
	settings.theme7Completed = nil
	settings.theme8Completed = nil
	settings.theme9Completed = nil
	settings.theme10Completed = nil
	settings.theme11Completed = nil
	settings.theme12Completed = nil
	settings.theme13Completed = nil
	settings.theme14Completed = true
	
	for i = #settings.eaglesUsedIn , 1, -1 do
		local v = settings.eaglesUsedIn[i]
		if v.world >= 4 then
			_G.table.remove(settings.eaglesUsedIn, i)
		end
	end

	for levelPack = 4, #levelOrder.packs do
		--print("  levelPack: " .. levelOrder.packs[levelPack] .. "\n")
		for level = 1, #levelOrder[levelOrder.packs[levelPack]] -- do
			--print("    level: " .. levelOrder[levelOrder.packs[levelPack]][level] .. "\n")
			--highscores[levelOrder[levelOrder.packs[levelPack]][level]] = nil
--[[		end
	end

	saveLuaFileWrapper("settings.lua", "settings", true)
	saveLuaFileWrapper("highscores.lua", "highscores", true)
	
	--prepareMenuPage(mainMenu, true)
	prepareMenuPage(episodeSelectionPage)
	--prepareMenuPage(levelSelectionPagesBasic)
	prepareMenuPage(levelSelectionPagesExtra)
	prepareMenuPage(levelSelectionPagesGoldenEggs[1])
	prepareMenuPage(levelSelectionPagesPack3)
	prepareMenuPage(levelSelectionPagesPack4)
	
	setActiveMenuPage(mainMenu)
	setGameMode(updateMenu)
	drawMenu()
	--print("Levels locked.\n")
end
]]

function createMightyEagle(meX, meY)
	levelCompleteTimer = 0
	levelFailedTimer = -200
	eagleX, eagleY = nil, nil
	--print("createMightyEagle: " .. meX .. ", " .. meY)
			
	local newName = "MightyEagle_a"
	local blockDef = blockTable.blocks["MightyEagleBird"]
	--print("eagleX: " .. levelLimitMinX .. ", eagleY: " .. meY - (meX - levelLimitMinX) / 2  .. "\n")
	createCircle(newName, blockDef.sprite, levelLimitMinX + 1, meY - (meX - levelLimitMinX+1) / 2, blockDef.radius, blockDef.density, blockDef.friction, blockDef.restitution, true, blockDef.z_order)
	objects.world[newName].targetX = meX
	objects.world[newName].targetY = meY
	-- eagle init velocity
	objects.world[newName].initVelX, objects.world[newName].initVelY = vNormalize(objects.world[newName].targetX - objects.world[newName].x, objects.world[newName].targetY - objects.world[newName].y)
	objects.world[newName].definition = "MightyEagleBird"
	objects.world[newName].controllable = blockDef.controllable
	objects.world[newName].strength = blockDef.strength
	objects.world[newName].defence = blockDef.defence
	objects.world[newName].material = blockDef.material
	objects.world[newName].damageFactors = blockDef.damageFactors
	objects.world[newName].useLegacyCollisionPath = blockDef.useLegacyCollisionPath
	objects.world[newName].levelGoal = false
	local xp, yp = _G.res.getSpritePivot("INGAME_BIRDS_2",blockDef.sprite)
	objects.world[newName].spritePivotX = xp
	objects.world[newName].spritePivotY = yp
	objects.world[newName].damageSprite = blockDef.sprite
	objects.world[newName].xVel = 0
	objects.world[newName].yVel = 0
	setSprite(newName, objects.world[newName].damageSprite)
	setRotation(newName, 0)
	setVelocity(newName, objects.world[newName].xVel, objects.world[newName].yVel)
	objects.world[newName].animTimer = 9999
	objects.world[newName].jumpTimer = 9999
	objects.world[newName].animOn = false
	objects.world[newName].isMightyEagle = true
	objects.world[newName].shot = true
	objects.world[newName].particleTimer = 0 
	objects.world[newName].particleTimerLimit = 0.025
	objects.world[newName].recordTrajectory = false
	birds[newName] = objects.world[newName]
	--_G.res.playAudio(getAudioName(blockTable.blocks[objects.world[newName].definition].specialSound), 1, false)
	birdsCounter = birdsCounter + 1
	currentZoomedScale = objects.castleCameraData[deviceModel].sx
	--cameraAnimationSliderTarget = 1
	flyingBird = objects.world[newName]
	setMaxTranslation(5)
	_G.particles.setHardLimit(250)
	_G.particles.setSoftLimit(0, 0.2)
end

function removeBlocks()
	if objects.world == nil then
		return
	end
	-- for k, v in _G.pairs(deadBlocks) do
		-- print("GameLogic.lua: "..k.." block has been destroyed \n")
	-- end
	-- remove objects if their strength is 0
	for k, v in _G.pairs(deadBlocks) do
		if v ~= nil and v.strength ~= nil then
			local bDef = getObjectDefinition(k)
			local scoreToAdd = blockDestroyedScoreIncrement
			
			if bDef.destroyedScoreInc ~= nil then
				scoreToAdd = blockTable.blocks[v.definition].destroyedScoreInc
			end
			
			if v.levelGoal then
				scoreToAdd = pigletteDestroyedScoreIncrement
				_G.res.playAudio(getAudioName("piglette_damage"), 1, false)
				_G.table.insert(floatingScores, { x = v.x, y = v.y, sprite = "5K_GREEN", score = scoreToAdd, time = 0, lifetime = 0.9, maxScale = floatingScoreScaling * 1, xs = 0  } )
				if settings.mightyEagleEnabled == true and startedFromEditor ~= true then
					-- check if only one piglette is still alive 
					local anyPiglettesAlive = 0
					for k2, v2 in _G.pairs(levelGoals) do
						if v2.levelGoal then
							anyPiglettesAlive = anyPiglettesAlive + 1
						end
					end
					if anyPiglettesAlive == 1 then
						--_G.res.playAudio(getAudioName("level_clear_military"), 1, false)
						if inGameEagleButtonVisible == true and isEagleDisabled() ~= true then
							inGameEagleButtonScale = 1
						end
					end
				end
			else
				if bDef.spriteScore ~= nil then
					_G.table.insert(floatingScores, { x = v.x, y = v.y, sprite = bDef.spriteScore, score = scoreToAdd, time = 0, lifetime = 0.9, maxScale = floatingScoreScaling * 1, xs = 0  } )
				else
					_G.table.insert(floatingScores, { x = v.x, y = v.y, text = "" .. scoreToAdd, score = scoreToAdd, time = 0, lifetime = 0.6, maxScale = floatingScoreScaling * (0.25 + scoreToAdd / 3000), xs = 0 } )
				end
			end
			scoreTable["blocks"].score = scoreTable["blocks"].score + scoreToAdd

			local bDef = getObjectDefinition(k)
			local particle = bDef.particles
			if particle == nil then
				particle = blockTable.materials[v.material].particles
			end

			local destroySound = blockTable.materials[v.material].destroyedSound
			local particleAmount = 12
			local batAmount = _G.math.random(12, 20)
			if particle == "smokeBuff" then
				particleAmount = 1
			elseif particle == "batBuff" then
				particleAmount = batAmount
			elseif particle == "flameBuff" then
				particleAmount = 1
			end
			if bDef.specialty == "BOMB" then
				makeExplosion(deadBlocks[k], bDef, getAudioName("tnt_explodes"))
			end

			if destroySound ~= nil then
				_G.res.playAudio(getAudioName(destroySound), 0.7, false, 3)
			end
			
			if eagleBaitLaunched ~= true and (deviceModel == "iphone" or deviceModel == "ipad" or deviceModel == "iphone4") then
				if v.material ~= nil then
					if v.material == "wood" then
						if settings.woodBlocksDestroyed == nil then
							settings.woodBlocksDestroyed = 0
						end
						settings.woodBlocksDestroyed = settings.woodBlocksDestroyed + 1
						if settings.woodBlocksDestroyed == 5000 then
							addToAchievementUnlockQueue("Woodpecker", true)
						end
						if settings.woodBlocksDestroyed == 100 then
							addToAchievementUnlockQueue("Woodpecker Lite", true)
						end
					elseif v.material == "light" then
						if settings.iceBlocksDestroyed == nil then
							settings.iceBlocksDestroyed = 0
						end
						settings.iceBlocksDestroyed = settings.iceBlocksDestroyed + 1
						if settings.iceBlocksDestroyed == 5000 then
							addToAchievementUnlockQueue("Icepicker", true)
						end
						if settings.iceBlocksDestroyed == 100 then
							addToAchievementUnlockQueue("Icepicker Lite", true)
						end
					elseif v.material == "rock" then
						if settings.rockBlocksDestroyed == nil then
							settings.rockBlocksDestroyed = 0
						end
						settings.rockBlocksDestroyed = settings.rockBlocksDestroyed + 1
						if settings.rockBlocksDestroyed == 5000 then
							addToAchievementUnlockQueue("Stonecutter", true)
						end
					elseif v.material == "piglette" then
						if settings.pigsDestroyed == nil then
							settings.pigsDestroyed = 0
						end
						if eagleBaitLaunched ~= true then
							settings.pigsDestroyed = settings.pigsDestroyed + 1
						end
						if settings.pigsDestroyed == 1000 then
							addToAchievementUnlockQueue("Pig Popper", true)
						end
					elseif v.material == "amber" or v.material == "ruby" or v.material == "amethyst" then
						print(" ::::::::::: JEWEL DESTROYED")
						if settings.jewelsDestroyed == nil then
							settings.jewelsDestroyed = 0
						end
						if eagleBaitLaunched ~= true then
							settings.jewelsDestroyed = settings.jewelsDestroyed + 1
						end
	
						if settings.jewelsDestroyed == 100 then
							print("------ Ultimate Bejeweler TO ACHIEVEMENTS QUEUE -\n")
							addToAchievementUnlockQueue("Ultimate Bejeweler", true)
						end

					elseif v.material == "stalaktite_tip" then
						print(" ::::::::::: STALAKTITE DESTROYED")
					
						if settings.stalaktitesDestroyed == nil then
							settings.stalaktitesDestroyed = 0
						end
						if eagleBaitLaunched ~= true then
							settings.stalaktitesDestroyed = settings.stalaktitesDestroyed + 1
						end
	
						if settings.stalaktitesDestroyed == 100 then
							print("------ Hard as a Rock TO ACHIEVEMENTS QUEUE -\n")
							addToAchievementUnlockQueue("Hard as a Rock", true)
						end
					end
					totalBlocks = 0
					if settings.woodBlocksDestroyed ~= nil then
						totalBlocks = totalBlocks + settings.woodBlocksDestroyed
					end
					if settings.iceBlocksDestroyed ~= nil then
						totalBlocks = totalBlocks + settings.iceBlocksDestroyed
					end
					
					if settings.rockBlocksDestroyed ~= nil then
						totalBlocks = totalBlocks + settings.rockBlocksDestroyed
					end
					
					if totalBlocks == 50000 then
						addToAchievementUnlockQueue("Block Smasher", true)
					end
					if totalBlocks == 500000 then
						addToAchievementUnlockQueue("Smash Maniac", true)
					end
					if totalBlocks == 500 then
						addToAchievementUnlockQueue("Block Smasher Lite", true)
					end
				end
			end
			
			if eagleBaitLaunched ~= true then
				if currentLevelNumberInTheme == 2 and currentWorldNumber == 2 then
					if v.name == "ExtraBeachBall_1" then
						goldenEggAchieved("Level3")
					end
				end
				
				if currentLevelNumberInTheme == 14 and currentWorldNumber == 6 then
					if v.name == "StaticBalloon03_2" then
						goldenEggAchieved("Level10")
					end
				end
				
				if currentLevelNumberInTheme == 7 and currentWorldNumber == 4 then
					if v.name == "ExtraGoldenEgg_1" then
						goldenEggAchieved("Level9")
					end
				end
				
				if currentLevelNumberInTheme == 19 and currentWorldNumber == 5 then
					if v.name == "ExtraGoldenEgg_1" then
						goldenEggAchieved("Level2")
					end
				end
				
				if currentLevelNumberInTheme == 15 and currentWorldNumber == 8 then
					if v.name == "ExtraGoldenEgg_1" then
						goldenEggAchieved("Level13")
					end
				end
				
				if currentLevelNumberInTheme == 14 and currentWorldNumber == 9 then
					if v.name == "ExtraGoldenEgg_1" then
						goldenEggAchieved("Level14")
					end
				end
				
				if currentLevelNumberInTheme == 3 and currentWorldNumber == 10 then
					if v.name == "ExtraRubberDuck_1" then
						goldenEggAchieved("Level15")
					end
				end
				
				if currentLevelNumberInTheme == 15 and currentWorldNumber == 11 then
					if v.name == "ExtraGoldenEgg_1" then
						goldenEggAchieved("Level16")
					end
				end
				
				if currentLevelNumberInTheme == 12 and currentWorldNumber == 12 then
					if v.name == "ExtraHolyGrail_4" then
						goldenEggAchieved("Level18")
					end
				end
				
				if currentLevelNumberInTheme == 10 and currentWorldNumber == 13 then
					if v.name == "ExtraGoldenEgg_1" then
						goldenEggAchieved("Level19")
					end
				end
				
				if currentLevelNumberInTheme == 4 and currentWorldNumber == 14 then
					if v.name == "ExtraGoldenEgg_1" then
						goldenEggAchieved("Level20")
					end
				end
				
				if currentLevelNumberInTheme == 12 and currentWorldNumber == 13 then
					if v.name == "ExtraSuperBowl_2" then
						goldenEggAchieved("Level22")
					end
				end
			
				if currentLevelNumberInTheme == 12 and currentWorldNumber == 15 then
					if v.name == "ExtraGoldenEgg_1" then
						goldenEggAchieved("Level23")
					end
				end
			end
			
			addParticles(k, particle, particleAmount, false)
			removeObject(k)
			levelGoals[k] = nil	
			objects.world[k] = nil
			deadBlocks[k] = nil
		end
	end
end



function updateScore(dt)
	score = 0
	for k, v in _G.pairs(scoreTable) do
		score = score + v.score
	end
end


function initPictureLevel()
	if currentPictureLevel == "PIGGY" then
		piggyPage = PiggyPage:new()
	elseif currentPictureLevel == "MIGHTY_EAGLE" then
		eaglePage = EaglePage:new()
	end
	
end



--------------------------------
--EaglePage-class, inherits Page
--------------------------------

EaglePage = Page:new()

function EaglePage:init()
	_G.res.stopAudio(currentMainMenuSong)
	
	self.name = "eaglePage"
	self.beakUpperDragStartCursorY = 0
	self.beakUpperDragTouchId = -1
	self.beakLowerDragStartCursorY = 0
	self.beakLowerDragTouchId = -1
	self.beakTwitch = false
	self.beakTwitchTimer = 0
	self.beakMovable = true
	self.drawStarEffect = false
	self.sheet = ""
		
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", x = screenWidth / 2, y = screenHeight / 2, renderState = true, drawToScreenSize = true  } ))
	self:insertItem("eagleBirds1", SpriteItem:new( { sprite = "CONCEPT_EAGLE_BIRDS_1", x = screenWidth/ 2, y = screenHeight / 2 } ))
	self:insertItem("eagleTongue", SpriteItem:new( { sprite = "CONCEPT_EAGLE_TONGUE", x = screenWidth, y = screenHeight / 2 } ))
	self:insertItem("beakLower", SpriteItem:new({ sprite = "CONCEPT_EAGLE_BEAK_LOWER", x = screenWidth, y = 0 }))
	self:insertItem("beakUpper", SpriteItem:new({ sprite = "CONCEPT_EAGLE_BEAK_UPPER", x = screenWidth, y = 0 }))
	self:insertItem("back", SpriteItem:new( { sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight } ))
		
	local starX, starY, effectOffset
	self.x = screenWidth
	
	self.beakUpperRestY = 0.61 * screenHeight
	self.beakLowerRestY = 0.6 * screenHeight
	self.beakHitBoxes = { x = screenWidth / 2, beakUpperTopY = self.beakUpperRestY - 0.009 * screenHeight, 
								beakUpperBotY = self.beakUpperRestY - 0.28 * screenHeight,
								beakLowerTopY = self.beakLowerRestY + 0.19 * screenHeight,
								beakLowerBotY = self.beakLowerRestY + 0.009 * screenHeight }
	self.twitchTopY = 0.78 * screenHeight
	self.twitchBotY = 0.33 * screenHeight
	self.botLimit = 0.34 * screenHeight
	self.topLimit = 0.72 * screenHeight	
	starX, starY, effectOffset = 0.75 * screenWidth, 0.55 * screenHeight, 0.008 * screenWidth
				


	self.starCollected = settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 2
	if self.starCollected then
		self:insertItem("starCollected", SpriteItem:new( {sprite = "GOLDEN_EGG_STAR_COLLECTED", x = starX, y = starY} ), "beakLower")
	else
		self:insertItem("star", SpriteItem:new( {sprite = "GOLDEN_EGG_STAR", x = starX, y = starY} ), "beakLower")
		self:insertItem("starEffect", SpriteItem:new( { sprite = "GOLDEN_EGG_STAR_EFFECT", x = starX - effectOffset, y = starY - effectOffset, angle = 0,
		renderState = true, useSpritePivot = true, visible = false} ), "star")	
	end
		
	self.beakUpperY = self.beakUpperRestY
	self.beakLowerY = self.beakLowerRestY
	self.beakUpperDragStartY = self.beakUpperRestY
	self.beakLowerDragStartY = self.beakLowerRestY
	self.items.beakLower.x = self.x
	self.items.beakUpper.x = self.x
	
	--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level5"] .. "\n")
	logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level5"]) 
end

function EaglePage:update(dt)

	if self.drawStarEffect == true then
		self.items.starEffect.angle = self.items.starEffect.angle + 0.6 * dt
		self.items.starEffect.visible = true
	end
				
	if self.beakMovable == true then
					
		if touchcount == 2 or (deviceModel == "n900" and touchcount == 1) then
			
			for k, v in _G.pairs(touches) do

				if v.x > self.beakHitBoxes.x and v.y > self.beakHitBoxes.beakUpperBotY
				   and v.y < self.beakHitBoxes.beakUpperTopY then
					self.beakUpperDragStartCursorY = v.y
					self.beakUpperDragStartY = self.beakUpperY
					self.beakUpperDragTouchId = k
				elseif v.x > self.beakHitBoxes.x and v.y >= self.beakHitBoxes.beakLowerBotY
					and v.y < self.beakHitBoxes.beakLowerTopY then
					self.beakLowerDragStartCursorY = v.y
					self.beakLowerDragStartY = self.beakLowerY
					self.beakLowerDragTouchId = k
				end
				
			end
				
			if self.beakUpperDragTouchId ~= -1 and touches[self.beakUpperDragTouchId] ~= nil 
			  and self.beakLowerDragTouchId ~= -1 and touches[self.beakLowerDragTouchId] ~= nil
			  and deviceModel ~= "n900" then
				self.beakUpperY = _G.math.min(self.beakUpperRestY, self.beakUpperDragStartY - (self.beakUpperDragStartCursorY - touches[self.beakUpperDragTouchId].y))
				self.beakLowerY = _G.math.max(self.beakLowerRestY, self.beakLowerDragStartY - (self.beakLowerDragStartCursorY - touches[self.beakLowerDragTouchId].y))
			elseif deviceModel == "n900" and self.beakUpperDragTouchId ~= -1 and touches[self.beakUpperDragTouchId] ~= nil then
				self.beakUpperY = _G.math.min(self.beakUpperRestY, self.beakUpperDragStartY - (self.beakUpperDragStartCursorY - touches[self.beakUpperDragTouchId].y))
			elseif deviceModel == "n900" and self.beakLowerDragTouchId ~= -1 and touches[self.beakLowerDragTouchId] ~= nil then
				self.beakLowerY = _G.math.max(self.beakLowerRestY, self.beakLowerDragStartY - (self.beakLowerDragStartCursorY - touches[self.beakLowerDragTouchId].y))
			end
						
			if deviceModel == "n900" and keyPressed["LBUTTON"] then
				if self.beakTwitch == false and cursor.x > self.beakHitBoxes.x 
				   and cursor.y > self.twitchBotY and cursor.y < self.twitchTopY then
					self.beakTwitch = true
					self.beakTwitchTimer = 0
				end
			end
			
		elseif keyPressed["C"] then
			self.beakUpperY = self.botLimit - 1
			self.beakLowerY = self.topLimit + 1
		elseif keyPressed["LBUTTON"] then
			if self.beakTwitch == false and cursor.x > self.beakHitBoxes.x 
			   and cursor.y > self.twitchBotY and cursor.y < self.twitchTopY then
				self.beakTwitch = true
				self.beakTwitchTimer = 0
			end
		else
			self.beakUpperDragTouchId = -1
			self.beakLowerDragTouchId = -1
		end
	end
		
	if self.beakTwitch == true then
		self.beakTwitchTimer = self.beakTwitchTimer + dt
		if self.beakTwitchTimer < 0.08 then
			self.beakUpperY = self.beakUpperY - 60 * dt
		elseif self.beakTwitchTimer < 0.16 then
			self.beakUpperY = _G.math.min(self.beakUpperRestY, self.beakUpperY + 30 * dt)
		else
			self.beakTwitch = false
			self.beakTwitchTimer = 0
		end
	end
		
	if deviceModel == "n900" then
		if self.beakUpperY < self.botLimit then
			self.beakUpperY = self.botLimit
			self.beakUpperRestY = self.botLimit
		elseif self.beakLowerY > self.topLimit then
			self.beakLowerY = self.topLimit
			self.beakLowerRestY = self.topLimit
		end
	else
		if self.beakUpperY < self.botLimit then
			self.beakUpperY = self.botLimit
		elseif self.beakLowerY > self.topLimit then
			self.beakLowerY = self.topLimit
		end
	end
		
	if self.beakUpperY <= self.botLimit and self.beakLowerY >= self.topLimit then
		self.beakUpperY = self.botLimit
		self.beakLowerY = self.topLimit
		self.beakUpperRestY = self.botLimit
		self.beakLowerRestY = self.topLimit
		self.beakMovable = false
		
		if not self.starCollected then
			self.drawStarEffect = true
		end
			
		if settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 1 then
			settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] = 2
			highscores[goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]] = {completed = true, birds = 0, score = 0, lowScore = 0}
			saveLuaFileWrapper("highscores.lua", "highscores", true)
			saveLuaFileWrapper("settings.lua", "settings", true)
			_G.res.playAudio("star_collect", 1, false)
		end
		
		if self.flurryLogged ~= true then
			--print("FlurryEventWithParam: Golden egg level completed, param: Level, paramValue: " .. goldenEggLevelMapping["Level5"] .. "\n")
			logFlurryEventWithParam("Golden egg level completed", "Level", "" .. goldenEggLevelMapping["Level5"]) 
			self.flurryLogged = true
		end
	end
		
	if self.beakTwitch == false and self.beakMovable == true then 
		if self.beakUpperDragTouchId == -1 and self.beakUpperY < self.beakUpperRestY then
			self.beakUpperY = _G.math.min(self.beakUpperY + 200 * dt, self.beakUpperRestY)
		end
		if self.beakLowerDragTouchId == -1 and self.beakLowerY > self.beakLowerRestY then
			self.beakLowerY = _G.math.max(self.beakLowerY - 200 * dt, self.beakLowerRestY)
		end
	end
				
	self.items.beakLower.y = self.beakLowerY
	self.items.beakUpper.y = self.beakUpperY
	
	if keyPressed["LBUTTON"] then
		local width, height = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "LS_BACK_BUTTON")
		if cursor.y > (screenHeight - height) and cursor.x < width then
			setGameMode(gotoLevelSelectionGoldenEggs)
		end
	end
	
end

--------------------------------
--PiggyPage-class, inherits Page
--------------------------------

PiggyPage = Page:new()

function PiggyPage:init()
	_G.res.stopAudio(currentMainMenuSong)
	
	self.name = "piggyPage"
	self.starCollected = settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 2
	self.drawStarEffect = false
	self.starAnimationTimer = 0
	self.starSoundPlayed = false
	self.nosey = screenHeight / 2
	self.nosevel = 0
	self.noseTwitch = false
	self.noseTwitchTimer = 0
	self.sheet = ""
	local _, tempHeight = _G.res.getSpriteBounds("", "CONCEPT_PIG_NOSE")
	self.noseSpriteHeight = tempHeight
		
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", x = screenWidth/2, y = screenHeight/2,renderState = true, drawToScreenSize = true } ))
	self:insertItem("pigBody", SpriteItem:new( { sprite = "CONCEPT_PIG_BODY", x = screenWidth/2, y = screenHeight/2 } ))
	self:insertItem("pigBird", SpriteItem:new( { sprite = "CONCEPT_PIG_BIRD", x = screenWidth/2, y = screenHeight/2 } ))
	self:insertItem("pigEyesOpen", SpriteItem:new( {sprite = "CONCEPT_PIG_EYES_OPEN", visible = false, x = screenWidth/2, y = screenHeight/2} ))
	self:insertItem("pigNose", SpriteItem:new( {name = "pig_nose", sprite = "CONCEPT_PIG_NOSE", x = screenWidth/2, y = screenHeight/2 } ))
	self:insertItem("back", SpriteItem:new( { sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight } ))
			
	local starX, starY
	local px, py = _G.res.getSpritePivot("", "CONCEPT_PIG_NOSE")
	local pw, ph = _G.res.getSpriteBounds("", "CONCEPT_PIG_NOSE")
	local pigNoseLeft = -px + self.items.pigNose.x
	local pigNoseTop = -py + self.items.pigNose.y
	
	self.leftNostrilX, self.leftNostrilY = -0.004 * screenWidth, 0.05 * screenHeight
	self.rightNostrilX, self.rightNostrilY = 0.14 * screenWidth, 0.05* screenHeight
	self.hitboxX, self.hitboxY = 0.06 * screenWidth, 0.05* screenHeight
	self.nostrilRadius = 0.1 * screenWidth
	self.noseRadius = 0.19 * screenWidth
		
	starX, starY = pigNoseLeft + pw / 2, pigNoseTop	+ ph / 2

	
	if self.starCollected then
		self:insertItem("starCollected", SpriteItem:new( { sprite = "GOLDEN_EGG_STAR_COLLECTED", x = starX, y = starY }), "pigEyesOpen" )
	else
		self:insertItem("star", SpriteItem:new( { sprite = "GOLDEN_EGG_STAR", x = starX, y = starY }), "pigEyesOpen" )
		self:insertItem("starEffect", SpriteItem:new( { sprite = "GOLDEN_EGG_STAR_EFFECT", x = starX, y = starY, angle = 0 , renderState = true, useSpritePivot = true, visible = false }), "star" )
	end
	
	--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level6"] .. "\n")
	logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level6"]) 
end

function PiggyPage:update(dt)
		
	if touchcount == 2 or (deviceModel == "n900" and touchcount == 1) then
		local leftNostril = false
		local rightNostril = false
		for k,v in _G.pairs(touches) do
		
			if distance(v.x, v.y, self.leftNostrilX + screenWidth / 2, self.leftNostrilY + screenHeight / 2) < self.nostrilRadius then
				leftNostril = true
				if deviceModel == "n900" then
					self.leftHit = true
				end
			elseif distance(v.x, v.y, self.rightNostrilX + screenWidth / 2, self.rightNostrilY + screenHeight / 2) < self.nostrilRadius then
				rightNostril = true
				if deviceModel == "n900" then
					self.rightHit = true
				end
			elseif deviceModel == "n900" then
				self.leftHit, self.rightHit = false, false
			end	
		end
			
		if deviceModel == "n900" and keyPressed["LBUTTON"] then
			if self.noseTwitch == false and distance(cursor.x, cursor.y, self.hitboxX + screenWidth / 2, self.hitboxY + screenHeight / 2) < self.noseRadius then
				self.noseTwitch = true
				self.noseTwitchTimer = 0
			end
		end	
		
		if leftNostril == true and rightNostril == true or (deviceModel == "n900" and self.leftHit and self.rightHit) then
			self.drawStarEffect = true
			if not self.starCollected then
				self.items.starEffect.visible = true
			end
		end
	elseif keyPressed["C"] then
		self.drawStarEffect = true
		if not self.starCollected then
			self.items.starEffect.visible = true
		end
	elseif keyPressed["LBUTTON"] then
		if self.noseTwitch == false and distance(cursor.x, cursor.y, self.hitboxX + screenWidth / 2, self.hitboxY + screenHeight / 2) < self.noseRadius then
			self.noseTwitch = true
			self.noseTwitchTimer = 0
		end
	end
	
	if self.noseTwitch == true then
		self.noseTwitchTimer = self.noseTwitchTimer + dt
		if self.noseTwitchTimer < 0.08 then
			self.nosey = self.nosey - 60 * dt
		elseif self.noseTwitchTimer < 0.16 then
			self.nosey = self.nosey + 30 * dt
			if self.drawStarEffect == false and self.nosey > screenHeight / 2 then
				self.nosey = screenHeight / 2
			end
		else
			if self.drawStarEffect == false then
				self.nosey = screenHeight / 2
			end
			self.noseTwitch = false
			self.noseTwitchTimer = 0
		end
		
		self.items.pigNose.y = self.nosey
		
	end
	
	if self.drawStarEffect == true then
	
		self.starAnimationTimer = self.starAnimationTimer + dt
		
		if not self.starCollected then	
			self.items.starEffect.angle = self.items.starEffect.angle + 0.6 * dt
			-- sound
			if self.starAnimationTimer > 2.3 and self.starSoundPlayed == false then
				self.starSoundPlayed = true
				if settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 1 then
					settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] = 2
					highscores[goldenEggLevelMapping["Level" .. currentLevelNumberInTheme]] = {completed = true, birds = 0, score = 0, lowScore = 0}
					saveLuaFileWrapper("highscores.lua", "highscores", true)
					saveLuaFileWrapper("settings.lua", "settings", true)
					_G.res.playAudio("star_collect", 1, false)
				end
			end
		
		end
		
		-- nose
		if self.starAnimationTimer >= 1.5 and self.nosey < screenHeight + self.noseSpriteHeight then
			self.nosevel = self.nosevel + 800 * dt
			self.nosey = self.nosey + dt * self.nosevel
		end
		
		if (self.starAnimationTimer < 0.25 or (self.starAnimationTimer > 0.4 and self.starAnimationTimer < 0.8)
		    or self.starAnimationTimer > 0.9) then
			self.items.pigEyesOpen.visible = true
		else
			self.items.pigEyesOpen.visible = false
		end
		
		self.items.pigNose.y = self.nosey
							
		if self.complete ~= true then
			logFlurryEventWithParam("Golden egg level completed", "Level", "" .. goldenEggLevelMapping["Level6"]) 
			self.complete = true
		end
	end
	
	if keyPressed["LBUTTON"] then
		local width, height = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "LS_BACK_BUTTON")
		if cursor.y > (screenHeight - height) and cursor.x < width then
			setGameMode(gotoLevelSelectionGoldenEggs)
		end
	end
	
end

--------------------------------
--AccordionPage-class, inherits Page
--------------------------------

AccordionPage = Page:new()

function AccordionPage:init()
	self.name = "AccordionPage"
	self.sheet = ""
	
	self.bellowsW, self.bellowsH = _G.res.getSpriteBounds("","ACCO_MID")
	self.bellowsPX, self.bellowsPY = _G.res.getSpritePivot("","ACCO_MID")
	self.grandpaW, self.grandpaH = _G.res.getSpriteBounds("","PIGLETTE_GRANDPA_01")
	
	self.rightHandleW, self.rightHandleH = _G.res.getSpriteBounds("","ACCO_RIGHT")
	self.cursorData = { x = 0, y = 0, speedX = 0, speedY = 0}
	self.handleCursorData = {x = 1, y = 1}
	self.cursorReleased = true
	self.activeButton = nil
	
	self.ripCount = 0
	self.levelComplete = false
	self.resetRipStatus = false
	self.ripTimer = 0
	
	self.currentVolumeLeft = 0
	self.currentVolumeRight = 0
	self.isPlaying = false
	self.direction = "left"
	self.timerVolume = 0
	self.currentTrack = 5
	
	self.grandpaTimer = 0
	self.grandpaIsActive = true
	
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", selectable = false, x = screenWidth/2, y = screenHeight/2, renderState = true, drawToScreenSize = true } ))
	
	-- Accordion
	self:insertItem("accordionBellowsBroken", SpriteItem:new( { sheet = "", sprite = "ACCO_MID_BROKEN", visible = false, selectable = false, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2 } ))
	self:insertItem("accordionBellows", SpriteItem:new( { sheet = "", sprite = "ACCO_MID", selectable = false, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, renderState = true, xs = (self.bellowsW / 2 + self.bellowsW / 4) / (self.bellowsW - self.bellowsPX) , ys = 1 } ))
	self:insertItem("accordionLHandle", SpriteItem:new( { sheet = "", sprite = "ACCO_LEFT", selectable = false, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2 } ))
	self:insertItem("accordionRHandle", SpriteItem:new( { sheet = "", sprite = "ACCO_RIGHT", selectable = true, x = screenWidth/2 + self.bellowsW / 4, y = screenHeight/2 } ))
	
	-- Buttons
	self:insertItem("accButton1", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_1", spriteOn = "ACCO_BTN_DOWN_1", spriteOff = "ACCO_BTN_UP_1", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "cminor" } ))
	self:insertItem("accButton2", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_2", spriteOn = "ACCO_BTN_DOWN_2", spriteOff = "ACCO_BTN_UP_2", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "dismajor" } ))
	self:insertItem("accButton3", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_3", spriteOn = "ACCO_BTN_DOWN_3", spriteOff = "ACCO_BTN_UP_3", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "fmajor" } ))
	self:insertItem("accButton4", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_4", spriteOn = "ACCO_BTN_DOWN_4", spriteOff = "ACCO_BTN_UP_4", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "gminor" } ))
	self:insertItem("accButton5", SpriteItem:new( { sheet = "", sprite = "ACCO_BTN_UP_5", spriteOn = "ACCO_BTN_DOWN_5", spriteOff = "ACCO_BTN_UP_5", selectable = true, x = screenWidth/2 - self.bellowsW / 2.5, y = screenHeight/2, sound = "bmajor" } ))
	
	-- Grandpa
	local grandpaScale = 0.75 * screenWidth / 480
	if grandpaScale > 1.5 then
		grandpaScale = 1.5
	end
	self:insertItem("birdShadow", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_SHADOW", x = screenWidth - self.grandpaW * grandpaScale / 1.75, y = screenHeight - self.grandpaH * grandpaScale / 7, selectable = false}))
	self:insertItem("grandpa", SpriteItem:new( { sheet = "", sprite = "PIGLETTE_GRANDPA_01", selectable = true, x = screenWidth - self.grandpaW * grandpaScale / 1.75, y = screenHeight - self.grandpaH * grandpaScale / 1.75, xs = grandpaScale, ys = grandpaScale, renderState = true } ))
	
	-- Back Button
	self:insertItem("back", SpriteItem:new( {sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight, selectable = false } ))
end

function AccordionPage:update(dt)
	_G.res.setTrackVolume(0, 7)
	if cursor.x > (self.items["accordionLHandle"].x + self.bellowsW * 1.2) and self.accordionIsActive == true and touchcount >= 1 then
		self.accordionIsActive = true
		self:play(-dt, self.direction, self.activeButton, dt)
		
	else
		self.accordionIsActive = false
	end
	
	if self.levelCompleted ~= true then
		if touchcount >= 1 then
			--print("touches: ".. touchcount .."\n")
			self.activatedItems, self.activatedItemsTouchData = self:getActivatedItems()
			
			if self.activatedItems then
				for k, v in _G.pairs(self.activatedItems) do
					
					if v == "accordionRHandle" and self.cursorData.x ~= 0 and self.cursorData.y ~= 0 then
						
						if self.handleCursorData.x ~= touches[self.activatedItemsTouchData[v]].x then
							self.handleCursorData = touches[self.activatedItemsTouchData[v]]						
							self:updateBellows(self.handleCursorData.x)
							local currentDirection = self.direction
						
							if self.handleCursorData.x - self.cursorData.x > 2 then
								currentDirection = "right"
							elseif self.handleCursorData.x - self.cursorData.x < -2 then
								currentDirection = "left"
							end
							
							if self.direction ~= currentDirection then
								if currentDirection == "right" then
									self.currentTrack = 6
									self.currentVolumeRight = self.currentVolumeLeft
									self.currentVolumeLeft = 0
									_G.res.setTrackVolume(self.currentVolumeRight, 6)
									_G.res.setTrackVolume(0, 5)
								else
									self.currentTrack = 5
									self.currentVolumeLeft = self.currentVolumeRight
									self.currentVolumeRight = 0
									_G.res.setTrackVolume(0, 6)
									_G.res.setTrackVolume(self.currentVolumeLeft, 5)
								end
								--print("changing direction")
								if self.grandpaIsActive == true then
									if self.items["grandpa"].sprite == "PIGLETTE_GRANDPA_01" then
										self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_04_SMILE"
									else
										self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_01"
									end
									_G.res.playAudio(getAudioName("pig_accordion"), 0.7, false, 0)
								end
								--self.isPlaying = false
								self.direction = currentDirection
							end
							
							self:play(_G.tonumber(_G.string.format("%.1f", self.cursorData.speedX)), self.direction, self.activeButton, dt)
							--self:updateGrandpa(dt)
						else
							self:play(-dt, self.direction, self.activeButton, dt)
						end

						self.accordionIsActive = true
					elseif v == "grandpa" and keyPressed["LBUTTON"] then
						self.grandpaIsActive = not self.grandpaIsActive
						if self.grandpaIsActive == false then
							self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_01_BLINK"
						else
							self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_01"
						end
					elseif _G.string.sub(v, 1, _G.string.len(v) - 1) == "accButton" and touchcount <= 2 then
						self:activateButton(self.items[v])
					end
				end
			self.cursorReleased = false
			end
			
			-- if (self.handleCursorData.x > self.cursorData.x) and self.cursorData.speedX > 0.9 and self.handleCursorData.x > (self.items["accordionLHandle"].x + self.bellowsW * 0.5) and self.resetRipStatus ~= true then
				-- print("self.ripCount: "..self.ripCount)
				-- self.ripCount = self.ripCount + 1
				-- self.resetRipStatus = true
			-- end
			
			if self.items["accordionRHandle"].x >= (screenWidth/2 + self.bellowsW / 2.1) then
				self.ripTimer = self.ripTimer + dt
			else
				self.ripTimer = 0
			end
			
			if self.accordionIsActive == true and self.handleCursorData.x < (self.items["accordionLHandle"].x + self.bellowsW * 0.5) then
				self.resetRipStatus = false
			end
			self.cursorData.x = self.handleCursorData.x
			self.cursorData.y = self.handleCursorData.y
		else
			self.ripCount = 0
			self.ripTimer = 0
			self.cursorData.speedX = 0
			self.cursorReleased = true
		end
		
		if self.accordionIsActive ~= true then
			self:restoreBellows(dt)
		end
		
		-- if self.ripCount >= 7 * screenWidth / 480 then
			-- _G.res.stopAllAudio()
			-- self.ripCount = 0
			-- self.levelCompleted = true
			-- self.items["accordionBellowsBroken"].visible = true
			-- self.items["accordionBellows"].xs = 1
			-- self.items["accordionRHandle"].x = screenWidth / 2 + self.bellowsW / 2
			-- self:ripBellows()
		-- end
		
		if self.ripTimer >= 3 then
			_G.res.stopAllAudio()
			self.ripTimer = 0
			self.levelCompleted = true
			self.items["accordionBellowsBroken"].visible = true
			self.items["accordionBellows"].xs = 1
			self.items["accordionRHandle"].x = screenWidth / 2 + self.bellowsW / 2
			self:ripBellows()
		end
	else
		self:playRipAnimation(dt)
	end
	
end

function AccordionPage:playRipAnimation(dt)
	if self.items["accordionRHandle"].x <= (screenWidth * 2) then
		self.items["accordionRHandle"].x = self.items["accordionRHandle"].x + self.items["accordionRHandle"].x * 2*dt
		self.items["accordionBellows"].x = self.items["accordionBellows"].x + self.items["accordionRHandle"].x * 2*dt
	end
end

function AccordionPage:ripBellows()
	_G.res.playAudio(getAudioName("accordion_break"), 0.7, false, 0)
	goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
end

function AccordionPage:updateBellows(posX)
	if posX > (self.items["accordionLHandle"].x + self.rightHandleW / 2 + self.bellowsPX) and posX <= (screenWidth/2 + self.bellowsW / 2 + self.rightHandleW / 2) then
								
		self.cursorData.speedX = (_G.math.abs((self.items["accordionRHandle"].x - (posX - self.rightHandleW / 2))) / (self.bellowsW / 20))
		if self.cursorData.speedX > 1 then
			self.cursorData.speedX = 1
		end
		
		self.items["accordionRHandle"].x = posX - self.rightHandleW / 2
		self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
	end
	if self.items["accordionRHandle"].x > (screenWidth/2 + self.bellowsW / 2) then
		self.items["accordionRHandle"].x = screenWidth/2 + self.bellowsW / 2
		self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
	end		
end

function AccordionPage:restoreBellows(dt)
	if self.items["accordionRHandle"].x < (screenWidth/2 + self.bellowsW / 4 ) then
		if self.isPlaying == true and self.direction ~= "right" then
			self.currentTrack = 6
			self.currentVolumeRight = self.currentVolumeLeft
			self.currentVolumeLeft = 0
			self.direction = "right"
			_G.res.setTrackVolume(self.currentVolumeRight, 6)
			_G.res.setTrackVolume(0, 5)
		end
		self.items["accordionRHandle"].x = self.items["accordionRHandle"].x + self.items["accordionRHandle"].x * dt
		
		if self.items["accordionRHandle"].x > (screenWidth/2 + self.bellowsW / 4) then
			self.items["accordionRHandle"].x = (screenWidth/2 + self.bellowsW / 4)
		end
		
		self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
			
		self:play(-dt, self.direction, self.activeButton, dt)
	-- end
	elseif self.items["accordionRHandle"].x > (screenWidth/2 + self.bellowsW / 4 ) then
		if self.isPlaying == true and self.direction ~= "left" then
			self.currentTrack = 5
			self.currentVolumeLeft = self.currentVolumeRight
			self.currentVolumeRight = 0
			self.direction = "left"
			_G.res.setTrackVolume(self.currentVolumeLeft, 5)
			_G.res.setTrackVolume(0, 6)
		end
		self.items["accordionRHandle"].x = self.items["accordionRHandle"].x - self.items["accordionRHandle"].x * dt
		
		if self.items["accordionRHandle"].x < (screenWidth/2 + self.bellowsW / 4 ) then
			self.items["accordionRHandle"].x = (screenWidth/2 + self.bellowsW / 4 )
		end
		
		self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
		
		self:play(-dt, self.direction, self.activeButton, dt)
	else
		self:play(-dt, self.direction, self.activeButton, dt)
		if self.grandpaIsActive == true then
			self.items["grandpa"].sprite = "PIGLETTE_GRANDPA_01"
		end
	end
	-- if self.items["accordionRHandle"].x >= (screenWidth/2 + self.bellowsW / 4) then
		-- self:play(-dt, self.direction, self.activeButton, dt)
		-- self.items["accordionRHandle"].x = screenWidth/2 + self.bellowsW / 4
		-- self.items["accordionBellows"].xs = (self.items["accordionRHandle"].x - self.items["accordionLHandle"].x) / (self.bellowsW - self.bellowsPX)
	-- end
end

function AccordionPage:activateButton(button)
	if button ~= self.activeButton  then
		_G.res.stopAllAudio()
		self.isPlaying = false
		self.activeButton = button
		for i = 1, 5 do
			if self.items["accButton"..i] == button then
				if self.items["accButton"..i].sprite == self.items["accButton"..i].spriteOff then
					self.items["accButton"..i].sprite = self.items["accButton"..i].spriteOn
				end
			else
				self.items["accButton"..i].sprite = self.items["accButton"..i].spriteOff
			end
		end
	end
end

function AccordionPage:play(volume, direction, activeButton, dt)
	if audioRampVolume then
		--_G.res.stopAllAudio()
		self.currentVolumeRight = 0
		self.currentVolumeLeft = 0
		self.isPlaying = false
		return
	end
	
	--volume = 0.5
	self.timerVolume = self.timerVolume + dt
	
	if self.timerVolume >= 0.03 then
		self.timerVolume = 0
		if self.currentTrack == 6 then
			if volume < 0 then
				if self.currentVolumeRight >= 0 then
					self.currentVolumeRight = self.currentVolumeRight + volume
				end
			else
				if (volume - self.currentVolumeRight) > 0.1 then
					self.currentVolumeRight = self.currentVolumeRight + 0.1
				elseif (volume - self.currentVolumeRight) < -0.1 then
					self.currentVolumeRight = self.currentVolumeRight - 0.1
				else
					self.currentVolumeRight = volume
				end
			end
			_G.res.setTrackVolume(self.currentVolumeRight, self.currentTrack)
		else
			if volume < 0 then
				if self.currentVolumeLeft >= 0 then
					self.currentVolumeLeft = self.currentVolumeLeft + volume
				end
			else
				if (volume - self.currentVolumeLeft) > 0.1 then
					self.currentVolumeLeft = self.currentVolumeLeft + 0.1
				elseif (volume - self.currentVolumeLeft) < -0.1 then
					self.currentVolumeLeft = self.currentVolumeLeft - 0.1
				else
					self.currentVolumeLeft = volume
				end
			end
			_G.res.setTrackVolume(self.currentVolumeLeft, self.currentTrack)
		end
		
		
	end		
	
	--if _G.res.isAudioPlaying(activeButton.sound.."_"..direction) == false then
		
		if self.isPlaying ~= true then
			_G.res.setTrackVolume(0, 5)
			_G.res.setTrackVolume(0, 6)
			--print(""..activeButton.sound.."_"..direction.." volumeRight: "..self.currentVolumeRight.." volumeLeft: "..self.currentVolumeLeft)
			if activeButton ~= nil then
				_G.res.playAudio(activeButton.sound.."_right", 1, true, 6)
				_G.res.playAudio(activeButton.sound.."_left", 1, true, 5)
			else
				_G.res.playAudio("empty_accordion_right", 1, true, 6)
				_G.res.playAudio("empty_accordion_left", 1, true, 5)
			end
			self.isPlaying = true
		end
end

--------------------------------
--SequencerPage-class, inherits Page
--------------------------------

SequencerPage = Page:new()

function SequencerPage:init()
	self.name = "SequencerPage"
	self.sheet = ""
	self.currentPosition = 0
	self.isPlaying = false
	self.timerTempo = 0
	self.currentTempo = 0.25
	self.timerPlayAnim = 0
	self.soundPlayed = false
	self.birdAnimationClockwise = true
	self.activatedItems = {}
	self.dragging = false
	self.birdStartDraggingX = 0
	self.maxTempo = false
	self.starAchieved = false
	
	self.barWidth, self.barHeight = _G.res.getSpriteBounds("", "SOUNDBOARD_4_BG")
	self.bfpw, bfph =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_FOOTPRINT")
	
	local sw, sh = _G.res.getSpriteBounds("INGAME_BIRDS_1", "BIRD_BIG_BROTHER")

	local phw1, phh1 =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_PIG_1")
	local phw2, phh2 =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_PIG_1")
	local phw3, phh3 =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_PIG_1")
	self.shw, self.shh =  _G.res.getSpriteBounds("", "SOUNDBOARD_4_HIGHLIGHT")
	
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", selectable = false, x = screenWidth/2, y = screenHeight/2, renderState = true, drawToScreenSize = true } ))
	self:insertItem("sequencerBG", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_BG", x = 0, y = screenHeight * 0.15, xs = screenWidth, selectable = false, renderState = true}))
	
	self:insertItem("sequencerHighlight", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_HIGHLIGHT", x = ((66 * screenWidth) / 960) + (((66 * screenWidth) / 960) * 1.82 * self.currentPosition)  , y = screenHeight * 0.15, xs = 1.0, selectable = false, renderState = true}))
	
	
	local grassW, grassH = _G.res.getSpriteBounds("", "SOUNDBOARD_4_GRASS_TOP")
	local grassAmount = 0
	if grassW ~= 0 then
		grassAmount = _G.math.floor(screenWidth / grassW)
	end
	
	for i = 0, grassAmount do
		self:insertItem("grassTop"..i, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_GRASS_TOP", x = i * grassW, y = screenHeight * 0.15, selectable = false}))
		self:insertItem("grassBottom"..i, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_GRASS_BOTTOM", x = i * grassW, y = screenHeight * 0.15 + ((166 * self.barHeight) / 166), selectable = false}))
	end
	
	for i = 0, 7 do
		self:insertItem("pigLineOne_"..i+1, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_PIG_1", spriteOn = "PIGLETTE_BIG_01", 
		spriteDefault = "SOUNDBOARD_4_PIG_1", spriteActive = "PIGLETTE_BIG_01_SMILE", spriteSleep = "PIGLETTE_BIG_01_BLINK", x = (i * screenWidth / 8) + ((23 * screenWidth) / 480) + ((10 * screenWidth) / 480), 
		y = (screenHeight * 0.15) + ((30 * self.barHeight) / 166) , selectable = true, renderState = true, xOns = 0.45 * phw1 / 42, yOns = 0.45 * phh1 / 44, xs = 1.0, ys = 1.0}))
		self:insertItem("pigLineTwo_"..i+1, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_PIG_2", spriteOn = "PIGLETTE_HELMET_01", 
		spriteDefault = "SOUNDBOARD_4_PIG_2", spriteActive = "PIGLETTE_HELMET_01_SMILE", spriteSleep = "PIGLETTE_HELMET_01_BLINK", x = (i * screenWidth / 8) + ((23 * screenWidth) / 480) + ((10 * screenWidth) / 480), 
		y = (screenHeight * 0.15) + (((30 * self.barHeight) / 166) + ((50 * self.barHeight) / 166)) , selectable = true, renderState = true, xOns = 0.5 * phw2 / 46, yOns = 0.5 * phh2 / 44, xs = 1.0, ys = 1.0}))
		self:insertItem("pigLineThree_"..i+1, SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_PIG_3", spriteOn = "PIGLETTE_GRANDPA_01", 
		spriteDefault = "SOUNDBOARD_4_PIG_3", spriteActive = "PIGLETTE_GRANDPA_04_SMILE", spriteSleep = "PIGLETTE_GRANDPA_01_BLINK", x = (i * screenWidth / 8) + ((23 * screenWidth) / 480) + ((10 * screenWidth) / 480), 
		y = (screenHeight * 0.15) + (((30 * self.barHeight) / 166) + ((100 * self.barHeight) / 166)) , selectable = true, renderState = true, xOns = 0.45 * phw3 / 49, yOns = 0.45 * phh3 / 46, xs = 1.0, ys = 1.0}))
	end
	
	self:insertItem("birdFootprints", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_FOOTPRINT", x = screenWidth / 2, y = screenHeight - (screenHeight * 0.16) + sh / 2.5, selectable = false}))
	self:insertItem("birdShadow", SpriteItem:new({ sheet = "", sprite = "SOUNDBOARD_4_SHADOW", x = screenWidth / 2, y = screenHeight - (screenHeight * 0.16) + sh / 2.5, selectable = false}))
	
	local birdScale = 1
	
	if screenWidth > 480 then
		birdScale = 1.5
	end
	
	self:insertItem("birdPlay", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_BIG_BROTHER_BLINK", spritePlay = "BIRD_BIG_BROTHER", 
	spritePressed = "BIRD_BIG_BROTHER_YELL", spriteDefault = "BIRD_BIG_BROTHER_BLINK", x = screenWidth / 2, y = screenHeight - (screenHeight * 0.16), renderState = true, 
	alwaysRender = true, angle = 0, pivotX = sw / 2, pivotY = sh, xs = birdScale, ys = birdScale} ))
	
	self:insertItem("back", SpriteItem:new( {sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight, selectable = false } ))
end

function SequencerPage:update(dt)	
	
	if keyHold["LBUTTON"] then
		self.activatedItems = self:getActivatedItems()
		if self.activatedItems then
			for k, v in _G.pairs(self.activatedItems) do
				if v == "birdPlay" then
					local birdX = cursor.x
					if ( _G.math.abs(self.birdStartDraggingX - cursor.x) > 10) then
						if birdX < (self.items.birdFootprints.x - self.bfpw / 2) then
							birdX = self.items.birdFootprints.x - self.bfpw / 2
						elseif birdX > (self.items.birdFootprints.x + self.bfpw / 2) then
							birdX = self.items.birdFootprints.x + self.bfpw / 2
							self.maxTempo = true
						else
							self.maxTempo = false
						end
						self.items.birdShadow.x = birdX
						self.dragging = true
						self.items["birdPlay"].x = birdX
						self.currentTempo = 0.0007 * (self.items.birdFootprints.x + self.bfpw -  birdX ) 
					else
						self.dragging = false
					end
				end
			end
		end
	end
	
	if keyPressed["LBUTTON"]  then
		self.birdStartDraggingX = cursor.x
		self.activatedItems = self:getActivatedItems()
		self.dragging = false
	end
	
	if keyReleased["LBUTTON"] and not(self.dragging)  then		
		if self.activatedItems then
			for k, v in _G.pairs(self.activatedItems) do
				if v == "birdPlay" then
					self.isPlaying = not(self.isPlaying)
					if self.isPlaying then
					-- Wait 1 second to play the bird animation
						self.items["birdPlay"].sprite = self.items["birdPlay"].spritePressed
						_G.res.playAudio(getAudioName("big_brother_special_1"), 1.0, false, 0)
					else
						--_G.res.playAudio(getAudioName("big_brother_flying"), 1.0, false, 0)
						self.items["birdPlay"].sprite = self.items["birdPlay"].spriteDefault
						self.items["birdPlay"].angle = 0
						self.timerTempo = 0
						self.timerPlayAnim = 0
						self.currentPosition = 0
						self.items["sequencerHighlight"].x = ((66 * screenWidth) / 960) + (((66 * screenWidth) / 960) * 1.82 * self.currentPosition)
						for i = 1, 8 do
							if(self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteOn) or (self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteActive) then
								self.items["pigLineOne_"..i].sprite = self.items["pigLineOne_"..i].spriteSleep
							end
							if(self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteOn) or (self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteActive) then
								self.items["pigLineTwo_"..i].sprite = self.items["pigLineTwo_"..i].spriteSleep
							end
							if(self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteOn) or (self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteActive) then
								self.items["pigLineThree_"..i].sprite = self.items["pigLineThree_"..i].spriteSleep
							end
						end
					end
				else
					if (self.items[v].sprite == self.items[v].spriteDefault) and self.isPlaying then
						self.items[v].xs = self.items[v].xOns
						self.items[v].ys = self.items[v].yOns
						self.items[v].sprite = self.items[v].spriteOn				
					elseif (self.items[v].sprite == self.items[v].spriteDefault) and not(self.isPlaying) then
						self.items[v].xs = self.items[v].xOns
						self.items[v].ys = self.items[v].yOns
						self.items[v].sprite = self.items[v].spriteSleep
					else
						self.items[v].xs = 1.0
						self.items[v].ys = 1.0
						self.items[v].sprite = self.items[v].spriteDefault
					end
				end
			end
		end
	
	end
	if self.isPlaying then
		for i = 1, 8 do
			if(self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteSleep) then
				self.items["pigLineOne_"..i].sprite = self.items["pigLineOne_"..i].spriteOn
			end
			if(self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteSleep) then
				self.items["pigLineTwo_"..i].sprite = self.items["pigLineTwo_"..i].spriteOn
			end
			if(self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteSleep) then
				self.items["pigLineThree_"..i].sprite = self.items["pigLineThree_"..i].spriteOn
			end
		end
		self.timerPlayAnim = self.timerPlayAnim + dt
		if self.timerPlayAnim < 2.0 then
			self.timerPlayAnim = self.timerPlayAnim + dt
			return
		end
		self.items["birdPlay"].sprite = self.items["birdPlay"].spritePlay
		self:play(dt)
		self:playBirdAnimation(dt)
		self:checkComplete()
	end
end

function SequencerPage:checkComplete()
	local levelComplete = true
	
	for i = 1, 8 do
		levelComplete = levelComplete and (self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteOn)
		levelComplete = levelComplete and (self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteOn)
		levelComplete = levelComplete and (self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteOn)
	end
	
	if levelComplete and not(self.starAchieved) and self.maxTempo then
		self.isPlaying = false
		self.starAchieved = true
		self.items["birdPlay"].sprite = self.items["birdPlay"].spriteDefault
		self.items["birdPlay"].angle = 0
		self.timerTempo = 0
		self.timerPlayAnim = 0
		self.currentPosition = 0
		self.items["sequencerHighlight"].x = ((66 * screenWidth) / 960) + (((66 * screenWidth) / 960) * 1.82 * self.currentPosition)
		for i = 1, 8 do
			if(self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteOn) or (self.items["pigLineOne_"..i].sprite == self.items["pigLineOne_"..i].spriteActive) then
				self.items["pigLineOne_"..i].sprite = self.items["pigLineOne_"..i].spriteSleep
			end
			if(self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteOn) or (self.items["pigLineTwo_"..i].sprite == self.items["pigLineTwo_"..i].spriteActive) then
				self.items["pigLineTwo_"..i].sprite = self.items["pigLineTwo_"..i].spriteSleep
			end
			if(self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteOn) or (self.items["pigLineThree_"..i].sprite == self.items["pigLineThree_"..i].spriteActive) then
				self.items["pigLineThree_"..i].sprite = self.items["pigLineThree_"..i].spriteSleep
			end
		end
		goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
	end
end

function SequencerPage:playBirdAnimation(dt)
	
	if self.birdAnimationClockwise then
		if self.items["birdPlay"].angle < 0.1 then
			self.items["birdPlay"].angle = self.items["birdPlay"].angle + dt / (self.currentTempo * 6 )
		else
			self.birdAnimationClockwise = false
		end
	else
		if self.items["birdPlay"].angle > -0.1 then
			self.items["birdPlay"].angle = self.items["birdPlay"].angle - dt / (self.currentTempo * 6)
		else
			self.birdAnimationClockwise = true
		end
	end
end

function SequencerPage:play(dt)
	self.soundPlayed = false
	-- Start the sequencer
	if not(self.soundPlayed) then
		if(self.items["pigLineOne_"..self.currentPosition+1].sprite == "PIGLETTE_BIG_01") then
			_G.res.playAudio(getAudioName("pig_hi-hat_"..((self.currentPosition+1) % 2)+1), 1.0, false, 0)
			self.items["pigLineOne_"..self.currentPosition+1].sprite = self.items["pigLineOne_"..self.currentPosition+1].spriteActive
			self.items["pigLineOne_"..self.currentPosition+1].xs = self.items["pigLineOne_"..self.currentPosition+1].xOns
		end
		if(self.items["pigLineTwo_"..self.currentPosition+1].sprite == "PIGLETTE_HELMET_01") then
			_G.res.playAudio(getAudioName("pig_snare_"..((self.currentPosition+1) % 4)+1), 1.0, false, 0)
			self.items["pigLineTwo_"..self.currentPosition+1].sprite = self.items["pigLineTwo_"..self.currentPosition+1].spriteActive
			self.items["pigLineTwo_"..self.currentPosition+1].xs = self.items["pigLineTwo_"..self.currentPosition+1].xOns
		end
		if(self.items["pigLineThree_"..self.currentPosition+1].sprite == "PIGLETTE_GRANDPA_01") then
			_G.res.playAudio(getAudioName("pig_bd"), 1.0, false, 0)			
			self.items["pigLineThree_"..self.currentPosition+1].sprite = self.items["pigLineThree_"..self.currentPosition+1].spriteActive
			self.items["pigLineThree_"..self.currentPosition+1].xs = self.items["pigLineThree_"..self.currentPosition+1].xOns
		end
		self.soundPlayed = true
	end
	
	self.timerTempo = self.timerTempo + dt
	if self.timerTempo >= self.currentTempo then
		self.timerTempo = 0
		self.soundPlayed = false
		
		if(self.items["pigLineOne_"..self.currentPosition+1].sprite == self.items["pigLineOne_"..self.currentPosition+1].spriteActive) then
			self.items["pigLineOne_"..self.currentPosition+1].sprite = self.items["pigLineOne_"..self.currentPosition+1].spriteOn
		end
		if(self.items["pigLineTwo_"..self.currentPosition+1].sprite == self.items["pigLineTwo_"..self.currentPosition+1].spriteActive) then
			self.items["pigLineTwo_"..self.currentPosition+1].sprite = self.items["pigLineTwo_"..self.currentPosition+1].spriteOn
		end
		if(self.items["pigLineThree_"..self.currentPosition+1].sprite == self.items["pigLineThree_"..self.currentPosition+1].spriteActive) then
			self.items["pigLineThree_"..self.currentPosition+1].sprite = self.items["pigLineThree_"..self.currentPosition+1].spriteOn
		end
		
		self.currentPosition = self.currentPosition + 1
		
		if self.currentPosition > 7 then
			self.currentPosition = 0
		end
		self.items["sequencerHighlight"].x = ((66 * screenWidth) / 960) + (((66 * screenWidth) / 960) * 1.82 * self.currentPosition)
	end
end

--------------------------------
--KeyboardPage-class, inherits Page
--------------------------------

KeyboardPage = Page:new()

function KeyboardPage:init()
	self.name = "Keyboardpage"
	self.sheet = ""
	self.notesPlayed = ""
	self.notes = { C = {}, Cis = {}, D = {}, dis = {}, E = {}, F = {}, Fis = {}, G = {} }
	for k, v in _G.pairs(self.notes) do
		v.pressed = false
		v.playIDs = {nil, nil, nil}
		v.playCounter = 0
	end
	
	self.rightMelody = "CDdisCG"
	self.wholeMelody = "CDdCGGGFddDC"
	self.melodyPauses = { 0.5, 0.1875, 0.1875, 0.375, 0.375, 0.6, 0.375, 0.15, 0.225, 0.375, 0.15, 0.225 }
	self.melodyIndex = 1
	self.currentSound = "noteG"
	self.starCollected = settings.openGoldenEggLevels["Level" .. currentLevelNumberInTheme] == 2
	self.sessionStarCollected = false
	self.playMelody = false
	
	local boundingBoxWidth = screenWidth
	local boundingBoxHeight = screenHeight
	self.scale = screenHeight / 320
	
	if self.scale > 1.4 then
		self.scale = 1.4
	end
	
	if boundingBoxWidth > 640 then
		boundingBoxWidth = 640
	end
	
	if boundingBoxHeight > 480 then
		boundingBoxHeight = 480
	end
	
	local CY, CisY, DY, DisY, EY, FY, FisY, GY = 221 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2),
												132 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2),
												218 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2),
												132 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2),
												218 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2),
												215 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2),
												134 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2),
												222 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2)
	
	local rbW, rbH = _G.res.getSpriteBounds("INGAME_BIRDS_1","BIRD_RED")
	local bbW, bbH = _G.res.getSpriteBounds("INGAME_BIRDS_1","BIRD_BLUE")
	local ybW, ybH = _G.res.getSpriteBounds("INGAME_BIRDS_1","BIRD_YELLOW")
	local gbW, gbH = _G.res.getSpriteBounds("INGAME_BIRDS_1","BIRD_GREY")
	local pbW, pbH = _G.res.getSpriteBounds("INGAME_BIRDS_1","BIRD_BOOMERANG")
	local wbW, wbH = _G.res.getSpriteBounds("INGAME_BIRDS_1","BIRD_GREEN")
	
	self:insertItem("background", SpriteItem:new( { sheet = "", sprite = "GOLDEN_EGG_BG_1", selectable = false, x = screenWidth/2, y = screenHeight/2, renderState = true, drawToScreenSize = true } ))
	self:insertItem("shadow1", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 72 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = CisY + gbH / 2.75 * self.scale, selectable = false, xs = scale, ys = scale, renderState = true} ))
	self:insertItem("shadow2", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 168 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = DisY + gbH / 2.75 * self.scale, selectable = false, selectable = false, xs = self.scale, ys = self.scale, renderState = true } ))
	self:insertItem("shadow3", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 390 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = FisY + gbH / 2.75 * self.scale, selectable = false, selectable = false, xs = self.scale, ys = self.scale, renderState = true } ))
	self:insertItem("shadow4", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 41 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = CY + bbH / 2.75 * self.scale, selectable = false, renderState = true, xs = 0.5 * self.scale, ys = 0.5 * self.scale} ))
	self:insertItem("shadow5", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 122 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = DY + rbH / 2.75 * self.scale, selectable = false, renderState = true, xs = 0.65 * self.scale, ys = 0.65 * self.scale} ))
	self:insertItem("shadow6", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 212 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = EY + ybH / 2.75 * self.scale, selectable = false, renderState = true, xs = 0.9 * self.scale, ys = 0.9 * self.scale} ))
	self:insertItem("shadow7", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 315 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = FY + wbH / 2.75 * self.scale, selectable = false, selectable = false, xs = self.scale, ys = self.scale, renderState = true } ))
	self:insertItem("shadow8", SpriteItem:new( { sprite = "SOUNDBOARD_3_SHADOW", x = 420 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = GY + pbH / 2.5 * self.scale, selectable = false, renderState = true, xs = 0.85 * self.scale, ys = 0.85 * self.scale} ))
	self:insertItem("C", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_BLUE", sprite2 = "BIRD_BLUE_YELL", defaultSprite = "BIRD_BLUE", x = 39 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = CY, defaultY = 221 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = self.scale, ys = self.scale} ))
	self:insertItem("Cis", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_GREY", sprite2 = "BIRD_GREY_YELL", defaultSprite = "BIRD_GREY", x = 72 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = CisY, defaultY = 132 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = self.scale, ys = self.scale} ))
	self:insertItem("D", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_RED", sprite2 = "BIRD_RED_YELL", defaultSprite = "BIRD_RED", x = 123 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = DY, defaultY = 218 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = self.scale, ys = self.scale}))
	self:insertItem("dis", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_GREY_BLINK", sprite2 = "BIRD_GREY_YELL", defaultSprite = "BIRD_GREY_BLINK", x = 168 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = DisY, defaultY = 132 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = self.scale, ys = self.scale} ))
	self:insertItem("E", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_YELLOW", sprite2 = "BIRD_YELLOW_YELL", defaultSprite = "BIRD_YELLOW", x = 212 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = EY, defaultY = 218 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = self.scale, ys = self.scale} ))
	self:insertItem("F", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_GREEN", sprite2 = "BIRD_GREEN_YELL", defaultSprite = "BIRD_GREEN", x = 315 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = FY, defaultY = 215 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = self.scale, ys = self.scale} ))
	self:insertItem("Fis", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_GREY_FLYING", sprite2 = "BIRD_GREY_YELL", defaultSprite = "BIRD_GREY_FLYING", x = 392 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = FisY, defaultY = 134 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = self.scale, ys = self.scale} ))
	self:insertItem("G", SpriteItem:new( { sheet = "INGAME_BIRDS_1", sprite = "BIRD_BOOMERANG", sprite2 = "BIRD_BOOMERANG_YELL", defaultSprite = "BIRD_BOOMERANG", x = 434 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), y = GY, defaultY = 222 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = self.scale, ys = self.scale} ))
	
	self.items.C.clickArea = {xLeft = 10 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), xRight = 70 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), yBot = 241 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), yTop = 185 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = scale, ys = scale}
	self.items.D.clickArea = {xLeft = 77 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), xRight = 160 * (boundingBoxWidth / 480) + ((screenWidth - boundingBoxWidth) / 2), yBot = 250 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), yTop = 175 * (boundingBoxHeight / 320)+ ((screenHeight - boundingBoxHeight) / 2), renderState = true, xs = scale, ys = scale}

	
	self:insertItem("back", SpriteItem:new( {sheet = "BUTTONS_SHEET_1", sprite = "LS_BACK_BUTTON", y = screenHeight, selectable = false } ))
end


function KeyboardPage:update(dt)
	
	if self.playMelody then
		return self:play(dt)
	end
	
	if popupPage then
		return
	end
	
	if not settings.audioEnabled then
		_G.res.stopAllAudio()
	end
	
	for k, v in _G.pairs(self.notes) do
		for i = 1, 3 do
			if self.notes[k].playIDs[i] ~= nil and not _G.res.isAudioPlaying(self.notes[k].playIDs[i]) then
				self.notes[k].playIDs[i] = nil
				self.notes[k].playCounter = self.notes[k].playCounter - 1
			end
		end
	end
	
	local restore = false
	if touchcount >= 1 then
		-- Touches need to be checked with default bird sprites or sound might loop with
		-- certain cursor positions.
		local keysWithYellSprite = {}
		local tmpYs
		for k, v in _G.pairs(self.items) do
			if v.defaultSprite and v.sprite ~= v.defaultSprite then
				_G.table.insert(keysWithYellSprite, {key = k, y = v.y})
				v.sprite, v.sprite2 = v.sprite2, v.sprite
				v.y = v.defaultY
				if v.alwaysRender then
					tmpYs = v.ys
					v.ys = v.defaultYs
				end
			end
		end
		local activatedItems = self:getActivatedItems()
		-- Restore yell sprites.
		for k, v in _G.pairs(keysWithYellSprite) do
			local _, h = _G.res.getSpriteBounds(self.items[v.key].sheet, self.items[v.key].sprite)
			self.items[v.key].sprite, self.items[v.key].sprite2 = self.items[v.key].sprite2, self.items[v.key].sprite
			self.items[v.key].y = v.y
			if self.items[v.key].alwaysRender then
				self.items[v.key].ys = tmpYs	
			end
		end
	
		if activatedItems then
			for k, v in _G.pairs(activatedItems) do
				self.notes[v].activated = true
			end
			
			for key, value in _G.pairs(self.notes) do	
				if value.pressed and not value.activated then
					self:restoreKey(key)
				end
				local sound = "note" .. key
				if not value.pressed and value.activated then 
					if self.notes[key].playCounter <= 3 then
						self:pressKey(key)
						local c = _G.res.playAudio(sound, 1.0, false, 0)
						for i = 1, 3 do
							if self.notes[key].playIDs[i] == nil then
								self.notes[key].playIDs[i] = c
								self.notes[key].playCounter = self.notes[key].playCounter + 1
								break
							end
						end
						if not self.sessionStarCollected then
							self.notesPlayed = self.notesPlayed .. key	
						end	
					end
				end
				value.activated = false 
			end
		else
			restore = true
		end
	else
		restore = true
	end

	if restore then
		for k, v in _G.pairs(self.notes) do
			self:restoreKey(k)
		end
	end

	if _G.string.sub(self.rightMelody, 1, #self.notesPlayed) ~= self.notesPlayed then
		-- Check if new correct melody was started.
		if _G.string.sub(self.notesPlayed, #self.notesPlayed) == "C" then
			self.notesPlayed = "C"
		elseif _G.string.sub(self.notesPlayed, #self.notesPlayed - 1, #self.notesPlayed) == "CD" then
			self.notesPlayed = "CD"
		else
			self.notesPlayed = ""
		end
	elseif self.notesPlayed == self.rightMelody then
		self.notesPlayed = ""
		self.playMelody = true
	end
	
end

function KeyboardPage:play(dt)
	self.melodyPauses[self.melodyIndex] = self.melodyPauses[self.melodyIndex] - dt
	if self.melodyPauses[self.melodyIndex] > 0 then
		return
	else
		self:restoreKey(_G.string.sub(self.currentSound, 5, #self.currentSound))
		local key = _G.string.sub(self.wholeMelody, self.melodyIndex, self.melodyIndex)
		if key == "d" then
			key = key .. "is"
		end	
		self:pressKey(key)
		self.currentSound = "note" .. key
		_G.res.playAudio(self.currentSound, 1.0, false, 0)
		self.melodyIndex = self.melodyIndex + 1
		
		if self.melodyIndex > #self.wholeMelody then
			self.playMelody = false
			goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
			self.sessionStarCollected = true
		end
	end
end

function KeyboardPage:restoreKey(k)
	if self.notes[k].pressed then
		self.items[k].ys = self.scale
		self.items[k].y = self.items[k].defaultY
		if not self.items[k].alwaysRender then
			--self.items[k].renderState = false
		end
		if self.items[k].sprite ~= self.items[k].defaultSprite then
			self.items[k].sprite, self.items[k].sprite2 = self.items[k].sprite2, self.items[k].sprite
		end
		self.notes[k].pressed = false
	end
end

function KeyboardPage:pressKey(key)
	self.notes[key].pressed = true
	local item = self.items[key] 
	item.renderState = true
	local _, h = _G.res.getSpriteBounds(item.sheet, item.sprite)
	if item.alwaysRender and item.defaultYs then
		item.ys = item.ys * 0.85 * self.scale
		item.y = _G.math.floor(item.y + ((h * item.defaultYs - (h * item.ys)) / 2))
	else
		item.ys = 0.85 * self.scale
		item.y = _G.math.floor(item.y + ((h - (h * 0.85)) / 2))
	end
	self.items[key].sprite, self.items[key].sprite2 = self.items[key].sprite2, self.items[key].sprite
end


----------------

function getItemByName(items, name)
	
	for i = 1, #items do
		if items[i].name == name then
			return items[i], i
		elseif items[i].children ~= nil then
			for j = 1, #items[i].children do
				if items[i].children[j].name == name then
					return items[i].children[j], i, j
				end
			end
		end
	end
	
end

function updatePictureLevel(dt)
	
	if currentPictureLevel == "PIGGY" then
		piggyPage:update(dt)
		piggyPage:draw()
	elseif currentPictureLevel == "MIGHTY_EAGLE" then
		eaglePage:update(dt)
		eaglePage:draw()
	end
	
end


function drawPictureLevel(page)
	
	for i, v in _G.ipairs(page.items) do
		
		local xCoord = v.x or 0
		local yCoord = v.y or 0
		local sheet = v.sheet or page.defaultSheet or ""
	
		if v.name == "wheel" then
			local w, h = _G.res.getSpriteBounds(sheet, v.sprite)
			setRenderState(0, 0, 1, 1, v.angle, w / 2, h / 2)
			_G.res.drawSprite(sheet, v.sprite, xCoord, yCoord)
			setRenderState(0, 0, 1, 1, 0)
		elseif v.name == "bird" then
			local tmpWidth, tmpHeight = _G.res.getSpriteBounds(sheet, v.sprite)
			setRenderState(0, 0, 1, 1, v.angle, tmpWidth / 2, tmpHeight)
			_G.res.drawSprite(sheet, v.sprite, xCoord, yCoord)
			setRenderState(0, 0, 1, 1, 0)
		else
			if i == 1 then -- background
				_G.res.drawSprite(sheet, v.sprite, xCoord - screenWidth / 2, yCoord - screenHeight / 2, "TOP", "LEFT", screenWidth, screenHeight)
			else
				_G.res.drawSprite(sheet, v.sprite, xCoord, yCoord)
			end
		end
	end
	_G.res.drawSprite("BUTTONS_SHEET_1", "LS_BACK_BUTTON", 0, screenHeight)

end


function initSoundboard()
	_G.res.stopAudio(currentMainMenuSong)
	
	if currentSoundboard == "KEYBOARD" then
		keyboardPage = KeyboardPage:new()
		--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level12"] .. "\n")
		logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level12"]) 
	elseif currentSoundboard == "SEQUENCER" then
		sequencerPage = SequencerPage:new()	
		setGameOn(true) -- disable screen saver
	elseif currentSoundboard == "ACCORDION" then
		accordionPage = AccordionPage:new()	
		setGameOn(true) -- disable screen saver
	elseif currentSoundboard == "SOUNDBOARD1" then
		soundPage = { starEffect = false, 
				  starTimer = 0,
				  starAngle = 0,
				  items = {}
				}
		soundPage.state = 0
		soundPage.currentBird = 0
		soundPage.starState = 0
		soundPage.buttonPressTimes = {}
		soundPage.sessionStarCollected = false
		
		for i = 1, 16 do
			soundPage.buttonPressTimes[i] = 0
		end
		
		local boundingBox = { maxWidth = 1024, maxHeight = 768, left = 0, top = 0, width = screenWidth, height = screenHeight }
		
		if screenWidth > boundingBox.maxWidth then
			boundingBox.left = (screenWidth / 2) - (boundingBox.maxWidth / 2)
			boundingBox.width = boundingBox.maxWidth
		end
		
		if screenHeight > boundingBox.maxHeight then
			boundingBox.top = (screenHeight / 2) - (boundingBox.maxHeight / 2)
			boundingBox.height = boundingBox.maxHeight
		end
		
		
		_G.table.insert(soundPage.items, { sheet = "", sprite = "GOLDEN_EGG_BG_2", x = screenWidth / 2, y = screenHeight / 2})
		soundPage.defaultSheet = ""
		
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_BLOCK_ICE", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.89), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.50625)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_BLOCK_WOOD", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.78), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.5075)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_BLOCK_STONE", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.67), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.5049)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_TNT", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.52), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.5)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_SLINGSHOT", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.34), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.5)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_PIG_KING", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.89), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.82)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_PIG_OLD", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.68), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.82)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_PIG_HELMET", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.48), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.85)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_PIG_SMALL", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.305), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.88)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_LEVEL_FAIL", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.17), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.6460)})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_1_LEVEL_START", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.15), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.34)})
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_WHITE", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.89), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.1837) })
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_BLACK", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.7), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.1807) })
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_YELLOW", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.52), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.16107) })
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_RED", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.36), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.1415) })
		_G.table.insert(soundPage.items, { sprite = "SOUNDBOARD_1_BIRD_BLUE", x = _G.math.floor(boundingBox.left + boundingBox.width * 0.23), y = _G.math.floor(boundingBox.top + boundingBox.height * 0.13) })
		
		--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level4"] .. "\n")
		logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level4"]) 
				
	elseif currentSoundboard == "RADIO" then
		soundPage = { starEffect = false, 
				  starTimer = 0,
				  starAngle = 0,
				  items = {}
				}
		
		soundPage.dragStartCursorX = 0
		soundPage.dragTouchId = -1
		soundPage.dragging = false
		soundPage.animating = false
		soundPage.animatingTo = 0
		soundPage.delayedButtonSound = false
		soundPage.birdDanceY = 0
		soundPage.dragAngle = 0
		soundPage.musicPlaying = false
		soundPage.musicStartedWhenMuted = false
		soundPage.sessionStarCollected = false
		soundPage.buttonPressed = false
		soundPage.oldSwitches = {}
		soundPage.radioSwitches = {0, 0, 0, 0}
		soundPage.wheelDivider = 23 * (screenHeight / 320)
	
		soundPage.defaultSheet = ""
		_G.table.insert(soundPage.items, {sheet = "", sprite = "GOLDEN_EGG_BG_1", x = screenWidth / 2, y = screenHeight / 2})
		_G.table.insert(soundPage.items, {name = "radio", sprite = "SOUNDBOARD_2_RADIO", x = screenWidth / 2, y = screenHeight / 2})
		
		local rx, ry = _G.res.getSpritePivot("", "SOUNDBOARD_2_RADIO")
		local sw, sh = _G.res.getSpriteBounds("", "SOUNDBOARD_2_RADIO")
		local radioLeft = -rx + getItemByName(soundPage.items, "radio").x
		local radioTop = -ry + getItemByName(soundPage.items, "radio").y
		
		_G.table.insert(soundPage.items, {name = "birdShadow", sprite = "SOUNDBOARD_2_BIRD_SHADOW", x = screenWidth / 2, y = screenHeight / 2})
		_G.table.insert(soundPage.items, {name = "wheel", sprite = "SOUNDBOARD_2_WHEEL", x = screenWidth / 2, y = screenHeight / 2, angle = 0})
		_G.table.insert(soundPage.items, {sprite = "SOUNDBOARD_2_LCD", x = screenWidth / 2, y = screenHeight / 2})
		_G.table.insert(soundPage.items, {name = "indicator", sprite = "SOUNDBOARD_2_INDICATOR", x = radioLeft + (sw * 0.383), y = radioTop + (sh * 0.42)})	
		for i = 1, 4 do
			_G.table.insert(soundPage.items, {name = "preset" .. i, sprite = "SOUNDBOARD_2_BUTTON_DOWN_" .. i, x = screenWidth / 2, y = screenHeight / 2})
		end
		_G.table.insert(soundPage.items, {name = "bird", sprite = "SOUNDBOARD_2_BIRD",  angle = 0})
		local bird = getItemByName(soundPage.items, "bird")
		local birdShadow = getItemByName(soundPage.items, "birdShadow")
		local bw, bh = _G.res.getSpriteBounds("", bird.sprite)
		local bsw, bsh = _G.res.getSpriteBounds("", birdShadow.sprite)
		bird.x = radioLeft + sw - bw / 2.5
		bird.y = radioTop + sh - bh / 2.5
		
		
		birdShadow.x = radioLeft + sw - bw / 2.5
		birdShadow.y = radioTop + sh + bsh / 2
		
		soundPage.indicatorX, soundPage.indicatorY = getItemByName(soundPage.items, "indicator").x, getItemByName(soundPage.items, "indicator").y
		soundPage.birdOriginalY = getItemByName(soundPage.items, "bird").y
		soundPage.presetCoords = { radioLeft + (sw * 0.383), radioLeft + (sw * 0.522), radioLeft + (sw * 0.667), radioLeft + (sw * 0.806), radioLeft + (sw * 0.736) }
		soundPage.defaultMultiplier = 300 * (sw / 599)	
		--print("FlurryEventWithParam: Golden egg level started, param: Level, paramValue: " .. goldenEggLevelMapping["Level7"] .. "\n")
		logFlurryEventWithParam("Golden egg level started", "Level", "" .. goldenEggLevelMapping["Level7"]) 
	
		setGameOn(true) -- disable screen saver
	end

end

function cursorOnSoundboardSprite(item)
	local px,py = _G.res.getSpritePivot("", item.sprite)
	local w, h = _G.res.getSpriteBounds("", item.sprite)
		
	return cursor.x > item.x - px and cursor.x < item.x - px + w and cursor.y > item.y - py and cursor.y < item.y - py + h	
end

function touchOnSoundboardSprite(sheet, sprite, touchid, x, y)
	local px,py = _G.res.getSpritePivot(sheet, sprite)
	local w, h = _G.res.getSpriteBounds(sheet, sprite)
	
	return touches[touchid].y >= ((screenHeight / 2) - py) and touches[touchid].y <= ((screenHeight / 2) - py + h)
		and touches[touchid].x >= ((screenWidth / 2) - px) and touches[touchid].x <= ((screenWidth / 2) - px + w)
	

	--return touches[touchid].x > -px and touches[touchid].x < -px + w and touches[touchid].y > -py and touches[touchid].y < -py + h
	
end

function drawSoundboardButton(sheet, sprite, pressed, x, y)
	
	local scale = 1
	if pressed == true then
		scale = 1.1
		setRenderState(0, 0, scale, scale, 0)
		local w, h = _G.res.getSpriteBounds(sheet, sprite)
		local px, py = _G.res.getSpritePivot(sheet, sprite)
		x = (x / scale) + (px - (w / 2)) * (1 - (1 / scale))
		y = (y / scale) + (py - (h / 2)) * (1 - (1 / scale))
	end
	
	_G.res.drawSprite(sheet, sprite, _G.math.floor(x), _G.math.floor(y))
	if pressed == true then
		setRenderState(0, 0, 1, 1, 0)
	end
end

function updateSoundboard(dt)
	
	if oldScreenWidth ~= screenWidth or oldScreenHeight ~= screenHeight then
		oldScreenWidth = screenWidth
		oldScreenHeight = screenHeight
		initSoundboard()
	end
	
	if popupPage ~= nil then
		updateMenuPage(popupPage, dt)
	end
	
	if currentSoundboard == "KEYBOARD" then
		keyboardPage:update(dt)
		keyboardPage:draw()
	elseif currentSoundboard == "SEQUENCER" then
		sequencerPage:update(dt)
		sequencerPage:draw()
	elseif currentSoundboard == "ACCORDION" then
		accordionPage:update(dt)
		accordionPage:draw()
	elseif currentSoundboard == "SOUNDBOARD1" then
		
		if keyPressed["LBUTTON"] and soundPage.starEffect == false and popupPage == nil then
			
			-- ice block
			if cursorOnSoundboardSprite(soundPage.items[2]) then
				soundPage.buttonPressTimes[1] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("light_destroyed"), 1.0, false, 0)
				else
					_G.res.playAudio(getAudioName("light_collision"), 1.0, false, 0)
					soundPage.starState = 0
					soundPage.state = 0
				end
			
			-- wood block
			elseif cursorOnSoundboardSprite(soundPage.items[3]) then
				soundPage.buttonPressTimes[2] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("wood_destroyed"), 1.0, false, 0)
				else
					_G.res.playAudio(getAudioName("wood_collision"), 1.0, false, 0)
					soundPage.starState = 0
					soundPage.state = 0
				end
			
			-- stone block
			elseif cursorOnSoundboardSprite(soundPage.items[4]) then
				soundPage.buttonPressTimes[3] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("rock_destroyed"), 1.0, false, 0)
				else
					_G.res.playAudio(getAudioName("rock_collision"), 1.0, false, 0)
					soundPage.starState = 0
					soundPage.state = 0
				end
			
			-- tnt box
			elseif cursorOnSoundboardSprite(soundPage.items[5]) then
				soundPage.buttonPressTimes[4] = time
				_G.res.playAudio(getAudioName("tnt_explodes"), 1.0, false, 0)
			
			-- slingshot
			elseif cursorOnSoundboardSprite(soundPage.items[6]) then
				soundPage.buttonPressTimes[5] = time
				soundPage.state = 1
				_G.res.playAudio(getAudioName("slingshot_stretched"), 1.0, false, 0)
				if soundPage.starState == 1 then
					soundPage.starState = 2
				else
					soundPage.starState = 0
				end
			
			-- king pig
			elseif cursorOnSoundboardSprite(soundPage.items[7]) then
				soundPage.buttonPressTimes[6] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("piglette_destroyed"), 1.0, false, 0)
					if soundPage.starState == 3 then
						soundPage.starState = 4
						soundPage.state = 0
					else
						soundPage.state = 0
						soundPage.starState = 0
					end
				else
					_G.res.playAudio(getAudioName("piglette"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
				end
				
			-- old pig
			elseif cursorOnSoundboardSprite(soundPage.items[8]) then
				soundPage.buttonPressTimes[7] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("piglette_destroyed"), 1.0, false, 0)
					if soundPage.starState == 3 then
						soundPage.starState = 4
						soundPage.state = 0
					else
						soundPage.state = 0
						soundPage.starState = 0
					end
				else
					_G.res.playAudio(getAudioName("piglette"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
				end
			
			-- helmet pig
			elseif cursorOnSoundboardSprite(soundPage.items[9]) then
				soundPage.buttonPressTimes[8] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("piglette_destroyed"), 1.0, false, 0)
					if soundPage.starState == 3 then
						soundPage.starState = 4
						soundPage.state = 0
					else
						soundPage.state = 0
						soundPage.starState = 0
					end
				else
					_G.res.playAudio(getAudioName("piglette"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
				end
			
			-- small pig
			elseif cursorOnSoundboardSprite(soundPage.items[10]) then
				soundPage.buttonPressTimes[9] = time
				if soundPage.state >= 2 then
					_G.res.playAudio(getAudioName("piglette_destroyed"), 1.0, false, 0)
					if soundPage.starState == 3 then
						soundPage.starState = 4
						soundPage.state = 0
					else
						soundPage.state = 0
						soundPage.starState = 0
					end
				else
					_G.res.playAudio(getAudioName("piglette"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
				end
			
			-- level fail
			elseif cursorOnSoundboardSprite(soundPage.items[11]) then
				soundPage.buttonPressTimes[10] = time
				for i = 1, #audioGroups["level_failed_piglets"] do
					if _G.res.isAudioPlaying(audioGroups["level_failed_piglets"][i]) then
						_G.res.stopAudio(audioGroups["level_failed_piglets"][i])
					end
				end				 
				_G.res.playAudio(getAudioName("level_failed_piglets"), 1.0, false, 0)
				soundPage.state = 0
				soundPage.starState = 0
			
			-- level start
			elseif cursorOnSoundboardSprite(soundPage.items[12]) then
				soundPage.buttonPressTimes[11] = time
				for i = 1, #audioGroups["level_start_military"] do
					if _G.res.isAudioPlaying(audioGroups["level_start_military"][i]) then
						_G.res.stopAudio(audioGroups["level_start_military"][i])
					end
				end
				_G.res.playAudio(getAudioName("level_start_military"), 1.0, false, 0)
				soundPage.state = 0
				soundPage.starState = 1
			
			-- white bird
			elseif cursorOnSoundboardSprite(soundPage.items[13]) then
				soundPage.buttonPressTimes[12] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_05_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 1
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 1 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("special_egg"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_05_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			
			-- black bird
			elseif cursorOnSoundboardSprite(soundPage.items[14]) then
				soundPage.buttonPressTimes[13] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_04_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 2
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 2 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("special_explosion"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_04_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			
			-- yellow bird
			elseif cursorOnSoundboardSprite(soundPage.items[15]) then
				soundPage.buttonPressTimes[14] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_03_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 3
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 3 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("special_boost"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_03_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			
			-- red bird
			elseif cursorOnSoundboardSprite(soundPage.items[16]) then
				soundPage.buttonPressTimes[15] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_01_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 4
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 4 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("red_special"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_01_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			
			-- blue bird
			elseif cursorOnSoundboardSprite(soundPage.items[17]) then
				soundPage.buttonPressTimes[16] = time
				if soundPage.state == 1 then
					_G.res.playAudio(getAudioName("bird_02_flying"), 1.0, false, 0)
					soundPage.state = 2
					if soundPage.starState == 2 then
						soundPage.starState = 3
					else
						soundPage.starState = 0
					end
					soundPage.currentBird = 5
				elseif soundPage.state >= 2 then
					if soundPage.currentBird == 5 then
						if soundPage.state == 2 then
							_G.res.playAudio(getAudioName("special_group"), 1.0, false, 0)
							soundPage.state = 3
						else
							_G.res.playAudio(getAudioName("bird_02_collision"), 1.0, false, 0)
						end
					else
						_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
						soundPage.state = 0
						soundPage.starState = 0
						soundPage.currentBird = 0
					end
				else
					_G.res.playAudio(getAudioName("bird_misc"), 1.0, false, 0)
					soundPage.state = 0
					soundPage.starState = 0
					soundPage.currentBird = 0
				end
			end
			
			if soundPage.starState == 4 then
				soundPage.state = 0
				soundPage.starState = 0
				soundPage.currentBird = 0
				if not soundPage.sessionStarCollected then
					goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
					soundPage.sessionStarCollected = true
				end
			end
		end
		
		
	
		for i = 1, #soundPage.items do
			local sheet = soundPage.items[i].sheet or soundPage.defaultSheet
			if i >= 2 then
				drawSoundboardButton(sheet, soundPage.items[i].sprite, time - soundPage.buttonPressTimes[i - 1] < 0.2, soundPage.items[i].x, soundPage.items[i].y)
			else
				_G.res.drawSprite(sheet, soundPage.items[i].sprite, soundPage.items[i].x - screenWidth / 2, soundPage.items[i].y - screenHeight / 2,  "LEFT", "TOP", screenWidth, screenHeight)
			end
		end
		_G.res.drawSprite("BUTTONS_SHEET_1", "LS_BACK_BUTTON", 0, screenHeight)

		
	elseif currentSoundboard == "RADIO" then
	
		local tmpDeltaAngle = 0			
		if popupPage == nil then
			
			if touchcount == 2 or keyPressed["C"] then
		
				local tmpSwitches = {0, 0, 0, 0}
				
				for k, v in _G.pairs(touches) do
					for i = 1, 4 do
						if touchOnSoundboardSprite(soundPage.defaultSheet, "SOUNDBOARD_2_BUTTON_UP_" .. i, k) then
							tmpSwitches[i] = 1
						end
					end
				end
		
				if keyPressed["C"] then
					tmpSwitches = {1, 0, 1, 0}
				end
				
				for k, v in _G.pairs(tmpSwitches) do
					if soundPage.oldSwitches[k] ~= v then
						soundPage.buttonPressed = false
					end
					soundPage.oldSwitches[k] = v
				end
				
				local switchesDown = 0
				for i = 1, 4 do
					switchesDown = switchesDown + tmpSwitches[i]
				end
						
				if switchesDown == 2 then
					soundPage.radioSwitches = tmpSwitches
					if soundPage.upcomingTune ~= "funky_theme" then
						if soundPage.buttonPressed ~= true then
							_G.res.stopAllAudio()
							_G.res.playAudio("button_radio", 0.8, false)					
						end
						prepareRadioAnimation(soundPage.presetCoords[5], 0)
					end
					soundPage.dragTouchId = -1

					soundPage.buttonPressed = true
				end
			elseif keyPressed["LBUTTON"] then

				for i = 1, 4 do
					local itm = getItemByName(soundPage.items, "preset" .. i)
					itm.sprite = "SOUNDBOARD_2_BUTTON_UP_" .. i
					if soundPage.radioSwitches[i] == 0 and cursorOnSoundboardSprite(itm) then
						soundPage.radioSwitches = {0, 0, 0, 0}
						soundPage.radioSwitches[i] = 1	
						_G.res.stopAllAudio()
						_G.res.playAudio("button_radio", 1, false)
						soundPage.delayedButtonSound = false
						prepareRadioAnimation(soundPage.presetCoords[i], i)
						soundPage.buttonPressed = false
					end
				end			
				local px, py = _G.res.getSpritePivot(soundPage.defaultSheet, getItemByName(soundPage.items, "wheel").sprite)
				local w, h = _G.res.getSpriteBounds(soundPage.defaultSheet, getItemByName(soundPage.items, "wheel").sprite)
				local tmpDist = distance(-px + getItemByName(soundPage.items, "wheel").x + (w / 2), -py + getItemByName(soundPage.items, "wheel").y + (h / 2), cursor.x, cursor.y)
				
				if tmpDist < w * 2 then
					soundPage.dragAngle = _G.math.atan2((-py + getItemByName(soundPage.items, "wheel").y + (h / 2)- cursor.y), (-px + getItemByName(soundPage.items, "wheel").x + (w / 2) - cursor.x))
					soundPage.dragging = true
					soundPage.buttonPressed = false
				end
						
			elseif soundPage.dragging and keyHold["LBUTTON"] and touchcount == 1 then
				local px, py = _G.res.getSpritePivot(soundPage.defaultSheet, getItemByName(soundPage.items, "wheel").sprite)			
				local w, h = _G.res.getSpriteBounds(soundPage.defaultSheet, getItemByName(soundPage.items, "wheel").sprite)
				local tmpDist = distance(-px + getItemByName(soundPage.items, "wheel").x + (w / 2), -py + getItemByName(soundPage.items, "wheel").y + (h / 2), cursor.x, cursor.y)
				
				
				if tmpDist > w / 3 then 
					
					local tmpAngle = _G.math.atan2((-py + getItemByName(soundPage.items, "wheel").y  + (h / 2) - cursor.y), (-px + getItemByName(soundPage.items, "wheel").x + (w / 2) - cursor.x))
					if soundPage.dragAngle ~= nil then
						tmpDeltaAngle = tmpAngle - soundPage.dragAngle
						if tmpDeltaAngle >= _G.math.pi * 3/2 then
							tmpDeltaAngle = tmpDeltaAngle - _G.math.pi * 2
						elseif tmpDeltaAngle <= -_G.math.pi * 3/2 then
							tmpDeltaAngle = tmpDeltaAngle + _G.math.pi * 2
						end
						if _G.math.abs(tmpDeltaAngle) > 0 and soundPage.musicPlaying then
							_G.res.stopAllAudio()
							soundPage.musicPlaying = false
						end
						if _G.math.abs(tmpDeltaAngle) < _G.math.pi / 2 then
							soundPage.indicatorX = soundPage.indicatorX + tmpDeltaAngle * 12
							if soundPage.indicatorX < soundPage.presetCoords[1] then
								tmpDeltaAngle = 0
								soundPage.indicatorX = soundPage.presetCoords[1]
							elseif soundPage.indicatorX > soundPage.presetCoords[4] then
								tmpDeltaAngle = 0
								soundPage.indicatorX = soundPage.presetCoords[4]
							end
							getItemByName(soundPage.items, "wheel").angle = getItemByName(soundPage.items, "wheel").angle + tmpDeltaAngle
						end
					end
					soundPage.dragAngle = tmpAngle
				elseif tmpDist <= w / 2 then
					soundPage.dragAngle = nil
				end
		
			elseif keyReleased["LBUTTON"] and soundPage.dragging then	
				local shortDist, shortDistIndex = screenWidth, 0
				for i = 1, #soundPage.presetCoords do
					local tmpDist = _G.math.abs(soundPage.indicatorX - soundPage.presetCoords[i])
					if tmpDist < shortDist then
						shortDist = tmpDist
						shortDistIndex = i
					end
				end
							
				for i = 0, #soundPage.radioSwitches do
					soundPage.radioSwitches[i] = 0
				end
				soundPage.radioSwitches[shortDistIndex] = 1
				
				if shortDistIndex == 5 then 
					prepareRadioAnimation(soundPage.presetCoords[shortDistIndex], 0) -- funky station
					soundPage.radioSwitches = {1, 0, 1, 0}
				else
					prepareRadioAnimation(soundPage.presetCoords[shortDistIndex], shortDistIndex)
				end
				
				soundPage.dragging = false
				soundPage.delayedButtonSound = true
				
			elseif soundPage.animating then		
				updateSoundPageAnimation(dt)
			end
		end
		
		if soundPage.upcomingTune == "funky_theme" then
			soundPage.birdDanceY = (soundPage.birdDanceY + dt * 5) % _G.math.pi
			getItemByName(soundPage.items, "bird").angle = _G.math.sin(soundPage.birdDanceY) / 4
		elseif soundPage.birdDanceY > 0 then
			soundPage.birdDanceY = (soundPage.birdDanceY + dt * 5) 
			if soundPage.birdDanceY > _G.math.pi then
				soundPage.birdDanceY = 0
			end
			getItemByName(soundPage.items, "bird").angle = _G.math.sin(soundPage.birdDanceY) / 4
		end
	
		if soundPage.dragging ~= true then
			getItemByName(soundPage.items, "wheel").angle = (soundPage.indicatorX - soundPage.presetCoords[1]) / soundPage.wheelDivider
		end
		getItemByName(soundPage.items, "indicator").x = soundPage.indicatorX
		getItemByName(soundPage.items, "indicator").y = soundPage.indicatorY
		
		local _, birdHeight = _G.res.getSpriteBounds(soundPage.defaultSheet, getItemByName(soundPage.items, "bird").sprite)
		getItemByName(soundPage.items, "bird").y = soundPage.birdOriginalY - _G.math.sin(soundPage.birdDanceY) * birdHeight / 3
		
		for i = 1, 4 do
			local spriteName
			if soundPage.radioSwitches[i] == 1 then
				spriteName = "SOUNDBOARD_2_BUTTON_DOWN_" .. i
			else
				spriteName = "SOUNDBOARD_2_BUTTON_UP_" .. i
			end
			getItemByName(soundPage.items, "preset" .. i).sprite = spriteName
		end
		
		drawPictureLevel(soundPage)
		
	end
	
	_G.res.drawSprite("","MENU_SFX", 0, 0, "TOP", "LEFT")
	if settings.audioEnabled == false then
		local pivotX, pivotY = _G.res.getSpritePivot("", "MENU_SFX")
		_G.res.drawSprite("","BUTTON_OFF", pivotX, pivotY)
	end
	if keyPressed["LBUTTON"] and popupPage == nil then
		local width, height = _G.res.getSpriteBounds("", "MENU_SFX")
		if cursor.x < width and cursor.y < height then
			changeAudio()
			if settings.audioEnabled == false then
				if currentSoundboard ~= "RADIO" then
					_G.res.stopAllAudio()
				end
			elseif currentSoundboard == "RADIO" and soundPage.musicPlaying and soundPage.musicStartedWhenMuted then
				_G.res.playAudio(soundPage.upcomingTune, 0.8, true)
			end
		end
	end
	
	if audioRampVolume then
		audioRampVolume = audioRampVolume + (dt / audioRampLength)
		if audioRampVolume <= 0 then
			_G.res.stopAudioOutput()
			audioRampVolume = nil
		elseif audioRampVolume > 1 then
			audioRampVolume = nil
		else
			-- Use squared volume because it gives more linear response
			setMusicVolume( audioRampVolume * audioRampVolume )
			setEffectsVolume( audioRampVolume * audioRampVolume )
		end
	end
	
	if keyPressed["LBUTTON"] and popupPage == nil then
		local width, height = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "LS_BACK_BUTTON")
		if currentSoundboard == "ACCORDION" then
			if cursor.y > (screenHeight - height * 0.7) and cursor.x < width then
				_G.res.stopAllAudio()
				--_G.res.setTrackVolume(1, 6)
				--_G.res.setTrackVolume(1, 7)
				setEffectsVolume(1)
				setGameOn(false) -- enable screen saver
				setGameMode(gotoLevelSelectionGoldenEggs)
			end
		else
			
			if cursor.y > (screenHeight - height) and cursor.x < width then
				_G.res.stopAllAudio()
				setGameOn(false) -- enable screen saver
				setGameMode(gotoLevelSelectionGoldenEggs)
			end
		end
	end
	
	if popupPage ~= nil then
		drawMenuPage(popupPage)
		return
	end
end

function prepareRadioAnimation(target, index)
	
	soundPage.animatingTo = target
	soundPage.animating = true
	
	if soundPage.animatingTo < soundPage.indicatorX then
		soundPage.animationMultiplier = -soundPage.defaultMultiplier
	else
		soundPage.animationMultiplier = soundPage.defaultMultiplier
	end
	
	if index == 0 then
		soundPage.upcomingTune = "funky_theme"
	elseif index == 1 then
		soundPage.upcomingTune = "title_theme"
	else
		local tmpIndex = index - 1
		soundPage.upcomingTune = "ambient_theme" .. tmpIndex
	end

end

function updateSoundPageAnimation(dt)
	
	soundPage.indicatorX = soundPage.indicatorX + dt * soundPage.animationMultiplier
				
	if (soundPage.indicatorX >= soundPage.animatingTo and soundPage.animationMultiplier > 0)
		or (soundPage.indicatorX <= soundPage.animatingTo and soundPage.animationMultiplier < 0) then
		
		if soundPage.delayedButtonSound then
			soundPage.delayedButtonSound = false
			_G.res.stopAllAudio()
			_G.res.playAudio("button_radio", 1, false)
		end
					
		soundPage.animating = false
		soundPage.indicatorX = soundPage.animatingTo
		if soundPage.upcomingTune == "funky_theme" then
			if not soundPage.sessionStarCollected then
				goldenEggStarAchieved("Level" .. currentLevelNumberInTheme)
				soundPage.sessionStarCollected = true
			end
		end
					
		_G.res.playAudio(soundPage.upcomingTune, 0.8, true)
		soundPage.musicPlaying = true
		if settings.audioEnabled then
			soundPage.musicStartedWhenMuted = nil
		else
			soundPage.musicStartedWhenMuted = true
		end
	end

end


function animateBirdToSlingShot(dt)
	local testIndex = currentBirdIndex + 1
	if nextBirdTimer > 0 then
		nextBirdTimer = nextBirdTimer - dt
		if nextBirdTimer <= 0 then
			if getNextBird(testIndex) ~= nil then
				if birdFired then
					birdFired = false
					fillInNextBird = true
					selectedBird = nil
				end
			else
				allowResetToBirdCamera = false
				--print("Can't reset to bird camera\n")
			end
		end
	end
	
	if fillInNextBird == true then		
		if birdToSlingshotBirdName == nil then
			birdToSlingshotAnimationTimer = 0
			birdToSlingshotBirdName = getNextBird(testIndex)
			objects.world[birdToSlingshotBirdName].jumpTimer = 10000
			if objects.world[birdToSlingshotBirdName].jumpOn == true then
				birdToSlingshotAnimationStartY = objects.world[birdToSlingshotBirdName].oldY
				objects.world[birdToSlingshotBirdName].y = objects.world[birdToSlingshotBirdName].oldY
				objects.world[birdToSlingshotBirdName].jumpOn = false
				--print("levelStartPosition.y: " .. levelStartPosition.y .. "\n")
				--print("objects.world[birdToSlingshotBirdName].y: " .. objects.world[birdToSlingshotBirdName].y .. "\n")
				--print("birdToSlingshotAnimationHeight: " .. birdToSlingshotAnimationHeight .. "\n")
			end
			birdToSlingshotAnimationStartX = objects.world[birdToSlingshotBirdName].x
			birdToSlingshotAnimationStartY = objects.world[birdToSlingshotBirdName].y
			birdToSlingshotAnimationHeight = (levelStartPosition.y - objects.world[birdToSlingshotBirdName].y) * 1.33
		end
	
		--print("Bird to slingshot animation\n")
		birdToSlingshotAnimationTimer = birdToSlingshotAnimationTimer + dt
		
		local obj = objects.world[birdToSlingshotBirdName]
		
		if obj == nil then
			return 
		end
		
		--print("newPos: " .. obj.y + _G.math.sin(birdToSlingshotAnimationAngle*birdToSlingshotAnimationTimer) * birdToSlingshotAnimationHeight .. "\n")
		setPosition(obj.name, 
			birdToSlingshotAnimationStartX * (1 - birdToSlingshotAnimationTimer) + levelStartPosition.x * birdToSlingshotAnimationTimer, 
			birdToSlingshotAnimationStartY + _G.math.sin(birdToSlingshotAnimationAngle*birdToSlingshotAnimationTimer) * birdToSlingshotAnimationHeight)
		setRotation(obj.name, obj.angle + _G.math.pi*2*dt)
		
		-- get next bird ready for action
		if birdToSlingshotAnimationTimer >= 1 then
			birdToSlingshotBirdName = nil
			birdToSlingshotAnimationTimer = 0
			fillInNextBird = false
			birdReady = true
			currentBirdIndex = currentBirdIndex + 1
			currentBirdName = getNextBird(currentBirdIndex)
			setPosition(currentBirdName, levelStartPosition.x - 0.1, levelStartPosition.y - 0.1)
			rubberBandPos.x, rubberBandPos.y = levelStartPosition.x - 0.1, levelStartPosition.y - 0.1
			rubberBandAngle = _G.math.atan2(-0.1, 0.1)
			
			local castleToBirdCamDist = _G.math.abs(distance(objects.birdCameraData[deviceModel].px, objects.birdCameraData[deviceModel].py,
				objects.castleCameraData[deviceModel].px, objects.castleCameraData[deviceModel].py))
			local camToBirdCamDist = _G.math.abs(distance(screen.x, screen.y, objects.birdCameraData[deviceModel].px, 
				objects.birdCameraData[deviceModel].py))
			local volume = _G.math.min(1, _G.math.max(0.25, 1 - (camToBirdCamDist / castleToBirdCamDist)))
			
			_G.res.playAudio(getAudioName("bird_next_military"), volume, false)
			setObjectParameter(currentBirdName, 2, 1)
			setRotation(currentBirdName, 0)
		end
	end
end

function updateCharacterAnimations(dt)
	
	-- make piglets laugh when there are no birds left
	if checkLevelFailed() then
		--piglette smiles
		for k, v in _G.pairs(levelGoals) do
			setSprite(v.name, v.smileSprite)
		end
	else
		--piglette blinks
		for k, v in _G.pairs(levelGoals) do
			v.blinkTimer = v.blinkTimer - dt
			if v.blinkTimer < 0 then
				if v.blinkOn == true then
					v.blinkTimer = _G.math.random(1,30) / 10
					setSprite(v.name, v.damageSprite)
					v.blinkOn = false
				else
					v.blinkTimer = _G.math.random(1,4) / 10
					setSprite(v.name, v.blinkSprite)
					v.blinkOn = true
				end
			end
		end		
	end	
	
	--piglette oinks
	for k, v in _G.pairs(levelGoals) do
		v.oinkTimer = v.oinkTimer - dt
		if v.oinkTimer < 0 then
			v.oinkTimer = _G.math.random(10,60) / 10
			local lsx, lsy = physicsToWorldTransform(v.x, v.y)
			local dist = vLength(screen.x - lsx, screen.y - lsy)
			local volume = 1 - dist / 1000
			if volume > 0 then 
				_G.res.playAudio(getAudioName("piglette"), volume, false, 0) 
			end
		end
	end	

	
	-- bird animations
	for k, v in _G.pairs(birds) do
		if v.shot ~= true then
			v.animTimer = v.animTimer - dt
			-- blink and yell
			if v.animTimer < 0 then
				if v.animOn == true then
					v.animTimer = _G.math.random(10,150) / 100
					setSprite(v.name, v.damageSprite)
					v.animOn = false
				else
					v.animTimer = _G.math.random(10,20) / 100
					local animType = _G.math.random(1,4)
					local sprite = nil
					if animType == 1 then
						sprite = blockTable.blocks[v.definition].spriteYell
						--if sprite ~= nil then
						local lsx, lsy = physicsToWorldTransform(levelStartPosition.x, levelStartPosition.y )
						local dist = vLength(screen.x - lsx, screen.y - lsy)
						local volume = 1 - dist / 1000
						if volume > 0 and eagleBaitLaunched ~= true then 
							_G.res.playAudio(getAudioName("bird_misc"), volume, false, 0) 
						end
						--end
					else
						sprite = blockTable.blocks[v.definition].spriteBlink				
					end
					if sprite ~= nil then
						setSprite(v.name, sprite)
					end
					v.animOn = true
				end			
			end
			
			-- jump
			if currentBirdName ~= v.name then
				if v.jumpOn ~= true then
					v.jumpTimer = v.jumpTimer - dt			
				end

				if v.jumpTimer < 0 then
					v.jumpTimer = _G.math.random(0,35) / 10
					v.jumpHeight = _G.math.random(5,15) / 10
					v.jumpSpeed = 7 / v.jumpHeight * 1.2
					if levelCompleted then
						v.jumpTimer = 0
						v.jumpHeight = _G.math.random(25,35) / 10
						v.jumpSpeed = 7 / v.jumpHeight * 1.6
					end
					v.jumpAngle = 0
					v.jumpOn = true
					v.jumpRebound = false
					v.jumpRoll = 0
					if blockTable.blocks[v.definition].allowRoll == true and v.jumpHeight > 0.9 then
						v.jumpRoll = _G.math.random(0,4) - 1
					end
					v.oldY = v.y
					v.oldAngle = v.angle
				end
				
				if v.jumpOn == true then
					v.jumpAngle = v.jumpAngle + dt * v.jumpSpeed
					setPosition(v.name, v.x, v.oldY - _G.math.sin(v.jumpAngle) * v.jumpHeight)
					if (v.jumpRoll == -1 or v.jumpRoll == 1) and v.jumpRebound ~= true then
						setRotation(v.name, v.jumpAngle * 2 * v.jumpRoll)
					end
					-- if jump complete
					if v.jumpAngle > _G.math.pi then
						if v.jumpRebound == true then
							v.jumpOn = false
							v.y = v.oldY
							v.angle = v.oldAngle
							setPosition(v.name, v.x, v.y)
							setRotation(v.name, v.angle)
						else
							v.jumpRebound = true
							v.jumpAngle = 0
							v.jumpHeight = v.jumpHeight * 0.3
							v.jumpSpeed = v.jumpSpeed * 2
						end
					end
				end
			end
		end
	end	
end

-- XXX: ADD TO OTHERS
function drawCircle(x,y,radius, angle,r,g,b,a,w)
	local points = {}
					
	for i = 0,_G.math.pi * 2,0.5 do
			local px = _G.math.cos(i) * physicsToWorldTransform(radius,0)
			local py = _G.math.sin(i) * physicsToWorldTransform(radius,0)
			local point = {x + px, y +py}						
			_G.table.insert(points,point)							
	end
	
	drawPolygon(points,w, true,r,g,b,a,angle,0.5,0.5)	
end
-- XXX: ADD TO OTHERS
function drawPolygon(points,lineW,inWorld,r,g,b,a,angle,pivotX,pivotY)
	local wScale = worldScale
	
	if tempWorldScale ~= nil then
		wScale = tempWorldScale
	end
	
	-- Add the last one again to complete polygon.	
	_G.table.insert(points, points[1])

	pivotX = pivotX or 0.5
	pivotY = pivotY or 0.5
	
	local temp = 99999999
	local w = 0
	local h = 0
	local minX = temp
	local maxX = -temp
	local minY = temp
	local maxY = -temp
	
	-- find bounds
	for k,v in _G.pairs(points) do

		minX = _G.math.min(minX, points[k][1])
		minY = _G.math.min(minY, points[k][2])
			
		maxX = _G.math.max(maxX, points[k][1])
		maxY = _G.math.max(maxY, points[k][2])			
	end
	
	local w = (maxX - minX) 
	local h = (maxY - minY) 

	local px = pivotX * w
	local py = pivotY * h
	
	-- draw polygon
	for k,v in _G.pairs(points) do
		if(k > 1) then
			
			local x1 = points[k-1][1]
			local y1 = points[k-1][2]
			
			local x2 = points[k][1]
			local y2 = points[k][2]
			
			-- calculate rotation pivot
			local rotatePivotX = (minX + px) - x1   
			local rotatePivotY = (minY + py) - y1 			
			
			setRenderState(-screen.left, -screen.top, wScale, wScale, angle, rotatePivotX, rotatePivotY)
			drawLine(r,g,b,a,x1,y1,x2,y2,inWorld,lineW)		
		end
	end	
end

-- XXX: ADD TO OTHERS
function drawWireFrameRect(x1,y1,x2,y2,lineW, inWorld,r,g,b,a,angle,pivotX, pivotY)
	local points = {{x1,y1}, {x2,y1}, {x2,y2},{x1,y2}}
	drawPolygon(points,lineW, inWorld,r,g,b,a,angle,pivotX,pivotY)
end

-- XXX: ADD TO OTHERS
function drawDummyCollisionBox(object)
	
	if showSleepingObjects == true then
		local objectName = object.name
			
		if(objectName ~= nil and adjustedBlockDef ~= nil and adjustedBlockDef.objectNames[objectName] ~= nil) then
			local selected = objects.world[objectName]
			local blockDef = adjustedBlockDef.objectNames[objectName]
			
			local x, y = physicsToWorldTransform(selected.x, selected.y)
			--local w, h = _G.res.getSpriteBounds("", v.sprite)
			local w, h = _G.res.getSpriteBounds("", selected.sprite)

			
			
			local radius = adjustedBlockDef.objectNames[objectName].radius 
			local width = adjustedBlockDef.objectNames[objectName].width 
			local height = adjustedBlockDef.objectNames[objectName].height 
			local vertices = adjustedBlockDef.objectNames[objectName].vertices 
					
			if(radius ~= nil) then
				drawCircle(x,y,radius, selected.angle,255,0,255,255,2)
				drawString(""..radius, 0.5, x,y, nil,nil, true)
			elseif(width ~= nil and height ~= nil) then
					local ww, hh = physicsToWorldTransform(width, height) 
					local x1, y1 = x - ww / 2, y - hh / 2
					local x2, y2 = x + ww / 2, y + hh / 2					
					local pivX = object.spritePivotX / (w ) 
					local pivY = object.spritePivotY / (h )
					drawWireFrameRect(x1,y1,x2,y2,1,true,255,0,255,255,selected.angle,pivX, pivY)					
					drawString("w="..width .." h="..height, 0.5, x,y, nil,nil, true)
			
			elseif(vertices ~= nil) then
				local points = {}
					
				for kk,vv in _G.pairs(blockDef.vertices) do
					local wx,wy = w * vv.x, h  * vv.y 
					local point = {x + (wx) - w / 2, y + (wy) - h / 2}
					_G.table.insert(points,point)
				end					
				drawPolygon(points,2, true,255,0,255,255,object.angle,0.5,0.5)					

				for kk,vv in _G.pairs(blockDef.vertices) do
					local wx,wy = w * vv.x, h  * vv.y 
					local xString = _G.string.format("%.2f", (vv.x))
					local yString = _G.string.format("%.2f", (vv.y))
					drawString("("..xString.."/"..yString..")", 0.1, x + wx - w / 2,y + wy - h / 2, nil,nil, true)
				end					
			end				
		end
	end
end	


-- XXX: ADD TO OTHERS
function checkCollide(object1, object2, dir) 
    local left1 = object1.x1
    local left2 = object2.x1
    local right1 = object1.x2
    local right2 = object2.x2
    local top1 = object1.y1
    local top2 = object2.y1
    local bottom1 = object1.y2
    local bottom2 = object2.y2
	
	if(dir == 1) then
		if (bottom1 < top2) then return nil end;
		if (top1 > bottom2) then return nil end;	
	end
  
	if(dir == 0) then
		if (right1 < left2) then return nil end;
		if (left1 > right2) then return nil end;	
	end

	return true

end
-- XXX: ADD TO OTHERS
function getBoundingBox(object)
	local w,h = _G.res.getSpriteBounds(object.sprite)
	w,h = worldToPhysicsTransform(w,h)
	local x1 = object.x - w / 2
	local y1 = object.y - h / 2

	local x2 = object.x + w / 2
	local y2 = object.y - h / 2

	local x3 = object.x + w / 2
	local y3 = object.y + h / 2

	local x4 = object.x - w / 2
	local y4 = object.y + h / 2

	local _x1 = object.x - x1
	local _y1 = object.y - y1
	local _x2 = object.x - x2
	local _y2 = object.y - y2
	local _x3 = object.x - x3
	local _y3 = object.y - y3
	local _x4 = object.x - x4 
	local _y4 = object.y - y4	
	
	local an = object.angle
	local cosinus = _G.math.cos(an)
	local sinus = _G.math.sin(an)
	
	local __x1 = _x1 * cosinus - _y1 * sinus + object.x
	local __y1 = _x1 * sinus + _y1 * cosinus + object.y
	local __x2 = _x2 * cosinus - _y2 * sinus + object.x
	local __y2 = _x2 * sinus + _y2 * cosinus + object.y
	local __x3 = _x3 * cosinus - _y3 * sinus + object.x
	local __y3 = _x3 * sinus + _y3 * cosinus + object.y
	local __x4 = _x4 * cosinus - _y4 * sinus + object.x
	local __y4 = _x4 * sinus + _y4 * cosinus + object.y

	local minx = _G.math.min(_G.math.min(__x1,__x2), _G.math.min(__x3,__x4))
	local maxx = _G.math.max(_G.math.max(__x1,__x2), _G.math.max(__x3,__x4))
	
	local miny = _G.math.min(_G.math.min(__y1,__y2), _G.math.min(__y3,__y4))
	local maxy = _G.math.max(_G.math.max(__y1,__y2), _G.math.max(__y3,__y4))
	
	return {x1 = minx, y1 = miny, x2 = maxx, y2 = maxy}	
end
-- XXX: ADD TO OTHERS
function alignObjects(dir)
	
	local xDir = 0
	local yDir = 0
	
	if(dir == "DOWN") then
		yDir = -1		
	elseif(dir == "UP") then
		yDir = 1
	elseif(dir == "LEFT") then
		xDir = -1
	elseif(dir == "RIGHT") then
		xDir = 1
	end
	
	
	if(selectedObjects ~= nil and #selectedObjects > 1) then
		-- sort selected objects according to direction
		if(dir == "DOWN") then _G.table.sort( selectedObjects, function(a,b) return a.y > b.y end )	end	
		if(dir == "UP") then _G.table.sort( selectedObjects, function(a,b) return a.y < b.y end )	end	
		if(dir == "LEFT") then _G.table.sort( selectedObjects, function(a,b) return a.x < b.x end )	end	
		if(dir == "RIGHT") then _G.table.sort( selectedObjects, function(a,b) return a.x > b.x end )	end	
		
		
		for i = 1, #selectedObjects do
			local sel = selectedObjects[i]
			cBox1 = getBoundingBox(sel)			
			local w = cBox1.x2 - cBox1.x1
			local h = cBox1.y2 - cBox1.y1
			
			-- insert to initial position
			if(yDir == 1) then
				setPosition(sel.name, sel.x,  selectedObjectsAreaCoords.y1 +  h / 2)									
			elseif(yDir == -1) then
				setPosition(sel.name, sel.x,  selectedObjectsAreaCoords.y2 - h / 2)									
			elseif(xDir == 1) then 
				setPosition(sel.name, selectedObjectsAreaCoords.x2 - w / 2,  sel.y)									
			elseif(xDir == -1) then 
				setPosition(sel.name, selectedObjectsAreaCoords.x1 + w / 2 ,  sel.y)									
			end
			
			local val = 99999999999999
			local mincX = val
			local maxcX = -val
			local mincY = val
			local maxcY = -val
			local collided = false
			-- collision checks					
			for j = 1, i do
				-- for boxes that won't move anymore
				local sel2 = selectedObjects[j]							
				cBox2 = getBoundingBox(sel2)
				
				if(sel2 ~= sel) then
					local collideArea = nil
					if(xDir ~= 0) then
						collideArea = checkCollide(cBox1,cBox2,1)					
					else
						collideArea = checkCollide(cBox1,cBox2,0)					
					end
					if(collideArea ~= nil) then 				
						mincX = _G.math.min(cBox2.x1, mincX)
						maxcX = _G.math.max(cBox2.x2, maxcX)
						mincY = _G.math.min(cBox2.y1, mincY)
						maxcY = _G.math.max(cBox2.y2, maxcY)
						collided = true
					end		
				end					
			end
			
			if(collided == true) then
				local ww,hh = worldToPhysicsTransform(1,1)
				if(xDir ~=0) then
					local w = cBox1.x2 - cBox1.x1
					local xp = 0
					if(xDir == -1) then
						xp = maxcX
					else
						xp = mincX
					end
					setPosition(sel.name, xp + (ww + w / 2) * -xDir, sel.y)														
				else
					local h = cBox1.y2 - cBox1.y1
					local yp = 0
					if(yDir == 1) then
						yp = maxcY
					else
						yp = mincY
					end
					setPosition(sel.name, sel.x, yp + (hh + h / 2) * yDir)														
				end
			end
		end			
	end	
end
-- XXX: ADD TO OTHERS
selectedObjectsAreaCoords = nil
function drawSelectedObjectsArea()
	-- draw box of selected items
	if(selectedObjects ~= nil and #selectedObjects > 1) then
		
		local val = 9999999999
		local minX = val local minY = val local maxX = -val local maxY = -val		

		
		for k,v in _G.pairs(selectedObjects) do
			
			local points = getBoundingBox(v)
			
			local w = points.x2 - points.x1
			local h = points.y2 - points.y1
			
			
			minX = _G.math.min(minX, v.x - w / 2)
			minY = _G.math.min(minY, v.y - h / 2)

			maxX = _G.math.max(maxX, v.x + w / 2)
			maxY = _G.math.max(maxY, v.y + h / 2)
			
		end		

		if(selectedObjectsAreaCoords == nil or keyHold["LBUTTON"]) then
			selectedObjectsAreaCoords = {}
			selectedObjectsAreaCoords.x1 = minX
			selectedObjectsAreaCoords.y1 = minY
			selectedObjectsAreaCoords.x2 = maxX
			selectedObjectsAreaCoords.y2 = maxY				
		end
		
		local worldMinX, worldMinY = physicsToWorldTransform(selectedObjectsAreaCoords.x1, selectedObjectsAreaCoords.y1)
		local worldMaxX, worldMaxY = physicsToWorldTransform(selectedObjectsAreaCoords.x2, selectedObjectsAreaCoords.y2)
		drawWireFrameRect(worldMinX,worldMinY,worldMaxX,worldMaxY,3,true,255,0,255,255,0,0.5,0.5)
		
	else
		selectedObjectsAreaCoords = nil
	end	
end


--[1.5.4 
extraTutorialTimer = 0
function drawExtraTutorial(sprite)	
	
	if(extraTutorialTimer > 0.5 and birdSpecialtyAvailable == true and sprite ~= nil and settings.tutorials ~= nil) then		
		if(settings.tutorials[sprite] ~= nil) then						
			if(settings.tutorials[sprite].showHelp == true) then
				if deviceModel == "iphone4" and ((changeResolution ~= true and wantedResolution == "FULL") or (changeResolution == true and wantedResolution == "HALF")) then
					_G.res.drawSprite("", "TUTORIAL_FINGER_BIG", screenWidth * 0.90, screenHeight / 2, "BOTTOM", "HCENTER")			
				else
					_G.res.drawSprite("", "TUTORIAL_FINGER_BIG", screenWidth * 0.80, screenHeight, "BOTTOM", "HCENTER")							
				end
			end						
		end				
	end
end



--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- This function only draws the game without any logic

function drawGame()

	if showCameraDebugData then
		--store the current camera
		tempScreen = {}
		tempScreen.x = screen.x
		tempScreen.y = screen.y
		tempScreen.left = screen.left
		tempScreen.right = screen.right
		tempScreen.top = screen.top
		tempScreen.bottom = screen.bottom
		tempScreen.scale = worldScale

		--set the camera to zoomed out state
		local newScreenHeight = screenHeight / (screenWidth / ((levelRightEdge - levelLeftEdge) * physicsToWorld))
		worldScale = minWorldScale*0.9
		screen.x = (levelRightEdge + levelLeftEdge) * 0.5 * physicsToWorld
		screen.y = -newScreenHeight * 0.25
		setWorldScale(worldScale)
		defaultCamera(0)
	end
	
	local c = blockTable.themes[objects.theme].color
	setBGColor(c.r, c.g, c.b)
	
	--print("draw game\n")
	setFont(fontBasic)
	-- Draw background image
	if settings.gfxLowQuality == false or settings.gfxLowQuality == nil then
		drawBackgroundNative()	
	end
	
	----slingshot rubber band
	local rbx, rby = physicsToWorldTransform(rubberBandPos.x, rubberBandPos.y )
	local lsx, lsy = physicsToWorldTransform(levelStartPosition.x, levelStartPosition.y )
	
	local rbx1, rby1 = rbx, rby
	if currentBirdName ~= nil then
		local radius = objects.world[currentBirdName].radius
		if radius == nil then
			radius = objects.world[currentBirdName].width * 0.5
		end
		rbx1 = rbx - (radius + 0.05 ) * physicsToWorld * _G.math.cos(rubberBandAngle)
		rby1 = rby - (radius + 0.05 ) * physicsToWorld * _G.math.sin(rubberBandAngle)
	end
	
	local rbw = 50 / rubberBandLength
	if rbw > 25 then
		rbw = 25
	end

	if rbw < 10 then
		rbw = 10
	end
	
	--if currentGameMode == updateGame then
	local wScale = worldScale
	if tempWorldScale ~= nil then
		wScale = tempWorldScale
	end
	setRenderState(-screen.left - cameraShakeX, -screen.top - cameraShakeY, wScale, wScale, 0)
	_G.res.drawSprite("INGAME_BIRDS_1", "SLING_SHOT_01_BACK", lsx, lsy)
	local lsx1, lsy1 = lsx + 20, lsy
	drawLine2D(lsx1, lsy1, rbx1, rby1, rbw, 48, 23, 8, 255)
	if selectedBird == nil then
		_G.res.drawSprite("INGAME_BIRDS_1", "SLING_HOLDER", rbx1, rby1)
	end
	--end
	drawGameNative()
	
	drawForegroundNative()

	
	setRenderState(-screen.left - cameraShakeX, -screen.top - cameraShakeY, wScale, wScale, 0, 0, 0)
			
	-- local bcd = objects.birdCameraData[deviceModel]			
	-- _G.res.drawSprite("INGAME_BIRDS_1", "SLING_HOLDER", bcd.px, bcd.py)
	-- _G.res.drawSprite("INGAME_BIRDS_1", "HUD_ARROW_UP", 0, 0)
	
	local lsx2, lsy2 = lsx - 21, lsy - 3
	drawLine2D(lsx2, lsy2, rbx1, rby1, rbw, 48, 23, 8, 255)
	if selectedBird ~= nil then
		setRenderState(-screen.left - cameraShakeX, -screen.top - cameraShakeY, wScale, wScale, rubberBandAngle, _G.res.getSpritePivot("INGAME_BIRDS_1", "SLING_HOLDER"))
		_G.res.drawSprite("INGAME_BIRDS_1", "SLING_HOLDER", rbx1, rby1)
	end
	setRenderState(-screen.left - cameraShakeX, -screen.top - cameraShakeY, wScale, wScale, 0, 0, 0)
	_G.res.drawSprite("INGAME_BIRDS_1", "SLING_SHOT_01_FRONT", lsx, lsy)
	
	if useLevelLimits then
		if cameraTargetObject ~= nil then
			local ct = cameraTargetObject
			if ct.y*physicsToWorld < screen.top then
				setRenderState(-screen.left, -screen.top, wScale, wScale, 0, ct.spritePivotX, ct.spritePivotY)
				_G.res.drawSprite("INGAME_BIRDS_1", "HUD_ARROW_UP", _G.math.floor(ct.x*physicsToWorld), _G.math.floor(screen.top))
			end
		end
	end	
	
	if currentGameMode ~= updateEditor then

		setRenderState(0, 0, 1, 1, 0)
		
		local drawHud = true
		if currentGameMode == updateMenu and (currentMenuPage == levelComplete or currentMenuPage == levelFailed or 
			currentMenuPage == gameFinished or currentMenuPage == gameFinishedThreeStars or 
			currentMenuPage == gameFinishedLP2 or currentMenuPage == gameFinishedThreeStarsLP2 or
			currentMenuPage == gameFinishedLP3 or currentMenuPage == gameFinishedThreeStarsLP3 or
			currentMenuPage == gameFinishedLP4 or currentMenuPage == gameFinishedThreeStarsLP4 or
			currentMenuPage == gameFinishedLP5 or currentMenuPage == gameFinishedThreeStarsLP5 or 
			currentMenuPage == gameFinishedLP6 or currentMenuPage == gameFinishedThreeStarsLP6) or 
			(levelCompleted == true and levelCompleteTimer <= 0) or currentGameMode == updateLoading or
			currentGameMode == updateLoadingEx or loadingPageDrawn == true then
			drawHud = false
		end
			
		if drawHud then
			local yAdd = 0
			local bannerOffset = 0
			if scoreAdOffsetY ~= nil then
				bannerOffset = _G.math.min(_G.math.max(scoreAdOffsetY, 0), bannerHeight)
			end
			local scoreString = _G.string.format("%d", score)
			local scoreLen = _G.res.getStringWidth(scoreString)
			if deviceModel == "iphone4" and ((changeResolution ~= true and wantedResolution == "FULL") or (changeResolution == true and wantedResolution == "HALF")) then
				setRenderState(-screenWidth * 0.5, 0, 2, 2, 0)
			else
				setRenderState(0, 0, 1, 1, 0)
			end
			scoreLen = _G.math.max( scoreLen, oldScoreLen)
			oldScoreLen = scoreLen
			--[1.5.4
			if(flyingBird ~= nil and flyingBird.name ~= nil) then
				local bDef = getObjectDefinition(flyingBird.name)
				drawExtraTutorial(bDef.sprite)
			end
			--]

			
			if eagleBaitLaunched == true then
				local tempEagleScore = 0
				if highscores[levelName] ~= nil and highscores[levelName].eagleScore ~= nil and highscores[levelName].eagleScore > 0 then
					tempEagleScore = highscores[levelName].eagleScore
				end
				local highScoreLen = _G.res.getStringWidth(tempEagleScore .. "%")
				yAdd = _G.res.getFontLeading() + 1
					
				local highscoreStr = _G.res.getString("TEXTS_BASIC", "TEXT_EAGLE_HIGHSCORE")
				_G.res.drawString("TEXTS_BASIC", highscoreStr .. " ", screenWidth - 3 - highScoreLen, bannerOffset, "TOP", "RIGHT")
				
				_G.res.drawString("TEXTS_BASIC", _G.string.format("%d", tempEagleScore) .. "%", screenWidth - 3, bannerOffset, "TOP", "RIGHT")
			else	
				if highscores[levelName] ~= nil and highscores[levelName].score > 0 then
					local highScoreLen = _G.res.getStringWidth("" .. highscores[levelName].score)
					yAdd = _G.res.getFontLeading() + 1
					if scoreLen < highScoreLen then
						scoreLen = highScoreLen
					end
					
					local highscoreStr = _G.res.getString("TEXTS_BASIC", "MI_HIGH_SCORE")
					_G.res.drawString("TEXTS_BASIC", highscoreStr .. " ", screenWidth - 3 - scoreLen, bannerOffset, "TOP", "RIGHT")
					_G.res.drawString("TEXTS_BASIC", _G.string.format("%d", highscores[levelName].score), screenWidth - 3, bannerOffset, "TOP", "RIGHT")
				end

				local scoreStr = _G.res.getString("TEXTS_BASIC", "MI_SCORE")
				_G.res.drawString("TEXTS_BASIC", scoreStr .. " ", screenWidth - 3 - scoreLen, yAdd + bannerOffset, "TOP", "RIGHT")
				_G.res.drawString("TEXTS_BASIC", scoreString, screenWidth - 3, yAdd + bannerOffset, "TOP", "RIGHT")
				setRenderState(0, 0, 1, 1, 0)
				setFont("FONT_SCORE")
				for i = 1, #floatingScores do
					local fs = floatingScores[i]
					local fx, fy = physicsToWorldTransform(fs.x, fs.y)
					local wScale = worldScale
					-- tempWorldScale is temporary scaling that is only used when iphone4 goes to 480x320 resolution to display in-game menu etc.
					if tempWorldScale ~= nil then
						wScale = tempWorldScale
					end
					fx = (fx - screen.left) * wScale
					fy = (fy - screen.top) * wScale
					local xs = fs.xs
					setRenderState(0, 0, xs, xs)
					if fs.text ~= nil then
						_G.res.drawString("TEXTS_BASIC", fs.text, fx/xs, fy/xs, "BOTTOM", "HCENTER")
					end
					if fs.sprite ~= nil then 
						_G.res.drawSprite("MENU_ELEMENTS_1", fs.sprite, _G.math.floor(fx/xs), _G.math.floor(fy/xs), "BOTTOM", "HCENTER")
					end
				end
			end
			setFont(fontBasic)

			if deviceModel == "iphone4" and ((changeResolution ~= true and wantedResolution == "FULL") or (changeResolution == true and wantedResolution == "HALF")) then
				setRenderState(0, 0, 2, 2)
			else
				setRenderState(0, 0, 1, 1)
			end
			-- if hasMovingObjects then
				-- _G.res.drawString("", "HasMovingObjects", 0, screenHeight, "BOTTOM", "LEFT")
			-- end
			
			local mbx, mby = _G.res.getSpritePivot("BUTTONS_SHEET_1", "MENU_BUTTON")
			_G.res.drawSprite("BUTTONS_SHEET_1", "MENU_BUTTON", mbx, mby)
			if iapEnabled == true and inExtraWorld ~= true and eagleBaitLaunched ~= true and (inGameEagleButtonVisible == true or (inGameEagleButtonVisible ~= true and inGameEagleButtonScale ~= nil)) then
				local eagleButtonSprite = "BUTTON_USE_EAGLE"
				--- --- ---
	--			local eagleScoreBox = "EAGLE_FEATHER_BOX"
		--		local eagleFeather = "EAGLE_FEATHER_UNUSABLE"
				-- show that feather was gained.
				--[[
				if(highscores ~= nil and levelName ~= nil) then
					if(highscores[levelName] ~= nil) then
						if(highscores[levelName].eagleScore ~= nil and highscores[levelName].eagleScore >= 100) then									
							eagleFeather = "EAGLE_FEATHER_USABLE"
						end
					end				
				end]]
				
	--			local esbW , esbH = _G.res.getSpriteBounds("", eagleScoreBox)
		--		local esbPX, esbPY = _G.res.getSpritePivot("", eagleScoreBox)
--				local efW , efH = _G.res.getSpriteBounds("", eagleFeather)
	--			local efPX, efPY = _G.res.getSpritePivot("", eagleFeather)
				--- --- ---
				
				local w, _ = _G.res.getSpriteBounds("BUTTONS_SHEET_1", "MENU_BUTTON")
				local bw, bh = 0, 0
				local px, py = 0, 0
				
				if isEagleDisabled() == true then
					eagleButtonSprite = "BUTTON_USE_EAGLE_DISABLED"
					oldEagleButtonStatusDisabled = true
					bw, bh = _G.res.getSpriteBounds("BUTTONS_SHEET_1", eagleButtonSprite)
					px, py = _G.res.getSpritePivot("BUTTONS_SHEET_1", eagleButtonSprite)
					if eagleInfoTimer ~= nil and settings.eagleUsedTime ~= nil and eagleInfoTimer > 0 then
						local timeLeft = eagleLockedTime - timeDiff(currentTime(), settings.eagleUsedTime)
						_G.res.drawString("TEXTS_BASIC", formatTime(timeLeft), _G.math.floor(w + px), _G.math.floor(bh * 1.15), "VCENTER", "HCENTER") 
					end
				else
					bw, bh = _G.res.getSpriteBounds("BUTTONS_SHEET_1", eagleButtonSprite)
					px, py = _G.res.getSpritePivot("BUTTONS_SHEET_1", eagleButtonSprite)
					if oldEagleButtonStatusDisabled == true and inGameEagleButtonVisible == true then
						oldEagleButtonStatusDisabled = false
						_G.res.playAudio("goldenegg", 1, false)
					end
				end

				local scaleFactor = inGameEagleButtonScale or 1
				
				
				
				if(startedFromEditor ~= true) then
					local yPos = (py / bh) * bh
					local xPos = mbx + px + bw

					local xCoordEye = xPos + px * (1 - scaleFactor)
					local yCoordEye = yPos + py * (1 - scaleFactor)
					
					--[[
					local xCoordBox = xPos + esbPX * (1 - scaleFactor)
					local yCoordBox = yPos + esbPY * (1 - scaleFactor)
					
					local xCoordFeather = xPos + efPX * (1 - scaleFactor)
					local yCoordFeather = yPos + efPY * (1 - scaleFactor)
					]]
					--_G.res.drawSprite("", eagleScoreBox, xCoordBox ,yCoordBox, "HPIVOT", "VPIVOT", esbW * scaleFactor, esbH * scaleFactor)
					--_G.res.drawSprite("", eagleFeather, xCoordFeather,  yCoordFeather, "HPIVOT", "VPIVOT", efW * scaleFactor, efH * scaleFactor)				
					_G.res.drawSprite("BUTTONS_SHEET_1", eagleButtonSprite, xCoordEye,  yCoordEye, "HPIVOT", "VPIVOT", bw * scaleFactor, bh * scaleFactor)				
					
				end	
			end	
			setRenderState(0, 0, 1, 1)
			
			-- if birdSpecialtyAvailable and flyingBird ~= nil then
				-- _G.res.drawSprite("MENU", getObjectDefinition(flyingBird.name).spriteAction, screenWidth - 30, screenHeight - 35)
			-- end		
		end
		
		if #birdTutorialPopups > 0 and (deviceModel ~= "iphone4" or changeResolution ~= true) then
	
			drawRect( 0, 0, 0, 0.5, 0, 0, screenWidth, screenHeight, false)
			local tutorial = getItemByName(tutorials.items, birdTutorialPopups[1])
			local box = tutorials.backgroundBox
			drawBox(box.sprites, "", box.x, box.y, box.width, box.height, box.hanchor, box.vanchor)
			
			_G.res.drawCompoSprite("", tutorial.sprite, tutorial.x, tutorial.y)
			
			if showTutorialGoldenEgg == true and birdTutorialPopups[1] == settings.tutorials["BIRD_GREEN"].sprite and settings.openGoldenEggLevels["Level1"] == nil then
				setRenderState(0, 0, 0.65, 0.65)
				_G.res.drawSprite("", "GOLDEN_EGG_1", tutorialGoldenEggPosition.x, tutorialGoldenEggPosition.y)
				setRenderState(0, 0, 1, 1, 0)
			end
			
			_G.res.drawSprite("", "TUTORIAL_OK", _G.math.floor(tutorials.okButtonX), _G.math.floor(tutorials.okButtonY))
			
			if deviceModel == "android" and isBetaVersion then
				_G.res.drawSprite("MENU_LITEBETA_1", "BETA_BOTTOM_RIGHT", screenWidth, screenHeight)
			end
			
		end
	end

	--	void GameLua::drawCircle(float x, float y, float radius, float lineW, float r, float g, float b, float a);

	-- XXX: ADD TO OTHERS
	if currentGameMode == updateEditor then
		drawSelectedObjectsArea();
	end
	
	if(showSleepingObjects == true) then
		for k, v in _G.pairs(objects.world) do
			if v.sleeping == true and v.sprite ~= "" then
				local w, h = _G.res.getSpriteBounds("", v.sprite)
				w, h = w*0.5, h*0.5
				local x, y = physicsToWorldTransform(v.x, v.y)
				local x1, y1 = x - w, y - h
				local x2, y2 = x + w, y + h
				setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, v.spritePivotX, v.spritePivotY)
				drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
			end

			
			
			-- XXX: ADD TO OTHERS
			if(v.definition and v.sprite ~= "") then
				local blockDef = blockTable.blocks[v.definition]
		
				local w, h = _G.res.getSpriteBounds("", v.sprite)

				w, h = w*0.5, h*0.5
				local x, y = physicsToWorldTransform(v.x, v.y)
				local x1, y1 = x - w, y - h
				local x2, y2 = x + w, y + h
				
				
				
				if(blockDef.type == "circle") then
					local radius = blockDef.radius or _G.math.max(worldToPhysicsTransform(w,0),worldToPhysicsTransform(h,0))
					drawCircle(x,y,radius, v.angle,255,255,255,255,4)
					
				elseif (blockDef.type == "box" and blockDef.width ~= nil) then
					local ww, hh = physicsToWorldTransform(blockDef.width, blockDef.height) 
					local x1, y1 = x - ww / 2, y - hh / 2
					local x2, y2 = x + ww / 2, y + hh / 2
					
					local pivX = v.spritePivotX / (w * 2) 
					local pivY = v.spritePivotY / (h * 2)
					
					drawWireFrameRect(x1,y1,x2,y2,3,true,0,255,255,190,v.angle,pivX,pivY)
				
				elseif(blockDef.type == "box" and blockDef.width == nil) then
					local w, h = _G.res.getSpriteBounds("", v.sprite)
					w, h = w * 0.5, h * 0.5
					local x, y = physicsToWorldTransform(v.x, v.y)
					local x1, y1 = x - w, y - h
					local x2, y2 = x + w, y + h
					--setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, v.spritePivotX, v.spritePivotY)
					--drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
					drawWireFrameRect(x1,y1,x2,y2,3,true,0,255,255,190,v.angle,pivX,pivY)
				
				elseif (blockDef.type == "polygon" and blockDef.vertices) then
					local points = {}

					for kk,vv in _G.pairs(blockDef.vertices) do
						local wx,wy = w * 2 * vv.x, h * 2 * vv.y 
						local point = {x + wx - w, y + wy - h}
						_G.table.insert(points,point)
					end					
					drawPolygon(points,3, true,255,255,255,255,v.angle,0.5,0.5)
				end				
			end

			-- XXX: ADD TO OTHERS
			if v.strength ~= nil and v.sprite ~= nil and v.strength ~= blockTable.blocks[v.definition].strength and v.sprite ~= "" then
				local w, h = _G.res.getSpriteBounds("", v.sprite)
				w ,h = w * 0.50, h * 0.50
				local x, y = physicsToWorldTransform(v.x, v.y)
				local x1, y1 = x - w, y - h
				local x2, y2 = x + w, y + h 
				
				setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, v.spritePivotX, v.spritePivotY)
				
				drawLine(0,0,255,155,x1,y1,x2,y1,true,4)
				drawLine(0,0,255,155,x1,y1,x1,y2,true,4)
				setRenderState(-screen.left , -screen.top , wScale, wScale, v.angle, v.spritePivotX, -v.spritePivotY)
				drawLine(0,0,255,155,x1,y2,x2,y2,true,4)
				setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, -v.spritePivotX , v.spritePivotY )
				drawLine(0,0,255,155,x2,y1,x2,y2,true,4)
			end
			
			-- XXX: ADD TO OTHERS
			if(selectedObjects ~= nil and #selectedObjects == 1 and selectedObjects[1] == v) then			
				drawDummyCollisionBox(v)
			end
		end
	end	

	-- setRenderState(-screen.left, -screen.top, wScale, wScale, 0, 0, 0)
	-- drawRect( 1, 0, 0, 1, tapPosWorld.x - 3, tapPosWorld.y - 3, tapPosWorld.x + 3, tapPosWorld.y + 3, true)
	

	--_G.res.drawString("TEXTS_BASIC", "cp.x: " .. cursorPhysics.x .. " - cp.y: " .. cursorPhysics.y, cursor.x, cursor.y, "BOTTOM", "HCENTER")
	--_G.res.drawString("TEXTS_BASIC", "cw.x: " .. cursorWorld.x .. " - cw.y: " .. cursorWorld.y, cursor.x, cursor.y+20, "BOTTOM", "HCENTER")
	-- if cameraTargetObject ~= nil then
		-- wx, wy = physicsToWorldTransform(cameraTargetObject.x, cameraTargetObject.y)
		-- sx = wx
		-- sy = wy
		-- tlx = sx - screenWidth * 0.5
		-- tly = sy - screenHeight * 0.5
		-- tx = screen.left
		-- ty = screen.top
		-- _G.res.drawString("TEXTS_BASIC", "s: (" .. sx .. " - " .. sy .. ")", 0, 30, "TOP", "LEFT")
		-- _G.res.drawString("TEXTS_BASIC", "target: (" .. tlx .. " - " .. tly .. ")", 0, 50, "TOP", "LEFT")
		-- _G.res.drawString("TEXTS_BASIC", "topleft: (" .. tx .. " - " .. ty .. ")", 0, 70, "TOP", "LEFT")
	-- end
	setRenderState(0, 0, 1, 1, 0)
	
	oldZoomLevel = zoomLevel
	
	if deviceModel == "android" and isBetaVersion and currentGameMode == updateGame and #birdTutorialPopups == 0 then
		_G.res.drawSprite("MENU_LITEBETA_1", "BETA_BOTTOM_RIGHT", screenWidth, screenHeight)
	end
	
	if objects.world["MightyEagle_a"] ~= nil then
		local eagle = objects.world["MightyEagle_a"]
		if eagle.targetX > eagle.x then
			eagleDarkness = (100 - _G.math.min(_G.math.max(_G.math.abs(eagle.targetX - eagle.x), 0), 100)) / 200
		end
	end	
	if eagleDarkness ~= nil then
		drawRect( 0, 0, 0, eagleDarkness, 0, 0, screenWidth, screenHeight, false)
	end

	if popupPage ~= nil then
		drawMenuPage(popupPage)
	end
	
	
	if showCameraDebugData then
		local bcd = objects.birdCameraData[deviceModel]
		local ccd = objects.castleCameraData[deviceModel]
		local swx = screenWidth * 0.5 / tempScreen.scale
		local swy = screenHeight * 0.5 / tempScreen.scale
		
		setRenderState(-screen.left, -screen.top, wScale, wScale, 0, 0, 0)
		drawLine2D(bcd.px, bcd.py, ccd.px, ccd.py, 3, 48, 23, 8, 255)
		drawLine2D(animationScreen.x, animationScreen.y-15, animationScreen.x, animationScreen.y+15, 3, 48, 23, 8, 255)
		drawRectLines(visualizeScreen.x-swx, visualizeScreen.y-swy, visualizeScreen.x+swx, visualizeScreen.y+swy, 3, 255, 255, 255, 255)
		
		drawLine2D(leftLimit, -500, leftLimit, 50, 3, 255, 23, 8, 255)
		drawLine2D(rightLimit, -500, rightLimit, 50, 3, 255, 23, 8, 255)
		
		drawLine2D(leftLimit, groundLimit, rightLimit, groundLimit, 3, 255, 23, 8, 255)
		
		setRenderState(0, 0, 1, 1, 0)

		
		screen.x = tempScreen.x 
		screen.y = tempScreen.y
		screen.left = tempScreen.left
		screen.right = tempScreen.right
		screen.top = tempScreen.top
		screen.bottom = tempScreen.bottom
		worldScale	= tempScreen.scale
		
		setWorldScale(worldScale)
	end
	
	--[[ BEGIN FPS DEBUG CODE -- 
	if drawFPSStatistics then
		local FPSMinStr = String
		_G.res.drawString("", _G.string.format("FPSMin: %.1f", FPSMin), 0, screenHeight-60, "BOTTOM", "LEFT")
		_G.res.drawString("", _G.string.format("FPSAvg: %.1f", FPSFrames/FPSTime), 0, screenHeight-30, "BOTTOM", "LEFT")
		_G.res.drawString("", _G.string.format("FPSMax: %.1f", FPSMax), 0, screenHeight, "BOTTOM", "LEFT")
	end
	-- END FPS DEBUG CODE --]]
end


function drawEditor()
	
	local wScale = worldScale
	
	setRenderState(0, 0, 1, 1, 0)
	
	if editor.drawOneLayer then
		drawLayer(editor.currentLayer)				
		
		--draws selected objects on current layer
		for k, v in _G.pairs(selectedObjects) do										
			if v.definition ~= nil and v.definition ~= "" then
				local w, h = _G.res.getSpriteBounds("", blockTable.blocks[v.definition].sprite)
				w, h = w * v.scale.x, h * v.scale.y
				w, h = w * 0.5, h * 0.5
				local x, y = physicsToWorldTransform(v.x, v.y)
				local x1, y1 = x - w, y - h
				local x2, y2 = x + w, y + h
				local t_pivotX, t_pivotY = _G.res.getSpritePivot("", blockTable.blocks[v.definition].sprite)
				t_pivotX, t_pivotY = t_pivotX * v.scale.x, t_pivotY * v.scale.y
				--setRenderState(-screen.left, -screen.top, worldScale, worldScale, 0, 0, 0)
				setRenderState(	-screen.left, -screen.top, worldScale, worldScale, 
								v.angle, t_pivotX, t_pivotY)
				drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
			end			
		end
		
		if copiedObjects ~= nil then
			-- for k, v in _G.pairs(copiedObjects) do
				-- local sprite = blockTable.blocks[v.definition].sprite
				-- setRenderState(-screen.left / v.scale.x, -screen.top / v.scale.y, worldScale * v.scale.x, worldScale * v.scale.y, v.angle, res.getSpritePivot("", sprite))
				
				-- local x, y = physicsToWorldTransform(v.x + cursorPhysics.x, v.y + cursorPhysics.y)
				
				-- x, y = x / v.scale.x, y / v.scale.y
				
				-- res.drawSprite("", sprite, _G.math.floor(x), _G.math.floor(y))
			-- end
			for k, v in _G.pairs(copiedObjects) do
				local sprite = blockTable.blocks[v.definition].sprite
				local blockDefScale = blockTable.blocks[v.definition].scale or 1
				local pivotX, pivotY = 0, 0
				local flip = 1
				if blockTable.blocks[v.definition].horFlip then
					flip = -flip
				end

				pivotX, pivotY = _G.res.getSpritePivot(sprite)
				--setRenderState(-screen.left, -screen.top, worldScale * v.scale.x, worldScale * v.scale.y, v.angle, res.getSpritePivot("", sprite))
				setRenderState(flip * -screen.left / (v.scale.x * blockDefScale), -screen.top / (v.scale.y * blockDefScale), flip * worldScale * v.scale.x, worldScale * v.scale.y, flip * v.angle, pivotX, pivotY)
				
				local x, y = physicsToWorldTransform(v.x + cursorPhysics.x, v.y + cursorPhysics.y)
				
				x, y = flip * x / v.scale.x, y / v.scale.y
				
				_G.res.drawSprite(sprite, _G.math.floor(x), _G.math.floor(y))
			end
			setRenderState(0, 0, 1, 1, 0)
		end		
		
		setRenderState(0, 0, 1, 1, 0)	
		
	else
		--this call will draw all in game elements
		drawGame()
	end
	
	
	setRenderState(0, 0, 1, 1, 0)
	_G.res.drawString("TEXTS_BASIC", levelName, 0, 0, "TOP", "LEFT")

	if selectionRectActive then
		local x1, y1 = draggingStartPosWorld.x, draggingStartPosWorld.y
		local x2, y2 = cursorWorld.x, cursorWorld.y
		if x1 > x2 then	x1, x2 = x2, x1	end
		if y1 > y2 then	y1, y2 = y2, y1	end
		setRenderState(-screen.left, -screen.top, wScale, wScale, 0)
		drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
	end		

	setRenderState(0, 0, 1, 1, 0)
	if not editor.drawOneLayer then
		for k, v in _G.pairs(objects.joints) do
			drawJoint(v, "EDITOR_JOINT")
		end
	end
	
	if selectedObjects[1] ~= nil then
		if selectedObjects[1].controllable then
			if selectedObjects[1].startNumber ~= nil then
				_G.res.drawString("TEXTS_BASIC", "Start: " .. selectedObjects[1].startNumber, 0, 35, "TOP", "LEFT")
			end
		end
	end

	for k, v in _G.pairs(selectedObjects) do
		if v.sprite ~= nil and v.sprite ~= "" then
			local w, h = _G.res.getSpriteBounds("", v.sprite)
			w, h = w*0.5, h*0.5
			local x, y = physicsToWorldTransform(v.x, v.y)
			local x1, y1 = x - w, y - h
			local x2, y2 = x + w, y + h
			setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, v.spritePivotX, v.spritePivotY)
			drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
		end
	end
	
	if physicsEnabled then
		for k, v in _G.pairs(objects.world) do
			if v.sleeping == true and v.sprite ~= "" then
				local w, h = _G.res.getSpriteBounds("", v.sprite)
				w, h = w*0.5, h*0.5
				local x, y = physicsToWorldTransform(v.x, v.y)
				local x1, y1 = x - w, y - h
				local x2, y2 = x + w, y + h
				setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, v.spritePivotX, v.spritePivotY)
				drawRect(1, 0, 0, 0.5, x1, y1, x2, y2, true)
			end
		end
	end
	
	-- Draw small rect to indicate origin
	if keyHold["O"] then
		setRenderState(-screen.left*wScale, -screen.top*wScale, 1, 1, 0, 0, 0)
	else
		setRenderState(-screen.left, -screen.top, wScale, wScale, 0, 0, 0)
	end
	_G.res.drawSprite("", "ORIGO", 0, 0)
	setRenderState(0, 0, 1, 1, 0)

	if objectToAdd ~= nil then
		local sprite = blockTable.blocks[objectToAdd].sprite
		setRenderState(-screen.left, -screen.top, wScale, wScale, objectToAddAngle, _G.res.getSpritePivot("", sprite))
		_G.res.drawSprite("", sprite, _G.math.floor(cursorWorld.x), _G.math.floor(cursorWorld.y))
		setRenderState(0, 0, 1, 1, 0)
	end
	
	if not editor.drawOneLayer then
		if copiedObjects ~= nil then
			-- for k, v in _G.pairs(copiedObjects) do
				-- local sprite = objects.world[v.name].sprite
				-- setRenderState(-screen.left, -screen.top, wScale, wScale, v.angle, _G.res.getSpritePivot("", sprite))
				-- local x, y = physicsToWorldTransform(v.x + cursorPhysics.x, v.y + cursorPhysics.y)
				-- _G.res.drawSprite("", sprite, _G.math.floor(x), _G.math.floor(y))
			-- end
			for k, v in _G.pairs(copiedObjects) do
				local sprite = objects.world[v.name].sprite
				local blockDefScale = blockTable.blocks[v.definition].scale or 1
				local pivotX, pivotY = 0, 0
				local flip = 1
				if blockTable.blocks[v.definition].horFlip then
					flip = -flip
				end
				pivotX, pivotY = _G.res.getSpritePivot(sprite)
				setRenderState(flip * -screen.left / blockDefScale, -screen.top / blockDefScale, flip * worldScale * blockDefScale, worldScale * blockDefScale, flip * v.angle, pivotX, pivotY)
				local x, y = physicsToWorldTransform(v.x + cursorPhysics.x, v.y + cursorPhysics.y)
				x, y = flip * x / blockDefScale, y / blockDefScale
				_G.res.drawSprite(sprite, _G.math.floor(x), _G.math.floor(y))
			end
			
			setRenderState(0, 0, 1, 1, 0)
		end
		
		if levelSaved then
			_G.res.drawSprite("", "EDITOR_SAVED", screenWidth, 0)
		else
			_G.res.drawSprite("", "EDITOR_NOT_SAVED", screenWidth, 0)
		end

		if physicsEnabled then
			_G.res.drawSprite("", "EDITOR_PHYSICS_ON", screenWidth, 0)
		else
			_G.res.drawSprite("", "EDITOR_PHYSICS_OFF", screenWidth, 0)
		end

		if objects.castleCameraData and objects.castleCameraData[deviceModel] then
			_G.res.drawSprite("", "EDITOR_C_CAMERA_ON", screenWidth, 0)
		else
			_G.res.drawSprite("", "EDITOR_C_CAMERA_OFF", screenWidth, 0)
		end

		if objects.birdCameraData and objects.birdCameraData[deviceModel] then
			_G.res.drawSprite("", "EDITOR_B_CAMERA_ON", screenWidth, 0)
		else
			_G.res.drawSprite("", "EDITOR_B_CAMERA_OFF", screenWidth, 0)
		end
		
		if objects.doNotWaitForMovingObjects ~= nil then
			_G.res.drawString("", "QUICK END", screenWidth, screenHeight, "BOTTOM", "RIGHT")
		end
	end

end

function drawJoint(joint, sprite)
	if joint.x1 == nil then
		return
	end
	
	local jointWorldX1 = joint.x1
	local jointWorldY1 = joint.y1
	local jointWorldX2 = joint.x2
	local jointWorldY2 = joint.y2
	
	if joint.coordType == 2 then
		jointWorldX1, jointWorldY1 = getWorldPoint(joint.end1, jointWorldX1, jointWorldY1);
		jointWorldX2, jointWorldY2 = getWorldPoint(joint.end2, jointWorldX2, jointWorldY2);
	end
	
	local xdif = jointWorldX2 - jointWorldX1
	local ydif = jointWorldY2 - jointWorldY1
	local tlen = vLength(xdif, ydif)
	local x = 0
	local y = 0

	--print(k .. " " .. tlen .. " " .. vLength(x, y) .."\n")
	if tlen == 0 then
		return
	end

	local vlen = 0
	while vlen <= tlen do
		sx, sy = physicsToScreenTransform(jointWorldX1 + x, jointWorldY1 + y )
		_G.res.drawSprite("", sprite, sx, sy)
		x = x + xdif * 0.13
		y = y + ydif * 0.13
		vlen = vLength(x, y)
		--print("vlen: " .. vlen .. " tlen: " .. tlen .. "\n")
	end
end

-------------------------------------------------------------------------------
-- Cameras 

function defaultCamera(dt)
	screen.left = screen.x - screenWidth * 0.5 / worldScale
	screen.top = screen.y - screenHeight * 0.5 / worldScale
	screen.right = screen.x + screenWidth * 0.5 / worldScale
	screen.bottom = screen.y + screenHeight * 0.5 / worldScale
	
	--print("left : " .. screen.left .. ", top: " .. screen.top .. "\n")
	--print("right: " .. screen.right .. ", bottom: " .. screen.bottom .. "\n")
	--print("Scale: " .. worldScale .. "\n")
	
	setTopLeft(screen.left + cameraShakeX, screen.top + cameraShakeY)
end


--kamera
--stay on the current target
--if target changes move to the new target using given speed
--keep the defined objects visible if possible by current restraints

function getTempBirdCamera()
	local tempCamera = {}
	
	local bcd = objects.birdCameraData[deviceModel]
	local ccd = objects.castleCameraData[deviceModel]
	
	-- use current zoom (user defined) if camera is not zoomed in at max level defined by current camera
	if maxZoomLevel == true then	
		tempCamera.sx = bcd.sx
	else
		tempCamera.sx = currentZoomedScale
	end
	
	if tempCamera.sx > bcd.sx then
		tempCamera.sx = bcd.sx
	end
	if tempCamera.sx < minWorldScale then
		tempCamera.sx = minWorldScale
	end
	
	tempCamera.py = bcd.py	
	local alpha = (tempCamera.sx - minWorldScale) / (bcd.sx - minWorldScale)
	--print("alpha: " .. alpha .. "\n")
	tempCamera.py = bcd.py * alpha + ccd.py * (1 - alpha)

	local groundPos = tempCamera.py + screenHeight * 0.5 / tempCamera.sx 
	if groundPos > groundLimit then
		tempCamera.py = tempCamera.py + (groundLimit - groundPos)
	end
	
	local leftPos = bcd.px - screenWidth * 0.5 / tempCamera.sx 
	tempCamera.px = bcd.px
	if leftPos < leftLimit then
		tempCamera.px = bcd.px + (leftLimit - leftPos)
	end	
	
	return tempCamera
end


function getTempCastleCamera()
	local tempCamera = {}
	local ccd = objects.castleCameraData[deviceModel]
		
	-- use current zoom (user defined) if camera is not zoomed in at max level defined by current camera
	if maxZoomLevel == true then		
		tempCamera.sx = ccd.sx
	else
		tempCamera.sx = currentZoomedScale
	end
	
	if tempCamera.sx > ccd.sx then
		tempCamera.sx = ccd.sx
	end
	if tempCamera.sx < minWorldScale then
		tempCamera.sx = minWorldScale
	end
	
	local groundPos = ccd.py + screenHeight * 0.5 / tempCamera.sx
	tempCamera.py = ccd.py
	if groundPos > groundLimit then
		tempCamera.py = ccd.py + (groundLimit - groundPos)
	end
		
	local rightPos = ccd.px + screenWidth * 0.5 / tempCamera.sx 
	tempCamera.px = ccd.px
	if rightPos > rightLimit then
		tempCamera.px = ccd.px + (rightLimit - rightPos)
	end
	
	return tempCamera
end

useLevelLimits = true
function doItAllCamera(dt)
	--print(currentFrame .. " doItAllCamera camera\n")

	local ccd = objects.castleCameraData[deviceModel]
	local bcd = objects.birdCameraData[deviceModel]
	
	-- do not allow to zoom beyond level limits
	-- if zoomLevel + bcd.sx < minWorldScale and zoomLevel + ccd.sx < minWorldScale then
		-- zoomLevel = oldZoomLevel
	-- end
	
	-- Zoom level has changed
	if oldZoomLevel ~= zoomLevel then
		maxZoomLevel = false
		currentZoomedScale = currentZoomedScale + zoomLevel - oldZoomLevel
		-- if current zoomed scale is bigger than the current target camera set the scale to the camera scale
		if cameraAnimationSliderTarget == 0 then
			if currentZoomedScale >= bcd.sx then
				currentZoomedScale = bcd.sx
				maxZoomLevel = true
			end
		else
			if currentZoomedScale >= ccd.sx then
				currentZoomedScale = ccd.sx
				maxZoomLevel = true
			end
		end
		if currentZoomedScale < minWorldScale then
			currentZoomedScale = minWorldScale
		end
		oldZoomLevel = zoomLevel
		animationWorldScale = currentZoomedScale
	end	
	
	local bcdt = getTempBirdCamera()
	local ccdt = getTempCastleCamera()
	
	if ccd ~= nil and bcd ~= nil then
		local springFactor = dt * 3.5
		local scaleFactor = screenWidth / ccd.screenWidth
		local screenTemp = { x = 0, y = 0 }
		local dx = ccdt.px - bcdt.px
		
		if dx < 1 then dx = 1 end
		
		animateScale = true
		-- camera left boundary limit
		if cameraAnimationSlider < 0 then
			cameraAnimationSlider = cameraAnimationSlider - cameraAnimationSlider * 0.3
			if cameraAnimationSlider < -0.01 then
				animateScale = false
			end
			forceSprings = true
			sweepSpeed = 0
		end

		-- camera right boundary limit
		if cameraAnimationSlider > 1 then
			cameraAnimationSlider = cameraAnimationSlider + (1-cameraAnimationSlider) * 0.3
			if cameraAnimationSlider > 1.01 then
				animateScale = false
			end
			forceSprings = true
			sweepSpeed = 0
		end
		
		-- choose closest camera
		if cameraAnimationSlider > 0 and cameraAnimationSlider < 1 and sweepSpeed == 0 then
			forceSprings = false
			if cameraAnimationSlider < 0.5 then
				cameraAnimationSliderTarget = 0
			else
				cameraAnimationSliderTarget = 1
			end
		end
		
		-- animate camera without target
		if cameraTargetObject == nil then
			--print(currentFrame .. " Camera target object is nil\n")
			if not keyHold["LBUTTON"] and sweepSpeed == 0 then
				cameraAnimationSlider = cameraAnimationSlider + (cameraAnimationSliderTarget-cameraAnimationSlider) * 0.3
				--print("LButton and sweepSpeed\n")
			else
				if forceSprings ~= true then
					springFactor = 1
				end
			end
		
			--print("before cameraAnimationSlider: " .. cameraAnimationSlider .. " sweepSpeed: " .. sweepSpeed .. " cameraAnimationSliderTarget: " .. cameraAnimationSliderTarget .. " dt: " .. dt .. " dx: " .. dx .. "\n")
			--print("Before animationWorldScale: " .. animationWorldScale .. " animationScreen.x: " .. animationScreen.x .. " animationScreen.y: " .. animationScreen.y .. "\n")
			cameraAnimationSlider = cameraAnimationSlider - dt * sweepSpeed / (dx * bcd.sx) -- * worldScale)
			local tsx = bcdt.sx + (ccdt.sx - bcdt.sx) * cameraAnimationSlider
			local tpx = bcdt.px + (ccdt.px - bcdt.px) * cameraAnimationSlider
			local tpy = bcdt.py + (ccdt.py - bcdt.py) * cameraAnimationSlider			
			animationScreen.x = animationScreen.x - (animationScreen.x - tpx) * springFactor
			animationScreen.y = animationScreen.y - (animationScreen.y - tpy) * springFactor
			if animateScale == true then
				animationWorldScale = animationWorldScale - (animationWorldScale - tsx) * springFactor
			end
			if maxZoomLevel == true then
				currentZoomedScale = animationWorldScale
			end
			--print("After animationWorldScale: " .. animationWorldScale .. " animationScreen.x: " .. animationScreen.x .. " animationScreen.y: " .. animationScreen.y .. "\n")
			
			--print("after cameraAnimationSlider: " .. cameraAnimationSlider .. " sweepSpeed: " .. sweepSpeed .. " cameraAnimationSliderTarget: " .. cameraAnimationSliderTarget .. " dt: " .. dt .. " dx: " .. dx .. "\n")			
			--print("castle camera phase2 cas: " .. cameraAnimationSlider .. "\n")
			
			-- set the current values
			screen.x = animationScreen.x
			screen.y = animationScreen.y
			
			worldScale = animationWorldScale
			setWorldScale(worldScale)
			repositionScreen()
		end
	
		----[[
		if cameraTargetObject ~= nil then
			--print(currentFrame .. " Camera target object is " .. cameraTargetObject.name .. "\n")
			-- camera target x, y
			--print("castle camera phase1 cas: " .. cameraAnimationSlider .. "\n")	
			local ctx, cty = physicsToWorldTransform(cameraTargetObject.x, cameraTargetObject.y)
			if cameraTargetObject.xVel > 0 then
				cameraAnimationSlider = cameraAnimationSlider + cameraTargetObject.xVel * physicsToWorld * dt * 10 / dx
			end
			if cameraAnimationSlider > 1 then
				cameraAnimationSlider = 1
			end
			
			--print("cameraAnimationSlider: " .. cameraAnimationSlider .. "\n")
			
			-- current animation targets based on the bird velocity
			local tsx = bcdt.sx + (ccdt.sx - bcdt.sx) * cameraAnimationSlider
			local tpx = bcdt.px + (ccdt.px - bcdt.px) * cameraAnimationSlider
			local tpy = bcdt.py + (ccdt.py - bcdt.py) * cameraAnimationSlider
			
			animationWorldScale = animationWorldScale - (animationWorldScale - tsx) * springFactor
			animationScreen.x = animationScreen.x - (animationScreen.x - tpx) * springFactor
			animationScreen.y = animationScreen.y - (animationScreen.y - tpy) * springFactor		

			-- camera x, y
			local cleft = animationScreen.x - screenWidth * 0.5 / animationWorldScale
			local ctop = animationScreen.y - screenHeight * 0.5 / animationWorldScale
			local cright = animationScreen.x + screenWidth * 0.5 / animationWorldScale
			local cbottom = animationScreen.y + screenHeight * 0.5 / animationWorldScale

			local minx = _G.math.min(cleft, ctx - 50)
			local miny = _G.math.min(ctop, cty - 50)
			local maxx = _G.math.max(cright, ctx + 50)
			local maxy = _G.math.max(cbottom, cty + 50)
			
			if useLevelLimits then
				minx = _G.math.max(leftLimit, minx)
				maxx = _G.math.min(rightLimit, maxx)
			end
			
			--print("animation xy: " .. animationScreen.x .. ", " .. animationScreen.y .. "\n")
			--print("camera tl: " .. cleft .. ", " .. ctop .. "\n")
			--print("camera br: " .. cright .. ", " .. cbottom .. "\n")
			--print("ct: " .. ctx .. ", " .. cty .. "\n")
			--print("min: " .. minx .. ", " .. miny .. "\n")
			--print("max: " .. maxx .. ", " .. maxy .. "\n")

			local xScale = _G.math.abs(screenWidth/(maxx-minx))
			local yScale = _G.math.abs(screenHeight/(maxy-miny))
			
			local worldScaleTemp = _G.math.min(xScale, yScale) * scaleFactor
			--print("worldScaleTemp: " .. worldScaleTemp .. " animws: " .. animationWorldScale .. "\n")

			-- scale is never closer than the animation to castle camera's scale
			if worldScaleTemp > animationWorldScale then
				worldScaleTemp = animationWorldScale
				--print("worldScaleTemp = animationWorldScale.\n")
			end
			--print("worldScaleTemp: " .. worldScaleTemp .. "\n")
			
			screenTemp.x = (maxx + minx) * 0.5
			screenTemp.y = (maxy + miny) * 0.5

			if useLevelLimits then								
				-- if y scale is smaller we need to check that x coordinates stay inside the boundaries
				local limitsReached = false
				if (screenTemp.x + screenWidth * 0.5 / worldScaleTemp) > rightLimit then
					maxx = rightLimit
					minx = maxx - screenWidth / worldScaleTemp
					limitsReached = true
					if minx < leftLimit then
						minx = leftLimit
					end
					--print("Limits reached 1\n")
				end
				if (screenTemp.x - screenWidth * 0.5 / worldScaleTemp) < leftLimit then
					minx = leftLimit
					maxx = minx + screenWidth / worldScaleTemp
					limitsReached = true
					if maxx > rightLimit then
						maxx = rightLimit
					end
					--print("Limits reached 1\n")
				end
				if limitsReached then
					screenTemp.x = (maxx + minx) * 0.5
					worldScaleTemp = _G.math.abs(screenWidth/(maxx-minx)) * scaleFactor 
					--print("new worldScaleTemp: " .. worldScaleTemp .. "\n")
					--print("screenWidth: " .. screenWidth .. "\n")
					--print("min: " .. minx .. ", " .. miny .. "\n")
					--print("max: " .. maxx .. ", " .. maxy .. "\n")
				end
			end
			
			screen.x = screen.x - (screen.x - screenTemp.x) * springFactor
			animationWorldScale2 = animationWorldScale2 - (animationWorldScale2 - worldScaleTemp) * springFactor
			worldScale = animationWorldScale2
			--print("worldScale: " .. worldScale .. " worldScaleTemp: " .. worldScaleTemp .. "\n")
			
			-- if useLevelLimits then								
				-- maxy = groundLimit
				-- miny = maxy - screenHeight / worldScale
				-- screenTemp.y = (maxy + miny) * 0.5				
			-- end
			
			screen.y = screen.y - (screen.y - screenTemp.y) * springFactor
			
			forceSprings = true
			
			if ctx >= rightLimit or ctx <= leftLimit then
				animationWorldScale = worldScale
				animationScreen.x = screen.x
				animationScreen.y = screen.y
				-- print("animationWorldScale: " .. animationWorldScale .. " animationScreen.x: " .. animationScreen.x .. " animationScreen.y: " .. animationScreen.y .. "\n")
				--print("Camera target object outside level limits\n")
				cameraTargetObject = nil
			end
			
			-- flyCameraData.px = screen.x
			-- flyCameraData.py = screen.y
			-- flyCameraData.sx = worldScale
			-- flyCameraData.sy = worldScale
			-- flyCameraData.left = screen.x - screenWidth * 0.5 / worldScale
			-- flyCameraData.right = screen.x + screenWidth * 0.5 / worldScale
			-- flyCameraData.top = screen.y - screenHeight * 0.5 / worldScale
			-- flyCameraData.bottom = screen.y + screenHeight * 0.5 / worldScale
			
			--print("min: " .. minx .. ", " .. miny .. "\n")
			--print("max: " .. maxx .. ", " .. maxy .. "\n")
			
			setWorldScale(worldScale)
			repositionScreen()			
		end
		--]]		
	end
	defaultCamera(dt)
end

function returnToBirdCamera()
	showTapIcon = false
	showTapTimer = 0
	cameraFunction = doItAllCamera
	sweepSpeed = objects.castleCameraData[deviceModel].px - objects.birdCameraData[deviceModel].px
	cameraAnimationSliderTarget = 0
	if cameraAnimationSlider >= 1 then
		cameraAnimationSlider = 1
	end
	allowResetToBirdCamera = false
	cameraTargetObject = nil
	flyingBird = nil
end

function repositionScreen()
	local ccd = objects.castleCameraData[deviceModel]
	local bcd = objects.birdCameraData[deviceModel]
		
	-- scale is too big, limit the scale
	if worldScale < minWorldScale then
		worldScale = minWorldScale
		setWorldScale(worldScale)
		--print("Forced scale to minWorldScale.\n")
	end
	
	if showCameraDebugData then
		visualizeScreen.x = screen.x
		visualizeScreen.y = screen.y
	end
	
	local groundPos = screen.y + screenHeight * 0.5 / worldScale 
	if groundPos > groundLimit then
		screen.y = screen.y + (groundLimit - groundPos)
	end
		
	local rightPos = screen.x + screenWidth * 0.5 / worldScale 
	if rightPos > rightLimit then
		screen.x = screen.x + (rightLimit - rightPos)
	end	

	local leftPos = screen.x - screenWidth * 0.5 / worldScale 
	if leftPos < leftLimit then
		screen.x = screen.x + (leftLimit - leftPos)
	end
end

function levelStartCamera(dt)
	--print("Level start camera\n")
	local ccd = objects.castleCameraData[deviceModel]
	local bcd = objects.birdCameraData[deviceModel]

	if castleCameraTimer < 2 then
		local wx, wy = ccd.px, ccd.py
		if levelRestartedFrom == nil or startedFromEditor then
			worldScale = ccd.sx
		else
			worldScale  = getTempCastleCamera().sx
		end
		setWorldScale(worldScale)
		screen.x = wx
		screen.y = wy
		castleCameraTimer = castleCameraTimer + dt
		animationWorldScale = worldScale
		animationScreen.x = screen.x
		animationScreen.y = screen.y		
		
		if levelRestartedFrom ~= nil or startedFromEditor ~= true then
			repositionScreen()
		end
		
		defaultCamera(dt)
		return
	end

	castleCameraTimer = 0
	cameraAnimationSlider = 1
	cameraAnimationSliderTarget = 0
	sweepSpeed = ccd.px - bcd.px
	showTapIcon = false
	--print("levelStartCamera: cameraFunction = doItAllCamera\n")	
	cameraFunction = doItAllCamera
	animationScreen.x = screen.x
	animationScreen.y = screen.y
	animationWorldScale = worldScale	
	defaultCamera(dt)
end

function gotoCastleCamera(dt)
	if objects.birdCameraData[deviceModel] ~= nil then
		local ccd = objects.castleCameraData[deviceModel]
		local wx, wy = ccd.px, ccd.py
		local springFactor = dt * 4

		animationWorldScale = animationWorldScale - (animationWorldScale - ccd.sx) * springFactor
		animationScreen.x = animationScreen.x - (animationScreen.x - wx) * springFactor
		animationScreen.y = animationScreen.y - (animationScreen.y - wy) * springFactor
		
		cameraAnimationSliderTarget = 1
		cameraAnimationSlider = 1
		screen.x = animationScreen.x
		screen.y = animationScreen.y
		worldScale = animationWorldScale
		setWorldScale(worldScale)		
		
		--[[if _G.math.abs(worldScale - ccd.sx) < 0.05 and
			_G.math.abs(screen.x - wx) < 5 and
			_G.math.abs(screen.y - wy) < 5 then
			worldScale = ccd.sx
			setWorldScale(worldScale)
			screen.x = wx
			screen.y = wy
			--cameraFunction = defaultCamera
			--castleCameraTimer = 0
			--cameraAnimationSlider = 0
		end--]]
	end
	--doItAllCamera(dt)
	defaultCamera(dt)
end

function launchCamera(dt)
	--print("launch camera\n")

	if castleCameraTimer < 3 then
		castleCameraTimer = castleCameraTimer + dt
		defaultCamera(dt)
		return
	end
	
	if objects.birdCameraData and objects.birdCameraData[deviceModel] ~= nil then
		local ccd = objects.castleCameraData[deviceModel]
		local bcd = objects.birdCameraData[deviceModel]
		local wx, wy = bcd.px, bcd.py
		local springFactor = dt * 4

		animationWorldScale = animationWorldScale - (animationWorldScale - bcd.sx) * springFactor
		animationScreen.x = animationScreen.x - (animationScreen.x - wx) * springFactor
		animationScreen.y = animationScreen.y - (animationScreen.y - wy) * springFactor
		
		cameraAnimationSlider = (bcd.px - animationScreen.x)/(bcd.px - ccd.px)
		--print("bird camera cas: " .. cameraAnimationSlider .. "\n")		
		screen.x = animationScreen.x
		screen.y = animationScreen.y
		worldScale = animationWorldScale
		setWorldScale(worldScale)		

		-- worldScale = bcd.sx + (ccd.sx - bcd.sx) * cameraAnimationSlider
		-- screen.x = bcd.px + (ccd.px - bcd.px) * cameraAnimationSlider
		-- screen.y = bcd.py + (ccd.py - bcd.py) * cameraAnimationSlider
		-- setWorldScale(worldScale)

		if _G.math.abs(worldScale - ccd.sx) < 0.05 and
			_G.math.abs(screen.x - wx) < 5 and
			_G.math.abs(screen.y - wy) < 5 then
			worldScale = bcd.sx
			setWorldScale(worldScale)
			screen.x = wx
			screen.y = wy
			cameraFunction = defaultCamera
			castleCameraTimer = 0
			cameraAnimationSlider = 0
			--print("Launch camera in place!\n")
		end
	end
	defaultCamera(dt)
end


-------------------------------------------------------------------------------
-- The Others

function setPositions(xadd, yadd)
	for k, v in _G.pairs(selectedObjects) do
		setPosition(v.name, v.x + xadd*physicsScale, v.y + yadd*physicsScale)
		setSleeping(v.name, false)
	end
	levelSaved = false
end

-- scale update, when animated or user controlled
function updateScale()
	if oldScale ~= worldScale then
		local wx = cursor.x / oldScale + screen.left
		local wy = cursor.y / oldScale + screen.top
		local newx = (wx * worldScale - cursor.x) / worldScale
		local newy = (wy * worldScale - cursor.y) / worldScale

		screen.x = newx + screenWidth * 0.5 / worldScale
		screen.y = newy + screenHeight * 0.5 / worldScale
	end
	oldScale = worldScale
end


function birdCollision(object1, object2, force, damage)
	local obj1 = objects.world[object1]
	local obj2 = objects.world[object2]
	
	-- update score
	if obj1.controllable and damage > 0 then
		local bird = obj1
		
		local resultDamage = damage * 10
		_G.table.insert(floatingScores, { x = bird.x, y = bird.y, text = "" .. resultDamage, score = resultDamage, time = 0, lifetime = 0.6, maxScale = floatingScoreScaling * (0.25 + resultDamage / 3000), xs = 0 } )

		if scoreTable[object1] == nil then
			scoreTable[object1] = {}
			scoreTable[object1].score = 0
			--scoreTable[object1].blockDestroyedScore = blockDestroyedScoreIncrement
		end

		scoreTable[object1].score = scoreTable[object1].score + resultDamage
	end
	-- bird has been launched
	
	-- Willhelm Tell and Bull's Eye achievement check
	-- if both are birds..
	if obj1.shot and obj2.shot then
		-- ..and none of them has collided and are not eagle baits
		if not(obj1.hasCollided) and not(obj2.hasCollided) and not(settings.wilhelmTell) and not(obj1.isEagleBait) and not(obj2.isEagleBait) then
			if (obj1.parentName == nil or obj2.parentName == nil) or (obj1.parentName ~= obj2.parentName) then
				--print("Wilhelm Tell achieved! bird "..obj1.name.." has collided with target bird "..obj2.name )
				obj1.hasCollided, obj2.hasCollided = true, true
				if eagleBaitLaunched ~= true then
					settings.wilhelmTell = true
					addToAchievementUnlockQueue("Wilhelm Tell")
				end
			end
		-- if mighty eagle collides eagle bait, remove bait by frozing it
		elseif obj1.isMightyEagle and obj2.isEagleBait then
			obj2.frozen = true
		elseif obj2.isMightyEagle and obj1.isEagleBait then
			obj1.frozen = true
		end
	-- else if one is a bird and the other is a pig
	elseif obj1.shot and obj2.levelGoal and not(settings.bullsEye) then
		if not(obj1.hasCollided) and (obj2.x - levelStartPosition.x) > 75 then
			--print("Bull's eye achieved! bird "..obj1.name.." has collided with target pig "..obj2.name)
			obj1.hasCollided = true
			if eagleBaitLaunched ~= true then
				addToAchievementUnlockQueue("Bull's Eye")
				settings.bullsEye = true
			end
		end
	elseif obj2.shot and obj1.levelGoal and not(settings.bullsEye) then
		if not(obj2.hasCollided) and (obj1.x - levelStartPosition.x) > 75 then
			--print("Bull's eye achieved! bird "..obj2.name.." has collided with target pig "..obj1.name)
			obj2.hasCollided = true
			if eagleBaitLaunched ~= true then
				addToAchievementUnlockQueue("Bull's Eye")
				settings.bullsEye = true
			end
		end
	-- else just ignore it and set hasCollided to true
	elseif obj1.shot then
		obj1.hasCollided = true
	elseif obj2.shot then
		obj2.hasCollided = true
	end
	
	-- bird has been launched
	if flyingBird ~= nil and (flyingBird.name == object1 or flyingBird.name == object2) then			
		
		-- if birds collide camera target object is not reset nor is collision timer set
		if obj1.controllable ~= true or obj2.controllable ~= true then
			if cameraTargetObject ~= nil then
				if cameraTargetObject == obj1 or cameraTargetObject == obj2 then
					--print("Setting camera target object to nil in bird collision.\n")
					cameraTargetObject = nil
					animationScreen.x = screen.x
					animationScreen.y = screen.y
					animationWorldScale = worldScale
				end
			end
		end
		
		local bDef = getObjectDefinition(flyingBird.name)
		local birdSpecialty = bDef.specialty
		if birdSpecialty ~= "BOMB" then
			if bDef.spriteCollision ~= nil then
				if birdSpecialty == "GRENADE" then
					if birdSpecialtyAvailable then
						objects.world[flyingBird.name].sprite = bDef.spriteCollision
						setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)						
					end
				else
					objects.world[flyingBird.name].sprite = bDef.spriteCollision
					setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)				
				end
			end
			birdSpecialtyAvailable = false
			if birdSpecialty == "SUMMON_MIGHTY_EAGLE" then
				if flyingBird.collision ~= true and eagleTimer == nil then
					eagleTimer = 8.7
					eagleMoving = true
					--birdSpecialtyAvailable = true
					--print("Summon mighty eagle.\n")
				end
			end
		else
			if flyingBird.collision ~= true then
				objects.world[flyingBird.name].bombTimer = 1.5			
				objects.world[flyingBird.name].damageSprite = "BIRD_GREY_1"
				objects.world[flyingBird.name].sprite = objects.world[flyingBird.name].damageSprite
				setSprite(flyingBird.name, objects.world[flyingBird.name].sprite)
				birdSpecialtyAvailable = true
			end
		end
		-- set collision flag to true
		flyingBird.collision = true
		
	end
	
	if obj1.controllable then
		local bird = obj1
		local bDef = getObjectDefinition(bird.name)
		local birdSpecialty = bDef.specialty
		if birdSpecialty == "BOOMERANG" then
			bird.boomerangActive = false
		end
	end
	
	if obj2.controllable then
		local bird = obj2
		local bDef = getObjectDefinition(bird.name)
		local birdSpecialty = bDef.specialty
		if birdSpecialty == "BOOMERANG" then
			bird.boomerangActive = false
		end
	end
	
	--set collision flags
	if obj1.shot and obj1.controllable then
		obj1.collision = true
		-- bird to bird collision does not stop trajectory recording
		if obj2.controllable ~= true then
			obj1.recordTrajectory = false
		end
	end
	if obj2.shot and obj2.controllable then
		obj2.collision = true
		-- bird to bird collision does not stop trajectory recording
		if obj1.controllable ~= true then
			obj2.recordTrajectory = false
		end
	end	
	
	-- mark the granade to explode
	for i = #flyingGrenades, 1, -1 do
		local flyingGrenade = flyingGrenades[i].name
		if flyingGrenade == object1 and obj2.controllable ~= true or
			flyingGrenade == object2 and obj1.controllable ~= true then
			flyingGrenades[i].explode = true
			if object1 == flyingGrenade then
				object1 = nil
			end
		end
		
		if object1 == flyingGrenade and obj2.controllable == true then
			return
		end
		if object2 == flyingGrenade and obj1.controllable == true then
			return
		end
	end
	
	--local particleAmount = _G.math.random(12,20)
	
	if object1 ~= nil then
		if objects.world[object1].definition == "MightyEagleBird" and objects.world[object2].definition == "BaitSardine" then
			objects.world[object2].strength = 0
		elseif objects.world[object1].lowerThanGround or (objects.world[object1].definition == "MightyEagleBird" and object2 == "ground")  then
			objects.world[object1].hitGround = true
			cameraShake = 100
			local bDef = getObjectDefinition(objects.world[object1].name)
			bDef.spriteCollision = "BIRD_MIGHTY_EAGLE_RADIAL"
			objects.world[object1].sprite = bDef.spriteCollision
			setSprite(object1, objects.world[object1].sprite)						
			_G.res.playAudio("mighty_eagle_thump", 1, false)
			for k, v in _G.pairs(objects.world) do
				if v.strength ~= nil and v.levelGoal then
					local force = -v.mass * 15
					applyImpulse( v.name,
								0,
								force,
								v.x,
								v.y )
					v.strength = 0.0001
					v.defence = 0
				elseif v.isEagleBait then
					v.strength = 0
				end
			end
			-- delete all joints later in updateGame
			destroyJoints = true
			eagleTimer = 4
		end
	
		local birdie = birds[object1]
		local birdieStartForce = 0
		if object2 ~= nil and (getObjectDefinition(object2).material == "immovable" or getObjectDefinition(object2).material == "staticGround") then
			if birdie ~= nil and birdie.xVel ~= nil and birdie.yVel ~= nil then
				birdieStartForce = (vLength(birdie.xVel, birdie.yVel) * birdie.mass) / 10.0
			end
		end
		if force > collisionParticleForceThreshold or birdieStartForce > collisionParticleForceThreshold then
		 
			--print("Material: " .. getObjectDefinition(object2).material .. "\n")
			-- play either collision or damage sound
			local mat = blockTable.materials[getObjectDefinition(object2).material]
			if mat ~= nil then
				local sound = mat.collisionSound
				if damage > 10 then
					sound = mat.damageSound or sound
				end
				if sound ~= nil then
					_G.res.playAudio(getAudioName(sound), 0.7, false, 2)
				end
			end
			--print("Object: " .. object1 .. "\n")
			local particle = getObjectDefinition(object1).particles
			--print("particles: " .. particle .. "\n")
			local particleAmount = _G.math.random(12, 20)
			if getObjectDefinition(object1).particlesAmountLimits ~= nil then
				particleAmount = _G.math.random(getObjectDefinition(object1).particlesAmountLimits[1], getObjectDefinition(object1).particlesAmountLimits[2])
			end
			addParticles(object1, particle, particleAmount, false)
			
			-- scale volume with collision force
			local volume = 0.7
			if birdie ~= nil then
				local maxForce = ((60.0 * birdie.mass) / 10.0)
				local dmgFactor = blockTable.damageFactors[birdie.damageFactors].damageMultiplier[getObjectDefinition(object2).material]
				if dmgFactor ~= nil and dmgFactor > 1 then
					maxForce = maxForce * dmgFactor
				end
				volume = _G.math.min(_G.math.max(_G.math.max(force, birdieStartForce) / maxForce, 0.20), 1.0)
			end
					
			-- bird sound
			if getObjectDefinition(object1).collisionSound ~= nil then
				_G.res.playAudio(getAudioName(getObjectDefinition(object1).collisionSound), volume, false, 2)
			end
		end
	end
	
	if obj2.controllable ~= true then
		local sprites = getDamageSprite(obj2, blockTable.blocks)
		obj2.damageSprite = sprites.sprite
		obj2.blinkSprite = sprites.blink
		obj2.smileSprite = sprites.smile
	end
end

function blockCollision(object1, object2, force, wasDamageDone)
	--[[
	if(force > 0 and startedFromEditor) then
		local obj1 = objects.world[object1]
		local obj2 = objects.world[object2]
		obj2.debugDamageAmount = force;
		obj1.debugDamageAmount = force;
	end]]
	
	if wasDamageDone then
		local obj1 = objects.world[object1]
		local sprites = getDamageSprite(obj1, blockTable.blocks)
		local dmgSprite = sprites.sprite
		if dmgSprite ~= obj1.damageSprite then
			obj1.damageSprite = dmgSprite
			obj1.blinkSprite = sprites.blink
			obj1.smileSprite = sprites.smile			
			if getObjectDefinition(object1).damageSound ~= nil then
				_G.res.playAudio(getAudioName(getObjectDefinition(object1).damageSound), 0.5, false, 2)
			end
		end
		
		local obj2 = objects.world[object2]
		local sprites = getDamageSprite(obj2, blockTable.blocks)
		local dmgSprite = sprites.sprite		
		if dmgSprite ~= obj2.damageSprite then
			obj2.damageSprite = dmgSprite
			obj2.blinkSprite = sprites.blink		
			obj2.smileSprite = sprites.smile
			if getObjectDefinition(object2).damageSound ~= nil then
				_G.res.playAudio(getAudioName(getObjectDefinition(object2).damageSound), 0.5, false, 2)
			end
		end
	end

	if force > collisionSoundForceThreshold then
		--print("Material: " .. getObjectDefinition(object1).material .. "\n")
		local material1 = blockTable.materials[getObjectDefinition(object1).material]
		local material2 = blockTable.materials[getObjectDefinition(object2).material]
		if material1 ~= nil then
			_G.res.playAudio(getAudioName(blockTable.materials[getObjectDefinition(object1).material].collisionSound), 0.5, false, 2)
		end

		--print("Material: " .. getObjectDefinition(object2).material .. "\n")
		if material2 ~= nil and material2 ~= material1 then
			_G.res.playAudio(getAudioName(blockTable.materials[getObjectDefinition(object2).material].collisionSound), 0.5, false, 2)
		end
	end
end


function addParticles(object, particle, amount, ignoreLimits)
	local obj = objects.world[object]
	if obj == nil then
		return
	end

	local x, y = physicsToWorldTransform(obj.x, obj.y)
	local w, h = 1, 1

	if obj.radius == nil then
		w, h = physicsToWorldTransform(obj.width, obj.height)
	else
		w, h = physicsToWorldTransform(obj.radius*2, obj.radius*2)
	end

	newParticles(particle, amount, x, y, w, h, getAngle(obj.name), ignoreLimits)
end

function addParticlesToPosition(px, py, particle, amount)
	local x, y = physicsToWorldTransform(px, py)
	local w, h = 1, 1

	newParticles(particle, amount, x, y, w, h, getAngle(obj.name))
end

function removeBird(object)
	local k = object.name
	
	addParticles(k, getObjectDefinition(k).particles , 10, false)

	if cameraTargetObject == object then
		--print("--------------   Remove bird: setting camera target object to nil\n")
		cameraTargetObject = nil
	end
	
	if currentBirdName == k then
		currentBirdName = nil
	end
	if flyingBird == object then
		flyingBird = nil
		birdSpecialtyAvailable = false
	end
	
	removeObject(k)
	objects.world[k] = nil
	birds[k] = nil
	otherBirds[k] = nil

	_G.res.playAudio(getAudioName("bird_destroyed"), 1, false)	
end

-- This function finds the definition of the given level object based on its name
function getObjectDefinition(name)
	return blockTable.blocks[objects.world[name].definition]
end

-- returns the next bird name or nil if bird not found
function getNextBird(index)
	--print("Getting next bird: " .. index .. "\n")
	for k, v in _G.pairs(birds) do
		if v.controllable then
			if v.startNumber == index then
				return k
			end
		end
	end

	return nil
end

-- TODO: parse piglettes to own table
function checkLevelComplete()
	if eagleBaitLaunched == true and (eagleTimer == nil or eagleTimer > 0) then
		return false
	end
	if hasMovingObjects and objects.doNotWaitForMovingObjects ~= true then
		return false
	end
	for k, v in _G.pairs(levelGoals) do
		if v.levelGoal then
			return false
		end
	end
	return true
end

function checkLevelGoalsDestroyed()
	for k, v in _G.pairs(levelGoals) do
		if v.levelGoal then
			return false
		end
	end	
	return true
end

function checkLevelFailed()
	if hasMovingObjects and objects.doNotWaitForMovingObjects ~= true then
		return false
	end
	
	for k, v in _G.pairs(birds) do
		if v.controllable then
			return false
		end
	end
	return true
end

function getDamageSprite(object, definitions)
	local sprites = {}
	sprites.sprite = object.sprite
	sprites.blink = object.sprite
	sprites.smile = object.sprite
	
	if object.definition == nil or object.definition == "" then
		return sprites
	end

	if definitions[object.definition] == nil then
		return sprites
	end

	if definitions[object.definition].damageSprites == nil then
		return sprites
	end

	if object.strength == nil then
		return sprites
	end

	local percentage = (object.strength / definitions[object.definition].strength) * 100
	for k, v in _G.pairs(definitions[object.definition].damageSprites) do
		if v.min < percentage and v.max >= percentage then
			setSprite(object.name, v.sprite)
			sprites.sprite = v.sprite
			sprites.blink = v.sprite
			sprites.smile = v.sprite
			if v.blinkSprite ~= nil then
				sprites.blink = v.blinkSprite
			end
			if v.smileSprite ~= nil then
				sprites.smile = v.smileSprite
			end
			return sprites
		end
	end

	-- fail safe
	return sprites
end


function makeExplosion(object, definition, sound)
	if definition.explosionForce ~= nil then
		if sound ~= nil then
			_G.res.playAudio(sound, 0.7, false, 1)
		end
		addParticles(object.name, "explosion", 1, true)
		addParticles(object.name, "explosionBuff", 1, true)

		for k, v in _G.pairs(objects.world) do
			if v.controllable or object == v then
				--do nothing
			else
				local dist = vLength(v.x - object.x, v.y - object.y)
				if dist < definition.explosionRadius then
					local x, y = vNormalize(v.x - object.x, v.y - object.y)
					local force = physicsScale * definition.explosionForce / dist
					applyImpulse( k,
								x * force,
								y * force,
								v.x,
								v.y )
				end
				if dist < definition.explosionDamageRadius then
					if v.defence < definition.explosionDamage/dist then
						v.strength = v.strength - definition.explosionDamage/dist
						local sprites = getDamageSprite(v, blockTable.blocks)
						v.damageSprite = sprites.sprite
						v.blinkSprite = sprites.blink
						v.smileSprite = sprites.smile
						if v.strength <= 0 then
							deadBlocks[k] = v
						end
						--print("st: " .. v.strength .. "\n")
					end
				end
			end
		end
	end
end

function makeClickExplosion(objectX, objectY, explosionForce, explosionRadius, explosionDamage, explosionDamageRadius, sound)
	if sound ~= nil then
		_G.res.playAudio(sound, 0.7, false, 1)
	end

	local wx, wy = physicsToWorldTransform(objectX, objectY)
	newParticles("explosion", 1, wx, wy, 4, 4, 0)
	newParticles("explosionBuff", 1, wx, wy, 4, 4, 0)

	for k, v in _G.pairs(objects.world) do
		local dist = vLength(v.x - objectX, v.y - objectY)
		local x, y = vNormalize(v.x - objectX, v.y - objectY)
		if dist < explosionRadius then
			local force = physicsScale * explosionForce / dist
			applyImpulse( k,
						x * force,
						y * force,
						v.x,
						v.y )
		end
		if dist < explosionDamageRadius then
			if v.defence ~= nil and v.defence < explosionDamage/dist then
				v.strength = v.strength - explosionDamage/dist
				local sprites = getDamageSprite(v, blockTable.blocks)
				v.damageSprite = sprites.sprite
				v.blinkSprite = sprites.blink
				v.smileSprite = sprites.smile
				--print("st: " .. v.strength .. "\n")
			end
		end
	end
end


-------------------------------------------------------------------------------
-- Miscellaneous stuff


function worldToPhysicsTransform(x, y)
	local px = x * physicsScale
	local py = y * physicsScale
	return px, py
end

function worldToScreenTransform(x, y)
	local sx = (x - screen.left) * worldScale
	local sy = (y - screen.top) * worldScale
	return sx, sy
end

function screenToWorldTransform(x, y)
	local wx = x / worldScale + screen.left
	local wy = y / worldScale + screen.top
	return wx, wy
end

function physicsToWorldTransform(x, y)
	local wx = x * physicsToWorld
	local wy = y * physicsToWorld
	return wx, wy
end

function physicsToScreenTransform(x, y)
	local wx, wy = physicsToWorldTransform(x, y)
	local sx, sy = worldToScreenTransform(wx, wy)
	return sx, sy
end

function screenToPhysicsTransform(x, y)
	local wx, wy = screenToWorldTransform(x, y)
	local px, py = worldToPhysicsTransform(wx, wy)
	return px, py
end

function distance(x1,y1,x2,y2)
	local dx = x2-x1
	local dy = y2-y1
	return _G.math.sqrt(dx*dx+dy*dy)
end

-- returns current time in seconds from start of the month
function currentTime()
	local timeNow = { d = _G.os.date("%d")*1, h = _G.os.date("%H")*1, m = _G.os.date("%M")*1, s = _G.os.date("%S")*1 }
	return timeNow
end

-- returns difference between t1 and t2 in seconds, t2 must be greater than t1 and max diffrence is limited to one day
function timeDiff(t2, t1)
	local temp1 = (t1.h * 60 * 60) + (t1.m * 60) + (t1.s)
	local temp2 = (t2.h * 60 * 60) + (t2.m * 60) + (t2.s)
	if t2.d ~= t1.d then
		temp2 = temp2 + (24 * 60 * 60)
	end
	--print("timeDiff: " .. (temp2 - temp1) .. "\n")
	return (temp2 - temp1)
end

-- formats time given in seconds to (h)h:mm:ss if it's more than 1 hour or to (m)m:ss if it's less than 1 hour
function formatTime(inputTime)
	local timeText = ""
	local hours = _G.string.format("%d", _G.math.floor(inputTime / 3600))
	local minutes = _G.string.format("%d", _G.math.floor(_G.math.fmod(inputTime, 3600) / 60))
	local seconds = _G.string.format("%d", _G.math.fmod(_G.math.fmod(inputTime, 3600), 60))
	if inputTime >= 3600 then
		minutes = "00" .. minutes
		minutes = _G.string.sub(minutes, #minutes -1, #minutes)
		seconds = "00" .. seconds
		seconds = _G.string.sub(seconds, #seconds -1, #seconds)
		timeText = hours .. ":" .. minutes .. ":" .. seconds
	else
		seconds = "00" .. seconds
		seconds = _G.string.sub(seconds, #seconds -1, #seconds)
		timeText = minutes .. ":" .. seconds
	end
	return timeText
end

function checkObjectBounds(x, y, width, height, angle, cursorX, cursorY)	 
	local cx = cursorX - x
	local cy = cursorY - y
	
	local tcx = cx * _G.math.cos(angle) + cy * _G.math.sin(angle)
	local tcy = -cx * _G.math.sin(angle) + cy * _G.math.cos(angle)

	local halfWidth = width * 0.5
	local halfHeight = height * 0.5
	
	local left = -halfWidth
	local top = -halfHeight
	local right = halfWidth
	local bottom = halfHeight
	
	if tcx >= left and tcx < right then
		if tcy >= top and tcy < bottom then
			return true
		end
	end
	return false
end


function checkPolygonObjectBounds(x, y, width, height, angle, vertices, cursorX, cursorY)	 
	local cx = cursorX - x
	local cy = cursorY - y
	
	local tcx = cx * _G.math.cos(angle) + cy * _G.math.sin(angle)
	local tcy = -cx * _G.math.sin(angle) + cy * _G.math.cos(angle)
	
	local tVerts = {}
	
	for i = 1, #vertices do
		tVerts[i] = {}
		tVerts[i].x = vertices[i].x * width - 0.5*width
		tVerts[i].y = vertices[i].y * height - 0.5*height
	end
	
	return testPointInPolygon(tcx, tcy, tVerts)
end


function checkBounds(left, top, w, h, cursorX, cursorY, angle, hanchor, vanchor)
	--[[
	print("Checking bounds: ")
	print(" x:" .. x)
	print(" y:" .. y)
	print(" w:" .. w)
	print(" h:" .. h)
	print(" cx:" .. cursorX)
	print(" cy:" .. cursorY)
	print("\n")
	--]]
	if hanchor and vanchor then
		if hanchor == "HCENTER" then
			left = left - w * 0.5
		elseif hanchor == "LEFT" then
			left = left + w
		elseif hanchor == "RIGHT" then
			left = left - w
		end
		if vanchor == "VCENTER" then
			top = top - h * 0.5
		elseif vanchor == "TOP" then
			top = top + h
		elseif vanchor == "BOTTOM" then
			top = top - h
		end
	end
	
	if cursorX >= left and cursorX < left + w then
		if cursorY >= top and cursorY < top + h then
			return true
		end
	end
	return false
	
end

function checkTextBounds(textGroup, text, hanchor, vanchor, x, y, cursorX, cursorY)
	local w = _G.res.getStringWidth(_G.res.getString(textGroup, text))
	local h = _G.res.getFontLeading()
	--print("String width " .. text .. " " .. w .. "\n")
	--print("Font leading " .. h .. "\n")
	if hanchor == nil then
		x = x - w * 0.5
	elseif hanchor == "RIGHT" then
		x = x - w
	elseif hanchor == "HCENTER" then
		x = x - w * 0.5
	end

	if vanchor == nil then
		y = y - h * 0.5
	elseif vanchor == "BOTTOM" then
		y = y - h
	elseif vanchor == "VCENTER" then
		y = y - h * 0.5
	end

	return checkBounds(x, y, w, h, cursorX, cursorY)
end

function checkSpriteBounds(sheet, sprite, x, y, cursorX, cursorY)
	local w, h = _G.res.getSpriteBounds(sheet, sprite)
	local px, py = _G.res.getSpritePivot(sheet, sprite)

	return checkBounds(x - px, y - py, w, h, cursorX, cursorY)
end


function getObjectsInsideRect(x1, y1, x2, y2)
	if x1 > x2 then
		x1, x2 = x2, x1
	end
	if y1 > y2 then
		y1, y2 = y2, y1
	end

	local t = {}

	for k, v in _G.pairs(objects.world) do
		x, y = physicsToWorldTransform(v.x, v.y)
		if x > x1 and x <= x2 then
			if y > y1 and y <= y2 then
				if v.name ~= "ground" then
					_G.table.insert(t, v)
				end
			end
		end
	end

	return t
end


function getThemeObjectsInsideRect(x1, y1, x2, y2, layer)
	if x1 > x2 then
		x1, x2 = x2, x1
	end
	if y1 > y2 then
		y1, y2 = y2, y1
	end

	local t = {}

	for k, v in _G.pairs(themeSpriteObjects) do
		
		x, y = physicsToWorldTransform(v.x, v.y)
		
		if v.layer == layer and x > x1 and x <= x2 and y > y1 and y <= y2 then			
			_G.table.insert(t, v)						
		end
	end

	return t
end


function testPointInPolygon(x, y, vertices)
	local s = #vertices
	local e = 1
	local counter = 0
	
	while e <= #vertices do
		-- check that the line is not below this point
		if y > _G.math.min(vertices[s].y, vertices[e].y) then
			-- check that the line is not above this point
			if y <= _G.math.max(vertices[s].y, vertices[e].y) then
				-- check that the line is to the right from this point
				if x <= _G.math.max(vertices[s].x, vertices[e].x) then
					-- horizontal lines are ignored
					if vertices[s].y ~= vertices[e].y then
						local crossPointX = (y - vertices[s].y) * (vertices[e].x - vertices[s].x) / (vertices[e].y - vertices[s].y) + vertices[s].x
						if vertices[s].x == vertices[e].x or x < crossPointX then
							counter = counter + 1
						end
					end
				end
			end
		end
		
		s = e
		e = e + 1
	end
	
	if counter % 2 == 0 then
		return false
	end
	
	return true
end

--[[
ks Spring constant.
kd Spring damping constant.
r Distance to rest length.
v Spring velocity

Usage: springspeed += dampedSpring(0.8,0.5,distancetorest,springspeed) * dt
springlength += springspeed * dt
]]
function dampedSpring(ks, kd, r, v)
	return (ks * r) - (kd * v)
end

--[[
Calculates 2 times the signed triangle area. <br>

Algorithm from "Real time collision detection" by Christer Ericson, page 152.

@param aX Point A x-component
@param aY Point A y-component
@param bX Point B x-component
@param bY Point B y-component
@param cX Point C x-component
@param cY Point C y-component
The result is positive if abc is ccw, negative if abc is cw, zero if abc is degenerate.
]]
function signed2DTriArea(aX, aY, bX, bY, cX, cY)
	return (aX - cX) * (bY - cY) - (aY - cY) * (bX - cX)
end

--[[
Test if segments ab and cd overlap. If they do, compute intersection value t along ab and
intersection position p. <br>

Algorithm from "Real time collision detection" by Christer Ericson, page 152-153.
]]
function test2DSegmentSegment(aX, aY, bX, bY, cX, cY, dX, dY, findPoint)

	local instersectionValue, intersectionPoint = nil, nil

	-- Compute winding of abd (+ or -)
	local a1 = signed2DTriArea(aX, aY, bX, bY, dX, dY)
	-- To intersect, must have sign opposite of a1
	local a2 = signed2DTriArea(aX, aY, bX, bY, cX, cY)

	-- If c and d are on different sides of ab, areas have different signs
	if a1 ~= 0 and a2 ~= 0 and a1 * a2 < 0 then
		-- Compute signs for a and b with respect to segment cd
		local a3 = signed2DTriArea(cX, cY, dX, dY, aX, aY) -- Compute winding of cda (+ or -)
		-- Since area is constant a1 - a2 = a3 - a4, or a4 = a3 + a2 - a1
		local a4 = a3 + a2 - a1
		-- Points a and b on different sides of cd if areas have different signs
		if(a3 ~= 0 and a4 ~= 0 and a3 * a4 < 0) then
			if(findPoint == true) then -- Test if we want to get also intersection value and point
				-- Segments intersect. Find intersection point along L(t) = a + t * (b - a).
				-- Given height h1 of an over cd and height h2 of b over cd,
				-- t = h1 / (h1 - h2) = (b*h1/2 - b*h2/2) = a3 / (a3 - a4),
				-- where b ( the base of the triangles cda and adb, i.e., the length
				-- of cd) cancels out.
				intersectionValue = a3 / (a3 - a4)
				intersectionPoint = { x = aX + intersectionValue * (bX - aX), y = aY + intersectionValue * (bY - aY) }
			end
			return true, instersectionValue, intersectionPoint
		end
	end
	return false -- Segments do not intersect (or collinear)
end

function vLength(x, y)
	local len = _G.math.sqrt(x * x + y * y)
	return len

end

function vLengthsq(x, y)
	local len = (x * x + y * y)
	return len
end


function vNormalize(x, y)
	local len = _G.math.sqrt(x * x + y * y)
	return x/len, y/len
end

-------------------------------------------------------------------------------
-- Floating scores

function updateFloatingScores(dt)
	-- update floating scores
	local i = 1
	while i <= #floatingScores do
		local fs = floatingScores[i]
		fs.time = fs.time + dt

		if fs.time < 0.25 then
			fs.xs = fs.maxScale * fs.time / 0.25
		else
			if fs.time < fs.lifetime - 0.25 then
				fs.xs = fs.maxScale
			else
				fs.xs = fs.maxScale * (fs.lifetime - fs.time) / 0.25
			end
		end

		if floatingScores[i].time > floatingScores[i].lifetime then
			_G.table.remove(floatingScores, i)
		else
			i = i + 1
		end
	end
end

-------------------------------------------------------------------------------
-- Animations

function newAnimation(name, state, page, speedIn, speedOut)
	local v = {}
	v.page = page
	v.state = state
	v.percentage = 0
	v.speedIn = speedIn
	v.speedOut = speedOut
	v.name = name
	elementAnimations[name] = v
end

function updateAnimations(dt)
	for k, v in _G.pairs(elementAnimations) do
		if v.state == "ENTERING" then
			v.percentage = v.percentage + v.speedIn * dt
			if v.percentage > 100 then
				v.percentage = 100
				v.state = "VISIBLE"
				v.page.state = "READY"
			end
		elseif v.state == "VISIBLE" then
		elseif v.state == "EXITING" then
			v.percentage = v.percentage - v.speedOut * dt
			if v.percentage < 0 then
				v.percentage = 0
				v.state = "HIDDEN"
				v.page.state = "DISABLED"
				if k == "ingamePausePageScroll" then
					onExitPage(pausePage)
					
					-- continue game after pause menu has scrolled out
					if deviceModel == "iphone4" and (birdTutorialPopups == nil or #birdTutorialPopups == 0) then
						changeResolution = true
						wantedResolution = "FULL"
						resolutionChanged = true
					end
					setGameMode(updateGame)
					setPhysicsEnabled(true)
				end
			end
		end
	end
end

function setAnimationState(animation, state)
	local v = elementAnimations[animation]
	if state == "ENTERING" then
		if v.state == "HIDDEN" then
			v.state = state
			v.percentage = 0
			v.page.state = "DISABLED"
		elseif v.state == "EXITING" then
			v.state = state
		end
	elseif state == "VISIBLE" then
		if v.state == "ENTERING" or v.state == "HIDDEN" or v.state == "EXITING" then
			v.state = state
			v.percentage = 100
			v.page.state = "READY"			
		end
	elseif state == "EXITING" then
		if v.state == "VISIBLE" then
			v.state = state
			v.percentage = 100
			v.page.state = "READY"			
		elseif v.state == "ENTERING" then
			v.state = state
		end
	elseif state == "HIDDEN" then
		if v.state == "ENTERING" or v.state == "VISIBLE" or v.state == "EXITING" then
			v.state = state
			v.percentage = 0
			v.page.state = "DISABLED"
		end
	end
end

-------------------------------------------------------------------------------
-- Particle engine

function newParticles(type, amount, x, y, w, h, angle, ignoreLimits)
	local pt = particleTable.particles[type]
	if pt == nil then
		return
	end
	
	_G.particles.addParticles(type, amount, x, y, w, h, angle, ignoreLimits)

--[[	
	if softLimitSimultaneousParticles < particleAmount + amount then
		amount = amount * 0.5
	end
	
	for i = 1, amount, 1 do
		if particleAmount < hardLimitSimultaneousParticles then
			particleAmount = particleAmount + 1
			local p = { }
			p.x = x + (_G.math.random(0, w) - 0.5*w ) -- * cos(angle)
			p.y = y + (_G.math.random(0, h) - 0.5*h ) -- * sin(angle)
			p.xVel = _G.math.random(pt.minVel, pt.maxVel)
			p.yVel = _G.math.random(pt.minVel, pt.maxVel)
			p.angle = _G.math.random(1, 3.14)
			p.angleVel = _G.math.random(pt.minAngleVel, pt.maxAngleVel)
			p.scaleBegin = _G.math.random(pt.minScaleBegin, pt.maxScaleBegin)
			p.scaleEnd = _G.math.random(pt.minScaleEnd, pt.maxScaleEnd)
			p.scale = p.scaleBegin
			p.type = type
			p.sprite = pt.sprites[_G.math.random(1, #pt.sprites)]
			p.sheet = pt.sheet
			p.time = 0
			p.lifeTime = pt.lifeTime
			p.lifeTimeAnimation = pt.animation == "lifeTime"

			if p.lifeTimeAnimation then
				p.sprite = pt.sprites[1]
			end
			p.oldSprite = p.sprite
			p.spritePivotX, p.spritePivotY = _G.res.getSpritePivot(p.sheet, p.sprite)

			_G.table.insert(particles, p)
		end
	end
--]]
end

function updateParticles(dt)
	for k, v in _G.pairs(particles) do
		local p = v
		p.time = p.time + dt
		if p.time > p.lifeTime then
			_G.table.remove(particles, k)
			particleAmount = particleAmount - 1
		else
			pt = particleTable.particles[p.type]
			p.xVel = p.xVel + pt.gravityX * dt
			p.yVel = p.yVel + pt.gravityY * dt
			p.x = p.x + p.xVel * dt
			p.y = p.y + p.yVel * dt
			p.angle = p.angle + p.angleVel * dt
			p.scale = p.scaleBegin + (p.scaleEnd - p.scaleBegin) * (p.time / p.lifeTime)
			
			if p.lifeTimeAnimation then
				index = _G.math.ceil(#pt.sprites * (p.time / p.lifeTime))
				if index < 1 then index = 1 end
				if index > #pt.sprites then index = #pt.sprites end
				p.sprite = pt.sprites[index]
				if p.oldSprite ~= p.sprite then
					p.spritePivotX, p.spritePivotY = _G.res.getSpritePivot(p.sheet, p.sprite)
					p.oldSprite = p.sprite
				end
			end
		end
	end
end


function drawParticles()
	--local counter = 0
	for k, v in _G.pairs(particles) do
		--counter = counter + 1
		local p = v
		setRenderState(-screen.left/p.scale, -screen.top/p.scale, worldScale*p.scale, worldScale*p.scale, p.angle, p.spritePivotX, p.spritePivotY)
		_G.res.drawSprite(p.sheet, p.sprite, p.x/p.scale, p.y/p.scale)
	end
	--print("Particles: " .. particleAmount .. "\n")
end

-------------------------------

function getCutsceneBackgroundWidth(sprites)
	local bgWidth = 0
	for k, v in _G.pairs(sprites) do
		if v.isBackground then
			local tsw, _ = _G.res.getSpriteBounds("", v.sprite)
			bgWidth = bgWidth + tsw
		end
	end
	return bgWidth
end

function drawBoxWithTiledBorders( borderSprites, sheet, x1, y1, width, height, hAnchor, vAnchor, color)
	
	local r, g, b, a = 1.0, 1.0, 1.0, 1.0
	if color ~= nil then
		if color.red ~= nil then
			r = color.red
		end
		if color.green ~= nil then
			g = color.green
		end
		if color.blue ~= nil then
			b = color.blue
		end
		if color.alpha ~= nil then
			a = color.alpha
		end
	end
	
	local x2 = x1 + width
	local y2 = y1 + height
	
	-- top (& bottom) part
	local pxTopLeft,   pyTopLeft   = 0, 0
	local pxTopMiddle, pyTopMiddle = 0, 0
	local pxTopRight,  pyTopRight  = 0, 0
	local twTopLeft,   thTopLeft   = 0, 0
	local twTopMiddle, thTopMiddle = 0, 0
	local twTopRight,  thTopRight  = 0, 0
	
	-- left (& right) part
	local pxMiddleLeft, pyMiddleLeft = 0, 0
	local pxBottomLeft, pyBottomLeft = 0, 0
	local twMiddleLeft, thMiddleLeft = 0, 0
	local twBottomLeft, thBottomLeft = 0, 0
		
	-- top (& bottom) part
	if borderSprites.topLeft ~= nil then
		pxTopLeft, pyTopLeft = _G.res.getSpritePivot(sheet, borderSprites.topLeft)
		twTopLeft, thTopLeft = _G.res.getSpriteBounds(sheet, borderSprites.topLeft)
	elseif borderSprites.bottomLeft ~= nil then
		pxTopLeft, pyTopLeft = _G.res.getSpritePivot(sheet, borderSprites.bottomLeft)
		twTopLeft, thTopLeft = _G.res.getSpriteBounds(sheet, borderSprites.bottomLeft)
		borderSprites.topLeft = ""
	else
		borderSprites.topLeft = ""
	end
	if borderSprites.topMiddle ~= nil then
		pxTopMiddle, pyTopMiddle = _G.res.getSpritePivot(sheet, borderSprites.topMiddle)
		twTopMiddle, thTopMiddle = _G.res.getSpriteBounds(sheet, borderSprites.topMiddle)
	elseif borderSprites.bottomMiddle ~= nil then
		pxTopMiddle, pyTopMiddle = _G.res.getSpritePivot(sheet, borderSprites.bottomMiddle)
		twTopMiddle, thTopMiddle = _G.res.getSpriteBounds(sheet, borderSprites.bottomMiddle)
		borderSprites.topMiddle = ""
	else
		borderSprites.topMiddle = ""
	end
	if borderSprites.topRight ~= nil then
		pxTopRight,  pyTopRight  = _G.res.getSpritePivot(sheet, borderSprites.topRight)
		twTopRight,  thTopRight  = _G.res.getSpriteBounds(sheet, borderSprites.topRight)
	elseif borderSprites.bottomRight ~= nil then
		pxTopRight,  pyTopRight  = _G.res.getSpritePivot(sheet, borderSprites.bottomRight)
		twTopRight,  thTopRight  = _G.res.getSpriteBounds(sheet, borderSprites.bottomRight)
		borderSprites.topRight = ""
	else
		borderSprites.topRight = ""
	end
					
	local startXTopMiddle = x1 + twTopLeft - pxTopLeft + pxTopMiddle
	local stopXTopMiddle = x2 - pxTopRight - (twTopMiddle - pxTopMiddle)
	if stopXTopMiddle < startXTopMiddle then
		stopXTopMiddle = startXTopMiddle + 1
	end
	
	-- left (& right) part
	if borderSprites.topLeft ~= nil then
		pxTopLeft, pyTopLeft = _G.res.getSpritePivot(sheet, borderSprites.topLeft)
		twTopLeft, thTopLeft = _G.res.getSpriteBounds(sheet, borderSprites.topLeft)
	elseif borderSprites.topRight ~= nil then 
		pxTopLeft, pyTopLeft = _G.res.getSpritePivot(sheet, borderSprites.topRight)
		twTopLeft, thTopLeft = _G.res.getSpriteBounds(sheet, borderSprites.topRight)
		borderSprites.topLeft = ""
	else
		borderSprites.topLeft = ""
	end
	if borderSprites.left ~= nil then
		pxMiddleLeft, pyMiddleLeft = _G.res.getSpritePivot(sheet, borderSprites.left)
		twMiddleLeft, thMiddleLeft = _G.res.getSpriteBounds(sheet, borderSprites.left)
	elseif borderSprites.right ~= nil then 
		pxMiddleLeft, pyMiddleLeft = _G.res.getSpritePivot(sheet, borderSprites.right)
		twMiddleLeft, thMiddleLeft = _G.res.getSpriteBounds(sheet, borderSprites.right)
		borderSprites.left = ""
	else
		borderSprites.left = ""
	end
	if borderSprites.bottomLeft ~= nil then
		pxBottomLeft, pyBottomLeft  = _G.res.getSpritePivot(sheet, borderSprites.bottomLeft)
		twBottomLeft, thBottomLeft  = _G.res.getSpriteBounds(sheet, borderSprites.bottomLeft)
	elseif borderSprites.bottomRight ~= nil then
		pxBottomLeft, pyBottomLeft  = _G.res.getSpritePivot(sheet, borderSprites.bottomRight)
		twBottomLeft, thBottomLeft  = _G.res.getSpriteBounds(sheet, borderSprites.bottomRight)
		borderSprites.bottomLeft = ""
	else
		borderSprites.bottomLeft = ""
	end
	
	if borderSprites.right == nil then
		borderSprites.right = ""
	end
	if borderSprites.bottomMiddle == nil then
		borderSprites.bottomMiddle = ""
	end
	if borderSprites.bottomRight == nil then
		borderSprites.bottomRight = ""
	end
	if borderSprites.center == nil then
		borderSprites.center = ""
	end
	
	local startYMiddleLeft = y1 + thTopLeft - pyTopLeft + pyMiddleLeft 
	local stopYMiddleLeft = y2 - pyBottomLeft - ( thMiddleLeft - pyMiddleLeft)
	if stopYMiddleLeft < startYMiddleLeft then
		stopYMiddleLeft = startYMiddleLeft + 1
	end
	
	local correctedX1, correctedX2, xPivot, yPivot, horBorderOffset, verBorderOffset = 0, 0, 0, 0, 0, 0
	
	-- top (& bottom) middle sprite is drawn as many times as necessary to fill the gap between corners so the width of the box might increase
	local horDrawCount = _G.math.ceil(width / twTopMiddle)
	local offsetX = 0
	if horDrawCount ~= 0 and twTopMiddle ~= 0 then
		offsetX = (horDrawCount * twTopMiddle) - width
	end
	if hAnchor == "HCENTER" then
		correctedX1 = x1 - offsetX /2
		correctedX2 = x2 + offsetX / 2
		xPivot = -width / 2
		horBorderOffset = -offsetX / 2
	elseif hAnchor == "RIGHT" then
		correctedX1 = x1 - offsetX
		correctedX2 = x2 
		xPivot = -width
		horBorderOffset = -offsetX
	else -- left
		correctedX1 = x1
		correctedX2 = x2 + offsetX 
		xPivot = 0
	end
	
	-- left (& right) middle sprite is drawn as many times as necessary to fill the gap between corners so the height of the box might increase
	local verDrawCount = _G.math.ceil((y2 - y1) / thMiddleLeft)
	local offsetY = 0
	if verDrawCount ~= 0 and thMiddleLeft ~= 0 then
		offsetY = (verDrawCount * thMiddleLeft) - height
	end
	if vAnchor == "VCENTER" then
		correctedY1 = y1 - offsetY / 2
		correctedY2 = y2 + offsetY / 2
		yPivot = -height / 2
		verBorderOffset = -offsetY / 2
	elseif vAnchor == "BOTTOM" then
		correctedY1 = y1 - offsetY
		correctedY2 = y2 
		yPivot = -height
		verBorderOffset = -offsetY
	else -- top
		correctedY1 = y1
		correctedY2 = y2 + offsetY 
		yPivot = 0
	end
	for i = 0, (horDrawCount-1) * twTopMiddle, twTopMiddle do
		_G.res.drawSprite(sheet, borderSprites.topMiddle, _G.math.floor(startXTopMiddle + i + horBorderOffset + xPivot), _G.math.floor(correctedY1 + yPivot))
		_G.res.drawSprite(sheet, borderSprites.bottomMiddle, _G.math.floor(startXTopMiddle + i + horBorderOffset + xPivot) , _G.math.floor(correctedY2 + yPivot + 1))
	end
	for i = 0, (verDrawCount-1) * thMiddleLeft, thMiddleLeft do
		_G.res.drawSprite(sheet, borderSprites.left, _G.math.floor(correctedX1 + xPivot), _G.math.floor(startYMiddleLeft + i + verBorderOffset + yPivot))
		_G.res.drawSprite(sheet, borderSprites.right, _G.math.floor(correctedX2 + xPivot + 1), _G.math.floor(startYMiddleLeft + i + verBorderOffset + yPivot))
	end
	
	-- draw corners
	_G.res.drawSprite(sheet, borderSprites.topLeft, _G.math.floor(correctedX1 + xPivot), _G.math.floor(correctedY1 + yPivot))
	_G.res.drawSprite(sheet, borderSprites.topRight, _G.math.floor(correctedX2 + xPivot + 1), _G.math.floor(correctedY1 + yPivot))
	_G.res.drawSprite(sheet, borderSprites.bottomLeft, _G.math.floor(correctedX1 + xPivot), _G.math.floor(correctedY2 + yPivot + 1))
	_G.res.drawSprite(sheet, borderSprites.bottomRight, _G.math.floor(correctedX2 + xPivot + 1), _G.math.floor(correctedY2 + yPivot + 1))
	
	-- if color isn't defined then fill with center sprite
	if color ~= nil then
		drawRect(r, g, b, a, _G.math.floor(correctedX1 + xPivot), _G.math.floor(correctedY1 + yPivot), _G.math.floor(correctedX2 + xPivot), _G.math.floor(correctedY2 + yPivot), false)
	else
		_G.res.drawSprite(sheet, borderSprites.center, _G.math.floor(correctedX1 + xPivot), _G.math.floor(correctedY1 + yPivot), "TOP", "LEFT", _G.math.floor(correctedX2 - correctedX1 + 1), _G.math.floor(correctedY2 - correctedY1 + 1))
	end
	
	local correctedWidth = correctedX2 - correctedX1 + 1
	local correctedHeight = correctedY2 - correctedY1 + 1
	return _G.math.floor(correctedX1), _G.math.floor(correctedY1), _G.math.floor(correctedWidth), _G.math.floor(correctedHeight)
end

function drawBox( borderSprites, sheet, x1, y1, width, height, hAnchor, vAnchor, color)
	
	local boxSprites = borderSprites
	local r, g, b, a = 1.0, 1.0, 1.0, 1.0
	if color ~= nil then
		if color.red ~= nil then
			r = color.red
		end
		if color.green ~= nil then
			g = color.green
		end
		if color.blue ~= nil then
			b = color.blue
		end
		if color.alpha ~= nil then
			a = color.alpha
		end
	end

	local x2 = x1 + width - 1
	local y2 = y1 + height - 1
	
	local thTopMiddle = 0
	local twMiddleLeft = 0
	local twMiddleRight = 0
	
	local thBottomMiddle = 0
		
	if boxSprites.topLeft == nil then
		boxSprites.topLeft = ""
	end
	
	if boxSprites.topRight == nil then
		boxSprites.topRight = ""
	end
	
	if boxSprites.bottomLeft == nil then
		boxSprites.bottomLeft = ""
	end
	
	if boxSprites.bottomRight == nil then
		boxSprites.bottomRight = ""
	end

	if boxSprites.center == nil then
		boxSprites.center = ""
	end
	
	if boxSprites.topMiddle ~= nil then
		_, thTopMiddle = _G.res.getSpriteBounds(sheet, boxSprites.topMiddle)
	else
		boxSprites.topMiddle = ""
	end
	
	if boxSprites.left ~= nil then
		twMiddleLeft, _ = _G.res.getSpriteBounds(sheet, boxSprites.left)
	else
		boxSprites.left = ""
	end
	
	if boxSprites.right ~= nil then 
		twMiddleRight, _ = _G.res.getSpriteBounds(sheet, boxSprites.right)
	else
		boxSprites.right = ""
	end
	
	if boxSprites.bottomMiddle ~= nil then
		_, thBottomMiddle = _G.res.getSpriteBounds(sheet, boxSprites.bottomMiddle)
	else
		boxSprites.bottomMiddle = ""
	end
		
	local xPivot, yPivot = 0, 0
	
	if hAnchor == "HCENTER" then
		xPivot = -width / 2
	elseif hAnchor == "RIGHT" then
		xPivot = -width
	else -- left
		xPivot = 0
	end
	if vAnchor == "VCENTER" then
		yPivot = -height / 2
	elseif vAnchor == "BOTTOM" then
		yPivot = -height
	else -- top
		yPivot = 0
	end
		
	-- check if some part of the box is on screen
	if _G.math.floor(x1 - twMiddleLeft + xPivot) <= screenWidth and _G.math.floor(x1 + width + xPivot + twMiddleRight) >= 0 and
	   _G.math.floor(y1 - thTopMiddle + yPivot) <= screenHeight and _G.math.floor(y1 + height + yPivot + thBottomMiddle) >= 0 then
		-- draw borders
		_G.res.drawSprite(sheet, boxSprites.topMiddle, _G.math.floor(x1 + xPivot) , _G.math.floor(y1 - thTopMiddle + yPivot) , "TOP", "LEFT", _G.math.floor(width), _G.math.floor(thTopMiddle))
		_G.res.drawSprite(sheet, boxSprites.bottomMiddle, _G.math.floor(x1 + xPivot) , _G.math.floor(y1 + height + yPivot), "TOP", "LEFT", _G.math.floor(width), _G.math.floor(thBottomMiddle))
		_G.res.drawSprite(sheet, boxSprites.left, _G.math.floor(x1 - twMiddleLeft + xPivot) , _G.math.floor(y1 + yPivot) , "TOP", "LEFT", _G.math.floor(twMiddleLeft), _G.math.floor(height))
		_G.res.drawSprite(sheet, boxSprites.right, _G.math.floor(x1 + width + xPivot), _G.math.floor(y1 + yPivot) , "TOP", "LEFT", _G.math.floor(twMiddleRight), _G.math.floor(height))
		
		-- draw corners
		_G.res.drawSprite(sheet, boxSprites.topLeft, _G.math.floor(x1 + xPivot), _G.math.floor(y1 + yPivot), "BOTTOM", "RIGHT")
		_G.res.drawSprite(sheet, boxSprites.topRight, _G.math.floor(x1 + width + xPivot), _G.math.floor(y1 + yPivot), "BOTTOM", "LEFT")
		_G.res.drawSprite(sheet, boxSprites.bottomLeft, _G.math.floor(x1 + xPivot), _G.math.floor(y1 + height + yPivot), "TOP", "RIGHT")
		_G.res.drawSprite(sheet, boxSprites.bottomRight, _G.math.floor(x1 + width + xPivot), _G.math.floor(y1 + height + yPivot), "TOP", "LEFT")
		
		-- if color isn't defined then fill with center sprite
		if color ~= nil then
			drawRect(r, g, b, a, _G.math.floor(x1 + xPivot), _G.math.floor(y1 + yPivot), _G.math.floor(x2 + xPivot), _G.math.floor(y2 + yPivot), false)
		else
			-- print(_G.math.floor(width))
			_G.res.drawSprite(sheet, boxSprites.center, _G.math.floor(x1 + xPivot), _G.math.floor(y1 + yPivot), "TOP", "LEFT", _G.math.floor(width), _G.math.floor(height))
		end
	end
end

function createPopupBoxSpriteTables()

	popupBoxSprites = { topLeft = "POPUP_TOP_LEFT", topMiddle = "POPUP_TOP_MIDDLE", topRight = "POPUP_TOP_RIGHT",
						left = "POPUP_LEFT", center = "POPUP_CENTER", right = "POPUP_RIGHT", 
     				    bottomLeft = "POPUP_BOTTOM_LEFT", bottomMiddle = "POPUP_BOTTOM_MIDDLE", bottomRight = "POPUP_BOTTOM_RIGHT" }
						
	completeBoxSprites = { topLeft = "COMPLETE_TOP_LEFT", topMiddle = "COMPLETE_TOP_MIDDLE", topRight = "COMPLETE_TOP_RIGHT",
						   left = "COMPLETE_LEFT", center = "COMPLETE_CENTER", right = "COMPLETE_RIGHT", 
							}
	whiteBoxSprites = { topLeft = "WHITE_TOP_LEFT", topMiddle = "WHITE_TOP_MIDDLE", topRight = "WHITE_TOP_RIGHT",
						   left = "WHITE_LEFT", center = "WHITE_CENTER", right = "WHITE_RIGHT", 
						   bottomLeft = "WHITE_BOTTOM_LEFT", bottomMiddle = "WHITE_BOTTOM_MIDDLE", bottomRight = "WHITE_BOTTOM_RIGHT",
						}
	tutorialBoxSprites = { topLeft = "TUTORIAL_TOP_LEFT", topMiddle = "TUTORIAL_TOP_MIDDLE", topRight = "TUTORIAL_TOP_RIGHT",
						   left = "TUTORIAL_LEFT", center = "TUTORIAL_CENTER", right = "TUTORIAL_RIGHT", 
						   bottomLeft = "TUTORIAL_BOTTOM_LEFT", bottomMiddle = "TUTORIAL_BOTTOM_MIDDLE", bottomRight = "TUTORIAL_BOTTOM_RIGHT",
						}
	
	blackBoxSprites = { topLeft = "UPSELL_TOP_LEFT", topMiddle = "UPSELL_TOP_MIDDLE", topRight = "UPSELL_TOP_RIGHT",
						   left = "UPSELL_LEFT", center = "UPSELL_CENTER", right = "UPSELL_RIGHT", 
						   bottomLeft = "UPSELL_BOTTOM_LEFT", bottomMiddle = "UPSELL_BOTTOM_MIDDLE", bottomRight = "UPSELL_BOTTOM_RIGHT",
						}
	
	scoreBox = {topLeft = "SCORE_TOP_LEFT", left = "SCORE_LEFT", bottomLeft = "SCORE_BOTTOM_LEFT", bottomMiddle = "SCORE_BOTTOM_MIDDLE",
					  bottomRight = "SCORE_BOTTOM_RIGHT", right = "SCORE_RIGHT", topRight = "SCORE_TOP_RIGHT", topMiddle = "SCORE_TOP_MIDDLE",
					  center = "SCORE_CENTER"}
					  
	achievementBoxSprites = {left = "ACHIEVEMENT_BG_LEFT", center = "ACHIEVEMENT_BG_MIDDLE", right = "ACHIEVEMENT_BG_RIGHT"}
	playBoxSprites = {left = "PLAY_BUTTON_BG_LEFT", center = "PLAY_BUTTON_BG_MIDDLE", right = "PLAY_BUTTON_BG_RIGHT" }
end				

function calculatePlaytime()
	if playtimeCounter == nil then
		playtimeCounter = 0
	end
	
	if settings.playtime == nil then
		settings.playtime = playtimeCounter
	else
		settings.playtime = _G.string.format("%.0f", settings.playtime + playtimeCounter)
	end
	playtimeCounter = 0
end
		
function resetCameras()
-- resets camera for current screen resolution from original castle camera

	local ccd = objects.castleCameraData[deviceModel]
	if ccd.screenWidth == nil then
		ccd.screenWidth = 1680
	end
	if ccd.screenHeight == nil then
		ccd.screenHeight = 1050
	end

	local cameraAspectRation = ccd.screenWidth / ccd.screenHeight
	local currentAspectRation = screenWidth / screenHeight
	local tempCcd = {}
	if currentAspectRation >= cameraAspectRation then
		-- Current aspect ratio is wider than the one used to make the level, expand horizontally
		tempCcd.sx = originalCcd.sx * screenHeight / ccd.screenHeight
	else
		-- Current aspect ratio is narrower than the one used to make the level, expand vertically
		tempCcd.sx = originalCcd.sx * screenWidth / ccd.screenWidth
	end
	tempWorldScale = worldScale * (tempCcd.sx / ccd.sx)
	setWorldScale(tempWorldScale)
	--print("resetCameras! worldScale: " .. worldScale .. ", screenWidth: " .. screenWidth .. "\n")
end

-- iphone4 needs to init cameras again after the level is loaded when the screen resolution is changed 
function initCameras()
	cameraFunction = levelStartCamera
		
	if objects.castleCameraData ~= nil then
		local cameraSelected = false
		
		-- Try loading cameras in priority order
		for i=1,#g_cameraProfileList do
			local cameraProfile = g_cameraProfileList[i]
			if objects.castleCameraData[cameraProfile] ~= nil then
				cameraSelected = true
				if cameraProfile ~= deviceModel then
					objects.castleCameraData[deviceModel] = {}
					objects.castleCameraData[deviceModel].px = objects.castleCameraData[cameraProfile].px
					objects.castleCameraData[deviceModel].py = objects.castleCameraData[cameraProfile].py
					objects.castleCameraData[deviceModel].sx = objects.castleCameraData[cameraProfile].sx
					objects.castleCameraData[deviceModel].sy = objects.castleCameraData[cameraProfile].sy
					objects.castleCameraData[deviceModel].screenWidth = objects.castleCameraData[cameraProfile].screenWidth
					objects.castleCameraData[deviceModel].screenHeight = objects.castleCameraData[cameraProfile].screenHeight
				end
				break
			end
		end
		
		if cameraSelected == false then
			if objects.castleCameraData.px ~= nil then
				-- If no camera data is found for any profile, use generic data
				objects.castleCameraData[deviceModel] = {}
				objects.castleCameraData[deviceModel].px = objects.castleCameraData.px
				objects.castleCameraData[deviceModel].py = objects.castleCameraData.py
				objects.castleCameraData[deviceModel].sx = objects.castleCameraData.sx
				objects.castleCameraData[deviceModel].sy = objects.castleCameraData.sy
				objects.castleCameraData[deviceModel].screenWidth = objects.castleCameraData.screenWidth
				objects.castleCameraData[deviceModel].screenHeight = objects.castleCameraData.screenHeight
			else
				-- If no generic data found, assume very old format
				objects.castleCameraData[deviceModel] = {}
				objects.castleCameraData[deviceModel].px = screen.x
				objects.castleCameraData[deviceModel].py = screen.y
				objects.castleCameraData[deviceModel].sx = 1
				objects.castleCameraData[deviceModel].sy = 1
				objects.castleCameraData[deviceModel].screenWidth = screenWidth
				objects.castleCameraData[deviceModel].screenHeight = screenHeight
			end
		end
	
		local ccd = objects.castleCameraData[deviceModel]
		
		if ccd.screenWidth == nil then
			ccd.screenWidth = 1680
		end
		if ccd.screenHeight == nil then
			ccd.screenHeight = 1050
		end

		local cameraAspectRation = ccd.screenWidth / ccd.screenHeight
		local currentAspectRation = screenWidth / screenHeight
		
		if currentAspectRation >= cameraAspectRation or startedFromEditor == true then
			-- Current aspect ratio is wider than the one used to make the level, expand horizontally
			ccd.sx = ccd.sx * screenHeight / ccd.screenHeight
			ccd.sy = ccd.sy * screenHeight / ccd.screenHeight
		else
			-- Current aspect ratio is narrower than the one used to make the level, expand vertically
			ccd.sx = ccd.sx * screenWidth / ccd.screenWidth
			ccd.sy = ccd.sy * screenWidth / ccd.screenWidth
		end
		originalCcd = {}
		originalCcd.sx = ccd.sx
		originalCcd.sy = ccd.sy
		if objects.castleCameraData.version == nil then
			-- old version has the screen center position in wrong place
			worldScale = ccd.sx
			setWorldScale(worldScale)
			screen.left = ccd.px - screenWidth * 0.5
			screen.top = ccd.py - screenHeight * 0.5
			screen.right = screen.left + screenWidth / worldScale
			screen.bottom = screen.top + screenHeight / worldScale
			screen.x = (screen.right + screen.left) * 0.5
			screen.y = (screen.bottom + screen.top) * 0.5
			--print("CScreen: " .. screen.left .. ", " .. screen.top .. " - " .. screen.right .. ", " .. screen.bottom .. "\n")
			--print("CScreen: " .. screen.x .. ", " .. screen.y .. "\n")
			ccd.px = screen.x
			ccd.py = screen.y
			--updateScale()
		else
			worldScale = ccd.sx
			setWorldScale(worldScale)
			screen.x = ccd.px
			screen.y = ccd.py
			screen.left = screen.x - screenWidth * 0.5 / worldScale
			screen.top = screen.y - screenHeight * 0.5 / worldScale
			screen.right = screen.x + screenWidth * 0.5 / worldScale
			screen.bottom = screen.y + screenHeight * 0.5 / worldScale
			--updateScale()
		end
	else
		-- camera not defined set default camera
		objects.castleCameraData = {}
		objects.castleCameraData[deviceModel] = {}
		local ccd = objects.castleCameraData[deviceModel]
		ccd.sx = 1
		ccd.sy = 1
		ccd.px = screen.x
		ccd.py = screen.y
	end
	
	--animationWorldScale = worldScale 
	
	local ccd = objects.castleCameraData[deviceModel]
	ccd.top = screen.top
	ccd.left = screen.left
	ccd.right = screen.right
	ccd.bottom = screen.bottom
	cameraAnimationSlider = 1
	cameraAnimationSliderTarget = 1
	defaultCamera()
	
	local wx1, _ = worldToPhysicsTransform(ccd.left, ccd.top)
	local wx2, _ = worldToPhysicsTransform(ccd.right, ccd.bottom)
	--setTheme(currentTheme)
	
	if objects.birdCameraData ~= nil then
	
		local cameraSelected = false
		-- Try loading cameras in priority order
		for i=1,#g_cameraProfileList do
			local cameraProfile = g_cameraProfileList[i]
			if objects.birdCameraData[cameraProfile] ~= nil then
				cameraSelected = true
				if cameraProfile ~= deviceModel then
					objects.birdCameraData[deviceModel] = {}
					objects.birdCameraData[deviceModel].px = objects.birdCameraData[cameraProfile].px
					objects.birdCameraData[deviceModel].py = objects.birdCameraData[cameraProfile].py
					objects.birdCameraData[deviceModel].sx = objects.birdCameraData[cameraProfile].sx
					objects.birdCameraData[deviceModel].sy = objects.birdCameraData[cameraProfile].sy
					objects.birdCameraData[deviceModel].screenWidth = objects.birdCameraData[cameraProfile].screenWidth
					objects.birdCameraData[deviceModel].screenHeight = objects.birdCameraData[cameraProfile].screenHeight
				end
				break
			end
		end
		
		if cameraSelected == false then
			if objects.birdCameraData.px ~= nil then
				-- If no camera data is found for any profile, use generic data
				objects.birdCameraData[deviceModel] = {}
				objects.birdCameraData[deviceModel].px = objects.birdCameraData.px
				objects.birdCameraData[deviceModel].py = objects.birdCameraData.py
				objects.birdCameraData[deviceModel].sx = objects.birdCameraData.sx
				objects.birdCameraData[deviceModel].sy = objects.birdCameraData.sy
				objects.birdCameraData[deviceModel].screenWidth = objects.birdCameraData.screenWidth
				objects.birdCameraData[deviceModel].screenHeight = objects.birdCameraData.screenHeight
			else
				-- If no generic data found, assume very old format
				objects.birdCameraData[deviceModel] = {}
				objects.birdCameraData[deviceModel].px = screen.x
				objects.birdCameraData[deviceModel].py = screen.y
				objects.birdCameraData[deviceModel].sx = 1
				objects.birdCameraData[deviceModel].sy = 1
				objects.birdCameraData[deviceModel].screenWidth = screenWidth
				objects.birdCameraData[deviceModel].screenHeight = screenHeight
			end
		end
	
		local bcd = objects.birdCameraData[deviceModel]
		
		if bcd.screenWidth == nil then
			bcd.screenWidth = 1680
		end
		if bcd.screenHeight == nil then
			bcd.screenHeight = 1050
		end

		local cameraAspectRation = bcd.screenWidth / bcd.screenHeight
		local currentAspectRation = screenWidth / screenHeight
		
		if currentAspectRation >= cameraAspectRation then
			-- Current aspect ratio is wider than the one used to make the level, expand horizontally
			bcd.sx = bcd.sx * screenHeight / bcd.screenHeight
			bcd.sy = bcd.sy * screenHeight / bcd.screenHeight
		else
			-- Current aspect ratio is narrower than the one used to make the level, expand vertically
			bcd.sx = bcd.sx * screenWidth / bcd.screenWidth
			bcd.sy = bcd.sy * screenWidth / bcd.screenWidth
		end
		
		if objects.birdCameraData.version == nil then
			-- old version has the screen center position in wrong place
			scale = bcd.sx
			bcd.left = bcd.px - screenWidth * 0.5
			bcd.top = bcd.py - screenHeight * 0.5
			bcd.right = screen.left + screenWidth / scale
			bcd.bottom = screen.top + screenHeight / scale
			bcd.px = (screen.right + screen.left) * 0.5
			bcd.py = (screen.bottom + screen.top) * 0.5
			--print("BScreen: " .. screen.left .. ", " .. screen.top .. " - " .. screen.right .. ", " .. screen.bottom .. "\n")
			--print("BScreen: " .. screen.x .. ", " .. screen.y .. "\n")
		else
			bcd.left = bcd.px - screenWidth * 0.5 / bcd.sx
			bcd.top = bcd.py - screenHeight * 0.5 / bcd.sy
			bcd.right = screen.left + screenWidth / bcd.sx
			bcd.bottom = screen.top + screenHeight / bcd.sy
		end
	else
		-- bird camera not defined
		objects.birdCameraData = {}
		objects.birdCameraData[deviceModel] = {}
		local bcd = objects.birdCameraData[deviceModel]
		bcd.sx = 1
		bcd.sy = 1
		bcd.px = screen.x
		bcd.py = screen.y
		bcd.left = bcd.px - screenWidth * 0.5
		bcd.top = bcd.py - screenHeight * 0.5
		bcd.right = screen.left + screenWidth * 0.5
		bcd.bottom = screen.top + screenHeight * 0.5
	end

	local bcd = objects.birdCameraData[deviceModel]
	ccd.screenWidth = screenWidth
	ccd.screenHeight = screenHeight
	bcd.screenWidth = screenWidth
	bcd.screenHeight = screenHeight
		
	leftLimit = bcd.left - screenWidth * 0.20
	rightLimit = ccd.right + screenWidth * 0.20
	
	local leftLimitPhysics, rightLimitPhysics = worldToPhysicsTransform(leftLimit, rightLimit)
	if rightLimitPhysics > levelRightEdge then
		levelRightEdge = rightLimitPhysics
	end
	if leftLimitPhysics < levelLeftEdge then
		levelLeftEdge = leftLimitPhysics
	end
	-- set level left and right limit, other values do not affect at the moment
	levelLimitMinX = levelLeftEdge - screenWidth*0.75*physicsScale
	levelLimitMaxX = levelRightEdge + screenWidth*0.75*physicsScale
	setLevelLimits(levelLimitMinX, -10000, levelLimitMaxX, 20)
	
	-- calculate minimum scale. ie the player can't see the world smaller than this size
	maxLevelWidth = rightLimit - leftLimit
	minWorldScale = screenWidth / maxLevelWidth
	groundLimit = bcd.bottom
	if groundLimit < ccd.bottom then
		groundLimit = ccd.bottom
	end
	groundLimit = screenHeight / (minWorldScale * 5)
	if levelRestartedFrom == nil or startedFromEditor == true then 
		currentZoomedScale = bcd.sx
		if currentZoomedScale < ccd.sx then
			currentZoomedScale = ccd.sx
		end
	end
end



--name is the key for the theme sprite that is registered in the level file,
--attributes is the table to the key mentioned above
function addThemeSprite(name, attributes)

	--the global table themeSpriteObjects will have attributes that make 
	--selection/modifications available
	
	local obj = attributes
	local spr = blockTable.blocks[obj.definition].sprite
	if not spr and blockTable.blocks[obj.definition].damageSprites then
		spr = blockTable.blocks[obj.definition].damageSprites.damage1
	end
	
	local t_scaleX = 1
	local t_scaleY = 1
	
	if obj.scale ~= nil then
		t_scaleX = obj.scale.x or 1
		t_scaleY = obj.scale.y or 1
	end
	
	createThemeSprite(obj.name, spr, obj.x, obj.y, t_scaleX, t_scaleY, obj.angle, obj.layer)
	
	themeSpriteObjects[name] = { x = obj.x, y = obj.y, name = obj.name, definition = obj.definition,
								 scale = (obj.scale or {x=1,y=1}), angle = obj.angle, layer = obj.layer}
					
	--will hold the object in objects.world that represents the theme sprite. This is needed mostly for
	--selecting the object during editing, so we copy only the attributes that will be used
	local t_worldSprite = blockTable.blocks[obj.definition]
	
	local w, h = _G.res.getSpriteBounds("", spr)
	
	local sizeFactor = 0.92
	if t_worldSprite.density == 0 then
		sizeFactor = 1
	end
	
	w = w * physicsScale * sizeFactor
	h = h * physicsScale * sizeFactor
	
	themeSpriteObjects[name].type = t_worldSprite.type			
	themeSpriteObjects[name].width = w
	themeSpriteObjects[name].height = h
	themeSpriteObjects[name].vertices = t_worldSprite.vertices									
	
	if t_worldSprite.type == "circle" then
		if t_worldSprite.radius ~= nil then
			themeSpriteObjects[name].radius = t_worldSprite.radius
		else
			if spr ~= "" and spr ~= nil then
				local w, h = _G.res.getSpriteBounds("", spr)
				themeSpriteObjects[name].radius = w * 0.5 * physicsScale * sizeFactor
			end
		end								
	end
end


--------------------------------------------------------------------------------------------------------------------------------------------------------------
-- adMob stuff starts

function showAd()
	if ((isLiteVersion == true and (deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad")) or deviceModel == "android") and not settings.isPremium then
		print("Trying to show ad\n")
		if isShowingAd == true then
			print("Still showing previous ad, reseting ad timer\n")
			lastAdTime = time
		elseif adRequested == true then 
			scoreAdOffsetY = 0 
			print("Still requesting ad, doing nothing\n")
		elseif adReady == true then
			adReady = false
			isShowingAd = true
			isHidingAd = false
			lastAdTime = time
			adShowingStartedTime = time
			showAdvertisement()
			scoreAdOffsetY = 0 
			print("showing ad\n")
		elseif adRequested ~= true then
			print("No ad ready and not requesting ad, requesting now.\n")
			requestAd()
			adRequested = true
			scoreAdOffsetY = 0 
		end
	end
end

function requestAdSuccesful()
	if (isLiteVersion == true and (deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad")) or deviceModel == "android" then
		print("requestAdSuccesful\n")
		adReady = true
		adRequested = false
	end
end

function requestAdFailed()
	if (isLiteVersion == true and (deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad")) or deviceModel == "android" then
		print("requestAdFailed\n")
		adRequested = false
	end
end

function hideAd()
	if (isLiteVersion == true and (deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad")) or deviceModel == "android" then
		print("Trying to hide ad\n")
		if isShowingAd == true and isHidingAd ~= true then
			hideAdvertisement()
			isHidingAd = true
			print("hideAd\n")
		end
	end
end

function startAdTimer()
	if (isLiteVersion == true and (deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad")) or deviceModel == "android" then
		isShowingAd = true
		lastAdTime = time
		print("Starting Ad Timer, starting to show ad\n")
	end
end

function showVideoAd()
	if ((isLiteVersion == true and (deviceModel == "iphone" or deviceModel == "iphone4" or deviceModel == "ipad")) or deviceModel == "android") and not settings.isPremium then
		print("Checking if it's time for video ad\n")
		if videoReady == true and isShowingAd ~= true then
			print("Show video\n")
			showVideoAdvertisement()
			lastVideoAdTime = time
			videoAdRequested = false
		end
	end
end

function fullScreenAdDismissed()
	print("Fullscreen ad dismissed.\n")
	prepareMenusAfterAd = true
	scoreAdOffsetY = 0 
	if currentGameMode == updateGame and _G.res.isAudioPlaying(currentMainMenuSong) == true then
		_G.res.stopAudio(currentMainMenuSong)
	end
end

function fullScreenVideoDismissed()
	fullScreenAdDismissed()
	if currentGameMode == updateGame or (currentGameMode == updateMenu and currentMenuPage == pausePage) then
		setGameMode(hidePauseMenu)
	end
end

-- adMob stuff ends
-------------------------------------------------------------------------------
			--[[
			for k,v in _G.pairs(levelOrder.packs) do
				for kk,vv in _G.pairs(levelOrder[k]) do
					local levelName = vv
					print("LevelName
				end

			end ]]

--function updateTrialEagleValueAtHighscores()

--	if(settings.mightyEagleEnabled == true) then 
--		highscores.trialEagle = false
	--			{name = "buttonEagleBuy", sprite = "BUTTON_EAGLE", updateFunction = updateMenu, page = mightyEagleIngamePage },
--		local buttonEagleBuy = getItemByName(levelFailed.items, "buttonEagleBuy");
--		buttonEagleBuy.updateFunction = nil
--		buttonEagleBuy.page = nil
--		buttonEagleBuy.callFunction = function()
--										setGameMode(updateGame)
--										popupPage = nil
--										inGameEagleButtonVisible = false
--										launchEagleBaitInGame()
--									  end
		
--	else
--		highscores.trialEagle = true
--	end

	--[[
	print("----------------------- UPDATE ME HIGH SCORES -----------------")
	for k,v in _G.pairs(levelOrder.packs) do
		for kk,vv in _G.pairs(levelOrder[v]) do
			local levelName = vv
			if(settings.mightyEagleEnabled == true) then 
				if(highscores[vv] ~= nil and highscores[vv].trialEagleScore ~= nil) then
					highscores[vv].eagleScore = highscores[vv].trialEagleScore
					highscores[vv].trialEagleScore = nil
				end
			end
		end
	end ]]
	
--	saveLuaFileWrapper("highscores.lua", "highscores", true)
--end			



function getEpisodeFeathers(episodeNumber)
	local total = 0
	local maxFeathers = 0
	if(levelOrder ~= nil) then
		local v = levelOrder.episodes[episodeNumber]
		for kk,vv in _G.pairs(v) do
			maxFeathers = maxFeathers + #levelOrder[vv]
			local feathers = calculateFeathers({levelOrder[vv]})
			total = total + feathers
		end	
	end
	return total, maxFeathers
end	

--[[
function reduceEagles()
	if(settings.tryoutEagles and settings.tryoutEagles > 0) then
		settings.tryoutEagles = settings.tryoutEagles - 1;
		popupPage = nil
		inGameEagleButtonVisible = false
		launchEagleBaitInGame()
	end
end
]]




--
filename="gamelogic.lua"
